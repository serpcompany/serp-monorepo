[
  {
    "owner": "facebook",
    "repo": "react",
    "content": "TITLE: Creating a Basic React Component with JSX\nDESCRIPTION: This example demonstrates how to create a simple React component that renders a personalized greeting message. It shows importing the createRoot API from react-dom/client, defining a functional component with props, and rendering it to a DOM container.\nSOURCE: https://github.com/facebook/react/blob/main/README.md#2025-04-21_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport { createRoot } from 'react-dom/client';\n\nfunction HelloMessage({ name }) {\n  return <div>Hello {name}</div>;\n}\n\nconst root = createRoot(document.getElementById('container'));\nroot.render(<HelloMessage name=\"Taylor\" />);\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: A React functional component that filters and renders items using hooks (useItems, useMemo). Includes conditional rendering based on filtered items length and mapping over filtered items to render Stringify components.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-no-declarations-in-reactive-scope-with-early-return.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableAssumeHooksFollowRulesOfReact @enableTransitivelyFreezeFunctionExpressions\nfunction Component() {\n  const items = useItems();\n  const filteredItems = useMemo(\n    () =>\n      items.filter(([item]) => {\n        return item.name != null;\n      }),\n    [item]\n  );\n\n  if (filteredItems.length === 0) {\n    // note: this must return nested JSX to create the right scope\n    // shape that causes no declarations to be emitted\n    return (\n      <div>\n        <span />\n      </div>\n    );\n  }\n\n  return (\n    <>\n      {filteredItems.map(([item]) => (\n        <Stringify item={item} />\n      ))}\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Installing React DOM with npm\nDESCRIPTION: Command for installing both react and react-dom packages using npm.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-dom/README.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpm install react react-dom\n```\n\n----------------------------------------\n\nTITLE: Enhanced Memoization Logic in React Component Using Compiler Runtime - JavaScript\nDESCRIPTION: This snippet is an advanced version of the React component, which integrates the use of a compiler runtime for aggressive memoization. It includes conditional rendering based on cached execution paths via a component-internal cache. Dependencies include the React library and 'react/compiler-runtime'. The component renders based on whether the entity is set and manages internal state changes efficiently.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useCallback-nonescaping-invoked-callback-escaping-return.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @validatePreserveExistingMemoizationGuarantees @enableAssumeHooksFollowRulesOfReact @enableTransitivelyFreezeFunctionExpressions\nimport { useCallback } from \"react\";\n\nfunction Component(t0) {\n  const $ = _c(9);\n  const { entity, children } = t0;\n  let t1;\n  if ($[0] !== entity) {\n    t1 = () => entity != null;\n    $[0] = entity;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  const showMessage = t1;\n\n  const shouldShowMessage = showMessage();\n  let t2;\n  if ($[2] !== shouldShowMessage) {\n    t2 = <div>{shouldShowMessage}</div>;\n    $[2] = shouldShowMessage;\n    $[3] = t2;\n  } else {\n    t2 = $[3];\n  }\n  let t3;\n  if ($[4] !== children) {\n    t3 = <div>{children}</div>;\n    $[4] = children;\n    $[5] = t3;\n  } else {\n    t3 = $[5];\n  }\n  let t4;\n  if ($[6] !== t2 || $[7] !== t3) {\n    t4 = (\n      <div>\n        {t2}\n        {t3}\n      </div>\n    );\n    $[6] = t2;\n    $[7] = t3;\n    $[8] = t4;\n  } else {\n    t4 = $[8];\n  }\n  return t4;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\n    {\n      entity: { name: \"Sathya\" },\n      children: [<div key=\"gsathya\">Hi Sathya!</div>],\n    },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Inferred Dependencies\nDESCRIPTION: The compiled version of the component with automatically inferred dependencies for each effect hook. The compiler has added dependency tracking logic, memoization, and explicit dependency arrays based on the values referenced in each effect callback.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/infer-effect-dependencies.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @inferEffectDependencies\nimport { useEffect, useRef } from \"react\";\nimport useEffectWrapper from \"useEffectWrapper\";\n\nconst moduleNonReactive = 0;\n\nfunction Component(t0) {\n  const $ = _c(12);\n  const { foo, bar } = t0;\n\n  const ref = useRef(0);\n  let t1;\n  if ($[0] !== foo) {\n    t1 = { foo };\n    $[0] = foo;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  const localNonPrimitiveReactive = t1;\n  let t2;\n  if ($[2] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t2 = {};\n    $[2] = t2;\n  } else {\n    t2 = $[2];\n  }\n  const localNonPrimitiveNonreactive = t2;\n  let t3;\n  if ($[3] !== bar || $[4] !== foo || $[5] !== localNonPrimitiveReactive) {\n    t3 = () => {\n      console.log(foo);\n      console.log(bar);\n      console.log(moduleNonReactive);\n      console.log(0);\n      console.log(globalValue);\n      console.log(ref.current);\n      console.log(localNonPrimitiveReactive);\n      console.log(localNonPrimitiveNonreactive);\n    };\n    $[3] = bar;\n    $[4] = foo;\n    $[5] = localNonPrimitiveReactive;\n    $[6] = t3;\n  } else {\n    t3 = $[6];\n  }\n  useEffect(t3, [\n    foo,\n    bar,\n    localNonPrimitiveReactive,\n    localNonPrimitiveNonreactive,\n  ]);\n  let t4;\n  if ($[7] !== bar.baz || $[8] !== bar.qux) {\n    t4 = () => {\n      console.log(bar?.baz);\n      console.log(bar.qux);\n    };\n    $[7] = bar.baz;\n    $[8] = bar.qux;\n    $[9] = t4;\n  } else {\n    t4 = $[9];\n  }\n  useEffect(t4, [bar.baz, bar.qux]);\n  let t5;\n  if ($[10] !== foo) {\n    t5 = () => {\n      console.log(foo);\n    };\n    $[10] = foo;\n    $[11] = t5;\n  } else {\n    t5 = $[11];\n  }\n  useEffectWrapper(t5, [foo]);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with useState Hook\nDESCRIPTION: This snippet defines a React component that uses the useState hook to manage the state of an input field. It includes a handler function to update the state when the input value changes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/controlled-input.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useState} from 'react';\nfunction component() {\n  let [x, setX] = useState(0);\n  const handler = event => setX(event.target.value);\n  return <input onChange={handler} value={x} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: [],\n  isComponent: true,\n};\n```\n\n----------------------------------------\n\nTITLE: Creating a Counter Component with React Hooks\nDESCRIPTION: This example demonstrates how to create a simple counter component using React's useState hook and render it to the DOM. It shows the basic pattern of component creation, state management, and DOM rendering with the createRoot API.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react/README.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useState } from 'react';\nimport { createRoot } from 'react-dom/client';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  return (\n    <>\n      <h1>{count}</h1>\n      <button onClick={() => setCount(count + 1)}>\n        Increment\n      </button>\n    </>\n  );\n}\n\nconst root = createRoot(document.getElementById('root'));\nroot.render(<Counter />);\n```\n\n----------------------------------------\n\nTITLE: Defining Component with Conditional Logic in React - JavaScript\nDESCRIPTION: This snippet defines a functional React component 'Component' that performs conditional logic based on 'props.cond'. It initializes a variable 't0' and evaluates the condition without utilizing hooks. The fixture entry point is exported for testing purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-nested-ifs.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let t0;\n  if (props.cond) {\n    if (props.cond) {\n    }\n  }\n  t0 = undefined;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Initializing React Component with useMemo\nDESCRIPTION: This snippet demonstrates initializing a React component using the useMemo hook to memoize the computation of objects based on props. It reduces unnecessary recomputation by caching the results for given dependencies. Dependencies include React hooks and the makeObject function to transform props.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-independently-memoizeable.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const [a, b] = useMemo(() => {\n    const items = [];\n    const a = makeObject(props.a);\n    const b = makeObject(props.b);\n    return [a, b];\n  });\n  return [a, b];\n}\n```\n\n----------------------------------------\n\nTITLE: Streaming Server Rendering in Node Environments\nDESCRIPTION: New API for streaming server-side rendering in Node environments with full support for Suspense.\nSOURCE: https://github.com/facebook/react/blob/main/CHANGELOG.md#2025-04-21_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\nrenderToPipeableStream\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: This is the compiled version of the `Component` using React's compiler. It utilizes `react/compiler-runtime` and memoization techniques to optimize rendering performance. The compiled code caches intermediate values and component instances to avoid unnecessary re-renders, demonstrating how the compiler enhances efficiency.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-outlining-dupe-key-dupe-component.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enableJsxOutlining\nfunction Component(t0) {\n  const $ = _c(7);\n  const { arr } = t0;\n  const x = useX();\n  let t1;\n  if ($[0] !== arr || $[1] !== x) {\n    let t2;\n    if ($[3] !== x) {\n      t2 = (i, id) => {\n        const T0 = _temp;\n        return <T0 k={i + \"i\"} k1={i + \"j\"} key={id} x={x} />;\n      };\n      $[3] = x;\n      $[4] = t2;\n    } else {\n      t2 = $[4];\n    }\n    t1 = arr.map(t2);\n    $[0] = arr;\n    $[1] = x;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  let t2;\n  if ($[5] !== t1) {\n    t2 = <>{t1}</>;\n    $[5] = t1;\n    $[6] = t2;\n  } else {\n    t2 = $[6];\n  }\n  return t2;\n}\nfunction _temp(t0) {\n  const $ = _c(8);\n  const { k: k, k1: k1, x: x } = t0;\n  let t1;\n  if ($[0] !== k) {\n    t1 = <Foo k={k} />;\n    $[0] = k;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  let t2;\n  if ($[2] !== k1) {\n    t2 = <Foo k={k1} />;\n    $[2] = k1;\n    $[3] = t2;\n  } else {\n    t2 = $[3];\n  }\n  let t3;\n  if ($[4] !== t1 || $[5] !== t2 || $[6] !== x) {\n    t3 = (\n      <Bar x={x}>\n        {t1}\n        {t2}\n      </Bar>\n    );\n    $[4] = t1;\n    $[5] = t2;\n    $[6] = x;\n    $[7] = t3;\n  } else {\n    t3 = $[7];\n  }\n  return t3;\n}\n\nfunction Bar(t0) {\n  const $ = _c(3);\n  const { x, children } = t0;\n  let t1;\n  if ($[0] !== children || $[1] !== x) {\n    t1 = (\n      <>\n        {x}\n        {children}\n      </>\n    );\n    $[0] = children;\n    $[1] = x;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  return t1;\n}\n\nfunction Foo(t0) {\n  const { k } = t0;\n  return k;\n}\n\nfunction useX() {\n  return \"x\";\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ arr: [\"foo\", \"bar\"] }],\n};\n```\n\n----------------------------------------\n\nTITLE: Using the new useActionState Hook in React 19\nDESCRIPTION: useActionState is a new hook that manages actions inside transitions with access to the action's state and pending state. It accepts a reducer for calling actions and an initial state, with an optional string for form progressive enhancement.\nSOURCE: https://github.com/facebook/react/blob/main/CHANGELOG.md#2025-04-21_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nfunction MyComponent() {\n  const [state, dispatch] = useActionState(\n    (state, action) => {\n      // Handle different actions\n      switch(action.type) {\n        case 'update':\n          return { ...state, data: action.data };\n        default:\n          return state;\n      }\n    },\n    { data: null, loading: false },\n    'optional-form-action-id'\n  );\n\n  return (\n    <div>\n      {state.loading ? 'Loading...' : state.data}\n      <button onClick={() => startTransition(async () => {\n        dispatch({ type: 'update', data: await fetchData() });\n      })}>Load Data</button>\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Root Rendering with createRoot and hydrateRoot\nDESCRIPTION: New root rendering methods for improved React application initialization and hydration, supporting concurrent mode and better performance.\nSOURCE: https://github.com/facebook/react/blob/main/CHANGELOG.md#2025-04-21_snippet_15\n\nLANGUAGE: javascript\nCODE:\n```\nconst root = createRoot(document.getElementById('root'));\nroot.render(<App />);\n```\n\n----------------------------------------\n\nTITLE: JSX Comment Node Support\nDESCRIPTION: This code snippet demonstrates the support for comment nodes within JSX.  Comments enclosed within curly braces and forward slashes are now recognized and will not be rendered in the output. This feature allows developers to include comments directly within JSX code for documentation or temporary code exclusion.\nSOURCE: https://github.com/facebook/react/blob/main/CHANGELOG.md#2025-04-21_snippet_25\n\nLANGUAGE: JSX\nCODE:\n```\n\"<div>{/* this is a comment and won't be rendered */}</div>\"\n```\n\n----------------------------------------\n\nTITLE: Filtering Non-Zero Numbers from Array with Type Annotations in React\nDESCRIPTION: This snippet defines a useArray function that filters out zero values from an input array of numbers. It utilizes type annotations to enable compiler optimizations. The FIXTURE_ENTRYPOINT exports the function with a sample input for testing.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-annotations/todo_type-annotations-props.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableUseTypeAnnotations\nfunction useArray(items: Array<number>) {\n  // With type information we know that the callback cannot escape\n  // and does not need to be memoized, only the result needs to be\n  // memoized:\n  return items.filter(x => x !== 0);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useArray,\n  params: [[1, 0, 2, 0, 3, 0, 42]],\n};\n```\n\n----------------------------------------\n\nTITLE: Testing React StrictMode with react-is\nDESCRIPTION: Shows how to identify React StrictMode components using isStrictMode and typeOf functions.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-is/README.md#2025-04-21_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nimport React from \"react\";\nimport * as ReactIs from 'react-is';\n\nReactIs.isStrictMode(<React.StrictMode />); // true\nReactIs.typeOf(<React.StrictMode />) === ReactIs.StrictMode; // true\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Compiler Runtime\nDESCRIPTION: This is the transformed React component that leverages the React compiler runtime (`_c`) for memoization. It checks if `props.p0`, `props.p2`, and `props.p3` have changed using the cache `$`. If the props are unchanged, it reuses previously rendered elements from the cache. Otherwise, the component re-renders and updates the cache.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/switch.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(8);\n  let t0;\n  let y;\n  if ($[0] !== props.p0 || $[1] !== props.p2 || $[2] !== props.p3) {\n    const x = [];\n    switch (props.p0) {\n      case true: {\n        x.push(props.p2);\n        x.push(props.p3);\n      }\n      case false: {\n        y = x;\n      }\n    }\n\n    t0 = <Component data={x} />;\n    $[0] = props.p0;\n    $[1] = props.p2;\n    $[2] = props.p3;\n    $[3] = t0;\n    $[4] = y;\n  } else {\n    t0 = $[3];\n    y = $[4];\n  }\n  const child = t0;\n  y.push(props.p4);\n  let t1;\n  if ($[5] !== child || $[6] !== y) {\n    t1 = <Component data={y}>{child}</Component>;\n    $[5] = child;\n    $[6] = y;\n    $[7] = t1;\n  } else {\n    t1 = $[7];\n  }\n  return t1;\n}\n```\n\n----------------------------------------\n\nTITLE: Installing eslint-plugin-react-hooks via npm or yarn\nDESCRIPTION: Commands to install the eslint-plugin-react-hooks package as a development dependency using either npm or yarn package managers.\nSOURCE: https://github.com/facebook/react/blob/main/packages/eslint-plugin-react-hooks/README.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n# npm\nnpm install eslint-plugin-react-hooks --save-dev\n\n# yarn\nyarn add eslint-plugin-react-hooks --dev\n```\n\n----------------------------------------\n\nTITLE: Subscribing to RxJS BehaviorSubject with use-subscription in React\nDESCRIPTION: Code example showing how to use the useSubscription hook to subscribe to an RxJS BehaviorSubject. The component will re-render automatically when the subject emits a new value.\nSOURCE: https://github.com/facebook/react/blob/main/packages/use-subscription/README.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst subscription = useMemo(\n  () => ({\n    getCurrentValue: () => behaviorSubject.getValue(),\n    subscribe: callback => {\n      const subscription = behaviorSubject.subscribe(callback);\n      return () => subscription.unsubscribe();\n    }\n  }),\n\n  // Re-subscribe any time the behaviorSubject changes\n  [behaviorSubject]\n);\n\nconst value = useSubscription(subscription);\n```\n\n----------------------------------------\n\nTITLE: Downloading Experimental Build for DevTools\nDESCRIPTION: Command for downloading the latest experimental build of React from CI for DevTools development. This is an alternative to building dependencies from source.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/README.md#2025-04-21_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\n./scripts/release/download-experimental-build.js\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom React Hook with useMemo\nDESCRIPTION: Defines a custom React hook that uses useMemo to memoize an array containing a nested object property value. Demonstrates the relationship between object reference changes and nested property changes in memoization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useMemo-infer-more-specific.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees\n\nimport {useMemo} from 'react';\n\n// More specific memoization always results in fewer memo block\n// executions.\n// Precisely:\n//  x_new != x_prev does NOT imply x.y.z_new != x.y.z_prev\n//  x.y.z_new != x.y.z_prev does imply x_new != x_prev\nfunction useHook(x) {\n  return useMemo(() => [x.y.z], [x]);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useHook,\n  params: [{y: {z: 2}}],\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring eslint-plugin-react-hooks with flat config (ESLint 5.2.0)\nDESCRIPTION: Setup for ESLint 5.2.0 using the flat config format with the recommended-latest configuration in eslint.config.js.\nSOURCE: https://github.com/facebook/react/blob/main/packages/eslint-plugin-react-hooks/README.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as reactHooks from 'eslint-plugin-react-hooks';\n\nexport default [\n  // ...\n  reactHooks.configs['recommended-latest'],\n];\n```\n\n----------------------------------------\n\nTITLE: React useState Hook Usage in Component\nDESCRIPTION: This code snippet demonstrates the correct usage of the `useState` hook within a React component. The hook is called outside of any conditional statements or loops, which is required for React hooks to function correctly. The component `App` is a functional component that uses the useState hook to manage a state variable.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-69521d94fa03.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Valid because the neither the condition nor the loop affect the hook call.\nfunction App(props) {\n  const someObject = {propA: true};\n  for (const propName in someObject) {\n    if (propName === true) {\n    } else {\n    }\n  }\n  const [myState, setMyState] = useState(null);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Testing React Elements with react-is\nDESCRIPTION: Demonstrates how to check if a JSX element is a valid React element using isElement and typeOf functions.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-is/README.md#2025-04-21_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport React from \"react\";\nimport * as ReactIs from 'react-is';\n\nReactIs.isElement(<div />); // true\nReactIs.typeOf(<div />) === ReactIs.Element; // true\n```\n\n----------------------------------------\n\nTITLE: Error Handling for Prop Mutation in React\nDESCRIPTION: This snippet captures an error message that arises when the `Foo` component tries to mutate its `props`. It points out that mutating props directly is not allowed in React, advising to use local variables instead.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.mutate-props.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n  1 | function Foo(props) {\n> 2 |   props.test = 1;\n    |   ^^^^^ InvalidReact: Mutating component props or hook arguments is not allowed. Consider using a local variable instead (2:2)\n  3 |   return null;\n  4 | }\n  5 |\n```\n\n----------------------------------------\n\nTITLE: Rendering React Components in Browser\nDESCRIPTION: Example of how to use react-dom/client to render a React component in the browser. Shows importing createRoot, defining a simple component, and rendering it to a DOM element.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-dom/README.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createRoot } from 'react-dom/client';\n\nfunction App() {\n  return <div>Hello World</div>;\n}\n\nconst root = createRoot(document.getElementById('root'));\nroot.render(<App />);\n```\n\n----------------------------------------\n\nTITLE: Define React Component with Compiler Runtime\nDESCRIPTION: This code defines a React component function `foo` that uses `react/compiler-runtime`. It initializes a variable `x` using a memoized value from `_c`. It includes a conditional statement that modifies `x` based on input `a`. The function then assigns `x` to `y` and returns `y`. The function is exported as part of `FIXTURE_ENTRYPOINT` with component metadata.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-non-empty-initializer.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction foo(a, b) {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = [];\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  let x = t0;\n  if (a) {\n    x = 1;\n  }\n\n  const y = x;\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n\n```\n\n----------------------------------------\n\nTITLE: Initializing New React 18 Hooks\nDESCRIPTION: Introduction of new React 18 hooks including useId for generating unique IDs, startTransition and useTransition for marking non-urgent updates, useDeferredValue for deferred rendering, useSyncExternalStore for external store management, and useInsertionEffect for CSS-in-JS optimization.\nSOURCE: https://github.com/facebook/react/blob/main/CHANGELOG.md#2025-04-21_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\n// Generate unique IDs\nconst id = useId();\n\n// Mark updates as non-urgent\nstartTransition(() => {\n  setSearchQuery(input);\n});\n\n// Defer re-rendering\nconst deferredValue = useDeferredValue(value);\n\n// Sync external store\nconst state = useSyncExternalStore(subscribe, getSnapshot);\n\n// CSS-in-JS optimization\nuseInsertionEffect(() => {\n  // inject styles here\n});\n```\n\n----------------------------------------\n\nTITLE: Launching Standalone React DevTools from Terminal\nDESCRIPTION: Command to launch the standalone React DevTools application from the terminal. This is used for connecting to React Native applications or React DOM in non-standard browser environments.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/README.md#2025-04-21_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nreact-devtools\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Array Manipulation\nDESCRIPTION: This snippet defines a React component that takes props, creates an array, pushes a value from props, and returns the array along with its length. It demonstrates basic array manipulation and destructuring in a functional component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-property-inference.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const x = [];\n  x.push(props.value);\n  const {length: y} = x;\n  foo(y);\n  return [x, y];\n}\n```\n\n----------------------------------------\n\nTITLE: React Memoization Error Handling\nDESCRIPTION: This snippet contains a comment indicating a potential issue with memoization in React components. The error arises when the inferred dependencies for useMemo do not match the manually specified dependencies, which could lead to unexpected behavior regarding value updates. This highlights the importance of accurate dependency management in memoization for maintaining performance consistency.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.useMemo-property-call-chained-object.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n```\n   3 |\n   4 | function Component({propA}) {\n>  5 |   return useMemo(() => {\n     |                  ^^^^^^^\n>  6 |     return {\n     | ^^^^^^^^^^^^\n>  7 |       value: propA.x().y,\n     | ^^^^^^^^^^^^\n>  8 |     };\n     | ^^^^^^^^^^^^\n>  9 |   }, [propA.x]);\n     | ^^^^ CannotPreserveMemoization: React Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. The inferred dependencies did not match the manually specified dependencies, which could cause the value to change more or less frequently than expected (5:9)\n  10 | }\n  11 |\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Non-Fire Component in React - JavaScript\nDESCRIPTION: This snippet defines a React functional component named NonFireComponent that accepts a prop and logs it. The component utilizes the useEffect hook to invoke a local function foo, which logs the prop and a static string. Dependencies include React and its hooks.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/bailout-retry/no-fire-todo-syntax-shouldnt-throw.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableFire @panicThreshold(none)\nimport {fire} from 'react';\n\n/**\n * Compilation of this file should succeed.\n */\nfunction NonFireComponent({prop1}) {\n  /**\n   * This component bails out but does not use fire\n   */\n  const foo = () => {\n    try {\n      console.log(prop1);\n    } finally {\n      console.log('jbrown215');\n    }\n  };\n  useEffect(() => {\n    foo();\n  });\n}\n\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: A React component that renders a filtered list of unique items up to a maximum count, with a header showing the total count. Takes props for items array and maximum items to display.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/component.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const items = props.items;\n  const maxItems = props.maxItems;\n\n  const renderedItems = [];\n  const seen = new Set();\n  const max = Math.max(0, maxItems);\n  for (let i = 0; i < items.length; i += 1) {\n    const item = items.at(i);\n    if (item == null || seen.has(item)) {\n      continue;\n    }\n    seen.add(item);\n    renderedItems.push(<div>{item}</div>);\n    if (renderedItems.length >= max) {\n      break;\n    }\n  }\n  const count = renderedItems.length;\n  return (\n    <div>\n      <h1>{count} Items</h1>\n      {renderedItems}\n    </div>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Testing Valid React Element Types with isValidElementType\nDESCRIPTION: Demonstrates how to use react-is to verify if different React components are valid element types, including class components, function components, forwarded refs, and Context components.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-is/README.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport React from \"react\";\nimport * as ReactIs from \"react-is\";\n\nclass ClassComponent extends React.Component {\n  render() {\n    return React.createElement(\"div\");\n  }\n}\n\nconst FunctionComponent = () => React.createElement(\"div\");\n\nconst ForwardRefComponent = React.forwardRef((props, ref) =>\n  React.createElement(Component, { forwardedRef: ref, ...props })\n);\n\nconst Context = React.createContext(false);\n\nReactIs.isValidElementType(\"div\"); // true\nReactIs.isValidElementType(ClassComponent); // true\nReactIs.isValidElementType(FunctionComponent); // true\nReactIs.isValidElementType(ForwardRefComponent); // true\nReactIs.isValidElementType(Context.Provider); // true\nReactIs.isValidElementType(Context.Consumer); // true\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation in JavaScript\nDESCRIPTION: A simple React component that computes values from props, calls a function with those values, and renders a Foo component. Includes helper function declarations for demonstration purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/interdependent.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n/**\n * Should produce 1 scope:\n *\n * return: inputs=props.a & props.b; outputs=return\n *   const a = compute(props.a);\n *   const b = compute(props.b);\n *   foo(a, b);\n *   return = <Foo a={a} b={b} />\n */\nfunction Component(props) {\n  const a = compute(props.a);\n  const b = compute(props.b);\n  foo(a, b);\n  return <Foo a={a} b={b} />;\n}\n\nfunction compute() {}\nfunction foo() {}\nfunction Foo() {}\n```\n\n----------------------------------------\n\nTITLE: React Compiler Transformed Hook with Memoization\nDESCRIPTION: The React Compiler transformed version of the hook that implements memoization based on prop dependencies. It tracks props.a as the dependency and uses an array for memoization state.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/superpath-order1.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // When an unconditional dependency `props.a` is the subpath of a conditional\n// dependency `props.a.b`, we can safely overestimate and only track `props.a`\n// as a dependency\n\nimport { identity } from \"shared-runtime\";\n\n// ordering of accesses should not matter\nfunction useConditionalSuperpath1(t0) {\n  const $ = _c(3);\n  const { props, cond } = t0;\n  let x;\n  if ($[0] !== cond || $[1] !== props.a) {\n    x = {};\n    x.a = props.a;\n    if (identity(cond)) {\n      x.b = props.a.b;\n    }\n    $[0] = cond;\n    $[1] = props.a;\n    $[2] = x;\n  } else {\n    x = $[2];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useConditionalSuperpath1,\n  params: [{ props: { a: null }, cond: false }],\n  sequentialRenders: [\n    { props: { a: null }, cond: false },\n    { props: { a: {} }, cond: true },\n    { props: { a: { b: 3 } }, cond: true },\n    { props: {}, cond: false },\n    // test that we preserve nullthrows\n    { props: { a: { b: undefined } }, cond: true },\n    { props: { a: undefined }, cond: true },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with Memoization\nDESCRIPTION: This code shows the compiled React component with memoization applied using `react/compiler-runtime`. The `_c` function is used to cache the result of `obj.method()`, preventing redundant computations during re-renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-method-shorthand.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const obj = {\n      method() {\n        return 1;\n      },\n    };\n\n    t0 = obj.method();\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ x: 1 }, { a: 2 }, { b: 2 }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple React Component in JavaScript\nDESCRIPTION: This snippet defines a simple React functional component that returns a JSX element containing escaped HTML characters. It serves as a basic example for building React components.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-html-entity.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component() {\n  return <div>&gt;&lt;span &amp;</div>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Testing React Portals with react-is\nDESCRIPTION: Demonstrates checking if an element is a React Portal using isPortal and typeOf functions. Requires ReactDOM for portal creation.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-is/README.md#2025-04-21_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport * as ReactIs from 'react-is';\n\nconst div = document.createElement(\"div\");\nconst portal = ReactDOM.createPortal(<div />, div);\n\nReactIs.isPortal(portal); // true\nReactIs.typeOf(portal) === ReactIs.Portal; // true\n```\n\n----------------------------------------\n\nTITLE: Subscribing to DOM event dispatchers with use-subscription in React\nDESCRIPTION: Example demonstrating how to use the useSubscription hook to subscribe to event dispatchers like DOM elements. The component will automatically re-render when the input value changes.\nSOURCE: https://github.com/facebook/react/blob/main/packages/use-subscription/README.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport React, { useMemo } from \"react\";\nimport { useSubscription } from \"use-subscription\";\n\n// In this example, \"input\" is an event dispatcher (e.g. an HTMLInputElement)\n// but it could be anything that emits an event and has a readable current value.\nfunction Example({ input }) {\n\n  // Memoize to avoid removing and re-adding subscriptions each time this hook is called.\n  const subscription = useMemo(\n    () => ({\n      getCurrentValue: () => input.value,\n      subscribe: callback => {\n        input.addEventListener(\"change\", callback);\n        return () => input.removeEventListener(\"change\", callback);\n      }\n    }),\n\n    // Re-subscribe any time our input changes\n    // (e.g. we get a new HTMLInputElement prop to subscribe to)\n    [input]\n  );\n\n  // The value returned by this hook reflects the input's current value.\n  // Our component will automatically be re-rendered when that value changes.\n  const value = useSubscription(subscription);\n\n  // Your rendered output goes here ...\n}\n```\n\n----------------------------------------\n\nTITLE: React ForwardRef with Hook in Anonymous Function\nDESCRIPTION: This snippet demonstrates the usage of React's `forwardRef` with a hook inside an anonymous function. The `FancyButton` component is created using `React.forwardRef` and takes `props` and `ref` as arguments. The `useHook()` function is called within the component to utilize a custom hook.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-9a47e97b5d13.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Valid because hooks can be used in anonymous function arguments to\n// forwardRef.\nconst FancyButton = React.forwardRef(function (props, ref) {\n  useHook();\n  return <button {...props} ref={ref} />;\n});\n\n```\n\n----------------------------------------\n\nTITLE: Connecting React DevTools to React DOM in HTML\nDESCRIPTION: HTML snippet showing how to connect React DevTools to a React DOM application by adding a script tag that loads the DevTools client. This should be the first script in the head of the document during development.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/README.md#2025-04-21_snippet_5\n\nLANGUAGE: html\nCODE:\n```\n<!doctype html>\n<html lang=\"en\">\n  <head>\n    <script src=\"http://localhost:8097\"></script>\n```\n\n----------------------------------------\n\nTITLE: React Component with Conditional Hook Usage\nDESCRIPTION: The `InvalidComponent` conditionally calls the `useHook` function based on the `props.cond` value. This can violate the rules of hooks if the condition changes between renders, leading to unpredictable behavior. It imports `useHook` from `shared-runtime`.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/multiple-components-first-is-invalid.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @panicThreshold(none)\nimport {useHook} from 'shared-runtime';\n\nfunction InvalidComponent(props) {\n  if (props.cond) {\n    useHook();\n  }\n  return <div>Hello World!</div>;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Hydrating Server-Rendered App in React 18\nDESCRIPTION: New method to hydrate a server-rendered application in React 18. It replaces ReactDOM.hydrate and works with new React DOM Server APIs.\nSOURCE: https://github.com/facebook/react/blob/main/CHANGELOG.md#2025-04-21_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\nhydrateRoot\n```\n\n----------------------------------------\n\nTITLE: Configuring eslint-plugin-react-hooks with modern flat config (ESLint 6.0+)\nDESCRIPTION: Setup for ESLint 6.0 and newer using the modern flat config format with the recommended configuration in eslint.config.js.\nSOURCE: https://github.com/facebook/react/blob/main/packages/eslint-plugin-react-hooks/README.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as reactHooks from 'eslint-plugin-react-hooks';\n\nexport default [\n  // ...\n  reactHooks.configs.recommended,\n];\n```\n\n----------------------------------------\n\nTITLE: Creating and Using ReactTestRenderer with JSX\nDESCRIPTION: This snippet demonstrates how to use the react-test-renderer package to render a Link component to a JavaScript object and display its JSON representation. The renderer creates a pure JavaScript object representation of the component tree without requiring a browser or jsdom.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-test-renderer/README.md#2025-04-21_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nconst ReactTestRenderer = require('react-test-renderer');\n\nconst renderer = ReactTestRenderer.create(\n  <Link page=\"https://www.facebook.com/\">Facebook</Link>\n);\n\nconsole.log(renderer.toJSON());\n// { type: 'a',\n//   props: { href: 'https://www.facebook.com/' },\n//   children: [ 'Facebook' ] }\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with useState Hook\nDESCRIPTION: This snippet demonstrates a basic React component using the useState hook to manage a counter state. It renders the current count and a button to increment it.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/resolve-react-hooks-based-on-import-name.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useState as useReactState} from 'react';\n\nfunction Component() {\n  const [state, setState] = useReactState(0);\n\n  const onClick = () => {\n    setState(s => s + 1);\n  };\n\n  return (\n    <>\n      Count {state}\n      <button onClick={onClick}>Increment</button>\n    </>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Installing react-devtools as Project Dependency with Yarn\nDESCRIPTION: Command for adding react-devtools as a development dependency to a specific project using Yarn. This approach avoids global installations by scoping the tool to a single project.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/README.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nyarn add --dev react-devtools\n```\n\n----------------------------------------\n\nTITLE: Installing react-is package with Yarn and NPM\nDESCRIPTION: Commands to install the react-is package using either Yarn or NPM package managers.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-is/README.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n# Yarn\nyarn add react-is\n\n# NPM\nnpm install react-is\n```\n\n----------------------------------------\n\nTITLE: Using DOM Event Testing Library with Jest for React Components\nDESCRIPTION: This example demonstrates how to use dom-event-testing-library to test a React hook that handles tap events. It shows setting up tests with different pointer types, creating event targets, and dispatching pointer events in a way that realistically simulates browser behavior.\nSOURCE: https://github.com/facebook/react/blob/main/packages/dom-event-testing-library/README.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {\n  describeWithPointerEvent,\n  testWithPointerType,\n  createEventTarget,\n  setPointerEvent,\n  resetActivePointers\n} from 'dom-event-testing-library';\n\ndescribeWithPointerEvent('useTap', hasPointerEvent => {\n  beforeEach(() => {\n    // basic PointerEvent mock\n    setPointerEvent(hasPointerEvent);\n  });\n\n  afterEach(() => {\n    // clear active pointers between test runs\n    resetActivePointers();\n  });\n\n  // test all the pointer types supported by the environment\n  testWithPointerType('pointer down', pointerType => {\n    const ref = createRef(null);\n    const onTapStart = jest.fn();\n    render(() => {\n      useTap(ref, { onTapStart });\n      return <div ref={ref} />\n    });\n\n    // create an event target\n    const target = createEventTarget(ref.current);\n    // dispatch high-level pointer event\n    target.pointerdown({ pointerType });\n\n    expect(onTapStart).toBeCalled();\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Server-Side Rendering with React DOM\nDESCRIPTION: Example of server-side rendering using react-dom/server's renderToPipeableStream function. Shows how to create a stream and pipe it to an HTTP response.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-dom/README.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { renderToPipeableStream } from 'react-dom/server';\n\nfunction App() {\n  return <div>Hello World</div>;\n}\n\nfunction handleRequest(res) {\n  // ... in your server handler ...\n  const stream = renderToPipeableStream(<App />, {\n    onShellReady() {\n      res.statusCode = 200;\n      res.setHeader('Content-type', 'text/html');\n      stream.pipe(res);\n    },\n    // ...\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: JSX Children Transformation\nDESCRIPTION: This example illustrates how JSX children are transformed into arguments. Instead of wrapping children in an array, they are now directly passed as arguments to the React.DOM element. This modification simplifies the structure of the transformed code and affects how React components are rendered when using JSX.\nSOURCE: https://github.com/facebook/react/blob/main/CHANGELOG.md#2025-04-21_snippet_26\n\nLANGUAGE: JSX\nCODE:\n```\n\"<div><Component1/><Component2/></div>\"\n```\n\n----------------------------------------\n\nTITLE: Building DevTools Dependencies from Source\nDESCRIPTION: Command for building the dependencies required by React DevTools from source. This must be run from the root of the repository before starting local development of DevTools.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/README.md#2025-04-21_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\nyarn build-for-devtools\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with Custom Hook in JavaScript\nDESCRIPTION: This snippet defines a React component that uses a custom hook 'useMakeArray' from an imported 'ObjectWithHooks'. The component creates an array, adds an element from the hook's result, and returns that element. It also exports a fixture entrypoint for testing.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/flatten-scopes-with-methodcall-hook.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst { ObjectWithHooks } = require(\"shared-runtime\");\n\nfunction Component(props) {\n  const x = [];\n  const [y] = ObjectWithHooks.useMakeArray();\n  x.push(y);\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Advanced Function Component with Runtime Cache in React\nDESCRIPTION: This snippet demonstrates a more complex version of the 'Foo' component that utilizes the 'react/compiler-runtime' for caching and memoization. It checks if the cached value is available, and if not, it creates a new instance of 'Stringify'. The function manages render counting via a separate '_temp' function, enhancing performance through memoization strategies.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/update-global-in-callback.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { Stringify } from \"shared-runtime\";\n\nlet renderCount = 0;\nfunction Foo() {\n  const $ = _c(1);\n  const cb = _temp;\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = <Stringify cb={cb} shouldInvokeFns={true} />;\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\nfunction _temp() {\n  renderCount = renderCount + 1;\n  return renderCount;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Initializing and Connecting Backend to React DevTools\nDESCRIPTION: Example of how to use the backend API for a non-browser-based React renderer. This must be called before React packages are imported and run in the same context as React.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools-core/README.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nif (process.env.NODE_ENV !== 'production') {\n  const { initialize, connectToDevTools } = require(\"react-devtools-core\");\n\n  initialize(settings);\n  // Must be called before packages like react or react-native are imported\n  connectToDevTools({...config});\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Functional Component with Conditional Rendering in React\nDESCRIPTION: This snippet demonstrates a more advanced React functional component named 'Test' that uses the 'react/compiler-runtime' to implement memoization. It conditionally renders a string within a div, allowing for efficient updates based on state.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-bracket-in-text.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Test() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = (\n      <div>\n        {\n          \"If the string contains the string {pageNumber} it will be replaced by the page number.\"\n        }\n      </div>\n    );\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Test,\n  params: [],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Publish Release Script\nDESCRIPTION: This script publishes a release to NPM using specified tags. It's the final step in making a release available to the public after it has been prepared using other scripts. The `--tags` argument determines which channels (e.g., next, experimental, latest) the release will be published to.\nSOURCE: https://github.com/facebook/react/blob/main/scripts/release/README.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nscripts/release/publish.js --tags next\n```\n\n----------------------------------------\n\nTITLE: Managing State with useState and useEffect in React - JavaScript\nDESCRIPTION: This snippet demonstrates a basic React component named Component, utilizing useState and useEffect hooks. It initializes a state with value 0 and updates the state after a 10ms timeout using setTimeout. The component is exported as FIXTURE_ENTRYPOINT, allowing its use elsewhere. Dependencies include React's useEffect and useState hooks.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/valid-setState-in-useEffect-listener.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validateNoSetStateInPassiveEffects\nimport {useEffect, useState} from 'react';\n\nfunction Component() {\n  const [state, setState] = useState(0);\n  useEffect(() => {\n    setTimeout(setState, 10);\n  });\n  return state;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing React.memo Cache with React Components in JavaScript\nDESCRIPTION: This snippet illustrates the usage of React.memo caching using a custom symbol technique. The 'Component' function checks a cache symbol to decide if it needs to render a new child component or return a cached one. It demonstrates performance optimization via memoization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/quoted-strings-in-jsx-attribute.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nexport function Component() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = <Child text={'Some \\\"text\\\"'} />;\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nfunction Child(props) {\n  return props.text;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Basic Component Initialization in React\nDESCRIPTION: This snippet shows a simple React component that uses the useState hook to manage internal state. The component takes props, specifically a property 'x', transforms it with the function 'f', and displays it inside a div element. This serves as a typical pattern in functional React components where state initialization is tied to props.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useState-pruned-dependency-change-detect.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableChangeDetectionForDebugging\nimport {useState} from 'react';\n\nfunction Component(props) {\n  const [x, _] = useState(f(props.x));\n  return <div>{x}</div>;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Testing React Context Components with react-is\nDESCRIPTION: Shows how to determine if elements are Context Providers or Consumers using isContextConsumer, isContextProvider, and typeOf functions from react-is.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-is/README.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport React from \"react\";\nimport * as ReactIs from 'react-is';\n\nconst ThemeContext = React.createContext(\"blue\");\n\nReactIs.isContextConsumer(<ThemeContext.Consumer />); // true\nReactIs.isContextProvider(<ThemeContext.Provider />); // true\nReactIs.typeOf(<ThemeContext.Provider />) === ReactIs.ContextProvider; // true\nReactIs.typeOf(<ThemeContext.Consumer />) === ReactIs.ContextConsumer; // true\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: React component demonstrating memo block behavior with non-reactive values. Shows how array references are maintained when dealing with recreated values and memoization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-invalid-pruned-scope-leaks-value-via-alias.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport invariant from 'invariant';\nimport {makeObject_Primitives, mutate, sum, useIdentity} from 'shared-runtime';\n\n/**\n * Here, `z`'s original memo block is removed due to the inner hook call.\n * However, we also infer that `z` is non-reactive, so by default we would create\n * the memo block for `thing = [y, z]` as only depending on `y`.\n *\n * This could then mean that `thing[1]` and `z` may not refer to the same value,\n * since z recreates every time but `thing` doesn't correspondingly invalidate.\n *\n * The fix is to consider pruned memo block outputs as reactive, since they will\n * recreate on every render. This means `thing` depends on both y and z.\n */\nfunction MyApp({count}) {\n  const z = makeObject_Primitives();\n  const x = useIdentity(2);\n  const y = sum(x, count);\n  mutate(z);\n  const z2 = z;\n  const thing = [y, z2];\n  if (thing[1] !== z) {\n    invariant(false, 'oh no!');\n  }\n  return thing;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: MyApp,\n  params: [{count: 2}],\n  sequentialRenders: [{count: 2}, {count: 2}, {count: 3}],\n};\n```\n\n----------------------------------------\n\nTITLE: Using Client References in Server Components\nDESCRIPTION: Example showing how to import and use client references (both component and function) within a server component. Client references are passed as props to client components and will be executed on the client side.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-server/README.md#2025-04-21_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\n// client references don't have to just be components, anything can be \n// a reference, in this case we're importing a function that will be\n// passed to the ClientComp component\nimport { alert } from '...'\nimport { ClientComp } from '...'\n\nasync function App({ children }) {\n  return children\n}\n\ncreateResponse(\n  <App >\n    <ClientComp onClick={alert} message={\"hello world\"} />\n  </App>,\n...)\n```\n\n----------------------------------------\n\nTITLE: Using new React.createRef() API in JavaScript\nDESCRIPTION: Example of using the new React.createRef() API introduced in React 16.3 as an alternative to callback refs.\nSOURCE: https://github.com/facebook/react/blob/main/CHANGELOG.md#2025-04-21_snippet_16\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst myRef = React.createRef();\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Ref Hook in React\nDESCRIPTION: This snippet defines a custom hook 'useCustomRef' that initializes a ref with a default click function. The 'Foo' component illustrates how to use this ref in a button click handler, utilizing React's useCallback for memoization to optimize rendering. Key parameters include the click handler and the ref object.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.ref-like-name-not-a-ref.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees\nimport {useCallback, useRef} from 'react';\n\nfunction useCustomRef() {\n  return useRef({click: () => {}});\n}\n\nfunction Foo() {\n  const notaref = useCustomRef();\n\n  const onClick = useCallback(() => {\n    notaref.current?.click();\n  }, []);\n\n  return <button onClick={onClick} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [],\n  isComponent: true,\n};\n```\n\n----------------------------------------\n\nTITLE: Checking Out Pre-Built React\nDESCRIPTION: Checkout the latest version of React using a CI build from the main branch.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/CONTRIBUTING.md#2025-04-21_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\ncd <react-repo>\n\ncd scripts/release\nyarn install\n\n./download-experimental-build.js --commit=main\n```\n\n----------------------------------------\n\nTITLE: React Component with useCallback Memoization\nDESCRIPTION: This React component `useFoo` attempts to memoize a callback using `useCallback`. However, the React Compiler identifies that the memoization could not be preserved because the dependency array `[x]` is causing issues during compilation. Specifically, the compiler cannot guarantee the existing memoization due to how `x` is being handled.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.todo-useCallback-captures-invalidating-value.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees\n\nimport {useCallback} from 'react';\n\n// False positive:\n// We currently bail out on this because we don't understand\n// that `() => [x]` gets pruned because `x` always invalidates.\nfunction useFoo(props) {\n  const x = [];\n  useHook();\n  x.push(props);\n\n  return useCallback(() => [x], [x]);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{}]],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with Memo Directives\nDESCRIPTION: A React component implementation that demonstrates the usage of memo directives. The component uses 'use no memo' at the module level while enabling memo within the component function. It renders a Button component with a dynamic value passed through props.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/use-no-memo-module-scope-usememo-function-scope.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @compilationMode(all)\n'use no memo';\n\nfunction TestComponent({x}) {\n  'use memo';\n  return <Button>{x}</Button>;\n}\n```\n\n----------------------------------------\n\nTITLE: React Compiler Runtime Transformation\nDESCRIPTION: Shows the compiled version of the React component with explicit memoization cache management using compiler runtime symbols and temporary variables\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ref-like-name-in-effect.expect.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nfunction useCustomRef() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = { click: _temp };\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return useRef(t0);\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Unique IDs with useId Hook\nDESCRIPTION: New `useId` hook for generating unique, stable identifiers across client and server rendering, useful for form inputs and accessibility attributes.\nSOURCE: https://github.com/facebook/react/blob/main/CHANGELOG.md#2025-04-21_snippet_14\n\nLANGUAGE: javascript\nCODE:\n```\nconst id = useId();\nreturn <label htmlFor={id}>Name</label>;\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component Output\nDESCRIPTION: This snippet shows the compiled version of the component function. It introduces memoization using Symbol.for('react.memo_cache_sentinel') and imports a compiler runtime function. The structure is optimized for performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/function-declaration-reassign.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction component() {\n  const $ = _c(1);\n  let x;\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = {};\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  x = t0;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Initializing React Component with Compiler Runtime - JavaScript\nDESCRIPTION: This function defines a more complex React component that utilizes the 'react/compiler-runtime' to manage reactivity. It checks if the prop has changed and reuses an existing array for output if it hasn't. The expected input is a 'props' object containing a key 'a', and it outputs an array with the value of 'a'. It also maintains state for optimization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/iife-return-modified-later.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(3);\n  let t0;\n  let items;\n  if ($[0] !== props.a) {\n    t0 = [];\n    items = t0;\n\n    items.push(props.a);\n    $[0] = props.a;\n    $[1] = items;\n    $[2] = t0;\n  } else {\n    items = $[1];\n    t0 = $[2];\n  }\n  return items;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ a: {} }],\n};\n```\n\n----------------------------------------\n\nTITLE: Dynamic Hook Integration in React Component using useFire in JavaScript\nDESCRIPTION: This code illustrates a React component using a custom hook useFire from 'react/compiler-runtime'. It defines a temporary function to process properties and invokes it inside a useEffect hook, ensuring that changes in component properties trigger specific logic.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/repro-dont-add-hook-guards-on-retry.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useFire } from \"react/compiler-runtime\";\\nimport { useEffect, fire } from \"react\";\\n\\nfunction Component(props, useDynamicHook) {\\n  \"use memo\";\\n\\n  useDynamicHook();\\n  const foo = _temp;\\n  const t0 = useFire(foo);\\n\\n  useEffect(() => {\\n    t0(props);\\n  });\\n  return <div>hello world</div>;\\n}\\nfunction _temp(props_0) {\\n  console.log(props_0);\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Installing use-subscription package using Yarn or NPM\nDESCRIPTION: Commands to install the use-subscription package using either Yarn or NPM package managers.\nSOURCE: https://github.com/facebook/react/blob/main/packages/use-subscription/README.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n# Yarn\nyarn add use-subscription\n\n# NPM\nnpm install use-subscription\n```\n\n----------------------------------------\n\nTITLE: Managing Dependencies in a React Component - JavaScript\nDESCRIPTION: This snippet defines a React component function 'Foo' that conditionally renders an element based on the input properties 'cond' and 'value'. It uses 'identity' and 'Stringify' from 'shared-runtime' for processing and rendering. The component tracks state to optimize re-renders by checking if the dependencies have changed. The entry point 'FIXTURE_ENTRYPOINT' specifies parameters for executing the component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/infer-component-props-non-null.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enablePropagateDepsInHIR\\nimport {identity, Stringify} from 'shared-runtime';\\n\\nfunction Foo(props) {\\n  /**\\n   * props.value should be inferred as the dependency of this scope\\n   * since we know that props is safe to read from (i.e. non-null)\\n   * as it is arg[0] of a component function\\n   */\\n  const arr = [];\\n  if (props.cond) {\\n    arr.push(identity(props.value));\\n  }\\n  return <Stringify arr={arr} />;\\n}\\n\\nexport const FIXTURE_ENTRYPOINT = {\\n  fn: Foo,\\n  params: [{value: 2, cond: true}],\\n};\\n\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with useRef and onClick Handler\nDESCRIPTION: This snippet defines a React component that uses useRef to manage an input element and includes an onClick handler for a button. The handler checks and modifies the ref's current value.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-mutating-ref-in-callback-passed-to-jsx.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validateRefAccessDuringRender\nimport {useRef} from 'react';\n\nfunction Component() {\n  const ref = useRef(null);\n\n  const onClick = () => {\n    if (ref.current !== null) {\n      ref.current = '';\n    }\n  };\n\n  return (\n    <>\n      <input ref={ref} />\n      <button onClick={onClick} />\n    </>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing React Compiler Runtime Memoization\nDESCRIPTION: Uses React compiler runtime to create a memoized cache for component rendering, optimizing performance by caching computed values and rendered elements\nSOURCE: https://github.com/facebook/react/blob/main/compiler/apps/playground/__tests__/e2e/__snapshots__/page.spec.ts/parse-typescript-output.txt#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Foo() {\n  const $ = _c(2);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = foo();\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const x = t0 as number;\n  let t1;\n  if ($[1] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = <div>{x}</div>;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n```\n\n----------------------------------------\n\nTITLE: Original React Component with Context Usage\nDESCRIPTION: Defines a React component that uses Context API to access a boolean state and renders conditional output using a Stringify component. Includes context creation and component export configuration.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useContext-read-context-in-callback-if-condition.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {createContext, useContext} from 'react';\nimport {Stringify} from 'shared-runtime';\n\nconst FooContext = createContext({current: true});\n\nfunction Component(props) {\n  const foo = useContext(FooContext);\n\n  const getValue = () => {\n    if (foo.current) {\n      return {};\n    } else {\n      return null;\n    }\n  };\n  const value = getValue();\n\n  return <Stringify value={value} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Adding Transition Hooks in React\nDESCRIPTION: Introduction of new hooks `useTransition` and `useDeferredValue` to manage urgent and non-urgent updates in React applications, improving rendering performance and user experience.\nSOURCE: https://github.com/facebook/react/blob/main/CHANGELOG.md#2025-04-21_snippet_13\n\nLANGUAGE: javascript\nCODE:\n```\nconst [isPending, startTransition] = useTransition();\nconst deferredValue = useDeferredValue(value);\n```\n\n----------------------------------------\n\nTITLE: Implementing Optimistic Updates with useOptimistic Hook\nDESCRIPTION: The useOptimistic hook provides a way to update state immediately while a transition is in progress, creating a better user experience. It returns the current state and a setter function that can be called inside a transition.\nSOURCE: https://github.com/facebook/react/blob/main/CHANGELOG.md#2025-04-21_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nfunction CommentList() {\n  const [comments, setComments] = useState([]);\n  const [optimisticComments, addOptimisticComment] = useOptimistic(comments);\n  \n  async function handleAddComment(newComment) {\n    startTransition(async () => {\n      // Optimistically update the UI immediately\n      addOptimisticComment([...comments, newComment]);\n      \n      // Actually send the comment to the server\n      await submitComment(newComment);\n      \n      // When transition is complete, the real state will be updated\n      setComments([...comments, newComment]);\n    });\n  }\n  \n  return (\n    <div>\n      {optimisticComments.map(comment => <Comment data={comment} />)}\n      <AddCommentForm onSubmit={handleAddComment} />\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Supporting Named Hooks\nDESCRIPTION: This JavaScript snippet illustrates how to support named hooks in React DevTools by providing a `hookNamesModuleLoaderFunction` prop to the DevTools component. This function dynamically imports the necessary module for extracting hook names. The module is lazy-loaded only when the feature is enabled, improving performance.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools-inline/README.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n// Follow code examples above to configure the backend and frontend.\n// When rendering DevTools, the important part is to pass a 'hookNamesModuleLoaderFunction' prop.\nconst hookNamesModuleLoaderFunction = () => import('react-devtools-inline/hookNames');\n\n// Render:\n<DevTools\n  hookNamesModuleLoaderFunction={hookNamesModuleLoaderFunction}\n  {...otherProps}\n/>;\n```\n\n----------------------------------------\n\nTITLE: Input React Component Implementation\nDESCRIPTION: Original React component code showing state management with useState and useEffect hooks. Uses a global object for state storage and demonstrates effect dependencies.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-global-mutation-in-effect-indirect.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useEffect, useState} from 'react';\n\nlet someGlobal = {};\n\nfunction Component() {\n  const [state, setState] = useState(someGlobal);\n\n  const setGlobal = () => {\n    someGlobal.value = true;\n  };\n  useEffect(() => {\n    setGlobal();\n  }, []);\n\n  useEffect(() => {\n    setState(someGlobal.value);\n  }, [someGlobal]);\n\n  return <div>{String(state)}</div>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Using the new use API with Promises and Context\nDESCRIPTION: The use API allows reading resources during render and supports both promises and Context. When provided a promise, it will suspend until a value is resolved. Unlike hooks, use can be called conditionally within render.\nSOURCE: https://github.com/facebook/react/blob/main/CHANGELOG.md#2025-04-21_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\n// With Promise\nfunction ProfileDetails({ userId }) {\n  const userDataPromise = fetchUserData(userId);\n  \n  // Will suspend component until promise resolves\n  const userData = use(userDataPromise);\n  \n  return <div>{userData.name}</div>;\n}\n\n// With Context\nfunction ThemeText({ children }) {\n  // Can be used conditionally unlike useContext\n  const theme = use(ThemeContext);\n  \n  if (theme.dark) {\n    return <span className=\"dark-text\">{children}</span>;\n  } else {\n    return <span className=\"light-text\">{children}</span>;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Building React and Fixtures\nDESCRIPTION: This snippet provides instructions on how to build React and the manual testing fixtures. It uses `npm run build` to build React and `node fixtures/packaging/build-all.js` to build the fixtures.\nSOURCE: https://github.com/facebook/react/blob/main/fixtures/packaging/README.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncd react\nnpm run build\nnode fixtures/packaging/build-all.js\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: The compiled version of the Foo component that includes memoization logic using React compiler runtime. It uses a Symbol-based cache sentinel to determine whether to compute or reuse the previous value.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/memoize-value-block-value-conditional.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Foo(props) {\n  const $ = _c(1);\n  let x;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    true ? (x = []) : (x = {});\n    $[0] = x;\n  } else {\n    x = $[0];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Demonstrating difference between value property and attribute in JavaScript\nDESCRIPTION: Illustrates how the value property manipulates the working value for an input, while the attribute remains unchanged. This shows the separation between the visible/functional value and the attribute value.\nSOURCE: https://github.com/facebook/react/blob/main/fixtures/dom/src/components/fixtures/text-inputs/README.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nvar input = document.createElement('input')\ninput.defaultValue = 'hello'\ninput.value = 'goodbye'\n\nconsole.log(input.getAttribute('value')) // => \"hello\"\nconsole.log(input.value) // => \"goodbye\"\n```\n\n----------------------------------------\n\nTITLE: Defining Functional Component with Static Text in React\nDESCRIPTION: This snippet defines a simple React functional component named 'Test' which returns a static JSX element containing a string that references 'pageNumber'. It serves as a basic demonstration of component creation in React.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-bracket-in-text.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Test() {\n  return (\n    <div>\n      If the string contains the string &#123;pageNumber&#125; it will be\n      replaced by the page number.\n    </div>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Test,\n  params: [],\n};\n\n```\n\n----------------------------------------\n\nTITLE: JSX Transformed Output Example\nDESCRIPTION: This code shows the output of JSX transformation where children are passed as arguments. Component1 and Component2 are invoked directly as arguments to `React.DOM.div`. This change from wrapping the component calls in an array aims to simplify the generated code and potentially improve performance.\nSOURCE: https://github.com/facebook/react/blob/main/CHANGELOG.md#2025-04-21_snippet_27\n\nLANGUAGE: JavaScript\nCODE:\n```\n\"React.DOM.div(null, Component1(null), Component2(null))\"\n```\n\n----------------------------------------\n\nTITLE: Invalid Conditional Hook Usage in React\nDESCRIPTION: Demonstrates an invalid pattern where React Hooks are called conditionally using && operators. This violates the Rules of Hooks which require hooks to be called in a consistent order and not within conditions.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-rules-of-hooks-9bf17c174134.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Expected to fail\n\n// Invalid because it's dangerous and might not warn otherwise.\n// This *must* be invalid.\nfunction useHook() {\n  a && useHook1();\n  b && useHook2();\n}\n```\n\nLANGUAGE: text\nCODE:\n```\n  4 | // This *must* be invalid.\n  5 | function useHook() {\n> 6 |   a && useHook1();\n    |        ^^^^^^^^ InvalidReact: Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning) (6:6)\n\nInvalidReact: Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning) (7:7)\n  7 |   b && useHook2();\n  8 | }\n  9 |\n```\n\n----------------------------------------\n\nTITLE: Implementing Memoization with Validation in React\nDESCRIPTION: This code snippet defines a React functional component that utilizes the `useMemo` hook to memoize derived data based on the `arg.items` prop. It uses a `ValidateMemoization` component to ensure the memoization guarantees are preserved. The snippet is intended for scenarios where performance optimizations via memoization and validation are crucial.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-member-expression-single.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees @enableOptionalDependencies\nimport {ValidateMemoization} from 'shared-runtime';\nimport {useMemo} from 'react';\nfunction Component({arg}) {\n  const data = useMemo(() => {\n    const x = [];\n    x.push(arg?.items);\n    return x;\n  }, [arg?.items]);\n  return <ValidateMemoization inputs={[arg?.items]} output={data} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{arg: {items: 2}}],\n  sequentialRenders: [\n    {arg: {items: 2}},\n    {arg: {items: 2}},\n    {arg: null},\n    {arg: null},\n  ],\n};\n```\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @validatePreserveExistingMemoizationGuarantees @enableOptionalDependencies\nimport { ValidateMemoization } from \"shared-runtime\";\nimport { useMemo } from \"react\";\nfunction Component(t0) {\n  const $ = _c(7);\n  const { arg } = t0;\n\n  arg?.items;\n  let t1;\n  let x;\n  if ($[0] !== arg?.items) {\n    x = [];\n    x.push(arg?.items);\n    $[0] = arg?.items;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  t1 = x;\n  const data = t1;\n  const t2 = arg?.items;\n  let t3;\n  if ($[2] !== t2) {\n    t3 = [t2];\n    $[2] = t2;\n    $[3] = t3;\n  } else {\n    t3 = $[3];\n  }\n  let t4;\n  if ($[4] !== data || $[5] !== t3) {\n    t4 = <ValidateMemoization inputs={t3} output={data} />;\n    $[4] = data;\n    $[5] = t3;\n    $[6] = t4;\n  } else {\n    t4 = $[6];\n  }\n  return t4;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ arg: { items: 2 } }],\n  sequentialRenders: [\n    { arg: { items: 2 } },\n    { arg: { items: 2 } },\n    { arg: null },\n    { arg: null },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Using Refs as Props without forwardRef\nDESCRIPTION: In React 19, refs can be directly used as props, eliminating the need for forwardRef. This simplifies component API design and makes ref forwarding more straightforward.\nSOURCE: https://github.com/facebook/react/blob/main/CHANGELOG.md#2025-04-21_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\n// Before React 19 - using forwardRef\nconst ButtonBefore = React.forwardRef((props, ref) => {\n  return <button ref={ref} {...props} />;\n});\n\n// React 19 - direct ref passing\nfunction ButtonAfter(props) {\n  // ref can be received directly as a prop\n  return <button {...props} />;\n}\n\n// Usage\nfunction App() {\n  const buttonRef = useRef(null);\n  \n  return <ButtonAfter ref={buttonRef}>Click me</ButtonAfter>;\n}\n```\n\n----------------------------------------\n\nTITLE: Optimizing React Component with Default Value Assignment in JavaScript\nDESCRIPTION: This snippet shows an optimized version of the previous component. Instead of using array destructuring with a default value, it explicitly checks if the first element is undefined and assigns the default value accordingly. The functionality remains the same.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-default-past-end-of-array.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const [t0] = props.value;\n  const x = t0 === undefined ? 42 : t0;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ value: [] }],\n};\n```\n\n----------------------------------------\n\nTITLE: Backend Initialization and Activation\nDESCRIPTION: This JavaScript snippet demonstrates how to initialize and activate the React DevTools backend within an iframe.  It's crucial to initialize before React is loaded and activate only after the frontend is ready to avoid missing initialization events.  The code retrieves the iframe's contentWindow and passes it to the `initialize` and `activate` functions.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools-inline/README.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { activate, initialize } from 'react-devtools-inline/backend';\n\n// This should be the iframe the React application is running in.\nconst iframe = document.getElementById(frameID);\nconst contentWindow = iframe.contentWindow;\n\n// Call this before importing React (or any other packages that might import React).\ninitialize(contentWindow);\n\n// Initialize the frontend...\n\n// Call this only once the frontend has been initialized.\nactivate(contentWindow);\n```\n\n----------------------------------------\n\nTITLE: Defining Basic React Component in JavaScript\nDESCRIPTION: Defines a simple React component called Component that returns an empty div element. The snippet highlights the basic use of JSX to create a component structure. No dependencies are required other than React itself. Inputs include the component properties through props, and the output is a rendered JSX element.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-functions-component-with-jsx.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @compilationMode(infer)\nfunction Component(props) {\n  return <div />;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Original JavaScript Function 'foo'\nDESCRIPTION: This snippet defines the original 'foo' function, which takes four arguments (a, b, c, d) and returns an array 'y'. The logic within the function involves conditional checks based on 'a' and 'b' to push either 'c' or 'd' into the array. A label is used to potentially break out of the conditional block.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inverted-if.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(a, b, c, d) {\n  let y = [];\n  label: if (a) {\n    if (b) {\n      y.push(c);\n      break label;\n    }\n    y.push(d);\n  }\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Flight Render Function in React Server Components\nDESCRIPTION: This code demonstrates how to implement a render function for React Server Components using the Flight renderer. It creates a request and returns a ReadableStream for streaming the rendered output, handling starting, flowing, and aborting the render process.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-server/README.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {\n  createRequest,\n  startWork,\n  startFlowing,\n  stopFlowing,\n  abort,\n} from 'react-server/src/ReactFlightServer'\n\nfunction render(\n  model: ReactClientValue,\n  clientManifest: ClientManifest,\n  options?: Options,\n): ReadableStream {\n  const request = createRequest(\n    model,\n    clientManifest,\n    options ? options.onError : undefined,\n    options ? options.identifierPrefix : undefined,\n    options ? options.onPostpone : undefined,\n    options ? options.temporaryReferences : undefined,\n    __DEV__ && options ? options.environmentName : undefined,\n    __DEV__ && options ? options.filterStackFrame : undefined,\n  );\n  const stream = new ReadableStream(\n    {\n      type: 'bytes',\n      start: (controller): ?Promise<void> => {\n        startWork(request);\n      },\n      pull: (controller): ?Promise<void> => {\n        startFlowing(request, controller);\n      },\n      cancel: (reason): ?Promise<void> => {\n        stopFlowing(request);\n        abort(request, reason);\n      },\n    },\n    {highWaterMark: 0},\n  );\n  return stream;\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: Compiler-optimized version of the component that implements memoization using array-based caching to prevent unnecessary recalculations of values and dependencies.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-no-value-for-temporary.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(listItem, thread) {\n  const $ = _c(7);\n  let t0;\n  let t1;\n  let t2;\n  if ($[0] !== listItem || $[1] !== thread.threadType) {\n    const isFoo = isFooThread(thread.threadType);\n    t1 = useBar;\n    t2 = listItem;\n    t0 = getBadgeText(listItem, isFoo);\n    $[0] = listItem;\n    $[1] = thread.threadType;\n    $[2] = t0;\n    $[3] = t1;\n    $[4] = t2;\n  } else {\n    t0 = $[2];\n    t1 = $[3];\n    t2 = $[4];\n  }\n  let t3;\n  if ($[5] !== t0) {\n    t3 = [t0];\n    $[5] = t0;\n    $[6] = t3;\n  } else {\n    t3 = $[6];\n  }\n  const body = t1(t2, t3);\n  return body;\n}\n```\n\n----------------------------------------\n\nTITLE: React Compiler-Optimized Hook with Memoization\nDESCRIPTION: The compiler-transformed version of the useFoo hook that implements memoization using React's compiler runtime. It tracks previous values of x, y, and z and returns a cached object when inputs haven't changed, avoiding unnecessary object creation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/const-propagation-phi-nodes.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction useFoo(setOne) {\n  const $ = _c(4);\n  let x;\n  let y;\n  let z;\n  if (setOne) {\n    x = y = z = 1;\n  } else {\n    x = 2;\n    y = 3;\n    z = 5;\n  }\n  let t0;\n  if ($[0] !== x || $[1] !== y || $[2] !== z) {\n    t0 = { x, y, z };\n    $[0] = x;\n    $[1] = y;\n    $[2] = z;\n    $[3] = t0;\n  } else {\n    t0 = $[3];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [true],\n};\n```\n\n----------------------------------------\n\nTITLE: React Compiler Output with Memoization\nDESCRIPTION: This code shows the compiled version of the React component. It utilizes `react/compiler-runtime` to optimize rendering by memoizing intermediate results. The compiler-generated code uses an array `$` to store and reuse previously computed values, reducing unnecessary re-renders if the inputs haven't changed. The `_c` function from `react/compiler-runtime` is crucial for this memoization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-outlining-jsx-stored-in-id.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enableJsxOutlining\nfunction Component(t0) {\n  const $ = _c(7);\n  const { arr } = t0;\n  const x = useX();\n  let t1;\n  if ($[0] !== arr || $[1] !== x) {\n    let t2;\n    if ($[3] !== x) {\n      t2 = (i, id) => {\n        const T0 = _temp;\n        const jsx = <T0 i={i} key={id} x={x} />;\n        return jsx;\n      };\n      $[3] = x;\n      $[4] = t2;\n    } else {\n      t2 = $[4];\n    }\n    t1 = arr.map(t2);\n    $[0] = arr;\n    $[1] = x;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  let t2;\n  if ($[5] !== t1) {\n    t2 = <>{t1}</>;\n    $[5] = t1;\n    $[6] = t2;\n  } else {\n    t2 = $[6];\n  }\n  return t2;\n}\nfunction _temp(t0) {\n  const $ = _c(5);\n  const { i: i, x: x } = t0;\n  let t1;\n  if ($[0] !== i) {\n    t1 = <Baz i={i} />;\n    $[0] = i;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  let t2;\n  if ($[2] !== t1 || $[3] !== x) {\n    t2 = <Bar x={x}>{t1}</Bar>;\n    $[2] = t1;\n    $[3] = x;\n    $[4] = t2;\n  } else {\n    t2 = $[4];\n  }\n  return t2;\n}\n\nfunction Bar(t0) {\n  const $ = _c(3);\n  const { x, children } = t0;\n  let t1;\n  if ($[0] !== children || $[1] !== x) {\n    t1 = (\n      <>\n        {x}\n        {children}\n      </>\n    );\n    $[0] = children;\n    $[1] = x;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  return t1;\n}\n\nfunction Baz(t0) {\n  const { i } = t0;\n  return i;\n}\n\nfunction useX() {\n  return \"x\";\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ arr: [\"foo\", \"bar\"] }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Frozen Array (JavaScript)\nDESCRIPTION: This snippet defines a React component that creates an array, aliases it, freezes it using a custom hook, and passes it to another function. It demonstrates the concept of freezing objects and how aliases are affected.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/frozen-after-alias.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component() {\n  const a = [];\n  const b = a;\n  useFreeze(a);\n  foo(b); // should be readonly, value is guaranteed frozen via alias\n  return b;\n}\n\nfunction useFreeze() {}\nfunction foo(x) {}\n```\n\n----------------------------------------\n\nTITLE: Creating Root for Rendering in React 18\nDESCRIPTION: New method to create a root for rendering or unmounting in React 18. It replaces ReactDOM.render and is required for new React 18 features.\nSOURCE: https://github.com/facebook/react/blob/main/CHANGELOG.md#2025-04-21_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\ncreateRoot\n```\n\n----------------------------------------\n\nTITLE: TypeScript useReducer Type Simplification\nDESCRIPTION: Demonstrates simplified type annotations for useReducer hook in React 19, removing explicit type arguments in most cases\nSOURCE: https://github.com/facebook/react/blob/main/CHANGELOG.md#2025-04-21_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nuseReducer(reducer)\n```\n\nLANGUAGE: typescript\nCODE:\n```\nuseReducer<State, Action>(reducer)\n```\n\n----------------------------------------\n\nTITLE: Initializing a Custom React Renderer with react-reconciler\nDESCRIPTION: Basic example showing how to create a custom React renderer using the react-reconciler package. This demonstrates the main structure of using Reconciler with a HostConfig and exposing a public API.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-reconciler/README.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst Reconciler = require('react-reconciler');\n\nconst HostConfig = {\n  // You'll need to implement some methods here.\n  // See below for more information and examples.\n};\n\nconst MyRenderer = Reconciler(HostConfig);\n\nconst RendererPublicAPI = {\n  render(element, container, callback) {\n    // Call MyRenderer.updateContainer() to schedule changes on the roots.\n    // See ReactDOM, React Native, or React ART for practical examples.\n  }\n};\n\nmodule.exports = RendererPublicAPI;\n```\n\n----------------------------------------\n\nTITLE: Implementing FBT in a React Component\nDESCRIPTION: This snippet shows a React component using FBT for internationalization. It demonstrates how to use fbt tags and parameters within JSX to create localizable content.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbtparam-text-must-use-expression-container.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport fbt from 'fbt';\n\nfunction Component(props) {\n  return (\n    <Foo\n      value={\n        <fbt desc=\"Description of the parameter\">\n          <fbt:param name=\"value\">{'0'}</fbt:param>%\n        </fbt>\n      }\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Flight Rendering Examples with Primitive and Complex Types\nDESCRIPTION: Examples of rendering different data types with React Server Components, including primitives, objects, arrays, and collection types like Maps and Sets using the createResponse function.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-server/README.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// primitives\ncreateResponse(123, ...)\n\n// objects and Arrays\ncreateResponse({ messages: ['hello', 'react'] }, ...)\n\n// Maps, Sets, and more\ncreateResponse({ m: Map(['k', 'v'])}, ...)\n```\n\n----------------------------------------\n\nTITLE: Using useMemo for Memoization in React\nDESCRIPTION: This snippet defines a React functional component that uses the useMemo hook to compute a value based on the provided props. The component checks the prop's key and returns the corresponding value or a default value. It is intended to enhance performance by memoizing the result to avoid unnecessary calculations on re-renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-switch-no-fallthrough.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const x = useMemo(() => {\n    switch (props.key) {\n      case 'key': {\n        return props.value;\n      }\n      default: {\n        return props.defaultValue;\n      }\n    }\n  });\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n\n```\n\n----------------------------------------\n\nTITLE: Server-Side Rendering Stream Methods\nDESCRIPTION: New streaming methods for server-side rendering in React 16.\nSOURCE: https://github.com/facebook/react/blob/main/CHANGELOG.md#2025-04-21_snippet_22\n\nLANGUAGE: javascript\nCODE:\n```\nReactDOMServer.renderToNodeStream()\nReactDOMServer.renderToStaticNodeStream()\n```\n\n----------------------------------------\n\nTITLE: Original React Component with Error Handling\nDESCRIPTION: Basic React component that attempts to throw an error using throwErrorWithMessage and catches it to return null. Includes a fixture export for testing purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst {throwErrorWithMessage} = require('shared-runtime');\n\nfunction Component(props) {\n  let x;\n  try {\n    x = throwErrorWithMessage('oops');\n  } catch {\n    x = null;\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Demonstrating captureOwnerStack API Usage in React\nDESCRIPTION: The captureOwnerStack API is a development-only feature that returns an Owner Stack trace, which helps identify which components are responsible for rendering a particular component. It can be used to enhance error overlays or for debugging purposes.\nSOURCE: https://github.com/facebook/react/blob/main/CHANGELOG.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { captureOwnerStack } from 'react';\n\nfunction DebuggingComponent() {\n  // This API only works in development mode\n  const ownerStack = captureOwnerStack();\n  console.log('Components responsible for rendering this component:', ownerStack);\n  \n  return <div>Debugging component</div>;\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Compiler Runtime\nDESCRIPTION: Advanced implementation using React compiler runtime with optimized nested function handling, state tracking, and fire event mechanism\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/deep-scope.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c, useFire } from \"react/compiler-runtime\"; // @enableFire\\nimport { fire } from \"react\";\\n\\nfunction Component(props) {\\n  const $ = _c(3);\\n  const foo = _temp;\\n  const t0 = useFire(foo);\\n  let t1;\\n  if ($[0] !== props || $[1] !== t0) {\\n    t1 = () => {\\n      const nested = function nested() {\\n        const nestedAgain = function nestedAgain() {\\n          const nestedThrice = function nestedThrice() {\\n            t0(props);\\n          };\\n\\n          nestedThrice();\\n        };\\n\\n        nestedAgain();\\n      };\\n\\n      nested();\\n    };\\n    $[0] = props;\\n    $[1] = t0;\\n    $[2] = t1;\\n  } else {\\n    t1 = $[2];\\n  }\\n  useEffect(t1);\\n  return null;\\n}\\nfunction _temp(props_0) {\\n  console.log(props_0);\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Optimizing React Component with Memoization\nDESCRIPTION: This snippet shows how to implement a functional component with memoization using the '@compilationMode(infer)' directive and a separate memoization cache. It ensures that the component only re-renders if the memoized value changes, enhancing performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-function-expression-component.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @compilationMode(infer)\n\nconst Component = function ComponentName(props) {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = <Foo />;\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n};\n\n```\n\n----------------------------------------\n\nTITLE: Running Unit Tests for DevTools\nDESCRIPTION: Execute the unit tests for the core functionalities of the React DevTools.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/CONTRIBUTING.md#2025-04-21_snippet_8\n\nLANGUAGE: sh\nCODE:\n```\nyarn test-build-devtools\n```\n\n----------------------------------------\n\nTITLE: React Component with useCallback and useRef\nDESCRIPTION: This code defines a React component that uses `useCallback` to memoize an event handler and `useRef` to create a mutable reference to an object. The `onChange` handler updates the `inner` property of the ref's current value when the input value changes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useCallback-set-ref-nested-property-preserve-memoization.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enablePreserveExistingMemoizationGuarantees\nimport {useCallback, useRef} from 'react';\n\nfunction Component(props) {\n  const ref = useRef({inner: null});\n\n  const onChange = useCallback(event => {\n    // The ref should still be mutable here even though function deps are frozen in\n    // @enablePreserveExistingMemoizationGuarantees mode\n    ref.current.inner = event.target.value;\n  });\n\n  return <input onChange={onChange} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}]],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Basic React Component with useState and useEffect\nDESCRIPTION: Initial implementation of a React functional component using useState and useEffect hooks to manage and update component state\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useEffect-snap-test.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useEffect, useState} from 'react';\n\nfunction Component() {\n  const [state, setState] = useState('hello');\n  useEffect(() => {\n    setState('goodbye');\n  }, []);\n\n  return <div>{state}</div>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with FBT Optimization in JavaScript\nDESCRIPTION: This snippet shows the compiled and optimized version of the 'Foo' component. It uses the FBT runtime functions for efficient internationalization and includes memoization to avoid unnecessary re-renders when props don't change.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-preserve-whitespace-two-subtrees.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport fbt from \"fbt\";\n\nfunction Foo(t0) {\n  const $ = _c(3);\n  const { name1, name2 } = t0;\n  let t1;\n  if ($[0] !== name1 || $[1] !== name2) {\n    t1 = fbt._(\n      \"{user1} and {user2} accepted your PR!\",\n      [\n        fbt._param(\n          \"user1\",\n\n          <span key={name1}>\n            <b>{name1}</b>\n          </span>,\n        ),\n        fbt._param(\n          \"user2\",\n\n          <span key={name2}>\n            <b>{name2}</b>\n          </span>,\n        ),\n      ],\n      { hk: \"2PxMie\" },\n    );\n    $[0] = name1;\n    $[1] = name2;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{ name1: \"Mike\", name2: \"Jan\" }],\n};\n```\n\n----------------------------------------\n\nTITLE: Adding Root Node Operation in React DevTools\nDESCRIPTION: Example showing the operation payload for adding a root node to the component tree. It includes the operation type, fiber id, element type, and various capability flags.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/OVERVIEW.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n[\n  1, // add operation\n  1, // fiber id\n  11, // ElementTypeRoot\n  1, // this root is StrictMode enabled\n  1, // this root's renderer supports profiling\n  1, // this root's renderer supports StrictMode\n  1, // this root has owner metadata\n]\n```\n\n----------------------------------------\n\nTITLE: Implementing useMakeCallback React Hook - Original Code\nDESCRIPTION: Original implementation of a custom React hook that creates a callback function based on input object value. The hook uses useState and conditionally calls the callback during initial rendering when state is 0.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/assume-invoked/conditional-call.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useState} from 'react';\nimport {useIdentity} from 'shared-runtime';\n\n/**\n * Assume that conditionally called functions can be invoked and that their\n * property loads are hoistable to the function declaration site.\n */\nfunction useMakeCallback({obj}: {obj: {value: number}}) {\n  const [state, setState] = useState(0);\n  const cb = () => {\n    if (obj.value !== 0) setState(obj.value);\n  };\n  useIdentity(null);\n  if (state === 0) {\n    cb();\n  }\n  return {cb};\n}\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useMakeCallback,\n  params: [{obj: {value: 1}}],\n  sequentialRenders: [{obj: {value: 1}}, {obj: {value: 2}}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Implementing useFoo with useMemo\nDESCRIPTION: This snippet defines a custom hook `useFoo` that uses `useMemo` to memoize the concatenation of two arrays, `arr1` and `arr2`.  The result `{y}` is memoized based on changes to `y`, which is the concatenated array. It also exports a `FIXTURE_ENTRYPOINT` to specify function and params.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useMemo-reordering-depslist-assignment.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useMemo} from 'react';\n\nfunction useFoo(arr1, arr2) {\n  const x = [arr1];\n\n  let y;\n  return useMemo(() => {\n    return {y};\n  }, [((y = x.concat(arr2)), y)]);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [\n    [1, 2],\n    [3, 4],\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Memoization\nDESCRIPTION: This snippet shows the optimized version of the component using React's compiler runtime. It implements memoization to avoid unnecessary re-computations and conditionally executes the loop based on prop changes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/do-while-conditional-break.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  let x;\n  if ($[0] !== props) {\n    x = [0, 1, 2, 3];\n    do {\n      if (x === 0) {\n        break;\n      }\n\n      mutate(x);\n    } while (props.cond);\n    $[0] = props;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Installing and Running React Compiler Tests\nDESCRIPTION: Basic shell commands for setting up the development environment and running the React Compiler test suite using the custom 'snap' test runner in watch mode.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/docs/DEVELOPMENT_GUIDE.md#2025-04-21_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n# Install dependencies\nyarn\n\n# build the custom test runner\nyarn snap:build\n\n# Run the primary tests in watch mode\nyarn snap --watch\n```\n\n----------------------------------------\n\nTITLE: React Component with useMemo (Compiled Code)\nDESCRIPTION: This snippet presents the compiled version of the React component, leveraging `react/compiler-runtime` for enhanced memoization. It uses `_c` from `react/compiler-runtime` to cache and optimize the component's calculations. The `useMemo` hook is used to memoize a value based on the input prop `a`. `FIXTURE_ENTRYPOINT` is an object used for testing that specifies the component, its initial parameters, and the flag `isComponent`.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-simple-preserved-nomemo.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @disableMemoizationForDebugging\nimport { useMemo } from \"react\";\n\nfunction Component(t0) {\n  const $ = _c(5);\n  const { a } = t0;\n  let t1;\n  if ($[0] !== a || true) {\n    t1 = () => [a];\n    $[0] = a;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  let t2;\n  if ($[2] === Symbol.for(\"react.memo_cache_sentinel\") || true) {\n    t2 = [];\n    $[2] = t2;\n  } else {\n    t2 = $[2];\n  }\n  const x = useMemo(t1, t2);\n  let t3;\n  if ($[3] !== x || true) {\n    t3 = <div>{x}</div>;\n    $[3] = x;\n    $[4] = t3;\n  } else {\n    t3 = $[4];\n  }\n  return t3;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ a: 42 }],\n  isComponent: true,\n};\n\n```\n\n----------------------------------------\n\nTITLE: Using useMemo for Identity Function in React\nDESCRIPTION: This snippet demonstrates the use of the useMemo hook from React to optimize a function (identity). It ensures memoization of the result based on the input parameter x. The function is also included in an exportable fixture object for further testing or usage.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/prune-nonescaping-useMemo.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees\n\nimport {useMemo} from 'react';\nimport {identity} from 'shared-runtime';\n\n/**\n * This is technically a false positive, although it makes sense\n * to bailout as source code might be doing something sketchy.\n */\nfunction useFoo(x) {\n  useMemo(() => identity(x), [x]);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [2],\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Compiler Transformed Component with Memoization\nDESCRIPTION: The compiler-transformed version of the same component that automatically implements memoization. It imports a runtime helper and uses an array to cache the props and result, recalculating only when props change.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-receiver-method-call.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== props) {\n    const x = makeOptionalObject(props);\n    const y = makeObject(props);\n    t0 = x?.method(y.a, props.a, foo(y.b), bar(props.b));\n    $[0] = props;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const z = t0;\n  return z;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Functional Component in React - JavaScript\nDESCRIPTION: This snippet illustrates the definition of a functional React component named 'Component' which takes an 'arr' property and uses the custom hook 'useX'. It renders child components 'Bar', 'Baz', and 'Foo' based on the mapped values from the array.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-outlining-duplicate-prop.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableJsxOutlining\nfunction Component({arr}) {\n  const x = useX();\n  return (\n    <>\n      {arr.map((i, id) => {\n        return (\n          <Bar key={id} x={x}>\n            <Baz i={i}></Baz>\n            <Foo i={i}></Foo>\n          </Bar>\n        );\n      })}\n    </>\n  );\n}\nfunction Bar({x, children}) {\n  return (\n    <>\n      {x}\n      {children}\n    </>\n  );\n}\n\nfunction Baz({i}) {\n  return i;\n}\n\nfunction Foo({i}) {\n  return i;\n}\n\nfunction useX() {\n  return 'x';\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{arr: ['foo', 'bar']}],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component with useRef in useEffect\nDESCRIPTION: A React component that demonstrates how useRef values are used within useEffect hooks. The special comment @inferEffectDependencies indicates that the React compiler should automatically infer the dependencies.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/nonreactive-ref.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @inferEffectDependencies\nimport {useEffect, useRef} from 'react';\nimport {print} from 'shared-runtime';\n\n/**\n * Special case of `infer-effect-deps/nonreactive-dep`.\n *\n * We know that local `useRef` return values are stable, regardless of\n * inferred memoization.\n */\nfunction NonReactiveRefInEffect() {\n  const ref = useRef('initial value');\n  useEffect(() => print(ref.current));\n}\n```\n\n----------------------------------------\n\nTITLE: Using Compiler Runtime for Enhanced Logging Hook in JavaScript\nDESCRIPTION: This snippet builds upon the previous implementation by integrating React's compiler runtime. It optimizes the 'useHook' function to retrieve stateful logs efficiently, showing a structure that allows for conditionally resetting state based on the passed parameter 'end'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/labeled-break-within-label-loop.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction useHook(end) {\n  const $ = _c(2);\n  let log;\n  if ($[0] !== end) {\n    log = [];\n    for (let i = 0; i < end + 1; i++) {\n      log.push(`${i} @A`);\n      bb0: {\n        if (i === end) {\n          break bb0;\n        }\n        log.push(`${i} @B`);\n      }\n      log.push(`${i} @C`);\n    }\n    $[0] = end;\n    $[1] = log;\n  } else {\n    log = $[1];\n  }\n  return log;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useHook,\n  params: [1],\n};\n```\n\n----------------------------------------\n\nTITLE: Advanced React Component with Compiler Runtime Optimization\nDESCRIPTION: Enhanced version of the FancyButton component using React compiler runtime for memoization and performance optimization, with conditional rendering based on prop changes\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.bail.rules-of-hooks-e9f9bac89f8f.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst FancyButton = React.forwardRef((props, ref) => {\n  const $ = _c(3);\n  useHook();\n  let t0;\n  if ($[0] !== props || $[1] !== ref) {\n    t0 = <button {...props} ref={ref} />;\n    $[0] = props;\n    $[1] = ref;\n    $[2] = t0;\n  } else {\n    t0 = $[2];\n  }\n  return t0;\n});\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: Optimized version of the React component using compiler runtime for memoization and efficient re-rendering\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-attribute-with-jsx-fragment-value.flow.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(t0) {\n  const $ = _c(2);\n  const { items } = t0;\n  let t1;\n  if ($[0] !== items) {\n    t1 = items.length > 0 ? <Foo value={<>{items.map(_temp)}</>} /> : null;\n    $[0] = items;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n```\n\n----------------------------------------\n\nTITLE: Using React Compiler Runtime for Component Memoization\nDESCRIPTION: This JavaScript snippet demonstrates the usage of the React compiler runtime to define a component that handles memoization through function parameter manipulation. It introduces a cache mechanism, utilizing temporary functions for changing the behavior of 'f'. The expected inputs and outputs include console logs showing 'A', 'arg', and 'original'. The snippet is reliant on the 'react/compiler-runtime' library.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/property-call-evaluation-order.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // Should print A, arg, original\n\nfunction Component() {\n  const $ = _c(1);\n  const changeF = _temp2;\n  let x;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    x = { f: _temp3 };\n\n    (console.log(\"A\"), x).f((changeF(x), console.log(\"arg\"), 1));\n    $[0] = x;\n  } else {\n    x = $[0];\n  }\n  return x;\n}\nfunction _temp3() {\n  return console.log(\"original\");\n}\nfunction _temp2(o) {\n  o.f = _temp;\n}\nfunction _temp() {\n  return console.log(\"new\");\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  isComponent: false,\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization Logic\nDESCRIPTION: Compiled version of the React component showing the implementation of memoization using cache array and conditional value updates.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/use-memo-simple.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  \"use memo\";\n  const $ = _c(4);\n  let t0;\n  if ($[0] !== props.foo) {\n    t0 = [props.foo];\n    $[0] = props.foo;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const x = t0;\n  let t1;\n  if ($[2] !== x) {\n    t1 = <div x={x}>\"foo\"</div>;\n    $[2] = x;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ foo: 1 }],\n  isComponent: true,\n};\n```\n\n----------------------------------------\n\nTITLE: Managing Component State Interleaving in React - JavaScript\nDESCRIPTION: This JavaScript snippet defines a React component where two independent states, 'a' and 'b', are interleaved, making 'a' reactive. The component ultimately returns a single value 'x', which becomes reactive as it depends on 'c', a control value derived from 'a'. This snippet does not require any additional dependencies outside of the React component system, and inputs/outputs are managed through the 'props' object.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-from-interleaved-reactivity-if.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nfunction Component(props) {\n  // a and b are independent but their mutations are interleaved, so\n  // they get grouped in a reactive scope. this means that a becomes\n  // reactive since it will effectively re-evaluate based on a reactive\n  // input\n  const a = [];\n  const b = [];\n  b.push(props.cond);\n  a.push(null);\n\n  // Downstream consumer of a, which initially seems non-reactive except\n  // that a becomes reactive, per above\n  const c = [a];\n\n  let x;\n  if (c[0][0]) {\n    x = 1;\n  } else {\n    x = 2;\n  }\n  // The values assigned to `x` are non-reactive, but the value of `x`\n  // depends on the \"control\" value `c[0]` which becomes reactive via\n  // being interleaved with `b`.\n  // Therefore x should be treated as reactive too.\n  return [x];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{cond: true}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: Compiler-optimized version of the component that includes memoization using React's compiler runtime. It caches computed values and implements checks to avoid unnecessary recomputation while maintaining the same functionality as the original component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-within-mutable-range.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nconst { throwErrorWithMessage, shallowCopy } = require(\"shared-runtime\");\n\nfunction Component(props) {\n  const $ = _c(4);\n  let x;\n  if ($[0] !== props.value) {\n    x = [];\n    try {\n      let t0;\n      if ($[2] === Symbol.for(\"react.memo_cache_sentinel\")) {\n        t0 = throwErrorWithMessage(\"oops\");\n        $[2] = t0;\n      } else {\n        t0 = $[2];\n      }\n      x.push(t0);\n    } catch {\n      let t0;\n      if ($[3] === Symbol.for(\"react.memo_cache_sentinel\")) {\n        t0 = shallowCopy({});\n        $[3] = t0;\n      } else {\n        t0 = $[3];\n      }\n      x.push(t0);\n    }\n\n    x.push(props.value);\n    $[0] = props.value;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing React.forwardRef() in JavaScript\nDESCRIPTION: Demonstration of using the new React.forwardRef() API to allow components to forward their refs to a child component.\nSOURCE: https://github.com/facebook/react/blob/main/CHANGELOG.md#2025-04-21_snippet_17\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst ForwardedComponent = React.forwardRef((props, ref) => {\n  return <ChildComponent ref={ref} {...props} />;\n});\n```\n\n----------------------------------------\n\nTITLE: Foo Component for Value Rendering\nDESCRIPTION: Simple wrapper component that renders its value prop inside a div element\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-attribute-with-jsx-fragment-value.flow.expect.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Foo({value}) {\n  return <div>{value}</div>;\n}\n```\n\n----------------------------------------\n\nTITLE: Transformed React Hook with Compiler Runtime\nDESCRIPTION: This code shows the transformed version of the `useJoinCondDepsInUncondScopes` hook, likely after being processed by the React compiler (Forget). It introduces the `_c` function from `react/compiler-runtime` for memoization and dependency tracking. The transformed code uses a conditional check based on `props.a.b` to determine whether to re-execute the hook's logic, aiming to optimize re-renders based on changes to `props.a.b`.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/join-uncond-scopes-cond-deps.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // This tests an optimization, NOT a correctness property.\n// When propagating reactive dependencies of an inner scope up to its parent,\n// we prefer to retain granularity.\n//\n// In this test, we check that Forget propagates the inner scope's conditional\n// dependencies (e.g. props.a.b) instead of only its derived minimal\n// unconditional dependencies (e.g. props).\n// ```javascript\n//  scope @0 (deps=[???] decls=[x, y]) {\n//    let y = {};\n//    scope @1 (deps=[props] decls=[x]) {\n//      let x = {};\n//      if (foo) mutate1(x, props.a.b);\n//    }\n//    mutate2(y, props.a.b);\n//  }\n\nimport { CONST_TRUE, setProperty } from \"shared-runtime\";\n\nfunction useJoinCondDepsInUncondScopes(props) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== props.a.b) {\n    const y = {};\n    const x = {};\n    if (CONST_TRUE) {\n      setProperty(x, props.a.b);\n    }\n\n    setProperty(y, props.a.b);\n    t0 = [x, y];\n    $[0] = props.a.b;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useJoinCondDepsInUncondScopes,\n  params: [{ a: { b: 3 } }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Displaying Console Warning with Component Stack in React\nDESCRIPTION: This code snippet demonstrates how React DevTools can automatically append component stack information to console warnings, providing more context for debugging.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/CHANGELOG.md#2025-04-21_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconsole.warn('Example console warning with component stack added')\n```\n\n----------------------------------------\n\nTITLE: Memoizing Functional Components in React with Hooks\nDESCRIPTION: This JavaScript code snippet shows a functional component that uses React.memo to prevent unnecessary re-renders. The memo function is used to wrap an anonymous function component, while the useHook function is called within it. It returns a button element, spreading the received props. This requires React and appropriate hook implementation to function.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-eacfcaa6ef89.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Valid because hooks can be used in anonymous function arguments to\n// memo.\nconst MemoizedFunction = memo(function (props) {\n  useHook();\n  return <button {...props} />;\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing Memoization with React\nDESCRIPTION: This snippet utilizes React's useMemo hook to create a memoized object. It ensures that the object is not recreated on each render. Dependencies like 'identity' and 'makeObject_Primitives' from 'shared-runtime' are required for this functionality.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-maybe-modified-later-preserve-memoization-guarantees.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enablePreserveExistingMemoizationGuarantees\nimport {useMemo} from 'react';\nimport {identity, makeObject_Primitives, mutate} from 'shared-runtime';\n\nfunction Component(props) {\n  const object = useMemo(() => makeObject_Primitives(), []);\n  identity(object);\n  return object;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Component with useCallback Hook\nDESCRIPTION: This snippet defines a React component named 'Component' that accepts props. It uses the 'useCallback' hook to memoize the 'onClick' handler.  The 'onClick' handler logs the 'value' prop to the console when the div is clicked, and the handler is only recreated if 'props.value' changes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/drop-methodcall-usecallback.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as React from 'react';\n\nfunction Component(props) {\n  const onClick = React.useCallback(() => {\n    console.log(props.value);\n  }, [props.value]);\n  return <div onClick={onClick} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: 42}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: ESLint Error: Invalid React useMemo arguments\nDESCRIPTION: This ESLint error message indicates that the callback function passed to useMemo should not accept any arguments when the dependency array is empty. This is because the memoized value will only be calculated once, so the callback function shouldn't depend on any inputs. Removing the argument from the callback will resolve the error.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-useMemo-callback-args.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n  1 | function component(a, b) {\n> 2 |   let x = useMemo(c => a, []);\n    |                   ^^^^^^ InvalidReact: useMemo callbacks may not accept any arguments (2:2)\n  3 |   return x;\n  4 | }\n  5 |\n```\n\n----------------------------------------\n\nTITLE: Streaming Server Rendering in Modern Edge Runtimes\nDESCRIPTION: New API for streaming server-side rendering in modern edge runtime environments like Deno and Cloudflare workers.\nSOURCE: https://github.com/facebook/react/blob/main/CHANGELOG.md#2025-04-21_snippet_11\n\nLANGUAGE: javascript\nCODE:\n```\nrenderToReadableStream\n```\n\n----------------------------------------\n\nTITLE: Custom React Hook Definition\nDESCRIPTION: This code defines a custom React hook called `useCustomHook` that takes a string `src` as input. It utilizes `useRef` to store a unique ID and a boolean flag for tracking destruction. `useEffectEvent` is used to create an event handler that calls `getItem` with the `src` and unique ID.  `useEffect` is used to call getItemEvent on mount. The `getItem` function returns an object containing the `srcName` and `uid`. The function `uniqueId` is used to generate a new id on each call.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/import-as-local.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {\n  useEffect,\n  useRef,\n  // @ts-expect-error\n  experimental_useEffectEvent as useEffectEvent,\n} from 'react';\n\nlet id = 0;\nfunction uniqueId() {\n  'use no memo';\n  return id++;\n}\n\nexport function useCustomHook(src: string): void {\n  const uidRef = useRef(uniqueId());\n  const destroyed = useRef(false);\n  const getItem = (srcName, uid) => {\n    return {srcName, uid};\n  };\n\n  const getItemEvent = useEffectEvent(() => {\n    if (destroyed.current) return;\n\n    getItem(src, uidRef.current);\n  });\n\n  useEffect(() => {\n    destroyed.current = false;\n    getItemEvent();\n  }, []);\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Pointer Event Properties in DOM Event Testing\nDESCRIPTION: This snippet shows how to customize properties of pointer events when testing. It demonstrates setting properties like button state, coordinates, and pointer type to simulate specific interaction scenarios.\nSOURCE: https://github.com/facebook/react/blob/main/packages/dom-event-testing-library/README.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\ntarget.pointerdown({\n  button: 0,\n  buttons: 1,\n  pageX: 10,\n  pageY: 10,\n  pointerType,\n  // NOTE: use x,y instead of clientX,clientY\n  x: 10,\n  y: 10\n});\n```\n\n----------------------------------------\n\nTITLE: Original React Component with Memoization\nDESCRIPTION: Original source code showing a React component that processes an array of items using a mapping function. The component demonstrates how function references are memoized when returned as part of the component's output.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-map-noAlias-escaping-function.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const f = item => item;\n  const x = [...props.items].map(f); // `f` doesn't escape here...\n  return [x, f]; // ...but it does here so it's memoized\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{items: [{id: 1}]}],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic React Component with State (JavaScript)\nDESCRIPTION: This snippet shows a basic React component using the useState hook to manage a counter state. It renders a span displaying the count and a button to increment it.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/merge-scopes-callback.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableInstructionReordering\nimport {useState} from 'react';\n\nfunction Component() {\n  const [state, setState] = useState(0);\n  const onClick = () => {\n    setState(s => s + 1);\n  };\n  return (\n    <>\n      <span>Count: {state}</span>\n      <button onClick={onClick}>Increment</button>\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Compiler Runtime\nDESCRIPTION: This React component optimizes rendering performance by caching previous render states and minimizing calls to expensive operations. It uses a synthesized compiler_runtime mechanism provided by \\\\\"react/compiler-runtime\\\\\" to track and conditionally update parts of the component's logic based on changes to props. This approach efficiently manages state with array indexing.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/function-expression-prototype-call-mutating.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useMemo } from \"react\";\nimport { ValidateMemoization } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(7);\n  let t0;\n  let a;\n  if ($[0] !== props.name) {\n    a = [];\n    const f = function () {\n      a.push(props.name);\n    };\n\n    f.call();\n    $[0] = props.name;\n    $[1] = a;\n  } else {\n    a = $[1];\n  }\n  t0 = a;\n  const a_0 = t0;\n  let t1;\n  if ($[2] !== props.name) {\n    t1 = [props.name];\n    $[2] = props.name;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  let t2;\n  if ($[4] !== a_0 || $[5] !== t1) {\n    t2 = <ValidateMemoization inputs={t1} output={a_0} />;\n    $[4] = a_0;\n    $[5] = t1;\n    $[6] = t2;\n  } else {\n    t2 = $[6];\n  }\n  return t2;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ name: \"Jason\" }],\n  sequentialRenders: [\n    { name: \"Lauren\" },\n    { name: \"Lauren\" },\n    { name: \"Jason\" },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component Definition with Destructuring\nDESCRIPTION: This code defines a React component named 'Foo' that receives props. It destructures the 'a' property of props to extract 'x', 'y', and the rest into 'z'. The component then returns the value of 'x'.  This snippet uses object destructuring with rest properties.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unused-object-element.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Foo(props) {\n  const {x, y, ...z} = props.a;\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing useCallback with Compiler Runtime in JavaScript\nDESCRIPTION: Demonstrates an enhanced approach for implementing memoized functions in React using an internal compiler runtime utility. The function useFoo is optimized to cache its computation with a minimal dependency array, using a custom cache slot to manage dependency changes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useCallback-infer-fewer-deps.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @validatePreserveExistingMemoizationGuarantees\n\nimport { useCallback } from \"react\";\n\n// It's correct to produce memo blocks with fewer deps than source\nfunction useFoo(a, b) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== a) {\n    t0 = () => [a];\n    $[0] = a;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [1, 2],\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Component with Mutator (Input)\nDESCRIPTION: This React component receives a `mutator` prop and defines two functions, `poke` and `hide`, which call methods on the mutator. These functions are then passed as props to a `Foo` component. The component uses arrow functions for concise event handlers.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-member-expr-call.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component({mutator}) {\n  const poke = () => {\n    mutator.poke();\n  };\n\n  const hide = () => {\n    mutator.user.hide();\n  };\n\n  return <Foo poke={poke} hide={hide}></Foo>;\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Subpath Dependency Tracking\nDESCRIPTION: This code shows the compiled version of the React component. It imports `_c` from `react/compiler-runtime`, which likely represents the compiler's memoization/optimization helper.  It checks for changes in `props.a` to determine whether to update the local variable `x` and avoids unnecessary re-renders by reusing cached values.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/uncond-overlap-descendant.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // Test that we correctly track a subpath if the subpath itself is accessed as\n// a dependency\nfunction TestOverlappingDescendantTracked(props) {\n  const $ = _c(2);\n  let x;\n  if ($[0] !== props.a) {\n    x = {};\n    x.b = props.a.b.c;\n    x.c = props.a.b.c.x.y;\n    x.a = props.a;\n    $[0] = props.a;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: TestOverlappingDescendantTracked,\n  params: [{ a: { b: { c: { x: { y: 5 } } } } }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Caching\nDESCRIPTION: Shows the compiled version of the component with React's compiler-runtime optimization. Implements caching mechanism using array $ to store and retrieve previously computed values based on props.a.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/merge-nested-scopes-with-same-inputs.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { setProperty } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(2);\n  let y;\n  if ($[0] !== props.a) {\n    y = {};\n\n    const x = {};\n    setProperty(x, props.a);\n\n    y.a = props.a;\n    y.x = x;\n    $[0] = props.a;\n    $[1] = y;\n  } else {\n    y = $[1];\n  }\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ a: 42 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Creating a React Component in JavaScript\nDESCRIPTION: This snippet demonstrates how to create a simple React component that receives props and renders JSX elements. The component leverages a function, `makeFunction`, to process these props, and produces an output element that includes a `<span>` displaying `props.text`. The component expects props to be passed in as parameters and outputs a JSX structure. Dependencies include React and potential external function dependencies for `makeFunction`.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/call-with-independently-memoizable-arg.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const x = makeFunction(props);\n  const y = x(\n    <div>\n      <span>{props.text}</span>\n    </div>\n  );\n  return y;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining Component with useHook in React\nDESCRIPTION: This snippet defines a React functional component that utilizes a custom hook from 'shared-runtime'. It initializes an object, uses the hook to prevent memoization, and returns a structured output based on the component's props. It also exports a fixture entry point for easier testing with predefined parameters.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/prune-scopes-whose-deps-invalidate-object.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useHook} from 'shared-runtime';\n\nfunction Component(props) {\n  const x = {};\n  useHook(); // intersperse a hook call to prevent memoization of x\n  x.value = props.value;\n\n  const y = {x};\n\n  return {y};\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: 'sathya'}],\n};\n```\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useHook } from \"shared-runtime\";\n\nfunction Component(props) {\n  const x = {};\n  useHook();\n  x.value = props.value;\n\n  const y = { x };\n  return { y };\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ value: \"sathya\" }],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Optimizations\nDESCRIPTION: The compiled version of the component with added memoization and state tracking using React's compiler runtime. Implements caching of computed values and renders to avoid unnecessary recalculations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/component.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(8);\n  const items = props.items;\n  const maxItems = props.maxItems;\n  let renderedItems;\n  if ($[0] !== items || $[1] !== maxItems) {\n    renderedItems = [];\n    const seen = new Set();\n    const max = Math.max(0, maxItems);\n    for (let i = 0; i < items.length; i = i + 1, i) {\n      const item = items.at(i);\n      if (item == null || seen.has(item)) {\n        continue;\n      }\n\n      seen.add(item);\n      renderedItems.push(<div>{item}</div>);\n      if (renderedItems.length >= max) {\n        break;\n      }\n    }\n    $[0] = items;\n    $[1] = maxItems;\n    $[2] = renderedItems;\n  } else {\n    renderedItems = $[2];\n  }\n\n  const count = renderedItems.length;\n  let t0;\n  if ($[3] !== count) {\n    t0 = <h1>{count} Items</h1>;\n    $[3] = count;\n    $[4] = t0;\n  } else {\n    t0 = $[4];\n  }\n  let t1;\n  if ($[5] !== renderedItems || $[6] !== t0) {\n    t1 = (\n      <div>\n        {t0}\n        {renderedItems}\n      </div>\n    );\n    $[5] = renderedItems;\n    $[6] = t0;\n    $[7] = t1;\n  } else {\n    t1 = $[7];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Basic Async React Component in JavaScript\nDESCRIPTION: Simple React component that loads user data asynchronously and renders the user's name. Demonstrates basic async/await pattern with data fetching.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/await.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nasync function Component(props) {\n  const user = await load(props.id);\n  return <div>{user.name}</div>;\n}\n```\n\n----------------------------------------\n\nTITLE: Custom configuration with legacy config format\nDESCRIPTION: Advanced setup using legacy config (.eslintrc) with manual configuration of individual rules for finer control.\nSOURCE: https://github.com/facebook/react/blob/main/packages/eslint-plugin-react-hooks/README.md#2025-04-21_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\n{\n  \"plugins\": [\n    // ...\n    \"react-hooks\"\n  ],\n  \"rules\": {\n    // ...\n    \"react-hooks/rules-of-hooks\": \"error\",\n    \"react-hooks/exhaustive-deps\": \"warn\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Hook 'useFoo' in React (JavaScript)\nDESCRIPTION: The 'useFoo' function is a custom hook that takes 'minWidth' and 'otherProp' as parameters. It uses the useState hook to manage the width state and utilize useCallback for memoized style computation. The hook utilizes 'arrayPush' from 'shared-runtime' to manage an array of other properties. It ensures that memoized values are preserved across re-renders when dependencies are unchanged.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useCallback-in-other-reactive-block.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees\nimport {useCallback, useState} from 'react';\nimport {arrayPush} from 'shared-runtime';\n\n// useCallback-produced values can exist in nested reactive blocks, as long\n// as their reactive dependencies are a subset of depslist from source\nfunction useFoo(minWidth, otherProp) {\n  const [width, setWidth] = useState(1);\n  const x = [];\n  const style = useCallback(() => {\n    return {\n      width: Math.max(minWidth, width),\n    };\n  }, [width, minWidth]);\n  arrayPush(x, otherProp);\n  return [style, x];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [2, 'other'],\n};\n\n```\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @validatePreserveExistingMemoizationGuarantees\nimport { useCallback, useState } from \"react\";\nimport { arrayPush } from \"shared-runtime\";\n\n// useCallback-produced values can exist in nested reactive blocks, as long\n// as their reactive dependencies are a subset of depslist from source\nfunction useFoo(minWidth, otherProp) {\n  const $ = _c(7);\n  const [width] = useState(1);\n  let t0;\n  if ($[0] !== minWidth || $[1] !== otherProp || $[2] !== width) {\n    const x = [];\n    let t1;\n    if ($[4] !== minWidth || $[5] !== width) {\n      t1 = () => ({ width: Math.max(minWidth, width) });\n      $[4] = minWidth;\n      $[5] = width;\n      $[6] = t1;\n    } else {\n      t1 = $[6];\n    }\n    const style = t1;\n\n    arrayPush(x, otherProp);\n    t0 = [style, x];\n    $[0] = minWidth;\n    $[1] = otherProp;\n    $[2] = width;\n    $[3] = t0;\n  } else {\n    t0 = $[3];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [2, \"other\"],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Hook with Dependency Tracking\nDESCRIPTION: This code presents the compiled version of the `useFoo` hook. It utilizes `_c` from `react/compiler-runtime` for dependency tracking. The code checks if the props (`props.bar`, `props.cond`, `props.foo`) have changed since the last render. If so, it re-executes the original logic, otherwise, it reuses the cached value in `$[3]`. This optimized version aims to prevent unnecessary re-renders.  It also shows the use of the `mutate` function.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/ssa-renaming-ternary-with-mutation.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enablePropagateDepsInHIR\nimport { mutate } from \"shared-runtime\";\n\nfunction useFoo(props) {\n  const $ = _c(4);\n  let x;\n  if ($[0] !== props.bar || $[1] !== props.cond || $[2] !== props.foo) {\n    x = [];\n    x.push(props.bar);\n    props.cond ? ((x = []), x.push(props.foo)) : null;\n    mutate(x);\n    $[0] = props.bar;\n    $[1] = props.cond;\n    $[2] = props.foo;\n    $[3] = x;\n  } else {\n    x = $[3];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ cond: false, foo: 2, bar: 55 }],\n  sequentialRenders: [\n    { cond: false, foo: 2, bar: 55 },\n    { cond: false, foo: 3, bar: 55 },\n    { cond: true, foo: 3, bar: 55 },\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Error Handling for Invalid Ref Access - React - JavaScript\nDESCRIPTION: This code snippet provides an error comment detailing the invalid access of ref values in the render method of a React component. It highlights an important limitation of the React API regarding ref usage, indicating that `ref.current` should not be accessed during render. The output will be a console error rather than the intended display of the referenced value.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-read-ref-prop-in-render-destructure.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n```\n  1 | // @validateRefAccessDuringRender @compilationMode(infer)\n  2 | function Component({ref}) {\n> 3 |   const value = ref.current;\n    |                 ^^^^^^^^^^^ InvalidReact: Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef) (3:3)\n  4 |   return <div>{value}</div>;\n  5 | }\n  6 |\n```\n\n```\n\n----------------------------------------\n\nTITLE: Using the Frontend API for React DevTools UI\nDESCRIPTION: Example showing how to use the frontend API to render DevTools UI into a DOM element and start a socket server for communication between backend and frontend.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools-core/README.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport DevtoolsUI from \"react-devtools-core/standalone\";\n\n// See the full list of API methods in documentation below.\nconst { setContentDOMNode, startServer } = DevtoolsUI;\n\n// Render DevTools UI into a DOM element.\nsetContentDOMNode(document.getElementById(\"container\"));\n\n// Start socket server used to communicate between backend and frontend.\nstartServer(\n  // Port defaults to 8097\n  1234,\n\n  // Host defaults to \"localhost\"\n  \"example.devserver.com\",\n\n  // Optional config for secure socket (WSS).\n  {\n    key: fs.readFileSync('test/fixtures/keys/agent2-key.pem'),\n    cert: fs.readFileSync('test/fixtures/keys/agent2-cert.pem')\n  }\n);\n```\n\n----------------------------------------\n\nTITLE: React Component with useMemo - Compiled Output\nDESCRIPTION: Compiled version of the React component showing how useMemo is transformed into explicit memoization checks using compiler runtime utilities. Demonstrates the internal implementation of memoization caching.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/optional-member-expression-inverted-optionals-parallel-paths.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @validatePreserveExistingMemoizationGuarantees @enableOptionalDependencies @enablePropagateDepsInHIR\nimport { ValidateMemoization } from \"shared-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  let t0;\n\n  const x$0 = [];\n  x$0.push(props?.a.b?.c.d?.e);\n  x$0.push(props.a?.b.c?.d.e);\n  t0 = x$0;\n  let t1;\n  if ($[0] !== props.a.b.c.d.e) {\n    t1 = <ValidateMemoization inputs={[props.a.b.c.d.e]} output={x} />;\n    $[0] = props.a.b.c.d.e;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Memoization\nDESCRIPTION: This code snippet shows the optimized version of the React component. It uses `react/compiler-runtime` to memoize the result of the `map` and `filter` operations based on the `props?.items` value. This prevents re-renders if the `items` prop hasn't changed.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-call-with-optional-property-load.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== props?.items) {\n    t0 = props?.items?.map?.(render)?.filter(Boolean) ?? [];\n    $[0] = props?.items;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n```\n\n----------------------------------------\n\nTITLE: React ForwardRef with Conditional Hook Call (Invalid)\nDESCRIPTION: This code defines a `FancyButton` component using `React.forwardRef`. It attempts to conditionally call `useCustomHook` based on the `props.fancy` value. This is an invalid usage of hooks because hooks must be called in the same order on every render. It violates the Rules of Hooks.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.error.rules-of-hooks-27c18dc8dad2.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @skip\n// Unsupported input\n\n// Invalid because it's dangerous and might not warn otherwise.\n// This *must* be invalid.\nconst FancyButton = React.forwardRef((props, ref) => {\n  if (props.fancy) {\n    useCustomHook();\n  }\n  return <button ref={ref}>{props.children}</button>;\n});\n```\n\n----------------------------------------\n\nTITLE: Original React Component with useMemo Implementation\nDESCRIPTION: A simple React component that uses useState and useMemo hooks to track state and compute a derived value. It validates the memoization using a ValidateMemoization component that checks inputs and outputs.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fast-refresh-reloading.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableResetCacheOnSourceFileChanges\nimport {useMemo, useState} from 'react';\nimport {ValidateMemoization} from 'shared-runtime';\n\nfunction Component(props) {\n  const [state, setState] = useState(0);\n  const doubled = useMemo(() => [state * 2], [state]);\n  return <ValidateMemoization inputs={[state]} output={doubled} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n  sequentialRenders: [{}, {}],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing React Counter Component\nDESCRIPTION: This snippet defines a React component that uses useState to manage a counter. It renders a button that increments the count when clicked.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/function-expr-directive.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component() {\n  'use strict';\n  let [count, setCount] = React.useState(0);\n  function update() {\n    'worklet';\n    setCount(count => count + 1);\n  }\n  return <button onClick={update}>{count}</button>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  isComponent: true,\n};\n```\n\n----------------------------------------\n\nTITLE: Starting Stream Flow in React\nDESCRIPTION: Method to begin streaming render output to a destination (Node or Web stream). Handles continuous writing of chunks as they become available after async operations complete.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-server/README.md#2025-04-21_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nstartFlowing(request: Request, destination: Destination): void\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Non-Reactive Dependencies in React useEffect\nDESCRIPTION: Original source code showing a React component with a useEffect that has a non-reactive object in its dependencies. The commented documentation explains the current limitation in effect dependency inference and outlines potential future improvements.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/nonreactive-dep.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @inferEffectDependencies\nimport {useEffect} from 'react';\nimport {makeObject_Primitives, print} from 'shared-runtime';\n\n/**\n * Note that `obj` is currently added to the effect dependency array, even\n * though it's non-reactive due to memoization.\n *\n * This is a TODO in effect dependency inference. Note that we cannot simply\n * filter out non-reactive effect dependencies, as some non-reactive (by data\n * flow) values become reactive due to scope pruning. See the\n * `infer-effect-deps/pruned-nonreactive-obj` fixture for why this matters.\n *\n * Realizing that this `useEffect` should have an empty dependency array\n * requires effect dependency inference to be structured similarly to memo\n * dependency inference.\n * Pass 1: add all potential dependencies regardless of dataflow reactivity\n * Pass 2: (todo) prune non-reactive dependencies\n *\n * Note that instruction reordering should significantly reduce scope pruning\n */\nfunction NonReactiveDepInEffect() {\n  const obj = makeObject_Primitives();\n  useEffect(() => print(obj));\n}\n```\n\n----------------------------------------\n\nTITLE: React Component with useRef and onChange handler\nDESCRIPTION: This React component uses useRef to store a mutable value and an onChange handler to update it. The onChange handler updates the ref's current value based on the event's target value. The useEffect hook logs the current value of the ref after each render.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ref-in-effect.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const ref = useRef(null);\n  const onChange = e => {\n    const newValue = e.target.value ?? ref.current;\n    ref.current = newValue;\n  };\n  useEffect(() => {\n    console.log(ref.current);\n  });\n  return <Foo onChange={onChange} />;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Rendering Async Function Components with Flight\nDESCRIPTION: Example showing how to render async Function Components with Flight in React Server Components. The example demonstrates that components can be async and can return promises which are supported by the Flight renderer.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-server/README.md#2025-04-21_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nasync function App({ children }) {\n  return children\n}\n\ncreateResponse(<App ><Children /></App>, ...)\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic React Component in JavaScript\nDESCRIPTION: This snippet defines a React component named Foo, which returns a div element accepting a ref prop. It demonstrates the basic export of this component using a constant named FIXTURE_ENTRYPOINT. There are no external dependencies or prerequisites, and the code handles component referencing for div elements.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-functions-component-with-ref-arg.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @compilationMode(infer)\n\nfunction Foo({}, ref) {\n  return <div ref={ref} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom React Hook in JavaScript\nDESCRIPTION: This code snippet demonstrates the creation of a custom React hook. The `createHook` function returns a `useHook` function which in turn calls other hooks (`useHook1` and `useHook2`). This illustrates a valid pattern in React where hooks can invoke other hooks.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-2bec02ac982b.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @compilationMode(infer)\n// Valid because hooks can call hooks.\nfunction createHook() {\n  return function useHook() {\n    useHook1();\n    useHook2();\n  };\n}\n\n```\n\n----------------------------------------\n\nTITLE: React Component with useState Hook (Input)\nDESCRIPTION: This React component utilizes the useState hook to initialize a state variable 'x' with the initial value of 1. The component's purpose is to return this initial value of 'x'. The component is exported via FIXTURE_ENTRYPOINT for testing and usage in other modules.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hooks-with-React-namespace.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component() {\n  const [x, setX] = React.useState(1);\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom React Hook with Set Manipulation\nDESCRIPTION: This snippet defines a custom React hook 'useFoo' that creates and manipulates Sets based on input props. It uses external functions 'makeArray' and 'useHook', and returns two Sets.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/global-types/set-for-of-iterate-values.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {makeArray, useHook} from 'shared-runtime';\n\nfunction useFoo({propArr}: {propArr: Array<number>}) {\n  const s1 = new Set<number | Array<number>>([1, 2, 3]);\n  s1.add(makeArray(propArr[0]));\n\n  useHook();\n  const s2 = new Set();\n  for (const el of s1.values()) {\n    s2.add(el);\n  }\n\n  return [s1, s2];\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled Custom React Hook Definition\nDESCRIPTION: This code shows the compiled version of the `useCustomHook` after it has been processed by the React compiler.  It uses `_c` from `react/compiler-runtime` to create and manage a cache.  The compiled code efficiently updates the event handler and manages side effects using the memoization and caching capabilities provided by the React compiler.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/import-as-local.expect.md#2025-04-21_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport {\n  useEffect,\n  useRef,\n  // @ts-expect-error\n  experimental_useEffectEvent as useEffectEvent,\n} from \"react\";\n\nlet id = 0;\nfunction uniqueId() {\n  \"use no memo\";\n  return id++;\n}\n\nexport function useCustomHook(src) {\n  const $ = _c(6);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = uniqueId();\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const uidRef = useRef(t0);\n  const destroyed = useRef(false);\n  const getItem = _temp;\n  let t1;\n  if ($[1] !== src) {\n    t1 = () => {\n      if (destroyed.current) {\n        return;\n      }\n\n      getItem(src, uidRef.current);\n    };\n    $[1] = src;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  const getItemEvent = useEffectEvent(t1);\n  let t2;\n  if ($[3] !== getItemEvent) {\n    t2 = () => {\n      destroyed.current = false;\n      getItemEvent();\n    };\n    $[3] = getItemEvent;\n    $[4] = t2;\n  } else {\n    t2 = $[4];\n  }\n  let t3;\n  if ($[5] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t3 = [];\n    $[5] = t3;\n  } else {\n    t3 = $[5];\n  }\n  useEffect(t2, t3);\n}\n```\n\n----------------------------------------\n\nTITLE: Original Component with FBT Internationalization\nDESCRIPTION: A React component that uses FBT for internationalization to render a greeting message. It accepts a name prop and displays it within a localized greeting string.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-call-complex-param-value.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport fbt from 'fbt';\nimport {identity} from 'shared-runtime';\n\nfunction Component(props) {\n  const text = fbt(\n    `Hello, ${fbt.param('(key) name', identity(props.name))}!`,\n    '(description) Greeting'\n  );\n  return <div>{text}</div>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{name: 'Sathya'}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Code with Reactive Dependency Tracking - JavaScript\nDESCRIPTION: The compiled output from React's compiler showing how it optimizes the component by tracking props.a.b as a dependency. It uses the _c function from react/compiler-runtime to memoize calculations based on dependency changes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/cfg-switch-exhaustive.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // props.a.b should be added as a unconditional dependency to the reactive\n// scope that produces x, since it is accessed unconditionally in all cfg\n// paths\n\nimport { identity } from \"shared-runtime\";\n\nfunction useCondDepInSwitch(props, other) {\n  const $ = _c(3);\n  let x;\n  if ($[0] !== other || $[1] !== props.a.b) {\n    x = {};\n    bb0: switch (identity(other)) {\n      case 1: {\n        x.a = props.a.b;\n        break bb0;\n      }\n      case 2: {\n        x.b = props.a.b;\n        break bb0;\n      }\n      default: {\n        x.c = props.a.b;\n      }\n    }\n    $[0] = other;\n    $[1] = props.a.b;\n    $[2] = x;\n  } else {\n    x = $[2];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useCondDepInSwitch,\n  params: [{ a: { b: 2 } }, 2],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimizing React Component with Memoization in JavaScript\nDESCRIPTION: This snippet shows an optimized version of the component using React's compiler runtime for memoization. It caches the result of the computation to avoid unnecessary recalculations on re-renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-of-continue.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component() {\n  const $ = _c(1);\n  let ret;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const x = [0, 1, 2, 3];\n    ret = [];\n    for (const item of x) {\n      if (item === 0) {\n        continue;\n      }\n\n      ret.push(item / 2);\n    }\n    $[0] = ret;\n  } else {\n    ret = $[0];\n  }\n  return ret;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Using useMemo Hook in React\nDESCRIPTION: This code snippet showcases the correct usage of the `useMemo` hook in a React component. It defines a custom hook `useFoo` that conditionally memoizes a value based on the input `cond`. The `useMemo` hook ensures that the value is only recomputed when `cond` changes, preserving memoization guarantees.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/prune-nonescaping-useMemo-mult-returns-primitive.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees\n\nimport {useMemo} from 'react';\nimport {identity} from 'shared-runtime';\n\nfunction useFoo(cond) {\n  useMemo(() => {\n    if (cond) {\n      return 2;\n    } else {\n      return identity(5);\n    }\n  }, [cond]);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [true],\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Component with useCallback\nDESCRIPTION: This code defines a React component named Foo that utilizes useCallback to memoize a function (onFoo). The onFoo function logs the current router location whenever it's called. The useCallback hook ensures that the function is only recreated when the router location changes, preventing unnecessary re-renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-member-expr-arguments.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Foo(props) {\n  const onFoo = useCallback(\n    reason => {\n      log(props.router.location);\n    },\n    [props.router.location]\n  );\n\n  return onFoo;\n}\n\n```\n\n----------------------------------------\n\nTITLE: React State Mutation Error\nDESCRIPTION: Error message highlighting the incorrect attempt to directly mutate state returned from useReducer, which should be updated using the dispatch function\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.modify-useReducer-state.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n  3 | function Foo() {\n  4 |   let [state, setState] = useReducer({foo: 1});\n> 5 |   state.foo = 1;\n    |   ^^^^^ InvalidReact: Mutating a value returned from 'useReducer()', which should not be mutated. Use the dispatch function to update instead (5:5)\n  6 |   return state;\n  7 | }\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: The React compiler-transformed version of the Foo component that implements memoization. It uses a compiler runtime utility to cache the created object and avoid recreating it on subsequent renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/store-via-new.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Foo() {\n  const $ = _c(1);\n  let x;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    x = {};\n    const y = new Foo(x);\n    y.mutate();\n    $[0] = x;\n  } else {\n    x = $[0];\n  }\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: React Component with FBT Input\nDESCRIPTION: Original React component using FBT for internationalization. Shows how to use fbt.param to interpolate dynamic values into translated strings.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-call.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport fbt from 'fbt';\n\nfunction Component(props) {\n  const text = fbt(\n    `${fbt.param('(key) count', props.count)} items`,\n    '(description) Number of items'\n  );\n  return <div>{text}</div>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{count: 2}],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Counter Component\nDESCRIPTION: A simple React component implementing a counter with useState hook and worklet annotation. The component renders a button that increments a counter when clicked.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/arrow-expr-directive.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component() {\n  'use strict';\n  let [count, setCount] = React.useState(0);\n  const update = () => {\n    'worklet';\n    setCount(count => count + 1);\n  };\n  return <button onClick={update}>{count}</button>;\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Optimizations\nDESCRIPTION: The compiled version of the component with React runtime optimizations including memoization caching for the onClick handler and conditional rendering based on prop changes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-hoisting.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(3);\n  const wat = _temp;\n\n  const pathname_0 = props.wat;\n  const deeplinkItemId = pathname_0 ? props.itemID : null;\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = () => wat();\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  let t1;\n  if ($[1] !== deeplinkItemId) {\n    t1 = <button onClick={t0}>{deeplinkItemId}</button>;\n    $[1] = deeplinkItemId;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  return t1;\n}\nfunction _temp() {}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ wat: \"/dev/null\", itemID: 42 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining MyApp Component with Memoization - JavaScript\nDESCRIPTION: This snippet defines a variant of the MyApp component that leverages the React memoization feature. It checks against a cache sentinel to determine whether to return a new input element or the cached version, ensuring efficient rendering. The component is returned with an input element containing an updated pattern attribute syntax.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-preserve-escape-character.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; /**\n * Fixture showing `@babel/generator` bug with jsx attribute strings containing\n * escape sequences. Note that this is only a problem when generating jsx\n * literals.\n *\n * When using the jsx transform to correctly lower jsx into\n * `React.createElement` calls, the escape sequences are preserved correctly\n * (see evaluator output).\n */\nfunction MyApp() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = <input pattern={\"\\\\w\"} />;\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: MyApp,\n  params: [],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Type Checking in JavaScript\nDESCRIPTION: This code defines a React component with TypeScript-like type checking. It uses the 'identity' function from a shared runtime and demonstrates the use of the 'satisfies' keyword for type assertion. The component takes a prop 'id' and returns it after type checking.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-annotations/type-annotation-satisfies-number.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableUseTypeAnnotations\nimport {identity} from 'shared-runtime';\n\nfunction Component(props: {id: number}) {\n  const x = identity(props.id);\n  const y = x satisfies number;\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{id: 42}],\n};\n```\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableUseTypeAnnotations\nimport { identity } from \"shared-runtime\";\n\nfunction Component(props) {\n  const x = identity(props.id);\n  const y = x satisfies number;\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ id: 42 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Component Initialization with Simple Logic in React - JavaScript\nDESCRIPTION: This snippet demonstrates a simple React component that initializes an array to store the length of a given set of items and a mapped array of items' edges. The function relies on the presence of items and edges and safely uses optional chaining to account for potential null values. This version does not use any advanced caching mechanisms.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/memberexpr-join-optional-chain2.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const x = [];\n  x.push(props.items?.length);\n  x.push(props.items?.edges?.map?.(render)?.filter?.(Boolean) ?? []);\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{items: {edges: null, length: 0}}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Optimized State Management React JavaScript\nDESCRIPTION: This snippet shows an optimized state management approach using React's component for improved performance. The 'Component' function uses a compiler-runtime related import to optimize conditional updates of component states, minimizing re-computation and unnecessary renders. This requires installing the react/compiler-runtime package.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/independent-across-if.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction compute() {}\nfunction mutate() {}\nfunction foo() {}\nfunction Foo() {}\n\n/**\n * Should produce 3 scopes:\n *\n * a: inputs=props.a & props.c; outputs=a\n *   a = compute(props.a);\n *   if (props.c)\n *     mutate(a)\n * b: inputs=props.b & props.c; outputs=b\n *   b = compute(props.b);\n *   if (props.c)\n *     mutate(b)\n * return: inputs=a, b outputs=return\n *   return = <Foo a={a} b={b} />\n */\nfunction Component(props) {\n  const $ = _c(8);\n  let a;\n  let b;\n  if ($[0] !== props.a || $[1] !== props.b || $[2] !== props.c) {\n    a = compute(props.a);\n    b = compute(props.b);\n    if (props.c) {\n      mutate(a);\n      mutate(b);\n    }\n    $[0] = props.a;\n    $[1] = props.b;\n    $[2] = props.c;\n    $[3] = a;\n    $[4] = b;\n  } else {\n    a = $[3];\n    b = $[4];\n  }\n  let t0;\n  if ($[5] !== a || $[6] !== b) {\n    t0 = <Foo a={a} b={b} />;\n    $[5] = a;\n    $[6] = b;\n    $[7] = t0;\n  } else {\n    t0 = $[7];\n  }\n  return t0;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization Optimizations\nDESCRIPTION: Compiled version of the React component showing the internal memoization implementation using Symbol.for('react.memo_cache_sentinel') for cache detection and optimization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useCallback-set-ref-value-preserve-memoization.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enablePreserveExistingMemoizationGuarantees\nimport { useCallback, useRef } from \"react\";\n\nfunction Component(props) {\n  const $ = _c(2);\n  const ref = useRef(null);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = (event) => {\n      ref.current = event.target.value;\n    };\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const onChange = t0;\n  let t1;\n  if ($[1] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = <input onChange={onChange} />;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Labeled Statements\nDESCRIPTION: This is an optimized version of the Component function. It uses labeled statements (bb0, bb1, bb2) for control flow, removes some unnecessary code, and simplifies the switch statement. The core functionality remains the same as the original version.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/dominator.expect.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let x = 0;\n  bb0: if (props.a) {\n    x = 1;\n  } else {\n    if (props.b) {\n    } else {\n      break bb0;\n    }\n\n    x = 3;\n  }\n  bb1: bb2: switch (props.c) {\n    case \"a\": {\n      x = 4;\n      break bb2;\n    }\n    case \"b\": {\n      break bb1;\n    }\n    case \"c\": {\n    }\n    default: {\n      x = 6;\n    }\n  }\n  if (props.d) {\n    return null;\n  }\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing useFoo React Hook (Original Input)\nDESCRIPTION: Original implementation of a useFoo React hook that manipulates an array based on conditional props. The hook pushes either props.foo or props.bar into the array depending on props.cond value. This is the code before React compiler optimization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-renaming-unconditional-ternary.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction useFoo(props) {\n  let x = [];\n  x.push(props.bar);\n  props.cond\n    ? ((x = {}), (x = []), x.push(props.foo))\n    : ((x = []), (x = []), x.push(props.bar));\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{cond: false, foo: 2, bar: 55}],\n  sequentialRenders: [\n    {cond: false, foo: 2, bar: 55},\n    {cond: false, foo: 3, bar: 55},\n    {cond: true, foo: 3, bar: 55},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Building the React DevTools Firefox Extension\nDESCRIPTION: Commands for building the React DevTools Firefox extension from either the extension directory or project root.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools-extensions/firefox/README.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnode build\n```\n\nLANGUAGE: shell\nCODE:\n```\nyarn run build:firefox\n```\n\n----------------------------------------\n\nTITLE: Utilizing useEffect Hook in React Component\nDESCRIPTION: This snippet creates a React functional component that uses the useEffect hook. It logs the 'props.value' and lists an empty 'data' object as a dependency. The memoization issue arises because 'data' is reinitialized on every render, leading to potential infinite loops or performance issues. Prerequisites include installing React and understanding its lifecycle hooks.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-useEffect-dep-not-memoized.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validateMemoizedEffectDependencies\nimport {useEffect} from 'react';\n\nfunction Component(props) {\n  const data = {};\n  useEffect(() => {\n    console.log(props.value);\n  }, [data]);\n  mutate(data);\n  return data;\n}\n\n```\n\n----------------------------------------\n\nTITLE: React Component with Conditional Logic in JavaScript\nDESCRIPTION: This snippet defines a React component using conditional logic to check if a prop has changed and conditionally initialize the component state. It makes use of an imported compiler-runtime function to handle state management within the component function. The component is then exported as a fixture entry with specified parameters and an indicator of its component status.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-decl.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction component(a) {\n  const $ = _c(2);\n  let t;\n  if ($[0] !== a) {\n    t = { a };\n    const x = function x() {\n      t.foo();\n    };\n\n    x(t);\n    $[0] = a;\n    $[1] = t;\n  } else {\n    t = $[1];\n  }\n  return t;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Using Memoization to Optimize React Component Rendering\nDESCRIPTION: This code snippet defines a React functional component that leverages the 'useMemo' hook to memoize calculations based on the component's props. It also utilizes the 'ValidateMemoization' component to validate the inputs and outputs of the memoized data, ensuring that changes to the props do not negatively affect the memoization guarantees. Required dependencies include React and 'shared-runtime'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/error.todo-optional-member-expression-with-conditional-optional.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees @enableOptionalDependencies @enablePropagateDepsInHIR\nimport {ValidateMemoization} from 'shared-runtime';\nfunction Component(props) {\n  const data = useMemo(() => {\n    const x = [];\n    x.push(props?.items);\n    if (props.cond) {\n      x.push(props?.items);\n    }\n    return x;\n  }, [props?.items, props.cond]);\n  return (\n    <ValidateMemoization inputs={[props?.items, props.cond]} output={data} />\n  );\n}\n\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Memoization (JavaScript)\nDESCRIPTION: This snippet shows an optimized version of the React component using memoization. It caches computed values to avoid unnecessary recalculations, potentially improving performance in scenarios with frequent re-renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-expression-computed-key.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { identity } from \"shared-runtime\";\n\nconst SCALE = 2;\n\nfunction Component(props) {\n  const $ = _c(5);\n  const { key } = props;\n  let t0;\n  if ($[0] !== props.value) {\n    t0 = identity([props.value, SCALE]);\n    $[0] = props.value;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  let t1;\n  if ($[2] !== key || $[3] !== t0) {\n    t1 = { [key]: t0 };\n    $[2] = key;\n    $[3] = t0;\n    $[4] = t1;\n  } else {\n    t1 = $[4];\n  }\n  const context = t1;\n  return context;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ key: \"Sathya\", value: \"Compiler\" }],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with State and Event Handling\nDESCRIPTION: This snippet defines a React component using the useState hook. It implements nested functions for rendering and event handling, with a main render function that returns a div containing the result of calling function a().\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/multiple-calls-to-hoisted-callback-from-other-callback.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useState} from 'react';\n\nfunction Component(props) {\n  const [_state, setState] = useState();\n  const a = () => {\n    return b();\n  };\n  const b = () => {\n    return (\n      <>\n        <div onClick={() => onClick(true)}>a</div>\n        <div onClick={() => onClick(false)}>b</div>\n      </>\n    );\n  };\n  const onClick = value => {\n    setState(value);\n  };\n\n  return <div>{a()}</div>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing waitForCommitToBeReady for React Reconciler in JavaScript\nDESCRIPTION: This method is called after all suspendInstance calls are complete. It determines if a commit can happen immediately or if it needs to be suspended. It returns null for immediate commits or a function for suspended commits.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-reconciler/README.md#2025-04-21_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nwaitForCommitToBeReady() {\n  // Return null if the commit can happen immediately\n  // Or return a function: (initiateCommit: Function) => Function\n  // if the commit must be suspended\n}\n```\n\n----------------------------------------\n\nTITLE: Defining React Components with 'use forget' Directive\nDESCRIPTION: This snippet defines React components Bar, NoForget, and Foo. The Bar and Foo components use the 'use forget' directive for optimization. It also exports a FIXTURE_ENTRYPOINT for testing purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/gating-test-export-default-function.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @gating @compilationMode(annotation)\nexport default function Bar(props) {\n  'use forget';\n  return <div>{props.bar}</div>;\n}\n\nfunction NoForget(props) {\n  return <Bar>{props.noForget}</Bar>;\n}\n\nfunction Foo(props) {\n  'use forget';\n  return <Foo>{props.bar}</Foo>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: eval('Bar'),\n  params: [{bar: 2}],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimizing React Component with Compiler-Runtime and Memoization\nDESCRIPTION: This snippet shows an optimized version of the component using React's compiler-runtime. It implements memoization to avoid unnecessary recalculations and object creations, potentially improving performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-expression-computed-key-constant-number.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { identity } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(4);\n  let t0;\n  if ($[0] !== props.value) {\n    t0 = identity([props.value]);\n    $[0] = props.value;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  let t1;\n  if ($[2] !== t0) {\n    t1 = { [42]: t0 };\n    $[2] = t0;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  const context = t1;\n  return context;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ value: \"hello!\" }],\n};\n```\n\n----------------------------------------\n\nTITLE: Custom Wall with Unique ID\nDESCRIPTION: This JavaScript snippet provides an alternative custom \"wall\" implementation that utilizes a unique ID to ensure that only messages intended for a specific DevTools instance are processed. This is particularly useful when multiple DevTools instances may be rendered on the same page, preventing cross-communication.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools-inline/README.md#2025-04-21_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nconst uid = \"some-unique-string-shared-between-both-pieces\";\nconst wall = {\n  listen(listener) {\n    window.addEventListener(\"message\", (event) => {\n      if (event.data.uid === uid) {\n        listener(event.data);\n      }\n    });\n  },\n  send(event, payload) {\n    window.postMessage({ event, payload, uid }, \"*\");\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: React useRef Hook Usage with Render Error\nDESCRIPTION: This snippet demonstrates how to initialize a ref with `useRef` and then incorrectly attempts to read and modify the `current` value of the ref during the render phase of a React component. This practice is not allowed and will trigger a React error as refs should only be accessed in event handlers or effects.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.ref-initialization-arbitrary.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n//@flow\nimport {useRef} from 'react';\n\nconst DEFAULT_VALUE = 1;\n\ncomponent C() {\n  const r = useRef(DEFAULT_VALUE);\n  if (r.current == DEFAULT_VALUE) {\n    r.current = 1;\n  }\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: C,\n  params: [{}]}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Do-While Loop (Input Version)\nDESCRIPTION: This snippet defines a React component function with a do-while loop, although the loop immediately breaks. It also exports a FIXTURE_ENTRYPOINT object for testing.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/do-while-break.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  do {\n    break;\n  } while (props.cond);\n  return props;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with FBT Internationalization\nDESCRIPTION: This snippet shows a React component using FBT for internationalization. It renders a text component with parameterized content for easy translation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbtparam-with-jsx-element-content.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport fbt from 'fbt';\n\nfunction Component({name, data, icon}) {\n  return (\n    <Text type=\"body4\">\n      <fbt desc=\"Lorem ipsum\">\n        <fbt:param name=\"item author\">\n          <Text type=\"h4\">{name}</Text>\n        </fbt:param>\n        <fbt:param name=\"icon\">{icon}</fbt:param>\n        <Text type=\"h4\">\n          <fbt:param name=\"item details\">{data}</fbt:param>\n        </Text>\n      </fbt>\n    </Text>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Hook and Component Structure - JavaScript\nDESCRIPTION: This snippet showcases the definition of a custom hook 'useFreeze' and a simple functional component 'Component'. The 'Component' utilizes the 'useFreeze' hook to manage its state. The 'foo' function is also included, but its specific purpose is not defined. Notably, 'Component' returns JSX that incorporates the results of the hook and other variables.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hook-call.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction useFreeze() {}\nfunction foo() {}\n\nfunction Component(props) {\n  const x = [];\n  const y = useFreeze(x);\n  foo(y, x);\n  return (\n    <Component>\n      {x}\n      {y}\n    </Component>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: React Component Definition with Ternary Logic (Input)\nDESCRIPTION: Defines a React functional component named 'ternary' that accepts 'props' as input. It uses nested ternary operators to conditionally assign values to variables 'a' and 'b' based on the values of props. The component returns 'b' if 'a' is truthy, otherwise it returns null.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ternary-expression.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction ternary(props) {\n  const a = props.a && props.b ? props.c || props.d : props.e ?? props.f;\n  const b = props.a ? (props.b && props.c ? props.d : props.e) : props.f;\n  return a ? b : null;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: ternary,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Component with useFragment (Compiled Code)\nDESCRIPTION: This is the compiled version of the React component `Component`. It uses `react/compiler-runtime` to optimize rendering by caching previous results. The compiled code uses `_c` from `react/compiler-runtime`, `useFragment` from `shared-runtime` to fetch data, and memoizes the rendering of the posts and the final output.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/readonly-object-method-calls-mutable-lambda.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useFragment } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(3);\n  const x = makeObject();\n  const user = useFragment(\n    graphql`\n      fragment Component_user on User {\n        name\n      }\n    `,\n    props.user,\n  );\n  const posts = user.timeline.posts.edges.nodes.map((node) => {\n    x.y = true;\n    return <Post post={node} />;\n  });\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = {};\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  posts.push(t0);\n  const count = posts.length;\n  foo(count);\n  let t1;\n  if ($[1] !== posts) {\n    t1 = <>{posts}</>;\n    $[1] = posts;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  return t1;\n}\n\n```\n\n----------------------------------------\n\nTITLE: React Compiler Transformed Function with Memoization\nDESCRIPTION: The compiled version of the function using React's compiler runtime. It adds memoization to prevent unnecessary object creation and mutation on subsequent calls by storing the result in a cache array.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-property-alias-mutate.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction foo() {\n  const $ = _c(1);\n  let y;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const a = {};\n    const x = a;\n\n    y = {};\n    y.x = x;\n\n    mutate(a);\n    $[0] = y;\n  } else {\n    y = $[0];\n  }\n  return y;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Memoization and Conditional Rendering - React - JavaScript\nDESCRIPTION: This snippet illustrates an enhanced version of the 'Foo' component that incorporates memoization using a cache sentinel. It conditionally checks if the cache is available and processes data accordingly, ensuring efficient rendering while maintaining the same structure as the previous snippet.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoist-destruct.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Foo() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const foo = function foo() {\n      return (\n        <div>\n          {a} {z} {y}\n        </div>\n      );\n    };\n\n    const [t1, t2] = [1, { x: 2 }];\n    const a = t1;\n    const { x: t3, y: t4 } = t2;\n    const z = t3;\n    const y = t4 === undefined ? 10 : t4;\n    t0 = foo();\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [],\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Component with Optional Properties\nDESCRIPTION: This snippet defines a React component named `Component` that accesses nested properties (a, b, c, d) of the `props` object.  It uses the optional chaining operator `?.` to handle cases where `props.a` might be null or undefined, avoiding errors when trying to access properties on potentially null values. The value obtained from this nested property access is then passed to the `foo` function.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/nested-optional-member-expr.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// We should codegen nested optional properties correctly\n// (i.e. placing `?` in the correct PropertyLoad)\nfunction Component(props) {\n  let x = foo(props.a?.b.c.d);\n  return x;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Initializing React Component with Invalid State Update\nDESCRIPTION: Demonstrates a React component that incorrectly updates state directly during render, which triggers an infinite render loop and violates React's rendering rules\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-unconditional-set-state-in-render.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validateNoSetStateInRender\nfunction Component(props) {\n  const [x, setX] = useState(0);\n  const aliased = setX;\n\n  setX(1);\n  aliased(2);\n\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: React Error for Accessing Ref During Render\nDESCRIPTION: The error message generated when trying to access and modify a ref value during the render phase. React prohibits accessing ref.current during render as it violates the principles of pure rendering functions.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-useCallback-set-ref-nested-property-ref-modified-later-preserve-memoization.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n  12 |\n  13 |   // The ref is modified later, extending its range and preventing memoization of onChange\n> 14 |   ref.current.inner = null;\n     |   ^^^^^^^^^^^ InvalidReact: Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef) (14:14)\n  15 |\n  16 |   return <input onChange={onChange} />;\n  17 | }\n```\n\n----------------------------------------\n\nTITLE: Implementing Memoization Cache Handling in React Compiler Runtime\nDESCRIPTION: This function, nonReactFn, interacts with React's compiler runtime to handle memoization caching. It uses a Symbol to check for a cache sentinel and either creates a new cache object or returns an existing one.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/apps/playground/__tests__/e2e/__snapshots__/page.spec.ts/compilationMode-all-output.txt#2025-04-21_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // \n        @compilationMode(all)\nfunction nonReactFn() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = {};\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n```\n\n----------------------------------------\n\nTITLE: Using React Portal Creation\nDESCRIPTION: Example of using ReactDOM.createPortal() for rendering subtrees into different DOM nodes.\nSOURCE: https://github.com/facebook/react/blob/main/CHANGELOG.md#2025-04-21_snippet_21\n\nLANGUAGE: javascript\nCODE:\n```\nReactDOM.createPortal()\n```\n\n----------------------------------------\n\nTITLE: React Compiler Transformed Component with Memoization\nDESCRIPTION: The transformed version of the component uses React compiler-runtime for memoization. It introduces a cache mechanism with sentinel values to avoid recalculating values when the component re-renders, optimizing performance by preserving references.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/chained-assignment-context-variable.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { makeArray } from \"shared-runtime\";\n\nfunction Component() {\n  const $ = _c(3);\n  let x;\n  let y;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    y = x = {};\n\n    const foo = () => {\n      x = makeArray();\n    };\n\n    foo();\n    $[0] = x;\n    $[1] = y;\n  } else {\n    x = $[0];\n    y = $[1];\n  }\n  let t0;\n  if ($[2] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = [y, x];\n    $[2] = t0;\n  } else {\n    t0 = $[2];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Server Reference with 'use server' Directive\nDESCRIPTION: Example demonstrating server references with the 'use server' directive. This shows a function that can be called from both server components and client components but is executed on the server in both cases.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-server/README.md#2025-04-21_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\nasync function logOnServer(message) {\n  \"use server\"\n  console.log(message)\n}\n\nasync function App({ children }) {\n  // logOnServer can be used in a Server Component\n  logOnServer('used from server')\n  return children\n}\n\ncreateResponse(\n  <App >\n    <ClientComp onClick={logOnServer} message={\"used from client\"} />\n  </App>,\n...)\n```\n\n----------------------------------------\n\nTITLE: React Component Definition (Optimized)\nDESCRIPTION: This code snippet presents an optimized version of the `Component` using `react/compiler-runtime`. It uses a cache (`_c(4)`) to store previous results based on props. The optimized component memoizes its output based on `props.p0` and `props.p1`, avoiding re-renders if these props haven't changed. It effectively prevents unnecessary updates by checking if the props have changed before re-computing the component's output.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reassignment.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(4);\n  let t0;\n  if ($[0] !== props.p0 || $[1] !== props.p1) {\n    let x = [];\n    x.push(props.p0);\n    const y = x;\n    let t1;\n    if ($[3] === Symbol.for(\"react.memo_cache_sentinel\")) {\n      t1 = [];\n      $[3] = t1;\n    } else {\n      t1 = $[3];\n    }\n    x = t1;\n\n    y.push(props.p1);\n\n    t0 = <Component x={x} y={y} />;\n    $[0] = props.p0;\n    $[1] = props.p1;\n    $[2] = t0;\n  } else {\n    t0 = $[2];\n  }\n  return t0;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: The compiled version of the component with React compiler optimizations applied. It adds memoization logic to prevent unnecessary array recreation when the state hasn't changed, improving performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-functions-component-with-hook-call.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @compilationMode(infer)\nfunction Component(props) {\n  const $ = _c(2);\n  const [state] = useState(null);\n  let t0;\n  if ($[0] !== state) {\n    t0 = [state];\n    $[0] = state;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with Plain Objects\nDESCRIPTION: This snippet defines a React component using plain objects instead of JSX. It creates a counter with a button to increment the count, using the useState hook for state management.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/merge-consecutive-scopes-objects.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useState} from 'react';\nimport {Stringify} from 'shared-runtime';\n\nfunction Component(props) {\n  let [state, setState] = useState(0);\n  return [\n    {component: Stringify, props: {text: 'Counter'}},\n    {component: 'span', props: {children: [state]}},\n    {\n      component: 'button',\n      props: {\n        'data-testid': 'button',\n        onClick: () => setState(state + 1),\n        children: ['increment'],\n      },\n    },\n  ];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component with FBT\nDESCRIPTION: Source React component using FBT for internationalization. The component conditionally renders a div containing internationalized text with a parameter.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-no-value-for-temporary-reactive-scope-with-early-return.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @flow @enableAssumeHooksFollowRulesOfReact @enableTransitivelyFreezeFunctionExpressions\nimport {identity, makeObject_Primitives} from 'shared-runtime';\nimport fbt from 'fbt';\n\nfunction Component(props) {\n  const object = makeObject_Primitives();\n  const cond = makeObject_Primitives();\n  if (!cond) {\n    return null;\n  }\n\n  return (\n    <div className=\"foo\">\n      {fbt(\n        'Lorum ipsum' + fbt.param('thing', object.b) + ' blah blah blah',\n        'More text'\n      )}\n    </div>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: Initial implementation of a React component that creates a callback closure over a mutable variable and renders a Stringify component with the callback.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/context-variable-reassigned-outside-of-lambda.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {Stringify} from 'shared-runtime';\n\nfunction Component(props) {\n  let x = null;\n  const callback = () => {\n    console.log(x);\n  };\n  x = {};\n  return <Stringify callback={callback} shouldInvokeFns={true} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Memoization (JavaScript)\nDESCRIPTION: This snippet presents an optimized version of the same component using compiler-generated code for memoization and state management. It uses a custom caching mechanism to avoid unnecessary re-renders and function recreations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/merge-scopes-callback.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enableInstructionReordering\nimport { useState } from \"react\";\n\nfunction Component() {\n  const $ = _c(4);\n  const [state, setState] = useState(0);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = () => {\n      setState(_temp);\n    };\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const onClick = t0;\n  let t1;\n  if ($[1] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = <button onClick={onClick}>Increment</button>;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  let t2;\n  if ($[2] !== state) {\n    t2 = (\n      <>\n        <span>Count: {state}</span>\n        {t1}\n      </>\n    );\n    $[2] = state;\n    $[3] = t2;\n  } else {\n    t2 = $[3];\n  }\n  return t2;\n}\nfunction _temp(s) {\n  return s + 1;\n}\n```\n\n----------------------------------------\n\nTITLE: React Component Definition with Invoke\nDESCRIPTION: This snippet defines a React component `Foo` that initializes an array `x` of objects with a `value` property. It also defines a function `foo` that accesses an element in `x` based on a given parameter and returns its `value`. Finally, it uses the `invoke` function to call `foo` with the argument `1` and returns the result.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/lambda-array-access-member-expr-param.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n```javascript\nimport {invoke} from 'shared-runtime';\n\nfunction Foo() {\n  const x = [{value: 0}, {value: 1}, {value: 2}];\n  const foo = (param: number) => {\n    return x[param].value;\n  };\n\n  return invoke(foo, 1);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{}]\n};\n\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with Memoization (JavaScript)\nDESCRIPTION: This snippet defines a React component that uses memoization to optimize rendering performance. It conditionally renders content based on props and caches the result for subsequent renders with the same prop values.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/ssa-leave-case.expect.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enablePropagateDepsInHIR\nimport { Stringify } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(3);\n  let t0;\n  if ($[0] !== props.p0 || $[1] !== props.p1) {\n    const x = [];\n    let y;\n    if (props.p0) {\n      x.push(props.p1);\n      y = x;\n    }\n\n    t0 = (\n      <Stringify>\n        {x}\n        {y}\n      </Stringify>\n    );\n    $[0] = props.p0;\n    $[1] = props.p1;\n    $[2] = t0;\n  } else {\n    t0 = $[2];\n  }\n  return t0;\n}\n```\n\n----------------------------------------\n\nTITLE: Building the Extension Using Yarn\nDESCRIPTION: This snippet outlines the command to build the extension using Yarn from the root directory. Dependencies include Yarn package manager and the appropriate build script setup.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools-extensions/edge/README.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nyarn run build:extension:edge\n```\n\n----------------------------------------\n\nTITLE: Compiled React Components with Runtime Optimization\nDESCRIPTION: Compiled version of the components with memoization using react/compiler-runtime. Includes optimization for preventing unnecessary re-renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/component-declaration-basic.flow.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nexport default function Foo(t0) {\n  const $ = _c(2);\n  const { bar } = t0;\n  let t1;\n  if ($[0] !== bar) {\n    t1 = <Bar bar={bar} />;\n    $[0] = bar;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n\nfunction Bar(t0) {\n  const $ = _c(2);\n  const { bar } = t0;\n  let t1;\n  if ($[0] !== bar) {\n    t1 = <div>{bar}</div>;\n    $[0] = bar;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n\nfunction shouldNotCompile() {}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{ bar: 42 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized useFoo Function with Compiler Runtime Integration - JavaScript\nDESCRIPTION: This snippet showcases an optimized version of the 'useFoo' function that integrates with React's compiler runtime. It maintains state across renders and minimizes recalculations when the input has not changed, improving performance in React applications.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-sequential-optional-chain-nonnull.expect.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction useFoo(t0) {\n  const $ = _c(2);\n  const { a } = t0;\n  let x;\n  if ($[0] !== a.b.c.d.e) {\n    x = [];\n    x.push(a?.b.c?.d.e);\n    x.push(a.b?.c.d?.e);\n    $[0] = a.b.c.d.e;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Running Backend and Standalone DevTools for Local Development\nDESCRIPTION: Commands for running the backend and standalone components of React DevTools when developing the tool itself. These commands are used after completing prerequisite build steps.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/README.md#2025-04-21_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\nyarn start:backend\nyarn start:standalone\n```\n\n----------------------------------------\n\nTITLE: Configuring eslint-plugin-react-hooks with legacy config (ESLint 5.2.0+)\nDESCRIPTION: Setup for ESLint below 9.0.0 using the legacy .eslintrc format with the recommended-legacy configuration.\nSOURCE: https://github.com/facebook/react/blob/main/packages/eslint-plugin-react-hooks/README.md#2025-04-21_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n{\n  \"extends\": [\n    // ...\n    \"plugin:react-hooks/recommended-legacy\"\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a React Component with Conditional FBT Translations\nDESCRIPTION: This snippet defines a React component that uses FBT for internationalization. It conditionally renders different translated labels based on various conditions.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/lambda-with-fbt.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {fbt} from 'fbt';\n\nfunction Component() {\n  const buttonLabel = () => {\n    if (!someCondition) {\n      return <fbt desc=\"My label\">{'Purchase as a gift'}</fbt>;\n    } else if (\n      !iconOnly &&\n      showPrice &&\n      item?.current_gift_offer?.price?.formatted != null\n    ) {\n      return (\n        <fbt desc=\"Gift button's label\">\n          {'Gift | '}\n          <fbt:param name=\"price\">\n            {item?.current_gift_offer?.price?.formatted}\n          </fbt:param>\n        </fbt>\n      );\n    } else if (!iconOnly && !showPrice) {\n      return <fbt desc=\"Gift button's label\">{'Gift'}</fbt>;\n    }\n  };\n\n  return (\n    <View>\n      <Button text={buttonLabel()} />\n    </View>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: React Component with useState\nDESCRIPTION: This code defines a React component that utilizes the useState hook to manage state. It also includes examples of using Boolean, Number, and String constructor functions. A constant function is also defined and used within the component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capitalized-function-allowlist.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validateNoCapitalizedCalls @hookPattern:\".*\\b(use[^$]+)$\"\nimport * as React from 'react';\nconst React$useState = React.useState;\nconst THIS_IS_A_CONSTANT = () => {};\nfunction Component() {\n  const b = Boolean(true); // OK\n  const n = Number(3); // OK\n  const s = String('foo'); // OK\n  const [state, setState] = React$useState(0); // OK\n  const [state2, setState2] = React.useState(1); // OK\n  const constant = THIS_IS_A_CONSTANT(); // OK\n  return 3;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  isComponent: true,\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Component Rendering with Memo and Static Text in JavaScript\nDESCRIPTION: This snippet demonstrates a memoized approach to rendering a React component named `Component` using static text elements. It imports a custom React compiler-runtime function (`_c`) to optimize rendering by maintaining a cache for memoization. The component uses shared runtime dependencies (`StaticText1` and `StaticText2`) and evaluates prop values to update the component only when necessary, thus optimizing performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-tag-evaluation-order.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { StaticText1, StaticText2 } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(3);\n\n  const t0 = props.value;\n  let t1;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = <StaticText2 />;\n    $[0] = t1;\n  } else {\n    t1 = $[0];\n  }\n  let t2;\n  if ($[1] !== t0) {\n    t2 = (\n      <StaticText1>\n        {t0}\n        {t1}\n      </StaticText1>\n    );\n    $[1] = t0;\n    $[2] = t2;\n  } else {\n    t2 = $[2];\n  }\n  return t2;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ value: \"string value 1\" }],\n  isComponent: true,\n};\n\n```\n\n----------------------------------------\n\nTITLE: Input Component with useCallback and useRef\nDESCRIPTION: Original React component implementation using useCallback for memoization and useRef for maintaining mutable state. Shows how refs remain mutable even with memoization guarantees enabled.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useCallback-set-ref-value-preserve-memoization.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enablePreserveExistingMemoizationGuarantees\nimport {useCallback, useRef} from 'react';\n\nfunction Component(props) {\n  const ref = useRef(null);\n\n  const onChange = useCallback(event => {\n    // The ref should still be mutable here even though function deps are frozen in\n    // @enablePreserveExistingMemoizationGuarantees mode\n    ref.current = event.target.value;\n  });\n\n  return <input onChange={onChange} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Prepare Stable Release from NPM Script\nDESCRIPTION: This script prepares a stable release by checking out a 'next' release from NPM. It prompts the user to select stable version numbers and updates the package contents. This process is typically done to promote a tested 'next' release to a stable version.\nSOURCE: https://github.com/facebook/react/blob/main/scripts/release/README.md#2025-04-21_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nscripts/release/prepare-release-from-npm.js --version=0.0.0-241c4467e-20200129\n```\n\n----------------------------------------\n\nTITLE: Implementing React Context and Memoization Test Components\nDESCRIPTION: Defines React components that demonstrate context usage and memoization validation. Creates a context provider component and an inner component that uses the context value with memoization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/use-operator-call-expression.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {ValidateMemoization} from 'shared-runtime';\nimport {use, useMemo} from 'react';\n\nconst FooContext = React.createContext(null);\nfunction Component(props) {\n  return (\n    <FooContext.Provider value={props.value}>\n      <Inner />\n    </FooContext.Provider>\n  );\n}\n\nfunction Inner(props) {\n  const input = use(FooContext);\n  const output = useMemo(() => [input], [input]);\n  return <ValidateMemoization inputs={[input]} output={output} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: 42}],\n  sequentialRenders: [\n    {value: null},\n    {value: 42},\n    {value: 42},\n    {value: null},\n    {value: null},\n    {value: 42},\n    {value: null},\n    {value: 42},\n    {value: null},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing useSupportsTouchEvent Hook in React\nDESCRIPTION: This snippet defines a custom React hook that checks if the browser supports touch events. It uses useMemo for performance optimization and tries to create a TouchEvent to determine support.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-preds-undefined-try-catch-return-primitive.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableAssumeHooksFollowRulesOfReact @enableTransitivelyFreezeFunctionExpressions\n\nimport {useMemo} from 'react';\n\nconst checkforTouchEvents = true;\nfunction useSupportsTouchEvent() {\n  return useMemo(() => {\n    if (checkforTouchEvents) {\n      try {\n        document.createEvent('TouchEvent');\n        return true;\n      } catch {\n        return false;\n      }\n    }\n  }, []);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useSupportsTouchEvent,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Creating React Component with Context and Ref\nDESCRIPTION: This code defines a React component named `Component` that consumes a context `FooContext`, uses a ref, and updates state on click. The component clones the `children` prop and renders it within a div with an `onClick` handler.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/react-namespace.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst FooContext = React.createContext({current: null});\n\nfunction Component(props) {\n  const foo = React.useContext(FooContext);\n  const ref = React.useRef();\n  const [x, setX] = React.useState(false);\n  const onClick = () => {\n    setX(true);\n    ref.current = true;\n  };\n  return <div onClick={onClick}>{React.cloneElement(props.children)}</div>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{children: <div>Hello</div>}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Initializing React Component with State Hooks\nDESCRIPTION: A functional React component using useState and useMemo hooks to manage component state. The snippet demonstrates state initialization and conditional state updates, but contains a potential anti-pattern of calling setState within useMemo.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-conditional-setState-in-useMemo.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component({item, cond}) {\n  const [prevItem, setPrevItem] = useState(item);\n  const [state, setState] = useState(0);\n\n  useMemo(() => {\n    if (cond) {\n      setPrevItem(item);\n      setState(0);\n    }\n  }, [cond, key, init]);\n\n  return state;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring eslint-plugin-react-hooks with legacy config (ESLint < 5.2.0)\nDESCRIPTION: Setup for ESLint versions earlier than 5.2.0 using the legacy .eslintrc format with the recommended configuration.\nSOURCE: https://github.com/facebook/react/blob/main/packages/eslint-plugin-react-hooks/README.md#2025-04-21_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\n{\n  \"extends\": [\n    // ...\n    \"plugin:react-hooks/recommended\"\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Optimized useFoo Function with React Compiler Runtime\nDESCRIPTION: This snippet shows an optimized version of the useFoo function using React's compiler-runtime. It implements memoization manually, caching computed values and only recalculating when dependencies change, potentially improving performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useMemo-constant-prop.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @validatePreserveExistingMemoizationGuarantees\nimport { useMemo } from \"react\";\nimport { identity } from \"shared-runtime\";\n\nfunction useFoo(cond) {\n  const $ = _c(5);\n  const sourceDep = 0;\n  let t0;\n  let t1;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = identity(0);\n    $[0] = t1;\n  } else {\n    t1 = $[0];\n  }\n  t0 = t1;\n  const derived1 = t0;\n\n  const derived2 = (cond ?? Math.min(0, 1)) ? 1 : 2;\n  let t2;\n  let t3;\n  if ($[1] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t3 = identity(0);\n    $[1] = t3;\n  } else {\n    t3 = $[1];\n  }\n  t2 = t3;\n  const derived3 = t2;\n\n  const derived4 = (Math.min(0, -1) ?? cond) ? 1 : 2;\n  let t4;\n  if ($[2] !== derived2 || $[3] !== derived4) {\n    t4 = [derived1, derived2, derived3, derived4];\n    $[2] = derived2;\n    $[3] = derived4;\n    $[4] = t4;\n  } else {\n    t4 = $[4];\n  }\n  return t4;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [true],\n};\n```\n\n----------------------------------------\n\nTITLE: Creating Conditional Render Component with Props in React\nDESCRIPTION: This snippet defines a React functional component that conditionally renders one of two static text components based on the boolean prop 'showText1'. It utilizes the 'RenderPropAsChild' component to render the selected text dynamically. The component is exported with a predefined parameter for use in other parts of the application.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-ternary-local-variable.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {RenderPropAsChild, StaticText1, StaticText2} from 'shared-runtime';\n\nfunction Component(props: {showText1: boolean}) {\n  const Foo = props.showText1 ? StaticText1 : StaticText2;\n\n  return <RenderPropAsChild items={[() => <Foo key=\"0\" />]} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{showText1: false}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a React Component with Reactive State\nDESCRIPTION: This snippet defines a React component function named Component that initializes independent reactive states a and b, then manipulates them in a controlled manner. It uses the property cond from props to alter the state of b and indirectly makes dependent state variables reactive. The output is an array containing a seemingly non-reactive variable x, which is determined to be reactive due to its dependence on the control variable c. No additional dependencies are specified, aside from typical React usage. The inputs include props, and the output is an array with the variable x.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-from-interleaved-reactivity-for-in.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  // a and b are independent but their mutations are interleaved, so\n  // they get grouped in a reactive scope. this means that a becomes\n  // reactive since it will effectively re-evaluate based on a reactive\n  // input\n  const a = [];\n  const b = [];\n  b.push(props.cond);\n  a.push({a: false});\n\n  // Downstream consumer of a, which initially seems non-reactive except\n  // that a becomes reactive, per above\n  const c = [a];\n\n  let x;\n  for (const i in c[0][0]) {\n    x = 1;\n  }\n  // The values assigned to `x` are non-reactive, but the value of `x`\n  // depends on the \"control\" value `c[0]` which becomes reactive via\n  // being interleaved with `b`.\n  // Therefore x should be treated as reactive too.\n  return [x];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{cond: true}],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with useRef and Event Handling\nDESCRIPTION: This snippet defines a React component that uses the useRef hook to manage an input field's reference. It includes a button that, when clicked, clears the input field's value. The component demonstrates proper ref handling and event management in React.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-mutating-ref-property-in-callback-passed-to-jsx-indirect.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validateRefAccessDuringRender\nimport {useRef} from 'react';\n\nfunction Component() {\n  const ref = useRef(null);\n\n  const setRef = () => {\n    if (ref.current !== null) {\n      ref.current.value = '';\n    }\n  };\n\n  const onClick = () => {\n    setRef();\n  };\n\n  return (\n    <>\n      <input ref={ref} />\n      <button onClick={onClick} />\n    </>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: The compiled version of the component using React's compiler runtime for memoization. It includes a cache sentinel check and separates the mapping function into a standalone helper.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-map-mutable-array-non-mutating-lambda-mutated-result.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const x = [{}];\n    const y = x.map(_temp);\n    y[0].flag = true;\n    t0 = [x, y];\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\nfunction _temp(item) {\n  return item;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Memoization and Freeze - JavaScript\nDESCRIPTION: This code snippet utilizes the 'react/compiler-runtime' library to define a more complex React component. It initializes a variable using the library's functionality, conditionally sets up an array depending on cache sentinel, and applies 'useFreeze' to manage the state of the array 'a'. It demonstrates advanced React features including memoization and manual array management.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hooks-freeze-arguments.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = [];\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const a = t0;\n  useFreeze(a);\n  useFreeze(a);\n  call(a);\n  return a;\n}\n\nfunction useFreeze(x) {}\nfunction call(x) {}\n```\n\n----------------------------------------\n\nTITLE: React Impure Function Call Error\nDESCRIPTION: This error message highlights the violation of React's purity rule by the `Component` function. It specifically identifies `Date.now`, `performance.now` and `Math.random` as impure functions, indicating they can produce unstable results and violate the idempotent nature required by React for its components and hooks.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-impure-functions-in-render.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n  2 |\n  3 | function Component() {\n> 4 |   const date = Date.now();\n    |                ^^^^^^^^ InvalidReact: Calling an impure function can produce unstable results. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#components-and-hooks-must-be-idempotent). `Date.now` is an impure function whose results may change on every call (4:4)\n\nInvalidReact: Calling an impure function can produce unstable results. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#components-and-hooks-must-be-idempotent). `performance.now` is an impure function whose results may change on every call (5:5)\n\nInvalidReact: Calling an impure function can produce unstable results. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#components-and-hooks-must-be-idempotent). `Math.random` is an impure function whose results may change on every call (6:6)\n  5 |   const now = performance.now();\n  6 |   const rand = Math.random();\n  7 |   return <Foo date={date} now={now} rand={rand} />;\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: This code shows the compiled version of the React component Foo, using the react/compiler-runtime. It memoizes the result of rendering the Stringify component based on the state to optimize performance. The useEffect hook's callback updates the state, triggering a re-render.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-setstate.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useEffect, useState } from \"react\";\nimport { Stringify } from \"shared-runtime\";\n\nfunction Foo() {\n  const $ = _c(3);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = [];\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  useEffect(() => setState(2), t0);\n\n  const [state, t1] = useState(0);\n  const setState = t1;\n  let t2;\n  if ($[1] !== state) {\n    t2 = <Stringify state={state} />;\n    $[1] = state;\n    $[2] = t2;\n  } else {\n    t2 = $[2];\n  }\n  return t2;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{}],\n  sequentialRenders: [{}, {}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Implementing an Invalid React Component with Unconditional setState in JavaScript\nDESCRIPTION: This code snippet shows a React functional component that incorrectly uses the useState hook. It sets state unconditionally during render, which can cause an infinite loop. The component takes props, initializes state, and attempts to update it immediately.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.unconditional-set-state-in-render-after-loop.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validateNoSetStateInRender\nfunction Component(props) {\n  const [state, setState] = useState(false);\n  for (const _ of props) {\n  }\n  setState(true);\n  return state;\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional Lazy Loading with Suspense\nDESCRIPTION: Uses the Suspense component to conditionally render and lazy-load legacy React components. This pattern delays loading until the component is actually needed, which is configured with a button click event.\nSOURCE: https://github.com/facebook/react/blob/main/fixtures/nesting/README.md#2025-04-21_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\n<>\n  <button onClick={() => setShowGreeting(true)}>\n    Say hi\n  </button>\n  {showGreeting && (\n    <Suspense fallback={<Spinner />}>\n      <Greeting />\n    </Suspense>\n  )}\n</>\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Runtime Optimizations\nDESCRIPTION: The compiled version of the component using React compiler runtime (_c). Implements caching mechanism to avoid recreating objects when props haven't changed.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-expression-string-literal-key.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== props.foo) {\n    t0 = { foo: props.foo };\n    $[0] = props.foo;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const x = t0;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: React Compiler Runtime Integration in JavaScript\nDESCRIPTION: Illustrates an optimized React component using React's compiler runtime. It manages state with a cache-like mechanism and ensures efficient rendering of the Foo element by leveraging transformed syntax.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/use-callback-simple.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction component() {\n  const $ = _c(4);\n  const [count, setCount] = useState(0);\n  let t0;\n  if ($[0] !== count) {\n    t0 = () => setCount(count + 1);\n    $[0] = count;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const increment = t0;\n  let t1;\n  if ($[2] !== increment) {\n    t1 = <Foo onClick={increment} />;\n    $[2] = increment;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  return t1;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining Component Logic with Non-reactive Values in JavaScript\nDESCRIPTION: This snippet defines a simple React component that initializes two variables, x and y, as non-reactive values. The component processes props and uses a while loop to make y reactive, then flows this value into x. The expected output from invoking this component is an array containing the final value of x.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-dependency-fixpoint.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let x = 0;\n  let y = 0;\n\n  while (x === 0) {\n    x = y;\n    y = props.value;\n  }\n\n  // x and y initially start out with non-reactive values,\n  // but after an iteration of the loop y becomes reactive,\n  // and this reactive value then flows into x on the next\n  // loop iteration, making x reactive.\n  return [x];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: 42}],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Compiler Runtime Memoization\nDESCRIPTION: Transformed version of the React component using React compiler runtime for state tracking, memoization, and conditional re-rendering\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/same-variable-as-dep-and-redeclare-maybe-frozen.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(props) {\n  const $ = _c(16);\n  let x;\n  if ($[0] !== props.a) {\n    x = [];\n    x.push(props.a);\n    $[0] = props.a;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  // ... rest of the optimized implementation\n  return t2;\n}\n```\n\n----------------------------------------\n\nTITLE: React Compiler Runtime Optimized Component\nDESCRIPTION: Transformed component using React compiler runtime with memoization and cache mechanisms to optimize rendering and state management\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/incompatible-destructuring-kinds.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useMemo } from \"react\";\nimport { Stringify } from \"shared-runtime\";\n\nfunction Component(t0) {\n  const $ = _c(4);\n  let a;\n  let b;\n  let t1;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    a = \"a\";\n\n    const [t2, t3] = [null, null];\n    t1 = t3;\n    a = t2;\n    $[0] = a;\n    $[1] = b;\n    $[2] = t1;\n  } else {\n    a = $[0];\n    b = $[1];\n    t1 = $[2];\n  }\n  b = t1;\n  let t2;\n  if ($[3] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t2 = <Stringify a={a} b={b} onClick={() => a} />;\n    $[3] = t2;\n  } else {\n    t2 = $[3];\n  }\n  return t2;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimizing Functional Component Foo for React Compiler - JavaScript\nDESCRIPTION: The second snippet reflects a more optimized version of the 'Foo' component, leveraging React's compiler runtime. It employs memoization techniques to avoid unnecessary re-evaluations of variables, making the component more efficient by checking dependencies before rendering.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/infer-function-uncond-access-hoists-other-dep.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enablePropagateDepsInHIR\n\nimport { identity, makeArray, Stringify, useIdentity } from \"shared-runtime\";\n\nfunction Foo(t0) {\n  const $ = _c(8);\n  const { a, cond } = t0;\n  let t1;\n  if ($[0] !== a) {\n    t1 = () => [a, a.b.c];\n    $[0] = a;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  const fn = t1;\n  useIdentity(null);\n  let x;\n  if ($[2] !== a.b.c || $[3] !== cond) {\n    x = makeArray();\n    if (cond) {\n      x.push(identity(a.b.c));\n    }\n    $[2] = a.b.c;\n    $[3] = cond;\n    $[4] = x;\n  } else {\n    x = $[4];\n  }\n  let t2;\n  if ($[5] !== fn || $[6] !== x) {\n    t2 = <Stringify fn={fn} x={x} shouldInvokeFns={true} />;\n    $[5] = fn;\n    $[6] = x;\n    $[7] = t2;\n  } else {\n    t2 = $[7];\n  }\n  return t2;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{ a: null, cond: true }],\n  sequentialRenders: [\n    { a: null, cond: true },\n    { a: { b: { c: 4 } }, cond: true },\n    { a: { b: { c: 4 } }, cond: true },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized useHook Implementation with Memoization in JavaScript\nDESCRIPTION: This snippet presents an optimized version of the 'useHook' function with memoization. It uses the React compiler runtime for caching and only recalculates when input parameters change, improving performance for repeated renders with the same inputs.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/global-types/set-add-mutate.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { makeArray } from \"shared-runtime\";\n\nfunction useHook(t0) {\n  const $ = _c(5);\n  const { el1, el2 } = t0;\n  let s;\n  if ($[0] !== el1 || $[1] !== el2) {\n    s = new Set();\n    const arr = makeArray(el1);\n    s.add(arr);\n\n    arr.push(el2);\n    let t1;\n    if ($[3] !== el2) {\n      t1 = makeArray(el2);\n      $[3] = el2;\n      $[4] = t1;\n    } else {\n      t1 = $[4];\n    }\n    s.add(t1);\n    $[0] = el1;\n    $[1] = el2;\n    $[2] = s;\n  } else {\n    s = $[2];\n  }\n  return s.size;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useHook,\n  params: [{ el1: 1, el2: \"foo\" }],\n  sequentialRenders: [\n    { el1: 1, el2: \"foo\" },\n    { el1: 2, el2: \"foo\" },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with 'use no memo' and Fire\nDESCRIPTION: This React component demonstrates the use of the 'use no memo' directive and attempts to use a `fire` function within a `useEffect` hook. It logs props within the `foo` function and triggers side effects using `fire`. The component's intent is likely to test or demonstrate the interaction between memoization disabling and compiler-required features like `fire`.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/bailout-retry/error.use-no-memo.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableFire @panicThreshold(none)\nimport {fire} from 'react';\n\n/**\n * TODO: we should eventually distinguish between `use no memo` and `use no\n * compiler` directives. The former should be used to *only* disable memoization\n * features.\n */\nfunction Component({props, bar}) {\n  'use no memo';\n  const foo = () => {\n    console.log(props);\n  };\n  useEffect(() => {\n    fire(foo(props));\n    fire(foo());\n    fire(bar());\n  });\n\n  return null;\n}\n\n```\n\n----------------------------------------\n\nTITLE: React Component Input with Ref Access\nDESCRIPTION: Original React component implementation showing a basic ref access pattern using useRef hook. The component creates and returns a function that accesses the ref's current value.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/return-ref-callback.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @flow @validateRefAccessDuringRender @validatePreserveExistingMemoizationGuarantees\n\nimport {useRef} from 'react';\n\ncomponent Foo() {\n  const ref = useRef();\n\n  const s = () => {\n    return ref.current;\n  };\n\n  return s;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized Item Rendering with Fragment in React\nDESCRIPTION: This snippet features a more advanced version of a React component utilizing the 'useFragment' hook and internal caching. It uses a temporary variable to simplify rendering by checking if the items have changed and only re-maps them if necessary. It demonstrates efficient item rendering and reuse of values with React.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-call-logical.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useFragment } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(2);\n  const item = useFragment(\n    graphql`\n      fragment F on T {\n        id\n      }\n    `,\n    props.item,\n  );\n  let t0;\n  if ($[0] !== item.items) {\n    t0 = item.items?.map(_temp) ?? [];\n    $[0] = item.items;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\nfunction _temp(item_0) {\n  return renderItem(item_0);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Compiler-Runtime\nDESCRIPTION: This snippet presents the compiled version of the `useFoo` React component, generated using React's compiler-runtime. It utilizes the `_c` function from \"react/compiler-runtime\" for memoization. The compiled code optimizes the rendering process by caching the `SharedRuntime.Text` component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-local-memberexpr-tag-conditional.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport * as SharedRuntime from \"shared-runtime\";\nfunction useFoo(t0) {\n  const $ = _c(1);\n  const { cond } = t0;\n  if (cond) {\n    let t1;\n    if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n      t1 = <SharedRuntime.Text value={4} />;\n      $[0] = t1;\n    } else {\n      t1 = $[0];\n    }\n    return t1;\n  } else {\n    return null;\n  }\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ cond: true }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with useMemo Hook (JavaScript)\nDESCRIPTION: This snippet defines a React component 'Foo' that uses the useMemo hook. It demonstrates the use of makeArray function and how useMemo is applied to memoize an array based on a dependency.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useMemo-dep-array-literal-access.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees\n\nimport {useMemo} from 'react';\nimport {makeArray} from 'shared-runtime';\n\n// We currently only recognize \"hoistable\" values (e.g. variable reads\n// and property loads from named variables) in the source depslist.\n// This makes validation logic simpler and follows the same constraints\n// from the eslint react-hooks-deps plugin.\nfunction Foo(props) {\n  const x = makeArray(props);\n  // react-hooks-deps lint would already fail here\n  return useMemo(() => [x[0]], [x[0]]);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{val: 1}],\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring additionalHooks option for exhaustive-deps rule\nDESCRIPTION: Advanced configuration for the exhaustive-deps rule to validate dependencies of custom Hooks using a regex pattern to match custom Hook names.\nSOURCE: https://github.com/facebook/react/blob/main/packages/eslint-plugin-react-hooks/README.md#2025-04-21_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\n{\n  rules: {\n    // ...\n    \"react-hooks/exhaustive-deps\": [\"warn\", {\n      additionalHooks: \"(useMyCustomHook|useMyOtherCustomHook)\"\n    }]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Benchmark Execution Variants\nDESCRIPTION: Collection of benchmark command variations for different testing scenarios, including local/remote comparisons, repository targeting, and headless mode\nSOURCE: https://github.com/facebook/react/blob/main/scripts/bench/README.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# Compare local repo vs remote merge base repo\nyarn start\n\n# Compare local repo vs remote merge base repo without building\nyarn start --skip-build\n\n# Run local repo benchmarks only\nyarn start --local\n\n# Run remote merge base repo benchmarks only\nyarn start --remote\n\n# Run remote main repo benchmarks\nyarn start --remote=main\n\n# Run both local and remote benchmarks\nyarn start --remote --local\n\n# Run benchmarks in Chrome headless mode\nyarn start --headless\n\n# Run benchmarks matching specific string\nyarn start --benchmark=hacker\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Memoization\nDESCRIPTION: This snippet shows an optimized version of the React component using memoization. It uses a compiler-specific function _c for caching and implements the same functionality as the original component but with improved performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/multiple-calls-to-hoisted-callback-from-other-callback.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useState } from \"react\";\n\nfunction Component(props) {\n  const $ = _c(1);\n  const [, setState] = useState();\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const a = () => b();\n\n    const b = () => (\n      <>\n        <div onClick={() => onClick(true)}>a</div>\n        <div onClick={() => onClick(false)}>b</div>\n      </>\n    );\n\n    const onClick = (value) => {\n      setState(value);\n    };\n\n    t0 = <div>{a()}</div>;\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Custom Wall Implementation\nDESCRIPTION: This JavaScript snippet demonstrates an advanced integration of React DevTools with a custom \"wall\" object, allowing for more control over communication between the frontend and backend.  It creates custom bridge and store objects, initializes DevTools with these custom objects, and then activates the backend with its own custom bridge. This is beneficial for environments where default message events are not sufficient.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools-inline/README.md#2025-04-21_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nimport {\n  activate as activateBackend,\n  createBridge as createBackendBridge,\n  initialize as initializeBackend,\n} from 'react-devtools-inline/backend';\nimport {\n  createBridge as createFrontendBridge,\n  createStore,\n  initialize as createDevTools,\n} from 'react-devtools-inline/frontend';\n\n// DevTools uses \"message\" events and window.postMessage() by default,\n// but we can override this behavior by creating a custom \"Wall\" object.\n// For example...\nconst wall = {\n  _listeners: [],\n  listen(listener) {\n    wall._listeners.push(listener);\n  },\n  send(event, payload) {\n    wall._listeners.forEach(listener => listener({event, payload}));\n  },\n};\n\n// Initialize the DevTools backend before importing React (or any other packages that might import React).\ninitializeBackend(contentWindow);\n\n// Prepare DevTools for rendering.\n// To use the custom Wall we've created, we need to also create our own \"Bridge\" and \"Store\" objects.\nconst bridge = createFrontendBridge(contentWindow, wall);\nconst store = createStore(bridge);\nconst DevTools = createDevTools(contentWindow, { bridge, store });\n\n// You can render DevTools now:\nconst root = createRoot(container);\nroot.render(<DevTools {...otherProps} />);\n\n// Lastly, let the DevTools backend know that the frontend is ready.\n// To use the custom Wall we've created, we need to also pass in the \"Bridge\".\nactivateBackend(contentWindow, {\n  bridge: createBackendBridge(contentWindow, wall),\n});\n```\n\n----------------------------------------\n\nTITLE: Getting First Child After Finding Root in React DevTools\nDESCRIPTION: After finding the root containing the element at index N, this code gets the first child ID to begin traversal, skipping the root itself since roots aren't displayed in the component tree.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/OVERVIEW.md#2025-04-21_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\nconst firstChildID = root.children[0];\n```\n\n----------------------------------------\n\nTITLE: Frontend Initialization\nDESCRIPTION: This JavaScript snippet shows how to initialize the React DevTools frontend, which returns a React component for rendering. The `initialize` function configures the DevTools interface to listen to the window where the backend hook is injected.  The returned component should be rendered using `ReactDOMClient.createRoot` because it uses concurrent React features.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools-inline/README.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { initialize } from 'react-devtools-inline/frontend';\n\n// This should be the iframe the backend hook has been installed in.\nconst iframe = document.getElementById(frameID);\nconst contentWindow = iframe.contentWindow;\n\n// This returns a React component that can be rendered into your app.\n// e.g. render(<DevTools {...props} />);\nconst DevTools = initialize(contentWindow);\n```\n\n----------------------------------------\n\nTITLE: Original React Component with inferEffectDependencies Directive\nDESCRIPTION: A simple React component that creates an array containing a prop value and passes it to useEffect. The @inferEffectDependencies directive tells the React compiler to automatically determine and apply the correct dependencies for the effect.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/reactive-variable.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @inferEffectDependencies\nimport {useEffect} from 'react';\nimport {print} from 'shared-runtime';\n\nfunction ReactiveVariable({propVal}) {\n  const arr = [propVal];\n  useEffect(() => print(arr));\n}\n```\n\n----------------------------------------\n\nTITLE: React Component with Dynamic State and Logging\nDESCRIPTION: A React functional component that manages state, logs events, and renders different components based on current step. Uses useState and custom logging hook to control component behavior.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/validate-no-set-state-in-render-uncalled-function-with-mutable-range-is-valid.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const logEvent = useLogging(props.appId);\n  const [currentStep, setCurrentStep] = useState(0);\n\n  const onSubmit = errorEvent => {\n    logEvent(errorEvent);\n    setCurrentStep(1);\n  };\n\n  switch (currentStep) {\n    case 0:\n      return <OtherComponent data={{foo: 'bar'}} />;\n    case 1:\n      return <OtherComponent data={{foo: 'joe'}} onSubmit={onSubmit} />;\n    default:\n      logEvent('Invalid step');\n      return <OtherComponent data={null} />;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: React Component with Compiler Runtime\nDESCRIPTION: This code represents a compiled version of the previous React component, utilizing the `react/compiler-runtime`. It initializes a reactive scope using `_c(1)` and stores it in `$`. The component performs similar operations as before but leverages the reactive scope to manage the variables. It then uses the reactive scope to memoize the result of the computation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-from-interleaved-reactivity-do-while.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(1);\n\n  const a = [];\n  const b = [];\n  b.push(props.cond);\n  a.push(false);\n\n  const c = [a];\n\n  let x = 0;\n  do {\n    x = x + 1;\n  } while (c[0][0]);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = [x];\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ cond: true }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Initializing React Component with Inline Effect\nDESCRIPTION: First code snippet showing a React functional component using useEffect to mutate an external object's property directly within the effect callback\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useEffect-external-mutate.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useEffect} from 'react';\n\nlet x = {a: 42};\n\nfunction Component(props) {\n  useEffect(() => {\n    x.a = 10;\n  });\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component with Memoization\nDESCRIPTION: React component implementing memoization of an object containing event handlers. Uses useMemo to optimize performance by preventing unnecessary recreation of handlers when config prop changes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reordering-across-blocks.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {Stringify} from 'shared-runtime';\n\nfunction Component({config}) {\n  const object = useMemo(() => {\n    const a = event => {\n      config?.onA?.(event);\n    };\n\n    const b = event => {\n      config?.onB?.(event);\n    };\n\n    return {\n      b,\n      a,\n    };\n  }, [config]);\n\n  return <Stringify value={object} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Installing react-devtools Globally with Package Managers\nDESCRIPTION: Commands for installing the react-devtools package globally using either Yarn or NPM package managers. This is the recommended approach for development tools that will be used across multiple projects.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/README.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n# Yarn\nyarn global add react-devtools\n\n# NPM\nnpm install -g react-devtools\n```\n\n----------------------------------------\n\nTITLE: Creating a Memoized Component with React.memo\nDESCRIPTION: Input source code showing a simple React.memo wrapper around a functional component that returns a div element. This is the code before compilation optimization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-function-React-memo.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @compilationMode(infer)\nReact.memo(props => {\n  return <div />;\n});\n```\n\n----------------------------------------\n\nTITLE: React Component with Conditional Logic\nDESCRIPTION: This code defines a React component named `Component` that accepts `props` as input. It uses a conditional statement based on `props.cond` to assign either 1 or 2 to the variable `x`.  The component returns an array containing the value of `x`. This example highlights a scenario where `x` is treated as reactive due to its dependency on the reactive `props.cond` even though the assignment is not directly reactive.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-if.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let x;\n  if (props.cond) {\n    x = 1;\n  } else {\n    x = 2;\n  }\n  // The values assigned to `x` are non-reactive, but the value of `x`\n  // depends on the \"control\" value `props.cond` which is reactive.\n  // Therefore x should be treated as reactive too.\n  return [x];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  sequentialRenders: [\n    {cond: true},\n    {cond: true},\n    {cond: false},\n    {cond: false},\n    {cond: true},\n    {cond: false},\n    {cond: true},\n    {cond: false},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Memoizing React Component Arguments\nDESCRIPTION: This code snippet imports shared-runtime utilities and uses React's useMemo to memoize component arguments. The purpose is to map nodes and validate memoization by comparing input and output through ValidateMemoization. The Component is structured to test sequential rendering scenarios with various argument configurations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-member-expression-as-memo-dep.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees @enableOptionalDependencies\nimport {identity, ValidateMemoization} from 'shared-runtime';\nimport {useMemo} from 'react';\n\nfunction Component({arg}) {\n  const data = useMemo(() => {\n    return arg?.items.edges?.nodes.map(identity);\n  }, [arg?.items.edges?.nodes]);\n  return (\n    <ValidateMemoization inputs={[arg?.items.edges?.nodes]} output={data} />\n  );\n}\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{arg: null}],\n  sequentialRenders: [\n    {arg: null},\n    {arg: null},\n    {arg: {items: {edges: null}}},\n    {arg: {items: {edges: null}}},\n    {arg: {items: {edges: {nodes: [1, 2, 'hello']}}}},\n    {arg: {items: {edges: {nodes: [1, 2, 'hello']}}}},\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Implementing useFoo with React's useMemo Hook\nDESCRIPTION: This snippet defines a useFoo function that uses React's useMemo hook to memoize a computation based on data.a. It also exports a FIXTURE_ENTRYPOINT for testing purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useMemo-inner-decl.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees\nimport {useMemo} from 'react';\nimport {identity} from 'shared-runtime';\n\nfunction useFoo(data) {\n  return useMemo(() => {\n    const temp = identity(data.a);\n    return {temp};\n  }, [data.a]);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{a: 2}],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with Pre/Post Increment Operations (Compiled Code)\nDESCRIPTION: This code represents a compiled version of the React component from the 'Input' section, likely generated by 'react/compiler-runtime'. The component performs similar pre-increment and post-increment operations on its props. The compiled version includes optimizations and memoization using the `_c` function from 'react/compiler-runtime'. The FIXTURE_ENTRYPOINT object provides the component, test parameters, and specifies that it is not a React Component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/update-expression-on-function-parameter-1.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(t0) {\n  const $ = _c(10);\n  let { a, b: t1, c: t2 } = t0;\n  let [b] = t1;\n  let { c } = t2;\n  const d = a++;\n  const e = ++a;\n  const f = b--;\n  const g = --b;\n  const h = c++;\n  const i = --c;\n  let t3;\n  if (\n    $[0] !== a ||\n    $[1] !== b ||\n    $[2] !== c ||\n    $[3] !== d ||\n    $[4] !== e ||\n    $[5] !== f ||\n    $[6] !== g ||\n    $[7] !== h ||\n    $[8] !== i\n  ) {\n    t3 = [a, b, c, d, e, f, g, h, i];\n    $[0] = a;\n    $[1] = b;\n    $[2] = c;\n    $[3] = d;\n    $[4] = e;\n    $[5] = f;\n    $[6] = g;\n    $[7] = h;\n    $[8] = i;\n    $[9] = t3;\n  } else {\n    t3 = $[9];\n  }\n  return t3;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ a: 2, b: [3], c: { c: 4 } }],\n  isComponent: false,\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Component with useMemo\nDESCRIPTION: This React component utilizes `useMemo` to memoize a value derived from `propA.x()`. The intention is to optimize performance by preventing unnecessary recalculations. The dependencies array `[propA.x]` specifies when the memoized value should be updated.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.useMemo-property-call-dep.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees\nimport {useMemo} from 'react';\n\nfunction Component({propA}) {\n  return useMemo(() => {\n    return propA.x();\n  }, [propA.x]);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Mapped Rendering\nDESCRIPTION: A React functional component that renders an array of items using map, with nested Bar and Baz components and a custom hook useX\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-outlining-simple.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component({arr}) {\n  const x = useX();\n  return (\n    <>\n      {arr.map((i, id) => {\n        return (\n          <Bar key={id} x={x}>\n            <Baz i={i}></Baz>\n          </Bar>\n        );\n      })}\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Input React Component with useRef and useCallback\nDESCRIPTION: Original React component implementation using useRef to store a nested object and useCallback for handling input changes. The component demonstrates memoization patterns while maintaining ref mutability.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useCallback-set-ref-nested-property.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useCallback, useRef} from 'react';\n\n// Identical to useCallback-set-ref-nested-property-preserve-memoization,\n// but with a different set of compiler flags\nfunction Component({}) {\n  const ref = useRef({inner: null});\n\n  const onChange = useCallback(event => {\n    // The ref should still be mutable here even though function deps are frozen in\n    // @enablePreserveExistingMemoizationGuarantees mode\n    ref.current.inner = event.target.value;\n  });\n\n  return <input onChange={onChange} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Lazy Loading Legacy React Components\nDESCRIPTION: Demonstrates how to lazily load legacy React components using a custom helper function similar to 'React.lazy'. This technique helps load the legacy bundle only when required, enhancing application performance.\nSOURCE: https://github.com/facebook/react/blob/main/fixtures/nesting/README.md#2025-04-21_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport lazyLegacyRoot from './lazyLegacyRoot';\n\n// Lazy-load a component from the bundle using legacy React.\nconst Greeting = lazyLegacyRoot(() => import('../legacy/Greeting'));\n\nfunction AboutPage() {\n  return (\n    <>\n      <h3>This component is rendered by React ({React.version}).</h3>\n      <Greeting />\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: React Component Definition with Conditional Logic\nDESCRIPTION: Defines a React component named `Foo` that accepts `a` and `cond` props. It utilizes optional chaining (`a.b?.c.d`, `a.b?.c.e`) to safely access nested properties of the `a` prop. The component conditionally pushes values into an array based on the `cond` prop and then renders a `Stringify` component with the derived data.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/infer-function-uncond-optional-hoists-other-dep.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enablePropagateDepsInHIR\n\nimport {identity, makeArray, Stringify, useIdentity} from 'shared-runtime';\n\nfunction Foo({a, cond}) {\n  // Assume fn can be uncond evaluated, so we can safely evaluate a.b?.c.<any>\n  const fn = () => [a, a.b?.c.d];\n  useIdentity(null);\n  const arr = makeArray();\n  if (cond) {\n    arr.push(identity(a.b?.c.e));\n  }\n  return <Stringify fn={fn} arr={arr} shouldInvokeFns={true} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{a: null, cond: true}],\n  sequentialRenders: [\n    {a: null, cond: true},\n    {a: {b: {c: {d: 5}}}, cond: true},\n    {a: {b: null}, cond: false},\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization Logic\nDESCRIPTION: Compiled version of the React component showing the implementation of memoization cache using Symbols and conditional rendering. Includes compiler-specific optimizations and caching mechanism.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useCallback-set-ref-nested-property.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useCallback, useRef } from \"react\";\n\n// Identical to useCallback-set-ref-nested-property-preserve-memoization,\n// but with a different set of compiler flags\nfunction Component(t0) {\n  const $ = _c(3);\n  let t1;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = { inner: null };\n    $[0] = t1;\n  } else {\n    t1 = $[0];\n  }\n  const ref = useRef(t1);\n  let t2;\n  if ($[1] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t2 = (event) => {\n      ref.current.inner = event.target.value;\n    };\n    $[1] = t2;\n  } else {\n    t2 = $[1];\n  }\n  const onChange = t2;\n  let t3;\n  if ($[2] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t3 = <input onChange={onChange} />;\n    $[2] = t3;\n  } else {\n    t3 = $[2];\n  }\n  return t3;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Flight Prerendering Function\nDESCRIPTION: Implementation of a prerender function for Flight in React Server Components. Unlike regular rendering, prerendering handles errors differently and returns a Promise that resolves to an object containing a prelude stream once all content is ready.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-server/README.md#2025-04-21_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nfunction prerender(\n  model: ReactClientValue,\n  clientManifest: ClientManifest,\n  options?: Options,\n): Promise<StaticResult> {\n  return new Promise((resolve, reject) => {\n    const onFatalError = reject;\n    function onAllReady() {\n      const stream = new ReadableStream(\n        {\n          type: 'bytes',\n          start: (controller): ?Promise<void> => {\n            startWork(request);\n          },\n          pull: (controller): ?Promise<void> => {\n            startFlowing(request, controller);\n          },\n          cancel: (reason): ?Promise<void> => {\n            stopFlowing(request);\n            abort(request, reason);\n          },\n        },\n        // $FlowFixMe[prop-missing] size() methods are not allowed on byte streams.\n        {highWaterMark: 0},\n      );\n      resolve({prelude: stream});\n    }\n    const request = createPrerenderRequest(\n      model,\n      clientManifest,\n      onAllReady,\n      onFatalError,\n      options ? options.onError : undefined,\n      options ? options.identifierPrefix : undefined,\n      options ? options.onPostpone : undefined,\n      options ? options.temporaryReferences : undefined,\n      __DEV__ && options ? options.environmentName : undefined,\n      __DEV__ && options ? options.filterStackFrame : undefined,\n    );\n    startWork(request);\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Using Custom Hooks - JavaScript\nDESCRIPTION: This snippet showcases a valid usage of hooks in React, where one custom hook can call another. It demonstrates the principle that hooks can be nested, allowing for modular and reusable logic within components.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-9d7879272ff6.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Valid because hooks can call hooks.\nfunction useHook() {\n  return useHook1(useHook2());\n}\n```\n\n----------------------------------------\n\nTITLE: React Component with useRef\nDESCRIPTION: This React component, VideoTab, uses the useRef hook to create a reference. A function `x` is defined that logs the current value of the reference. This function is then passed as the `videos` prop to the `VideoList` component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ref-current-aliased-no-added-to-dep.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validateRefAccessDuringRender false\nfunction VideoTab() {\n  const ref = useRef();\n  const t = ref.current;\n  let x = () => {\n    console.log(t);\n  };\n\n  return <VideoList videos={x} />;\n}\n\n```\n\n----------------------------------------\n\nTITLE: React Error Message for Invalid Hook Call\nDESCRIPTION: This snippet shows the error message produced by React when a Hook is called conditionally, violating the Rules of Hooks. The error indicates that Hooks must always be called in a consistent order. The message also provides a link to the React documentation explaining the Rules of Hooks in more detail.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-rules-of-hooks-ea7c2fb545a9.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n   5 | function useHookWithConditionalHook() {\n   6 |   if (cond) {\n>  7 |     useConditionalHook();\n     |     ^^^^^^^^^^^^^^^^^^ InvalidReact: Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning) (7:7)\n   8 |   }\n   9 | }\n  10 |\n```\n\n----------------------------------------\n\nTITLE: React Component with Compiler Runtime Memoization\nDESCRIPTION: This snippet shows the compiled version of the React component `Component` utilizing `react/compiler-runtime`'s internal memoization through the `_c` function. It achieves similar memoization behavior as the `useMemo` version but leverages the compiler for optimized performance. It uses an array `$` to store previously computed values and compares them before recomputing.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useMemo-conditional-access-alloc.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @validatePreserveExistingMemoizationGuarantees\nimport { useMemo } from \"react\";\nimport { identity } from \"shared-runtime\";\n\nfunction Component(t0) {\n  const $ = _c(5);\n  const { propA, propB } = t0;\n  let t1;\n\n  const t2 = propB?.x.y;\n  let t3;\n  if ($[0] !== t2) {\n    t3 = identity(t2);\n    $[0] = t2;\n    $[1] = t3;\n  } else {\n    t3 = $[1];\n  }\n  let t4;\n  if ($[2] !== propA || $[3] !== t3) {\n    t4 = { value: t3, other: propA };\n    $[2] = propA;\n    $[3] = t3;\n    $[4] = t4;\n  } else {\n    t4 = $[4];\n  }\n  t1 = t4;\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ propA: 2, propB: { x: { y: [] } } }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiler-Optimized React Component\nDESCRIPTION: The compiler-transformed version of the component with optimizations like memoization cache, early returns using symbols, and efficient prop comparison logic. Demonstrates how React internally optimizes component rendering.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-renaming-conflicting-decls.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { Stringify, identity, makeArray, toJSON } from \"shared-runtime\";\nimport { useMemo } from \"react\";\n\nfunction Component(props) {\n  const $ = _c(13);\n  let t0;\n  let t1;\n  let t2;\n  if ($[0] !== props) {\n    t2 = Symbol.for(\"react.early_return_sentinel\");\n    bb0: {\n      t0 = toJSON(props);\n      const propsString = t0;\n      if (propsString.length <= 2) {\n        t2 = null;\n        break bb0;\n      }\n\n      t1 = identity(propsString);\n    }\n    $[0] = props;\n    $[1] = t1;\n    $[2] = t2;\n    $[3] = t0;\n  } else {\n    t1 = $[1];\n    t2 = $[2];\n    t0 = $[3];\n  }\n  if (t2 !== Symbol.for(\"react.early_return_sentinel\")) {\n    return t2;\n  }\n  let t3;\n  if ($[4] !== t1) {\n    t3 = { url: t1 };\n    $[4] = t1;\n    $[5] = t3;\n  } else {\n    t3 = $[5];\n  }\n  const linkProps = t3;\n  let t4;\n  if ($[6] !== linkProps) {\n    const x = {};\n    let t5;\n    let t6;\n    let t7;\n    let t8;\n    let t9;\n    if ($[8] === Symbol.for(\"react.memo_cache_sentinel\")) {\n      t5 = [1];\n      t6 = [2];\n      t7 = [3];\n      t8 = [4];\n      t9 = [5];\n      $[8] = t5;\n      $[9] = t6;\n      $[10] = t7;\n      $[11] = t8;\n      $[12] = t9;\n    } else {\n      t5 = $[8];\n      t6 = $[9];\n      t7 = $[10];\n      t8 = $[11];\n      t9 = $[12];\n    }\n    t4 = (\n      <Stringify\n        link={linkProps}\n        val1={t5}\n        val2={t6}\n        val3={t7}\n        val4={t8}\n        val5={t9}\n      >\n        {makeArray(x, 2)}\n      </Stringify>\n    );\n    $[6] = linkProps;\n    $[7] = t4;\n  } else {\n    t4 = $[7];\n  }\n  return t4;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ val: 2 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Hook Component\nDESCRIPTION: Compiled version of the React hook with added memoization and feature flag handling. Includes compiler runtime imports and conditional implementations based on feature flags.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/gating-nonreferenced-identifier-collision.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { isForgetEnabled_Fixtures } from \"ReactForgetFeatureFlag\"; // @gating\nimport { identity, useHook as useRenamed } from \"shared-runtime\";\nconst _ = {\n  useHook: isForgetEnabled_Fixtures() ? () => {} : () => {},\n};\nidentity(_.useHook);\nconst useHook = isForgetEnabled_Fixtures()\n  ? function useHook() {\n      const $ = _c(1);\n      useRenamed();\n      let t0;\n      if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n        t0 = <div>hello world!</div>;\n        $[0] = t0;\n      } else {\n        t0 = $[0];\n      }\n      return t0;\n    }\n  : function useHook() {\n      useRenamed();\n      return <div>hello world!</div>;\n    };\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useHook,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: Transformed version of the component with added memoization logic using Symbol.for('react.memo_cache_sentinel'). Includes caching mechanism to prevent unnecessary recreations of mutable objects and arrays.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/alias-capture-in-method-receiver-and-mutate.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { makeObject_Primitives, mutate } from \"shared-runtime\";\n\nfunction Component() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const a = makeObject_Primitives();\n\n    const x = [];\n    x.push(a);\n\n    mutate(x);\n    t0 = [x, a];\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Utilizing useMemo with ValidateMemoization in React JavaScript\nDESCRIPTION: Demonstrates a React component using the useMemo hook from the 'shared-runtime' package for memoization. It constructs a data array based on the props, which is passed to the ValidateMemoization component to validate the memoization logic. The snippet requires 'shared-runtime' as a dependency, with 'props.items' being the crucial parameter monitored for changes. The output is a React element rendered conditionally based on memoized data. This approach limits unnecessary renderings in React components.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/optional-member-expression-single-with-unconditional.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {ValidateMemoization} from 'shared-runtime';\nfunction Component(props) {\n  const data = useMemo(() => {\n    const x = [];\n    x.push(props?.items);\n    x.push(props.items);\n    return x;\n  }, [props.items]);\n  return <ValidateMemoization inputs={[props.items]} output={data} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Memoization\nDESCRIPTION: This snippet shows the compiled and optimized version of the React component. It uses memoization techniques to improve performance by caching values and only updating when necessary.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/function-expression-maybe-mutates-hook-return-value.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(4);\n  const id = useSelectedEntitytId();\n  let t0;\n  if ($[0] !== id) {\n    t0 = () => {\n      log(id);\n    };\n    $[0] = id;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const onLoad = t0;\n  let t1;\n  if ($[2] !== onLoad) {\n    t1 = <Foo onLoad={onLoad} />;\n    $[2] = onLoad;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  return t1;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Component with Hook - JavaScript\nDESCRIPTION: This snippet defines a React component that correctly utilizes a hook. It demonstrates the use of hooks within functional components in React, ensuring that components adhere to best practices when incorporating React hooks.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-1ff6c3fbbc94.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Valid because components can use hooks.\nfunction ComponentWithHook() {\n  useHook();\n}\n\n```\n\n----------------------------------------\n\nTITLE: Ternary Operator in React Component\nDESCRIPTION: This JavaScript code defines a React component named `ternary` that takes `props` as input. Inside the component, a ternary operator is used to conditionally assign values to the variable `x` based on the value of `props.a`. The component then returns the sum of `x` and `y`. The `FIXTURE_ENTRYPOINT` object exports the component and its configuration for testing or usage elsewhere.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ternary-assignment-expression.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction ternary(props) {\n  let x = 0;\n  const y = props.a ? (x = 1) : (x = 2);\n  return x + y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: ternary,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Memoization\nDESCRIPTION: This snippet illustrates a more complex version of the component using memoization to optimize rendering in React. It uses a custom cache sentinel to decide if it should create a new ref object or reuse an existing one. The input change handling and rendering are similarly structured, but the logic incorporates additional checks for memoization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ref-current-field-write-not-added-to-dep.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useRef } from \"react\";\n\nfunction Component() {\n  const $ = _c(2);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = { text: { value: null } };\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const ref = useRef(t0);\n  let t1;\n  if ($[1] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const inputChanged = (e) => {\n      ref.current.text.value = e.target.value;\n    };\n\n    t1 = <input onChange={inputChanged} />;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Handling Ref Access in React JavaScript Components\nDESCRIPTION: This JavaScript function demonstrates an issue when attempting to access the 'current' property of a ref during the rendering phase in a React component. It highlights an invalid access pattern, which can lead to runtime errors. The React 'useRef' hook is used here, and the function is expected to return a component with a ref applied to a 'Foo' element. No explicit inputs are required, apart from standard component props.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-ref-value-as-props.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validateRefAccessDuringRender\nfunction Component(props) {\n  const ref = useRef(null);\n  return <Foo ref={ref.current} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Original React Hook Implementation with Label Break Pattern\nDESCRIPTION: A custom React hook that conditionally adds data to an array. It uses a labeled block with a conditional break to control execution flow, and processes nested object properties.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-poisoned/break-poisons-outer-scope.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {identity} from 'shared-runtime';\n\nfunction useFoo({input, cond}) {\n  const x = [];\n  label: {\n    if (cond) {\n      break label;\n    }\n    x.push(identity(input.a.b));\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{input: {a: {b: 2}}, cond: false}],\n  sequentialRenders: [\n    {input: {a: {b: 2}}, cond: false},\n    // preserve nullthrows\n    {input: null, cond: false},\n    {input: null, cond: true},\n    {input: {}, cond: false},\n    {input: {a: {b: null}}, cond: false},\n    {input: {a: null}, cond: false},\n    {input: {a: {b: 3}}, cond: false},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Compiler-generated Memoization\nDESCRIPTION: This snippet shows the compiled and optimized version of the React component. It includes compiler-generated memoization logic using an array for caching, and demonstrates how React's compiler optimizes the original code for better performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-mixed-scope-and-local-variables-with-default.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { Stringify, graphql } from \"shared-runtime\";\n\nfunction useFragment(_arg1, _arg2) {\n  \"use no forget\";\n  return {\n    urls: [\"url1\", \"url2\", \"url3\"],\n    comments: [\"comment1\"],\n  };\n}\n\nfunction Component(props) {\n  const $ = _c(8);\n  const post = useFragment(\n    graphql`\n      fragment F on T {\n        id\n      }\n    `,\n    props.post,\n  );\n  let t0;\n  if ($[0] !== post) {\n    const allUrls = [];\n\n    const { media: t1, comments: t2, urls: t3 } = post;\n    const media = t1 === undefined ? null : t1;\n    let t4;\n    if ($[2] !== t2) {\n      t4 = t2 === undefined ? [] : t2;\n      $[2] = t2;\n      $[3] = t4;\n    } else {\n      t4 = $[3];\n    }\n    const comments = t4;\n    let t5;\n    if ($[4] !== t3) {\n      t5 = t3 === undefined ? [] : t3;\n      $[4] = t3;\n      $[5] = t5;\n    } else {\n      t5 = $[5];\n    }\n    const urls = t5;\n    let t6;\n    if ($[6] !== comments.length) {\n      t6 = (e) => {\n        if (!comments.length) {\n          return;\n        }\n\n        console.log(comments.length);\n      };\n      $[6] = comments.length;\n      $[7] = t6;\n    } else {\n      t6 = $[7];\n    }\n    const onClick = t6;\n\n    allUrls.push(...urls);\n    t0 = <Stringify media={media} allUrls={allUrls} onClick={onClick} />;\n    $[0] = post;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ post: {} }],\n  isComponent: true,\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Fixture for Component Testing\nDESCRIPTION: This snippet defines a fixture for testing the Component. It specifies the component function, initial parameters, and a sequence of renders with different prop combinations to test the component's behavior.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-provider-store-capture-namespace-import.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{a: 0, b: 0}],\n  sequentialRenders: [\n    {a: 0, b: 0},\n    {a: 1, b: 0},\n    {a: 1, b: 1},\n    {a: 1, b: 2},\n    {a: 2, b: 2},\n    {a: 3, b: 2},\n    {a: 0, b: 0},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimizing Property Mutations in React with JavaScript\nDESCRIPTION: Implements an optimized version of the useFoo function where it avoids unnecessary mutations by tracking previous property values. The code leverages react/compiler-runtime for improved dependency checks and efficient state management. It addresses property changes efficiently by reducing redundant operations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/ssa-renaming-unconditional-with-mutation.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enablePropagateDepsInHIR\nimport { mutate } from \"shared-runtime\";\n\nfunction useFoo(props) {\n  const $ = _c(4);\n  let x;\n  if ($[0] !== props.bar || $[1] !== props.cond || $[2] !== props.foo) {\n    x = [];\n    x.push(props.bar);\n    if (props.cond) {\n      x = [];\n      x.push(props.foo);\n    } else {\n      x = [];\n      x.push(props.bar);\n    }\n\n    mutate(x);\n    $[0] = props.bar;\n    $[1] = props.cond;\n    $[2] = props.foo;\n    $[3] = x;\n  } else {\n    x = $[3];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ bar: \"bar\", foo: \"foo\", cond: true }],\n  sequentialRenders: [\n    { bar: \"bar\", foo: \"foo\", cond: true },\n    { bar: \"bar\", foo: \"foo\", cond: true },\n    { bar: \"bar\", foo: \"foo\", cond: false },\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Component Definition with Reactive Props\nDESCRIPTION: This code defines a React component that reassigns a variable 'x' based on the reactive prop 'props.cond'. The assignment occurs within a function expression to create a context variable. The component returns 'x' wrapped in an array, treating 'x' as reactive due to its dependency on the reactive 'props.cond'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-on-context-variable.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {identity} from 'shared-runtime';\n\nfunction Component(props) {\n  let x;\n  // Reassign `x` based on a reactive value, but inside a function expression\n  // to make it a context variable\n  const f = () => {\n    if (props.cond) {\n      x = 1;\n    } else {\n      x = 2;\n    }\n  };\n  // Pass `f` through a function to prevent IIFE inlining optimizations\n  const f2 = identity(f);\n  f2();\n\n  // The values assigned to `x` are non-reactive, but the value of `x`\n  // depends on the \"control\" value `props.cond` which is reactive.\n  // Therefore x should be treated as reactive too.\n  return [x];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  sequentialRenders: [\n    {cond: true},\n    {cond: true},\n    {cond: false},\n    {cond: false},\n    {cond: true},\n    {cond: false},\n    {cond: true},\n    {cond: false},\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Error Handling for Invalid useMemo Usage\nDESCRIPTION: This snippet captures an error message that indicates the misuse of the useMemo hook with an async callback. The error message informs the developer that useMemo callbacks must not be asynchronous or generator functions.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-useMemo-async-callback.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n  1 | function component(a, b) {\n> 2 |   let x = useMemo(async () => {\n    |                   ^^^^^^^^^^^^^\n> 3 |     await a;\n    | ^^^^^^^^^^^^\n> 4 |   }, []);\n    | ^^^^ InvalidReact: useMemo callbacks may not be async or generator functions (2:4)\n  5 |   return x;\n  6 | }\n  7 |\n\n```\n\n----------------------------------------\n\nTITLE: Implementing FBT Localization in React Component\nDESCRIPTION: React component implementation showing FBT usage for text localization. The code demonstrates parameter interpolation for dynamic text but encounters an issue with local variable naming that conflicts with the FBT transform.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/error.todo-fbt-as-local.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport fbt from 'fbt';\nimport {identity} from 'shared-runtime';\n\n/**\n * Note that the fbt transform looks for callsites with a `fbt`-named callee.\n * This is incompatible with react-compiler as we rename local variables in\n * HIRBuilder + RenameVariables.\n *\n * See evaluator error:\n *   Found differences in evaluator results\n *   Non-forget (expected):\n *   (kind: ok) <div>Hello, Sathya!Goodbye, Sathya!</div>\n *   Forget:\n *   (kind: exception) fbt$0.param is not a function\n */\n\nfunction Foo(props) {\n  const getText1 = fbt =>\n    fbt(\n      `Hello, ${fbt.param('(key) name', identity(props.name))}!`,\n      '(description) Greeting'\n    );\n\n  const getText2 = fbt =>\n    fbt(\n      `Goodbye, ${fbt.param('(key) name', identity(props.name))}!`,\n      '(description) Greeting2'\n    );\n\n  return (\n    <div>\n      {getText1(fbt)}\n      {getText2(fbt)}\n    </div>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{name: 'Sathya'}],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing a Basic Host Config for a Custom React Renderer\nDESCRIPTION: Example of a minimal Host Config implementation that would be required for a custom renderer. Shows essential methods for creating instances and handling DOM-like mutations.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-reconciler/README.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst HostConfig = {\n  createInstance(type, props) {\n    // e.g. DOM renderer returns a DOM node\n  },\n  // ...\n  supportsMutation: true, // it works by mutating nodes\n  appendChild(parent, child) {\n    // e.g. DOM renderer would call .appendChild() here\n  },\n  // ...\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a Memoized React Component - JavaScript\nDESCRIPTION: This snippet demonstrates a memoized version of the React 'Component' using the 'react/compiler-runtime' library to enhance performance. It checks if the memoization cache is hit and accordingly returns the child component with the text prop. This snippet showcases advanced React techniques for optimizing component rendering.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/quoted-strings-jsx-attribute-escaped-constant-propagation.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nexport function Component() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = <Child text={'Some \"text\"'} />;\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nfunction Child(props) {\n  return props.text;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Invalid React Hook Usage Component\nDESCRIPTION: Example of incorrect hook usage where a hook is passed as a prop to a component. This violates React's rules of hooks as hooks must be the same function on every render.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-hook-as-prop.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component({useFoo}) {\n  useFoo();\n}\n\n```\n\nLANGUAGE: text\nCODE:\n```\n  1 | function Component({useFoo}) {\n> 2 |   useFoo();\n    |   ^^^^^^ InvalidReact: Hooks must be the same function on every render, but this value may change over time to a different function. See https://react.dev/reference/rules/react-calls-components-and-hooks#dont-dynamically-use-hooks (2:2)\n  3 | }\n  4 |\n\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: Simple React component using useState hook and defining a handler function to update state, rendered with a Foo component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/concise-arrow-expr.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component() {\n  let [x, setX] = useState(0);\n  const handler = v => setX(v);\n  return <Foo handler={handler}></Foo>;\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: Transformed version of the component with memoization logic added by the React compiler. Uses Symbol.for('react.memo_cache_sentinel') to implement caching of the generated session ID object.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/merge-consecutive-nested-scopes.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nconst { getNumber } = require(\"shared-runtime\");\n\nfunction Component(props) {\n  const $ = _c(1);\n  let x;\n  if (props.cond) {\n    let t0;\n    if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n      t0 = { session_id: getNumber() };\n      $[0] = t0;\n    } else {\n      t0 = $[0];\n    }\n    x = t0;\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ cond: true }],\n};\n```\n\n----------------------------------------\n\nTITLE: Initializing React Component with useRef Hook\nDESCRIPTION: This snippet defines a React component 'C' that uses the useRef hook to create a mutable reference. The component initializes the reference to 1 if it's null. It also includes Flow type annotations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-ref-initialization.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n//@flow\nimport {useRef} from 'react';\n\ncomponent C() {\n  const r = useRef(null);\n  if (r.current == null) {\n    r.current = 1;\n  }\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: C,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Compiler Runtime in JavaScript\nDESCRIPTION: This snippet shows the optimized version of the React component after compilation. It uses the React compiler runtime for performance improvements, including memoization of the Stringify component rendering.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/component-inner-function-with-many-args.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { Stringify } from \"shared-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  const cb = _temp;\n  let t0;\n  if ($[0] !== props.id) {\n    t0 = <Stringify cb={cb} id={props.id} />;\n    $[0] = props.id;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\nfunction _temp(x, y, z) {\n  return x + y + z;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ id: 0 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a Function in React Component - JavaScript\nDESCRIPTION: This snippet defines a React functional component named `Component`, which initializes a variable `x` and includes a nested function `foo` that modifies `x`. The component's return statement includes a child component `Child`, passing `y` as a prop, where `y` gets assigned the result of calling `bar` with `foo`. The snippet also highlights an error regarding the reassigning of variable `x`, suggesting the use of state instead.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.declare-reassign-variable-in-function-declaration.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component() {\n  let x = null;\n  function foo() {\n    x = 9;\n  }\n  const y = bar(foo);\n  return <Child y={y} />;\n}\n\n```\n\n----------------------------------------\n\nTITLE: React Component with Compiler Runtime\nDESCRIPTION: The `ValidComponent` utilizes the `react/compiler-runtime`'s `_c` function to memoize the rendered JSX based on the `greeting` prop. This optimization avoids unnecessary re-renders when the `greeting` prop remains the same. It imports `_c` from `react/compiler-runtime` and stores the previous greeting and rendered element for comparison.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/multiple-components-first-is-invalid.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @panicThreshold(none)\nimport { useHook } from \"shared-runtime\";\n\nfunction InvalidComponent(props) {\n  if (props.cond) {\n    useHook();\n  }\n  return <div>Hello World!</div>;\n}\n\nfunction ValidComponent(props) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== props.greeting) {\n    t0 = <div>{props.greeting}</div>;\n    $[0] = props.greeting;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Skip Build React Benchmarks\nDESCRIPTION: Runs benchmarks without rebuilding bundles, useful for local performance tweaking when remote bundles are already built\nSOURCE: https://github.com/facebook/react/blob/main/scripts/bench/README.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nyarn --cwd=../../ build react/index,react-dom/index --type=UMD_PROD && yarn start --skip-build\n```\n\n----------------------------------------\n\nTITLE: React Component with Memoization using compiler-runtime\nDESCRIPTION: This code defines a React component optimized with memoization using `react/compiler-runtime`. It aims to prevent unnecessary re-renders by caching the element based on the `width` prop. It uses `shared-runtime`'s `shallowCopy` function. The component checks if the `width` prop has changed, and only recreates the element if it has, storing the result in a cache for future use.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-freeze.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { shallowCopy } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(2);\n  let element;\n  if ($[0] !== props.width) {\n    const childprops = { style: { width: props.width } };\n    element = _jsx(\"div\", { childprops, children: '\"hello world\"' });\n    shallowCopy(childprops);\n    $[0] = props.width;\n    $[1] = element;\n  } else {\n    element = $[1];\n  }\n  return element;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}]\n};\n\n```\n\n----------------------------------------\n\nTITLE: Original React useMemo Implementation\nDESCRIPTION: Original implementation using React's useMemo hook to memoize the minimum value between two numbers. The hook prevents unnecessary recalculations by caching the result based on the dependency array.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useMemo-infer-nonallocating.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees\n\nimport {useMemo} from 'react';\n\n// It's correct to infer a useMemo value is non-allocating\n// and not provide it with a reactive scope\nfunction useFoo(num1, num2) {\n  return useMemo(() => Math.min(num1, num2), [num1, num2]);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [2, 3],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: Original React component that processes video items and generates thumbnails using useMemo hook. The component takes props with an item, processes base videos, and renders them in a FlatList component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const item = props.item;\n  const thumbnails = [];\n  const baseVideos = getBaseVideos(item);\n  useMemo(() => {\n    baseVideos.forEach(video => {\n      const baseVideo = video.hasBaseVideo;\n      if (Boolean(baseVideo)) {\n        thumbnails.push({extraVideo: true});\n      }\n    });\n  });\n  return <FlatList baseVideos={baseVideos} items={thumbnails} />;\n}\n```\n\n----------------------------------------\n\nTITLE: React Compiler-Transformed Component with Memoization\nDESCRIPTION: The compiler-transformed version of the component with added memoization logic. It uses React's compiler runtime to cache the result of shallowCopy when props haven't changed, avoiding unnecessary computation on re-renders while maintaining the console logging operations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/console-readonly.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { shallowCopy } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== props) {\n    t0 = shallowCopy(props);\n    $[0] = props;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const x = t0;\n\n  console.log(x);\n  console.info(x);\n  console.warn(x);\n  console.error(x);\n  console.trace(x);\n  console.table(x);\n  global.console.log(x);\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ a: 1, b: 2 }],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with useMemo\nDESCRIPTION: This React component uses `React.useState` to initialize a state variable `x` to 0. It then employs `React.useMemo` to calculate an `expensiveNumber` based on `x` using the `calculateExpensiveNumber` function from 'shared-runtime'. The component renders a div containing the calculated `expensiveNumber`.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/babel-existing-react-namespace-import.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as React from 'react';\nimport {calculateExpensiveNumber} from 'shared-runtime';\n\nfunction Component(props) {\n  const [x] = React.useState(0);\n  const expensiveNumber = React.useMemo(() => calculateExpensiveNumber(x), [x]);\n\n  return <div>{expensiveNumber}</div>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Building React and Setting Up SSR Fixtures\nDESCRIPTION: Instructions for building React locally and setting up the SSR fixtures environment. This requires running the build command in the React root directory followed by installing dependencies in the fixtures folder.\nSOURCE: https://github.com/facebook/react/blob/main/fixtures/ssr/README.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncd fixtures/ssr\nyarn\nyarn start\n```\n\n----------------------------------------\n\nTITLE: React useLayoutEffect with Unmemoized Dependency in JavaScript\nDESCRIPTION: This code defines a React component `Component` that uses the `useLayoutEffect` hook. The effect's dependency array includes a new object `{}` assigned to `data` within the component. This causes the effect to re-run on every render, as the object identity changes, which the React compiler flags as an unoptimized effect.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-useLayoutEffect-dep-not-memoized.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validateMemoizedEffectDependencies\nimport {useLayoutEffect} from 'react';\n\nfunction Component(props) {\n  const data = {};\n  useLayoutEffect(() => {\n    console.log(props.value);\n  }, [data]);\n  mutate(data);\n  return data;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Accessing React Context\nDESCRIPTION: This code snippet demonstrates how to access context values using the `useContext` hook in a functional React component. It retrieves `foo` and `bar` properties from the `MyContext` and passes them as props to the `Bar` component. The `@lowerContextAccess` comment likely indicates compiler optimizations related to context access.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/todo.lower-context-access-property-load.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @lowerContextAccess\nfunction App() {\n  const context = useContext(MyContext);\n  const foo = context.foo;\n  const bar = context.bar;\n  return <Bar foo={foo} bar={bar} />;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Original React Component with useMemo\nDESCRIPTION: A React functional component that uses useMemo to conditionally create and memoize an object based on a prop condition\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-if-else-multiple-return.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const x = useMemo(() => {\n    if (props.cond) {\n      return makeObject(props.a);\n    }\n    return makeObject(props.b);\n  });\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with useMemo Hook in JavaScript\nDESCRIPTION: This snippet defines a React component using the `useMemo` hook to cache computed data based on the `props.value`. It exports a constant `FIXTURE_ENTRYPOINT` to facilitate testing or integration, which includes the component function and relevant parameters. React library is a required dependency.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/drop-methodcall-usememo.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as React from 'react';\n\nfunction Component(props) {\n  const x = React.useMemo(() => {\n    const x = [];\n    x.push(props.value);\n    return x;\n  }, [props.value]);\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: 42}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Hook Definition: useFoo with Emit Freeze and Forget Instrumentation\nDESCRIPTION: This JavaScript code defines a React hook named `useFoo` that takes `props` as an argument and returns the result of calling the `foo` function with `props.x` and `__DEV__`. It is annotated with `@enableEmitFreeze` and `@instrumentForget`, suggesting it's part of a memoization or optimization process within a React component, likely using React's compiler.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/emit-freeze-nonconflicting-global-reference.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableEmitFreeze @instrumentForget\nfunction useFoo(props) {\n  return foo(props.x, __DEV__);\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing React Component with useMemo Hook\nDESCRIPTION: This snippet defines a React component that uses useMemo to memoize a computed value based on the 'value' prop. It includes error handling and null checks.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-unreachable-code-early-return-in-useMemo.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableAssumeHooksFollowRulesOfReact @enableTransitivelyFreezeFunctionExpressions\nimport {useMemo, useState} from 'react';\nimport {ValidateMemoization, identity} from 'shared-runtime';\n\nfunction Component({value}) {\n  const result = useMemo(() => {\n    if (value == null) {\n      return null;\n    }\n    try {\n      return {value};\n    } catch (e) {\n      return null;\n    }\n  }, [value]);\n  return <ValidateMemoization inputs={[value]} output={result} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: null}],\n  sequentialRenders: [\n    {value: null},\n    {value: null},\n    {value: 42},\n    {value: 42},\n    {value: null},\n    {value: 42},\n    {value: null},\n    {value: 42},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Function 'bar' with React Compiler Runtime in JavaScript\nDESCRIPTION: This snippet defines an enhanced version of the function 'bar' that utilizes React's compiler runtime. It initializes a state variable with 'a', checks its value, and either initializes a new object or retrieves an existing one. The function returns 'y' from its internal state management.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-alias-computed-load-iife.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction bar(a) {\n  const $ = _c(2);\n  let y;\n  if ($[0] !== a) {\n    const x = [a];\n    y = {};\n\n    y = x[0];\n    $[0] = a;\n    $[1] = y;\n  } else {\n    y = $[1];\n  }\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: bar,\n  params: [\"TodoAdd\"],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Custom React Hook with Input Properties\nDESCRIPTION: Implements a custom React hook called useMakeCallback that returns a callback function. The hook takes an object and setState function as parameters and returns a callback that updates state with the object's value.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/assume-invoked/return-function.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {createHookWrapper} from 'shared-runtime';\n\n/**\n * Assume that directly returned functions are invoked and that their property\n * loads are hoistable.\n */\nfunction useMakeCallback({\n  obj,\n  setState,\n}: {\n  obj: {value: number};\n  setState: (newState: number) => void;\n}) {\n  return () => setState(obj.value);\n}\n\nconst setState = (arg: number) => {\n  'use no memo';\n  return arg;\n};\nexport const FIXTURE_ENTRYPOINT = {\n  fn: createHookWrapper(useMakeCallback),\n  params: [{obj: {value: 1}, setState}],\n  sequentialRenders: [\n    {obj: {value: 1}, setState},\n    {obj: {value: 2}, setState},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Initial React Component Definition\nDESCRIPTION: This code defines a React component named `Component` that conditionally returns an array. If `props.cond` is true, it pushes `props.a` into an array and returns it. Otherwise, it returns an array created using `makeArray(props.b)`. The `FIXTURE_ENTRYPOINT` object provides configuration for testing and rendering the component sequentially with different props.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/early-return-within-reactive-scope.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {makeArray} from 'shared-runtime';\n\nfunction Component(props) {\n  let x = [];\n  if (props.cond) {\n    x.push(props.a);\n    // oops no memo!\n    return x;\n  } else {\n    return makeArray(props.b);\n  }\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  sequentialRenders: [\n    // pattern 1\n    {cond: true, a: 42},\n    {cond: true, a: 42},\n    // pattern 2\n    {cond: false, b: 3.14},\n    {cond: false, b: 3.14},\n    // pattern 1\n    {cond: true, a: 42},\n    // pattern 2\n    {cond: false, b: 3.14},\n    // pattern 1\n    {cond: true, a: 42},\n    // pattern 2\n    {cond: false, b: 3.14},\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining App Component with React Context\nDESCRIPTION: This snippet shows a basic React functional component (App) that uses the useContext hook to access values from MyContext. It renders a Bar component with the extracted context values.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/lower-context-access-hook-guard.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @lowerContextAccess @enableEmitHookGuards\nfunction App() {\n  const {foo} = useContext(MyContext);\n  const {bar} = useContext(MyContext);\n  return <Bar foo={foo} bar={bar} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing useRef current Property During Render in React\nDESCRIPTION: This JavaScript code demonstrates an error case where a ref's current property is accessed during component rendering. The code initializes a ref with useRef, conditionally sets its value, and then tries to use the ref value in a way that violates React's rules about accessing ref.current during render.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.ref-initialization-post-access-2.expect.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n//@flow\nimport {useRef} from 'react';\n\ncomponent C() {\n  const r = useRef(null);\n  if (r.current == null) {\n    r.current = 1;\n  }\n  f(r.current);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: C,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Using Cached Value in useFoo - JavaScript\nDESCRIPTION: This version of 'useFoo' enhances the previous implementation by introducing caching logic with the React compiler runtime. It checks if a cached value exists before calling 'getNumber', storing the result for future calls. This approach improves performance by reducing unnecessary calls to the shared runtime function, while still accounting for errors in the process. The function is still set up to be exported as a fixture, maintaining the same structure.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/empty-catch-statement.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { getNumber } from \"shared-runtime\";\n\nfunction useFoo() {\n  const $ = _c(1);\n  try {\n    let t0;\n    if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n      t0 = getNumber();\n      $[0] = t0;\n    } else {\n      t0 = $[0];\n    }\n    return t0;\n  } catch {}\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Original Invalid React Component Definition\nDESCRIPTION: A React function component that incorrectly defines another component function inside its render body, which violates React's best practices as components created during render will reset their state on each render.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/static-components/invalid-dynamically-constructed-component-function.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @logger @validateStaticComponents\nfunction Example(props) {\n  function Component() {\n    return <div />;\n  }\n  return <Component />;\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying Improved DevTools Editing Interface in Markdown\nDESCRIPTION: Demonstrates the improved parsing and editing capabilities for arrays and objects in React DevTools using GIF images.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/CHANGELOG.md#2025-04-21_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n###### Improved DevTools editing interface\n\n**Improved parsing**\nValue parsing logic has been relaxed so as to no longer require quotes around strings or double quotes:\n![looser parsing logic](https://user-images.githubusercontent.com/29597/93407442-36504300-f860-11ea-90e8-5ad54c9b8b34.gif)\n\n**Modifying arrays**\nNew values can be added to array props/state/hooks now. Existing values can also be deleted:\n![adding and removing values from an array](https://user-images.githubusercontent.com/29597/93407457-3ea87e00-f860-11ea-8b85-a41904e6c25f.gif)\n\n**Modifying objects**\nNew keys can be added to object props/state/hooks now. Existing keys can be renamed or deleted entirely:\n![adding/renaming/removing object properties](https://user-images.githubusercontent.com/29597/93407464-449e5f00-f860-11ea-909b-49dafb56f6c5.gif)\n```\n\n----------------------------------------\n\nTITLE: React Component Definition (Input)\nDESCRIPTION: Defines a simple React component named `Component` that takes `props` as input. It creates a `MaybeMutable` object and renders a `div` containing the result of calling `maybeMutate` with the `MaybeMutable` object. This snippet represents the initial, unoptimized component definition.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/builtin-jsx-tag-lowered-between-mutations.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const maybeMutable = new MaybeMutable();\n  return <div>{maybeMutate(maybeMutable)}</div>;\n}\n```\n\n----------------------------------------\n\nTITLE: Opting Out of Automatic Batching in React 18\nDESCRIPTION: Method to opt out of the new automatic batching behavior in React 18 for specific state updates.\nSOURCE: https://github.com/facebook/react/blob/main/CHANGELOG.md#2025-04-21_snippet_12\n\nLANGUAGE: javascript\nCODE:\n```\nflushSync\n```\n\n----------------------------------------\n\nTITLE: Input React Component with useCallback\nDESCRIPTION: Original React component implementation using useCallback and useRef hooks to handle input changes. The component demonstrates memoization behavior with the @enablePreserveExistingMemoizationGuarantees flag.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useCallback-set-ref-value-dont-preserve-memoization.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enablePreserveExistingMemoizationGuarantees\nimport {useCallback, useRef} from 'react';\n\nfunction Component(props) {\n  const ref = useRef(null);\n\n  const onChange = useCallback(event => {\n    // The ref should still be mutable here even though function deps are frozen in\n    // @enablePreserveExistingMemoizationGuarantees mode\n    ref.current = event.target.value;\n  });\n\n  return <input onChange={onChange} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Measuring Rendering Time - React - JavaScript\nDESCRIPTION: This snippet defines a simple React component that measures the time taken for rendering by capturing the start time and calculating the difference when rendering is complete. It returns a div that displays the rendering time along with the current timestamp.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/timers.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const start = performance.now();\n  const now = Date.now();\n  const time = performance.now() - start;\n  return (\n    <div>\n      rendering took {time} at {now}\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: React Compiler-Optimized useFoo Hook with Automatic Memoization\nDESCRIPTION: The transformed version of the useFoo hook after React Compiler processing. It adds automatic memoization to cache the callback function and results when inputs haven't changed, using an array $ for storing memoized values and dependency tracking.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/bug-invalid-array-map-manual.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction useFoo(t0) {\n  const $ = _c(5);\n  const { arr1, arr2 } = t0;\n  let t1;\n  if ($[0] !== arr2[0].value) {\n    t1 = (e) => arr2[0].value + e.value;\n    $[0] = arr2[0].value;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  const cb = t1;\n  let y;\n  if ($[2] !== arr1 || $[3] !== cb) {\n    y = [];\n    for (let i = 0; i < arr1.length; i++) {\n      y.push(cb(arr1[i]));\n    }\n    $[2] = arr1;\n    $[3] = cb;\n    $[4] = y;\n  } else {\n    y = $[4];\n  }\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ arr1: [], arr2: [] }],\n  sequentialRenders: [\n    { arr1: [], arr2: [] },\n    { arr1: [], arr2: null },\n    { arr1: [{ value: 1 }, { value: 2 }], arr2: [{ value: -1 }] },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Using useMemo in React Functional Components - JavaScript\nDESCRIPTION: Demonstrates the creation of React functional components using the `useMemo` hook to cache expensive calculations depending on state `x`. This optimization ensures that expensive computations are only recalculated when necessary dependencies change. Dependencies include `useState` and `calculateExpensiveNumber`. The input is a React component property, and the output is a rendered component where the calculation reflects the latest state value.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/babel-existing-react-import.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport {useState, useMemo} from 'react';\n\nfunction Component(props) {\n  const [x] = useState(0);\n  const expensiveNumber = useMemo(() => calculateExpensiveNumber(x), [x]);\n\n  return <div>{expensiveNumber}</div>;\n}\n\nfunction Component2(props) {\n  const [x] = useState(0);\n  const expensiveNumber = useMemo(() => calculateExpensiveNumber(x), [x]);\n\n  return <div>{expensiveNumber}</div>;\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Optimization\nDESCRIPTION: Compiled version of the React component with added optimization using memoization through array-based caching. The compiler introduces variables to track prop changes and memoize callback creation and execution.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-within-function-expression-returns-caught-value.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { throwInput } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(4);\n  let t0;\n  if ($[0] !== props) {\n    t0 = () => {\n      try {\n        throwInput([props.value]);\n      } catch (t1) {\n        const e = t1;\n        return e;\n      }\n    };\n    $[0] = props;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const callback = t0;\n  let t1;\n  if ($[2] !== callback) {\n    t1 = callback();\n    $[2] = callback;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ value: 42 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Component with Inner Function\nDESCRIPTION: A JavaScript function component that contains an inner function get2() which returns a constant value of 2\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-hoist-function-decls.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component() {\n  return get2();\n  function get2() {\n    return 2;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: React Component Compiled Output\nDESCRIPTION: Compiled version of the React component with added memoization logic. Uses compiler runtime utilities and implements caching mechanism to avoid unnecessary re-renders when props.value hasn't changed.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/mutation-during-jsx-construction.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { identity, mutate, mutateAndReturnNewValue } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(2);\n  let element;\n  if ($[0] !== props.value) {\n    const key = {};\n\n    element = <div key={mutateAndReturnNewValue(key)}>{props.value}</div>;\n\n    mutate(key);\n    $[0] = props.value;\n    $[1] = element;\n  } else {\n    element = $[1];\n  }\n  return element;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ value: 42 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Optimized Rendering in JavaScript\nDESCRIPTION: This snippet shows the compiled version of the React component with optimized rendering. It includes runtime imports and uses a caching mechanism to prevent unnecessary re-renders of the component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/meta-isms/repro-cx-namespace-assigned-to-temporary.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @compilationMode(infer) @enableAssumeHooksFollowRulesOfReact:false @customMacros(cx)\nimport { identity } from \"shared-runtime\";\n\nconst DARK = \"dark\";\n\nfunction Component() {\n  const $ = _c(2);\n  const theme = useTheme();\n\n  const t0 = cx.foo({\n    \"styles/light\": true,\n    \"styles/dark\": identity([theme.getTheme()]),\n  });\n  let t1;\n  if ($[0] !== t0) {\n    t1 = <div className={t0} />;\n    $[0] = t0;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n\nconst cx = {\n  foo(obj) {\n    const classes = [];\n    for (const [key, value] of Object.entries(obj)) {\n      if (value) {\n        classes.push(key);\n      }\n    }\n    return classes.join(\" \");\n  },\n};\n\nfunction useTheme() {\n  return {\n    getTheme() {\n      return DARK;\n    },\n  };\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: A React component that creates an array of mixed values, filters for non-empty strings, and joins them to create a className. Uses makeArray utility and custom string filtering logic.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/meta-isms/repro-cx-namespace-nesting.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {makeArray} from 'shared-runtime';\n\nfunction Component() {\n  const items = makeArray('foo', 'bar', '', null, 'baz', false, 'merp');\n  const classname = cx.namespace(...items.filter(isNonEmptyString));\n  return <div className={classname}>Ok</div>;\n}\n\nfunction isNonEmptyString(s) {\n  return typeof s === 'string' && s.trim().length !== 0;\n}\n\nconst cx = {\n  namespace(...items) {\n    return items.join(' ');\n  },\n};\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing a React Component with Switch Statement Logic\nDESCRIPTION: A React functional component that processes input props through a switch statement. The component stores props.a in an array, initializes x with props.b, and potentially updates x to props.d if props.c matches the array containing props.a.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/escape-analysis-not-switch-case.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const a = [props.a];\n  let x = props.b;\n  switch (props.c) {\n    case a: {\n      x = props.d;\n    }\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: Simple React component implementation with an ErrorView component that renders errors using Stringify, wrapped in Foo and Bar components.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/multi-arrow-expr-export-default-gating-test.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @gating\nimport {Stringify} from 'shared-runtime';\n\nconst ErrorView = (error, _retry) => <Stringify error={error}></Stringify>;\n\nexport default props => (\n  <Foo>\n    <Bar></Bar>\n    <ErrorView></ErrorView>\n  </Foo>\n);\n```\n\n----------------------------------------\n\nTITLE: Client Reference Examples with 'use client' Directive\nDESCRIPTION: Two examples of client references using the 'use client' directive. The first exports a simple function to be used on the client, and the second exports a client component. These are references that will be loaded on the client rather than executed on the server.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-server/README.md#2025-04-21_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n'use client'\n\nexport function alert(message) {\n  alert(message)\n}\n```\n\nLANGUAGE: jsx\nCODE:\n```\n'use client'\n\nexport function ClientComp({ onClick, message }) {\n  return <button onClick={onClick}>Alert</button>\n}\n```\n\n----------------------------------------\n\nTITLE: Prepare Experimental Release from CI Script\nDESCRIPTION: This script prepares an experimental release by downloading build artifacts from CI. It's similar to preparing a 'next' release, but uses the `-r experimental` flag to specify the experimental release channel. This ensures that the correct build artifacts with experimental features enabled are used.\nSOURCE: https://github.com/facebook/react/blob/main/scripts/release/README.md#2025-04-21_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nscripts/release/prepare-release-from-ci.js -r experimental --commit=0e526bc\n```\n\n----------------------------------------\n\nTITLE: React Hook Source Implementation\nDESCRIPTION: Original source code for a React hook that uses useMemo to memoize two values derived from input parameters. Takes an object with 'a' and 'b' properties and returns them in processed form.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/consecutive-use-memo.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useMemo} from 'react';\nimport {identity} from 'shared-runtime';\n\nfunction useHook({a, b}) {\n  const valA = useMemo(() => identity({a}), [a]);\n  const valB = useMemo(() => identity([b]), [b]);\n  return [valA, valB];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useHook,\n  params: [{a: 2, b: 3}],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with FBT Parameter - Source\nDESCRIPTION: Source code showing a React component using FBT JSX syntax for internationalization. Includes parameter interpolation with text prop and percentage symbol.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbtparam-with-jsx-fragment-value.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport fbt from 'fbt';\nimport {identity} from 'shared-runtime';\n\nfunction Component(props) {\n  return (\n    <Foo\n      value={\n        <fbt desc=\"Description of the parameter\">\n          <fbt:param name=\"value\">{<>{identity(props.text)}</>}</fbt:param>%\n        </fbt>\n      }\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using Memoization and Conditional Rendering in a React Component - JavaScript\nDESCRIPTION: This snippet showcases an advanced implementation of a React functional component using memoization. The component, 'Component', incorporates the 'react/compiler-runtime' for memoization of the component's output based on props. It initializes a memoized value and leverages optional function calls to decide how to render JSX based on the props received.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-call-with-independently-memoizable-arg.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== props) {\n    const x = makeOptionalFunction(props);\n\n    t0 = x?.(\n      <div>\n        <span>{props.text}</span>\n      </div>,\n    );\n    $[0] = props;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const y = t0;\n  return y;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing React Components with Different Memoization Strategies\nDESCRIPTION: This snippet defines four React components (ComponentA, ComponentB, ComponentC, and ComponentD) that demonstrate different approaches to handling props and memoization. Each component has a unique behavior regarding how props.b influences the component's output.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/conditional-early-return.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n/**\n * props.b does *not* influence `a`\n */\nfunction ComponentA(props) {\n  const a_DEBUG = [];\n  a_DEBUG.push(props.a);\n  if (props.b) {\n    return null;\n  }\n  a_DEBUG.push(props.d);\n  return a_DEBUG;\n}\n\n/**\n * props.b *does* influence `a`\n */\nfunction ComponentB(props) {\n  const a = [];\n  a.push(props.a);\n  if (props.b) {\n    a.push(props.c);\n  }\n  a.push(props.d);\n  return a;\n}\n\n/**\n * props.b *does* influence `a`, but only in a way that is never observable\n */\nfunction ComponentC(props) {\n  const a = [];\n  a.push(props.a);\n  if (props.b) {\n    a.push(props.c);\n    return null;\n  }\n  a.push(props.d);\n  return a;\n}\n\n/**\n * props.b *does* influence `a`\n */\nfunction ComponentD(props) {\n  const a = [];\n  a.push(props.a);\n  if (props.b) {\n    a.push(props.c);\n    return a;\n  }\n  a.push(props.d);\n  return a;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: ComponentA,\n  params: [{a: 1, b: false, d: 3}],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Hook with Optional Chaining in React\nDESCRIPTION: This snippet defines a custom hook 'useFoo' that handles multiple props with optional chaining and nullish coalescing. It demonstrates complex prop handling and type definitions for null and object types.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/nested-optional-chains.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {identity} from 'shared-runtime';\n\n/**\n * identity(...)?.toString() is the outer optional, and prop?.value is the inner\n * one.\n * Note that prop?.\n */\nfunction useFoo({\n  prop1,\n  prop2,\n  prop3,\n  prop4,\n  prop5,\n  prop6,\n}: {\n  prop1: null | {value: number};\n  prop2: null | {inner: {value: number}};\n  prop3: null | {fn: (val: any) => NonNullable<object>};\n  prop4: null | {inner: {value: number}};\n  prop5: null | {fn: (val: any) => NonNullable<object>};\n  prop6: null | {inner: {value: number}};\n}) {\n  // prop1?.value should be hoisted as the dependency of x\n  const x = identity(prop1?.value)?.toString();\n\n  // prop2?.inner.value should be hoisted as the dependency of y\n  const y = identity(prop2?.inner.value)?.toString();\n\n  // prop3 and prop4?.inner should be hoisted as the dependency of z\n  const z = prop3?.fn(prop4?.inner.value).toString();\n\n  // prop5 and prop6?.inner should be hoisted as the dependency of zz\n  const zz = prop5?.fn(prop6?.inner.value)?.toString();\n  return [x, y, z, zz];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [\n    {\n      prop1: null,\n      prop2: null,\n      prop3: null,\n      prop4: null,\n      prop5: null,\n      prop6: null,\n    },\n  ],\n  sequentialRenders: [\n    {\n      prop1: null,\n      prop2: null,\n      prop3: null,\n      prop4: null,\n      prop5: null,\n      prop6: null,\n    },\n    {\n      prop1: {value: 2},\n      prop2: {inner: {value: 3}},\n      prop3: {fn: identity},\n      prop4: {inner: {value: 4}},\n      prop5: {fn: identity},\n      prop6: {inner: {value: 4}},\n    },\n    {\n      prop1: {value: 2},\n      prop2: {inner: {value: 3}},\n      prop3: {fn: identity},\n      prop4: {inner: {value: 4}},\n      prop5: {fn: identity},\n      prop6: {inner: {value: undefined}},\n    },\n    {\n      prop1: {value: 2},\n      prop2: {inner: {value: undefined}},\n      prop3: {fn: identity},\n      prop4: {inner: {value: undefined}},\n      prop5: {fn: identity},\n      prop6: {inner: {value: undefined}},\n    },\n    {\n      prop1: {value: 2},\n      prop2: {},\n      prop3: {fn: identity},\n      prop4: {},\n      prop5: {fn: identity},\n      prop6: {inner: {value: undefined}},\n    },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component Source Implementation\nDESCRIPTION: Source implementation of a React component demonstrating memoization patterns with module-level state variables. Uses useState and useMemo hooks with a module-level counter to test memoization behavior during fast refresh.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fast-refresh-refresh-on-const-changes-dev.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @compilationMode(infer) @enableResetCacheOnSourceFileChanges\nimport {useEffect, useMemo, useState} from 'react';\nimport {ValidateMemoization} from 'shared-runtime';\n\nlet pretendConst = 0;\n\nfunction unsafeResetConst() {\n  pretendConst = 0;\n}\n\nfunction unsafeUpdateConst() {\n  pretendConst += 1;\n}\n\nfunction Component() {\n  useState(() => {\n    // unsafe: reset the constant when first rendering the instance\n    unsafeResetConst();\n  });\n  // UNSAFE! changing a module variable that is read by a component is normally\n  // unsafe, but in this case we're simulating a fast refresh between each render\n  unsafeUpdateConst();\n\n  // TODO: In fast refresh mode (@enableResetCacheOnSourceFileChanges) Forget should\n  // reset on changes to globals that impact the component/hook, effectively memoizing\n  // as if value was reactive. However, we don't want to actually treat globals as\n  // reactive (though that would be trivial) since it could change compilation too much\n  // btw dev and prod. Instead, we should reset the cache via a secondary mechanism.\n  const value = useMemo(() => [{pretendConst}], [pretendConst]);\n\n  return <ValidateMemoization inputs={[pretendConst]} output={value} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n  sequentialRenders: [{}, {}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a React Component in JavaScript\nDESCRIPTION: Defines a React functional component using useState to manage state and useCallback for memoizing the increment function. The component renders a Foo element that triggers the increment function on click.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/use-callback-simple.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component() {\n  const [count, setCount] = useState(0);\n  const increment = useCallback(() => setCount(count + 1));\n\n  return <Foo onClick={increment}></Foo>;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Optimized Conditional Computation in React Component (JavaScript)\nDESCRIPTION: This snippet implements the same Component using the React compiler-runtime to handle memoization through a custom mechanism. It tracks previous props using an internal array to determine when the values should be recalculated, improving performance in more complex scenarios. This version retains the same input and output structure as the previous snippet but is optimized for React's reconciliation process. It includes additional handling for maintaining internal state across renders, aiming to minimize unnecessary computations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/useMemo-multiple-if-else.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enablePropagateDepsInHIR\nimport { useMemo } from \"react\";\n\nfunction Component(props) {\n  const $ = _c(6);\n  let t0;\n  bb0: {\n    let y;\n    if (\n      $[0] !== props.a ||\n      $[1] !== props.b ||\n      $[2] !== props.cond ||\n      $[3] !== props.cond2\n    ) {\n      y = [];\n      if (props.cond) {\n        y.push(props.a);\n      }\n      if (props.cond2) {\n        t0 = y;\n        break bb0;\n      }\n\n      y.push(props.b);\n      $[0] = props.a;\n      $[1] = props.b;\n      $[2] = props.cond;\n      $[3] = props.cond2;\n      $[4] = y;\n      $[5] = t0;\n    } else {\n      y = $[4];\n      t0 = $[5];\n    }\n    t0 = y;\n  }\n  const x = t0;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ a: 1, b: 2, cond2: false }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiled Output of useFoo Function with Memoization\nDESCRIPTION: The React compiler-optimized version of useFoo that implements memoization using a cache array with sentinel values. It caches both object creation and the resulting array, preventing unnecessary recalculations when inputs haven't changed.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/todo-merge-ssa-phi-access-nodes.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport {\n  identity,\n  makeObject_Primitives,\n  setPropertyByKey,\n} from \"shared-runtime\";\n\n/**\n * A bit of an edge case, but we could further optimize here by merging\n * re-orderability of nodes across phis.\n */\nfunction useFoo(cond) {\n  const $ = _c(5);\n  let x;\n  if (cond) {\n    if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n      x = {};\n      setPropertyByKey(x, \"a\", { b: 2 });\n      $[0] = x;\n    } else {\n      x = $[0];\n    }\n\n    Math.max(x.a.b, 0);\n  } else {\n    if ($[1] === Symbol.for(\"react.memo_cache_sentinel\")) {\n      x = makeObject_Primitives();\n      setPropertyByKey(x, \"a\", { b: 3 });\n      $[1] = x;\n    } else {\n      x = $[1];\n    }\n\n    Math.max(x.a.b, 0);\n  }\n  let y;\n  if ($[2] !== cond || $[3] !== x) {\n    y = [];\n    if (identity(cond)) {\n      y.push(x.a.b);\n    }\n    $[2] = cond;\n    $[3] = x;\n    $[4] = y;\n  } else {\n    y = $[4];\n  }\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [true],\n};\n```\n\n----------------------------------------\n\nTITLE: Initializing React Component in JavaScript\nDESCRIPTION: The function 'Component' is a simple React component that receives props and returns a JSX element. It formats the numeric property 'x' using 'toFixed' and renders it within a 'div'. The export 'FIXTURE_ENTRYPOINT' contains the component function and a sample parameter object for testing. There are no external dependencies besides basic React JSX functionality.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ignore-use-no-forget.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @ignoreUseNoForget\nfunction Component(prop) {\n  'use no forget';\n  const result = prop.x.toFixed();\n  return <div>{result}</div>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{x: 1}],\n};\n```\n\n----------------------------------------\n\nTITLE: Destructuring Data Attribute in React Function\nDESCRIPTION: This snippet defines a function 'foo' that uses object destructuring to extract a 'data-foo-bar' attribute from its parameter. It then returns this value, demonstrating how to handle data attributes in React components.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructure-param-string-literal-key-invalid-identifier.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo({'data-foo-bar': dataTestID}) {\n  return dataTestID;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [{'data-foo-bar': {}}],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Hook Usage Rules in JavaScript\nDESCRIPTION: This code snippet defines a function that improperly uses a hook inside a normal function, violating React's rules about hooks. It is used to illustrate cases that should be flagged as invalid to maintain the integrity of hook usage across the application.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.invalid.invalid-rules-of-hooks-c59788ef5676.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @skip\n// Passed but should have failed\n\n// Currently invalid because it violates the convention and removes the \"taint\"\n// from a hook. We *could* make it valid to avoid some false positives but let's\n// ensure that we don't break the \"renderItem\" and \"normalFunctionWithConditionalHook\"\n// cases which must remain invalid.\nfunction normalFunctionWithHook() {\n  useHookInsideNormalFunction();\n}\n\n```\n\n----------------------------------------\n\nTITLE: Conditional Logic in React Component - JavaScript\nDESCRIPTION: This snippet defines a React component that takes props to determine the value of 'x' based on several conditions. It processes the props and sets 'x' according to the values provided. Additionally, it constructs a FIXTURE_ENTRYPOINT containing the component function and metadata for possible integration.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reverse-postorder.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let x;\n  if (props.cond) {\n    switch (props.test) {\n      case 0: {\n        x = props.v0;\n        break;\n      }\n      case 1: {\n        x = props.v1;\n        break;\n      }\n      case 2: {\n      }\n      default: {\n        x = props.v2;\n      }\n    }\n  } else {\n    if (props.cond2) {\n      x = props.b;\n    } else {\n      x = props.c;\n    }\n  }\n  x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Reactive Store Implementation in React Component\nDESCRIPTION: Utilizes a custom reactive store to manage component state through the React `compiler-runtime`. It represents a variation of managing component reactivity by incorporating runtime-specific optimizations, potentially for memoization or state caching. Dependencies include the `react/compiler-runtime` module for accessing `_c`. Input is through props while outputs handle a reactive state store managed via the `$` symbol. The logic further iterates over an array and checks reactivity through conditional caching.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-from-interleaved-reactivity-for-init.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(1);\n\n  const a = [];\n  const b = [];\n  b.push(props.cond);\n  a.push(0);\n\n  const c = [a];\n\n  let x;\n  for (let i = c[0][0]; i < 10; i++) {\n    x = 1;\n  }\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = [x];\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ cond: true }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Optimized useFoo React Hook with Compiler Runtime in JavaScript\nDESCRIPTION: This snippet shows an optimized version of the useFoo hook using React's compiler runtime. It implements memoization to avoid unnecessary computations and object creations. The optimization includes caching of previous inputs and outputs using an array managed by the compiler runtime.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructure-in-branch-ssa.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction useFoo(props) {\n  const $ = _c(9);\n\n  let x = null;\n  let y = null;\n  let z;\n  let myList;\n  if ($[0] !== props) {\n    myList = [];\n    if (props.doDestructure) {\n      ({ x, y, z } = props);\n\n      myList.push(z);\n    }\n    $[0] = props;\n    $[1] = myList;\n    $[2] = x;\n    $[3] = y;\n    $[4] = z;\n  } else {\n    myList = $[1];\n    x = $[2];\n    y = $[3];\n    z = $[4];\n  }\n  let t0;\n  if ($[5] !== myList || $[6] !== x || $[7] !== y) {\n    t0 = { x, y, myList };\n    $[5] = myList;\n    $[6] = x;\n    $[7] = y;\n    $[8] = t0;\n  } else {\n    t0 = $[8];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ x: \"hello\", y: \"world\", doDestructure: true }],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with fire function\nDESCRIPTION: This code defines a React component that uses the 'fire' function to execute a function 'foo' on every render. The 'foo' function logs the value of the 'prop1' prop. The useEffect hook is used to call 'fire' with the result of 'foo(prop1)'. Also, the prop1.value is being incremented on every render.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/bailout-retry/bailout-validate-prop-write.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableFire @panicThreshold(none)\nimport {fire} from 'react';\n\nfunction Component({prop1}) {\n  const foo = () => {\n    console.log(prop1);\n  };\n  useEffect(() => {\n    fire(foo(prop1));\n  });\n  prop1.value += 1;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with Reactive Scope Behavior in JavaScript\nDESCRIPTION: This code defines a React component that demonstrates reactive scope behavior. It creates objects, uses hooks, and manipulates values to test how React assigns and merges scopes during reconciliation. The component is designed to show how value mutations are handled within the same reactive scope.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-invalid-scope-merging-value-blocks.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {\n  CONST_TRUE,\n  identity,\n  makeObject_Primitives,\n  mutateAndReturn,\n  useHook,\n} from \"shared-runtime\";\n\n/**\n * value and `mutateAndReturn(value)` should end up in the same reactive scope.\n * (1) `value = makeObject` and `(temporary) = mutateAndReturn(value)` should be assigned\n * the same scope id (on their identifiers)\n * (2) alignScopesToBlockScopes should expand the scopes of both `(temporary) = identity(1)`\n * and `(temporary) = mutateAndReturn(value)` to the outermost value block boundaries\n * (3) mergeOverlappingScopes should merge the scopes of the above two instructions\n */\nfunction Component(t0) {\n  const value = makeObject_Primitives();\n  useHook();\n  const mutatedValue =\n    identity(1) && CONST_TRUE ? mutateAndReturn(value) : null;\n  const result = [];\n  useHook();\n  result.push(value, mutatedValue);\n  return result;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n  sequentialRenders: [{}, {}, {}],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with useContext Mutation\nDESCRIPTION: This React component attempts to modify the value obtained from `useContext` within the `onClick` handler.  This is an anti-pattern because context values should be updated using state management techniques or by dispatching actions to a reducer. The `FooContext` is directly mutated, which is flagged as an invalid operation in React.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-mutate-context-in-callback.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const FooContext = useContext(Foo);\n  // This function should be memoized, but its mutable range is entangled\n  // with the useContext call. We can't memoize hooks, therefore the\n  // reactive scope around the hook + callback is pruned and we're left\n  // w no memoization of the callback.\n  //\n  // Ideally we'd determine that this isn't called during render and can\n  // therefore be considered \"immutable\" or otherwise safe to memoize\n  // independently\n  const onClick = () => {\n    FooContext.current = true;\n  };\n  return <div onClick={onClick} />;\n}\n\n```\n\n----------------------------------------\n\nTITLE: React Component Definition\nDESCRIPTION: This code defines a simple React component that takes `props` as input, calls the `bar()` and `foo()` functions, and returns an object containing `items` and `count`. It represents the initial state of the component before any compiler optimizations are applied.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactivity-analysis-reactive-via-mutation-of-property-load.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const items = bar();\n  mutate(items.a, props.a);\n\n  const count = foo(items.length + 1);\n\n  return {items, count};\n}\n```\n\n----------------------------------------\n\nTITLE: Using React Compiler Runtime in a Memoized Component\nDESCRIPTION: This snippet imports the React compiler runtime and defines a memoized component that processes cached values. It demonstrates the use of memoization in function components and the handling of special characters in JSX.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-html-entity.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = <div>{\"<span &\"}</div>;\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Managing Reactive Ref in React Component - JavaScript\nDESCRIPTION: This snippet demonstrates the use of the useRef hook along with forwardRef in React to manage reactive values. It includes a Parent component that conditionally uses reactive references and a Child component implemented using forwardRef. The system uses the shared-runtime's Stringify component for some of its functional requirements. The fixture entry point defined establishes different renders based on conditional values. Key dependencies are react and shared-runtime packages.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-ref-param.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useRef, forwardRef} from 'react';\nimport {Stringify} from 'shared-runtime';\n\n/**\n * Fixture showing that Ref types may be reactive.\n * We should always take a dependency on ref values (the outer box) as\n * they may be reactive. Pruning should be done in\n * `pruneNonReactiveDependencies`\n */\n\nfunction Parent({cond}) {\n  const ref1 = useRef(1);\n  const ref2 = useRef(2);\n  const ref = cond ? ref1 : ref2;\n  return <Child ref={ref} />;\n}\n\nfunction ChildImpl(_props, ref) {\n  const cb = () => ref.current;\n  return <Stringify cb={cb} shouldInvokeFns={true} />;\n}\n\nconst Child = forwardRef(ChildImpl);\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Parent,\n  params: [{cond: true}],\n  sequentialRenders: [{cond: true}, {cond: false}],\n};\n```\n\n----------------------------------------\n\nTITLE: Validating Ref Access During Render in React - JavaScript\nDESCRIPTION: This code defines a functional component that attempts to access a ref's current value during the render cycle. It demonstrates the improper usage of React's `useRef` hook by modifying the `current` property, which is against React's rules and results in an error. The error indicates that accessing ref values in this way is invalid and directs to the React documentation for more information on proper usage.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-set-and-read-ref-during-render.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validateRefAccessDuringRender\nfunction Component(props) {\n  const ref = useRef(null);\n  ref.current = props.value;\n  return ref.current;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Configuring a Sandboxed `iframe` (Frontend)\nDESCRIPTION: This JavaScript snippet configures the React DevTools frontend to communicate with a sandboxed iframe's backend.  It initializes the frontend and then posts a message to the iframe to activate the backend once the iframe is loaded. This indirect activation is required due to the sandboxed environment's restrictions.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools-inline/README.md#2025-04-21_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nimport { initialize } from \"react-devtools-inline/frontend\";\n\nconst iframe = document.getElementById(\"target\");\nconst { contentWindow } = iframe;\n\n// Initialize DevTools UI to listen to the iframe.\n// This returns a React component we can render anywhere in the main window.\n// Be sure to use ReactDOMClient.createRoot() to render this component.\nconst DevTools = initialize(contentWindow);\n\n// Let the backend know to initialize itself.\n// We can't do this directly because the iframe is sandboxed.\n// Only initialize the backend once the DevTools frontend has been initialized.\niframe.onload = () => {\n  contentWindow.postMessage(\n    {\n      type: \"activate-backend\"\n    },\n    \"*\"\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Invalid Hook Usage in React Component Callback\nDESCRIPTION: Shows an invalid pattern where a hook (useHookInsideCallback) is called inside a useEffect callback function. This violates React's Rules of Hooks which require hooks to be called at the top level of function components or custom hooks.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.bail.rules-of-hooks-8503ca76d6f8.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @skip\n// Unsupported input\n\n// Invalid because it's a common misunderstanding.\n// We *could* make it valid but the runtime error could be confusing.\nconst ComponentWithHookInsideCallback = React.memo(props => {\n  useEffect(() => {\n    useHookInsideCallback();\n  });\n  return <button {...props} />;\n});\n```\n\nLANGUAGE: text\nCODE:\n```\n   6 | const ComponentWithHookInsideCallback = React.memo(props => {\n   7 |   useEffect(() => {\n>  8 |     useHookInsideCallback();\n     |     ^^^^^^^^^^^^^^^^^^^^^ InvalidReact: Hooks must be called at the top level in the body of a function component or custom hook, and may not be called within function expressions. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning). Cannot call Custom within a function component (8:8)\n   9 |   });\n  10 |   return <button {...props} />;\n  11 | });\n```\n\n----------------------------------------\n\nTITLE: Defining a React Component Using Stringify - JavaScript\nDESCRIPTION: This snippet demonstrates how to define a simple React component that takes a list of items as props and renders each item using the 'Stringify' component. It illustrates basic usage of the 'map' function within JSX and shows module import syntax. The 'Component' function expects an 'items' array as props, and outputs an HTML structure mapping each item to a 'Stringify' component. Dependencies include React and 'shared-runtime'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/outlined-helper.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {Stringify} from 'shared-runtime';\n\nfunction Component(props) {\n  return (\n    <div>\n      {props.items.map(item => (\n        <Stringify key={item.id} item={item.name} />\n      ))}\n    </div>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{items: [{id: 1, name: 'one'}]}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Creating React Hook with Caching Mechanism - JavaScript\nDESCRIPTION: This snippet utilizes 'react/compiler-runtime' and 'shared-runtime' libraries to create a React hook with caching capabilities. It checks whether the stored cache differs from the new value, applying state mutations to ensure efficient re-renders. The hook generates an object with a 'getValue' method to access the current state's value.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-method-shorthand-aliased-mutate-after.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { createHookWrapper, mutate, mutateAndReturn } from \"shared-runtime\";\nfunction useHook(t0) {\n  const $ = _c(2);\n  const { value } = t0;\n  let obj;\n  if ($[0] !== value) {\n    const x = mutateAndReturn({ value });\n    obj = {\n      getValue() {\n        return value;\n      },\n    };\n\n    mutate(x);\n    $[0] = value;\n    $[1] = obj;\n  } else {\n    obj = $[1];\n  }\n  return obj;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: createHookWrapper(useHook),\n  params: [{ value: 0 }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Using Effect with Inferred Dependencies in React\nDESCRIPTION: A React functional component that demonstrates automatic dependency inference with a custom effect hook. The component creates an array from a prop value and passes it to an effect that prints the array. Note that the effect dependency on 'arr' will be automatically inferred.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/no-emit-lint-repro.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @inferEffectDependencies @noEmit\nimport { print } from \"shared-runtime\";\nimport useEffectWrapper from \"useEffectWrapper\";\n\nfunction ReactiveVariable({ propVal }) {\n  const arr = [propVal];\n  useEffectWrapper(() => print(arr));\n}\n```\n\n----------------------------------------\n\nTITLE: React Component Utilizing Optimized Custom Hook - JavaScript\nDESCRIPTION: This snippet represents a functional React component that employs the enhanced custom useState hook. It initializes its state to 'hello' and updates the state on user interaction by clicking the rendered div. The component efficiently re-renders based on state changes achieved through memoization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/globals-dont-resolve-local-useState.expect.md#2025-04-21_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component() {\n  const $ = _c(5);\n  const [state, setState] = useState(\"hello\");\n  let t0;\n  if ($[0] !== setState) {\n    t0 = () => setState(\"goodbye\");\n    $[0] = setState;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  let t1;\n  if ($[2] !== state || $[3] !== t0) {\n    t1 = <div onClick={t0}>{state}</div>;\n    $[2] = state;\n    $[3] = t0;\n    $[4] = t1;\n  } else {\n    t1 = $[4];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining React Components with use no memo Directive\nDESCRIPTION: Two React functional components demonstrating different syntax styles (function expression and arrow function) that both use the 'use no memo' directive to opt out of memoization. Both components render a Button component with a dynamic value.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/apps/playground/__tests__/e2e/__snapshots__/page.spec.ts/use-no-memo-output.txt#2025-04-21_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst TestComponent = function () {\n  \"use no memo\";\n  return <Button>{x}</Button>;\n};\nconst TestComponent2 = ({ x }) => {\n  \"use no memo\";\n  return <Button>{x}</Button>;\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Compiler-Runtime Caching\nDESCRIPTION: This snippet shows an optimized version of the 'foo' function using React's compiler-runtime. It implements caching mechanisms to avoid unnecessary recalculations and re-renders, improving performance for repeated calls with the same parameters.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/escape-analysis-jsx-child.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction foo(a, b, c) {\n  const $ = _c(9);\n  let x;\n  if ($[0] !== a || $[1] !== b || $[2] !== c) {\n    x = [];\n    if (a) {\n      let y;\n      if ($[4] !== b || $[5] !== c) {\n        y = [];\n        if (b) {\n          y.push(c);\n        }\n        $[4] = b;\n        $[5] = c;\n        $[6] = y;\n      } else {\n        y = $[6];\n      }\n      let t0;\n      if ($[7] !== y) {\n        t0 = <div>{y}</div>;\n        $[7] = y;\n        $[8] = t0;\n      } else {\n        t0 = $[8];\n      }\n      x.push(t0);\n    }\n    $[0] = a;\n    $[1] = b;\n    $[2] = c;\n    $[3] = x;\n  } else {\n    x = $[3];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Creating and Exporting React Component in JavaScript\nDESCRIPTION: This JavaScript snippet defines a React functional component named 'Component' with predefined constant values. It exports a fixture configuration object which includes the component function, its parameters, and a flag indicating its nature as a component. This snippet seems to be geared towards testing or integration within a larger React application context.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-arrayexpression.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const a = 1;\n  const b = 2;\n  const x = [a, b];\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with useMemo\nDESCRIPTION: This code defines a React component `Component` that uses `useMemo` to memoize an object based on `propA` and a nested property `propB.x.y`. The `useMemo` hook ensures that the object is only re-created when either `propA` or `propB.x.y` changes, thus optimizing performance by preventing unnecessary re-renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useMemo-conditional-access-noAlloc.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees\nimport {useMemo} from 'react';\n\nfunction Component({propA, propB}) {\n  return useMemo(() => {\n    return {\n      value: propB?.x.y,\n      other: propA,\n    };\n  }, [propA, propB.x.y]);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{propA: 2, propB: {x: {y: []}}}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Original React Component in JavaScript\nDESCRIPTION: This snippet defines a React component that processes an array, filtering out zero and dividing non-zero elements by 2. It also exports a fixture for testing.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-of-continue.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component() {\n  const x = [0, 1, 2, 3];\n  const ret = [];\n  for (const item of x) {\n    if (item === 0) {\n      continue;\n    }\n    ret.push(item / 2);\n  }\n  return ret;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with useIdentity Hook\nDESCRIPTION: This code defines a React component named `useFoo` which leverages the `useIdentity` hook from the `shared-runtime` library. The component creates a Set, gets its values, and then returns the maximum value from the set. A fixture entry point is also exported for testing purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/call-spread-argument-mutable-iterator.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useIdentity} from 'shared-runtime';\n\nfunction useFoo() {\n  const it = new Set([1, 2]).values();\n  useIdentity();\n  return Math.max(...it);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{}],\n  sequentialRenders: [{}, {}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiled Function with Memoization\nDESCRIPTION: Optimized version of the function using React's compiler runtime. Implements memoization using a cache array to avoid redundant computations when inputs haven't changed.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/method-call.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { addOne, shallowCopy } from \"shared-runtime\";\n\nfunction foo(a, b, c) {\n  const $ = _c(5);\n  let t0;\n  if ($[0] !== a) {\n    t0 = shallowCopy(a);\n    $[0] = a;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const x = t0;\n  let t1;\n  if ($[2] !== b || $[3] !== x) {\n    t1 = x.foo(b);\n    $[2] = b;\n    $[3] = x;\n    $[4] = t1;\n  } else {\n    t1 = $[4];\n  }\n  const y = t1;\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [{ foo: addOne }, 3],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Using FBT for Internationalized React Component\nDESCRIPTION: This snippet shows how to create a React component that uses FBT to display an internationalized message with a parameter. The component renders a greeting message that includes the user's name after capitalizing it.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-params-complex-param-value.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport fbt from 'fbt';\n\nfunction Component(props) {\n  return (\n    <fbt desc={'Dialog to show to user'}>\n      Hello <fbt:param name=\"user name\">{capitalize(props.name)}</fbt:param>\n    </fbt>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: The compiled version of the React component with added memoization logic. It uses React's compiler runtime to optimize performance by caching computed values and only recalculating when dependencies change.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-expression-computed-key-constant-string.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { identity } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(4);\n  let t0;\n  if ($[0] !== props.value) {\n    t0 = identity([props.value]);\n    $[0] = props.value;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  let t1;\n  if ($[2] !== t0) {\n    t1 = { [\"KeyName\"]: t0 };\n    $[2] = t0;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  const context = t1;\n  return context;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ value: 42 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization in JavaScript\nDESCRIPTION: This snippet shows the compiled version of the Component function, incorporating React's compiler runtime for memoization. It uses a Symbol-based cache sentinel to determine whether to recompute or return cached values.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/mutable-lifetime-with-aliasing.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction mutate(x, y) {\n  \"use no forget\";\n  if (!Array.isArray(x.value)) {\n    x.value = [];\n  }\n  x.value.push(y);\n  if (y != null) {\n    y.value = x;\n  }\n}\n\nfunction Component(props) {\n  const $ = _c(1);\n  let x;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const a = {};\n    const b = [a];\n    const c = {};\n    const d = { c };\n\n    x = {};\n    x.b = b;\n    const y = mutate(x, d);\n    if (a) {\n    }\n    if (b) {\n    }\n    if (c) {\n    }\n    if (d) {\n    }\n    if (y) {\n    }\n\n    mutate(x, null);\n    $[0] = x;\n  } else {\n    x = $[0];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: React Context Usage with @lowerContextAccess\nDESCRIPTION: This React component, `App`, consumes context values `foo` from `joe` and `bar` from `MyContext` using the `useContext` hook. It then passes these values as props to a `Bar` component. The `@lowerContextAccess` annotation likely indicates special handling of context access during compilation or transformation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/todo.lower-context-access-nested-destructuring.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @lowerContextAccess\nfunction App() {\n  const {\n    joe: {foo},\n    bar,\n  } = useContext(MyContext);\n  return <Bar foo={foo} bar={bar} />;\n}\n\n```\n\n----------------------------------------\n\nTITLE: React Compiler Runtime Optimization with Memoization\nDESCRIPTION: Transformed version of the useFoo hook using React compiler runtime (_c) for dependency tracking and memoization. Implements complex caching logic to minimize unnecessary recomputations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/nested-optional-chains.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction useFoo(t0) {\n  const $ = _c(15);\n  const { prop1, prop2, prop3, prop4, prop5, prop6 } = t0;\n  let t1;\n  if ($[0] !== prop1?.value) {\n    t1 = identity(prop1?.value)?.toString();\n    $[0] = prop1?.value;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  // ... similar memoization logic for other variables\n  return t5;\n}\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: Original implementation of a React component that uses conditional logic to modify a variable based on props. Uses the 'invoke' utility from shared-runtime to call a method.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/context-variable-reassigned-objectmethod.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {invoke} from 'shared-runtime';\n\nfunction Component({cond}) {\n  let x = 2;\n  const obj = {\n    method(cond) {\n      if (cond) {\n        x = 4;\n      }\n    },\n  };\n  invoke(obj.method, cond);\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{cond: true}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Caching\nDESCRIPTION: Compiled version of the React component with memoization logic implemented through the Forget feature flag. Includes caching for both ErrorView and the main component using React compiler runtime.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/multi-arrow-expr-export-default-gating-test.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { isForgetEnabled_Fixtures } from \"ReactForgetFeatureFlag\"; // @gating\nimport { Stringify } from \"shared-runtime\";\n\nconst ErrorView = isForgetEnabled_Fixtures()\n  ? (error, _retry) => {\n      const $ = _c(2);\n      let t0;\n      if ($[0] !== error) {\n        t0 = <Stringify error={error} />;\n        $[0] = error;\n        $[1] = t0;\n      } else {\n        t0 = $[1];\n      }\n      return t0;\n    }\n  : (error, _retry) => <Stringify error={error}></Stringify>;\n\nexport default isForgetEnabled_Fixtures()\n  ? (props) => {\n      const $ = _c(1);\n      let t0;\n      if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n        t0 = (\n          <Foo>\n            <Bar />\n            <ErrorView />\n          </Foo>\n        );\n        $[0] = t0;\n      } else {\n        t0 = $[0];\n      }\n      return t0;\n    }\n  : (props) => (\n      <Foo>\n        <Bar></Bar>\n        <ErrorView></ErrorView>\n      </Foo>\n    );\n```\n\n----------------------------------------\n\nTITLE: Using Special Effect in React\nDESCRIPTION: This snippet defines a React functional component that uses a special effect for managing side effects tied to props. It logs the prop value and captures any exceptions during the execution. The useSpecialEffect function is imported from 'shared-runtime', which handles the lifecycle of side effects. The expected input is a prop object with 'prop1', and the output is rendered JSX containing the prop value.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/bailout-retry/error.todo-syntax.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @inferEffectDependencies @panicThreshold(none)\nimport {useSpecialEffect} from 'shared-runtime';\n\n/**\n * Note that a react compiler-based transform still has limitations on JS syntax.\n * We should surface these as actionable lint / build errors to devs.\n */\nfunction Component({prop1}) {\n  'use memo';\n  useSpecialEffect(() => {\n    try {\n      console.log(prop1);\n    } finally {\n      console.log('exiting');\n    }\n  }, [prop1]);\n  return <div>{prop1}</div>;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Managing Relay Environment and Mutator in React Component\nDESCRIPTION: This snippet demonstrates the implementation of a React component that uses a Relay environment, encapsulated within a Mutator class. Relay acts as a backend for the component, facilitating data management. The component setup ensures immutability, treating instances as read-only. Key features include setting up the environment, initializing the mutator, and a demonstration of ensuring immutability and state management within the component. There are no dependencies mentioned other than the custom hook, `useOtherHook`, which is assumed to be part of a larger framework or additional library.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inadvertent-mutability-readonly-class.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const env = useRelayEnvironment();\n  // Note: this is a class has no mutable methods, ie it always treats `this` as readonly\n  const mutator = new Mutator(env);\n\n  useOtherHook();\n\n  // `x` should be independently memoizeable, since foo(x, mutator) cannot mutate\n  // the mutator.\n  const x = {};\n  foo(x, mutator);\n  return x;\n}\n\nclass Mutator {}\n\n```\n\n----------------------------------------\n\nTITLE: React Component Implementation\nDESCRIPTION: The implementation code for the React component showing the runtime behavior without type annotations. Demonstrates the same identity function processing with a test fixture.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-annotations/type-annotation-as-number.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableUseTypeAnnotations\nimport { identity } from \"shared-runtime\";\n\nfunction Component(props) {\n  const x = identity(props.id);\n  const y = x as number;\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ id: 42 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Testing React Fragments with react-is\nDESCRIPTION: Shows how to identify React Fragment components using isFragment and typeOf functions.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-is/README.md#2025-04-21_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport React from \"react\";\nimport * as ReactIs from 'react-is';\n\nReactIs.isFragment(<></>); // true\nReactIs.typeOf(<></>) === ReactIs.Fragment; // true\n```\n\n----------------------------------------\n\nTITLE: Optimizing React Components with Memoization\nDESCRIPTION: This snippet shows optimized versions of ComponentA and ComponentB using memoization techniques. It uses a custom compiler runtime function _c to cache previous render results and avoid unnecessary re-renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/conditional-on-mutable.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction ComponentA(props) {\n  const $ = _c(4);\n  let t0;\n  if ($[0] !== props.p0 || $[1] !== props.p1 || $[2] !== props.p2) {\n    const a = [];\n    const b = [];\n    if (b) {\n      a.push(props.p0);\n    }\n    if (props.p1) {\n      b.push(props.p2);\n    }\n\n    t0 = <Foo a={a} b={b} />;\n    $[0] = props.p0;\n    $[1] = props.p1;\n    $[2] = props.p2;\n    $[3] = t0;\n  } else {\n    t0 = $[3];\n  }\n  return t0;\n}\n\nfunction ComponentB(props) {\n  const $ = _c(4);\n  let t0;\n  if ($[0] !== props.p0 || $[1] !== props.p1 || $[2] !== props.p2) {\n    const a = [];\n    const b = [];\n    if (mayMutate(b)) {\n      a.push(props.p0);\n    }\n    if (props.p1) {\n      b.push(props.p2);\n    }\n\n    t0 = <Foo a={a} b={b} />;\n    $[0] = props.p0;\n    $[1] = props.p1;\n    $[2] = props.p2;\n    $[3] = t0;\n  } else {\n    t0 = $[3];\n  }\n  return t0;\n}\n\nfunction Foo() {}\nfunction mayMutate() {}\n```\n\n----------------------------------------\n\nTITLE: Defining Component with useMemo - JavaScript\nDESCRIPTION: This snippet defines a simple React functional component that uses the useMemo hook to memoize the output based on the dependency array [a, b]. It checks if 'a' is truthy, and if so, returns an object containing 'b'. The component is then exported as part of the FIXTURE_ENTRYPOINT object, which can be used in various contexts to reference the component with parameters for rendering.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-inlining-block-return.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component(a, b) {\n  let x = useMemo(() => {\n    if (a) {\n      return {b};\n    }\n  }, [a, b]);\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n\n```\n\n----------------------------------------\n\nTITLE: Validating Ref Access in React Component\nDESCRIPTION: Demonstrates incorrect usage of ref.current during component rendering, which violates React's rendering rules and can cause unexpected behavior\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-ref-in-callback-invoked-during-render.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validateRefAccessDuringRender\nfunction Component(props) {\n  const ref = useRef(null);\n  const renderItem = item => {\n    const current = ref.current;\n    return <Foo item={item} current={current} />;\n  };\n  return <Items>{props.items.map(item => renderItem(item))}</Items>;\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for React DevTools\nDESCRIPTION: Command to install all necessary dependencies for React DevTools development from the root of the repository.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools-extensions/README.md#2025-04-21_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nyarn install\n```\n\n----------------------------------------\n\nTITLE: Initial VideoTab Component Implementation\nDESCRIPTION: A basic React functional component using useRef to create a reference and define a logging function passed to VideoList\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ref-current-not-added-to-dep.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction VideoTab() {\n  const ref = useRef();\n  let x = () => {\n    console.log(ref.current);\n  };\n\n  return <VideoList videos={x} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Memoized Callback Hook in React\nDESCRIPTION: Implements a custom React hook that creates a memoized callback using useIdentity. The hook takes an object and a setState function, then returns a callback that updates state with the object's value.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/assume-invoked/hook-call.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {createHookWrapper, useIdentity} from 'shared-runtime';\n\n/**\n * Assume that functions passed hook arguments are invoked and that their\n * property loads are hoistable.\n */\nfunction useMakeCallback({\n  obj,\n  setState,\n}: {\n  obj: {value: number};\n  setState: (newState: number) => void;\n}) {\n  const cb = useIdentity(() => setState(obj.value));\n  return cb;\n}\n\nconst setState = (arg: number) => {\n  'use no memo';\n  return arg;\n};\nexport const FIXTURE_ENTRYPOINT = {\n  fn: createHookWrapper(useMakeCallback),\n  params: [{obj: {value: 1}, setState}],\n  sequentialRenders: [\n    {obj: {value: 1}, setState},\n    {obj: {value: 2}, setState},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component Rendering with Shallow Copy (Input)\nDESCRIPTION: This code defines a React component that renders a div element with specified child properties based on the `width` prop. It utilizes `react/jsx-runtime` for JSX transformation and `shared-runtime` for a shallow copy operation. The component creates a `childprops` object containing a style with the provided width, assigns it to the div, performs a shallow copy, and then returns the created element.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-freeze.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {jsx as _jsx} from 'react/jsx-runtime';\nimport {shallowCopy} from 'shared-runtime';\n\nfunction Component(props) {\n  const childprops = {style: {width: props.width}};\n  const element = _jsx('div', {\n    childprops: childprops,\n    children: '\"hello world\"',\n  });\n  shallowCopy(childprops); // function that in theory could mutate, we assume not bc createElement freezes\n  return element;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}]\n};\n\n```\n\n----------------------------------------\n\nTITLE: Installing eslint-plugin-react-compiler via npm\nDESCRIPTION: Command to install the eslint-plugin-react-compiler as a dev dependency. This plugin enhances the linting of React code by using the React compiler.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/eslint-plugin-react-compiler/README.md#2025-04-21_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nnpm install eslint-plugin-react-compiler --save-dev\n```\n\n----------------------------------------\n\nTITLE: Defining a Component with State Operations in React (JavaScript)\nDESCRIPTION: This snippet defines a React component using variable increment and decrement operations to manage state. It returns an object with state values and exports a fixture entry point pointing to the component. Dependencies include JavaScript ES6 for variable handling, with no external libraries required. The parameters are empty, and it outputs an object with updated state values.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/update-expression-constant-propagation.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nfunction Component() {\n  let a = 0;\n  const b = a++;\n  const c = ++a;\n  const d = a--;\n  const e = --a;\n  return {a, b, c, d, e};\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with Conditional Rendering in JavaScript\nDESCRIPTION: This snippet defines a React component 'useFoo' that conditionally renders based on input data. It uses imported utility functions for object manipulation and a Stringify component for display. The component includes a labeled block for flow control.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/mutation-within-jsx-and-break.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {\n  Stringify,\n  makeObject_Primitives,\n  mutate,\n  mutateAndReturn,\n} from 'shared-runtime';\n\nfunction useFoo({data}) {\n  let obj = null;\n  let myDiv = null;\n  label: {\n    if (data.cond) {\n      obj = makeObject_Primitives();\n      if (data.cond1) {\n        myDiv = <Stringify value={mutateAndReturn(obj)} />;\n        break label;\n      }\n      mutate(obj);\n    }\n  }\n\n  return myDiv;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{data: {cond: true, cond1: true}}],\n  sequentialRenders: [\n    {data: {cond: true, cond1: true}},\n    {data: {cond: true, cond1: true}},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Input React Component with FBT Translation\nDESCRIPTION: Original source code showing a React component that uses FBT for internationalization. The component takes an items prop and displays a translated string with the count of items.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-template-string-same-scope.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport fbt from 'fbt';\nimport {Stringify} from 'shared-runtime';\n\nexport function Component(props) {\n  let count = 0;\n  if (props.items) {\n    count = props.items.length;\n  }\n  return (\n    <Stringify>\n      {fbt(\n        `for ${fbt.param('count', count)} experiences`,\n        `Label for the number of items`,\n        {project: 'public'}\n      )}\n    </Stringify>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{items: [1, 2, 3]}],\n};\n```\n\n----------------------------------------\n\nTITLE: Managing Array Values with React and JavaScript\nDESCRIPTION: This snippet demonstrates the use of array operations, including adding elements to an array and mutating it using external methods imported from a shared runtime utility. It manages mutability in React's render context by pushing values into an array and mutating its state. Essential parameters include the input object with value property. The outcome is a modified array after attempting catches of potential errors.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/align-scopes-reactive-scope-overlaps-try.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport {arrayPush, mutate} from 'shared-runtime';\n\nfunction useFoo({value}) {\n  let items = null;\n  try {\n    // Mutable range of `items` begins here, but its reactive scope block\n    // should be aligned to above the try-block\n    items = [];\n    arrayPush(items, value);\n  } catch {\n    // ignore\n  }\n  mutate(items);\n  return items;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{value: 2}],\n  sequentialRenders: [{value: 2}, {value: 2}, {value: 3}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Modifying External Variable in React Component (JavaScript)\nDESCRIPTION: This code snippet defines a function component `Foo` that attempts to modify a JavaScript object `wat` defined outside the component's scope.  This violates React's principles of state management and immutability, leading to the \"InvalidReact\" error. The error suggests using an effect or a more appropriate React state management approach.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.store-property-in-global.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nlet wat = {};\n\nfunction Foo() {\n  wat.test = 1;\n  return wat;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining useBar Hook with Memoization\nDESCRIPTION: This snippet defines a React custom hook called useBar, which manages dependencies and memoization using useCallback. It captures the current value of variables to prevent unnecessary re-renders and optimizes rendering based on context changes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useCallback-extended-contextvar-scope.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees:true\n\nimport {useCallback} from 'react';\nimport {Stringify, useIdentity} from 'shared-runtime';\n\n/**\n * Here, the *inferred* dependencies of cb are `a` and `t1 = LoadContext capture x_@1`.\n * - t1 does not have a scope as it captures `x` after x's mutable range\n * - `x` is a context variable, which means its mutable range extends to all\n *    references / aliases.\n * - `a`, `b`, and `x` get the same mutable range due to potential aliasing.\n *\n * We currently bail out because `a` has a scope and is not transitively memoized\n * (as its scope is pruned due to a hook call)\n */\nfunction useBar({a, b}, cond) {\n  let x = useIdentity({val: 3});\n  if (cond) {\n    x = b;\n  }\n\n  const cb = useCallback(() => {\n    return [a, x];\n  }, [a, x]);\n\n  return <Stringify cb={cb} shouldInvoke={true} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useBar,\n  params: [{a: 1, b: 2}, true],\n};\n```\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @validatePreserveExistingMemoizationGuarantees:true\n\nimport { useCallback } from \"react\";\nimport { Stringify, useIdentity } from \"shared-runtime\";\n\n/**\n * Here, the *inferred* dependencies of cb are `a` and `t1 = LoadContext capture x_@1`.\n * - t1 does not have a scope as it captures `x` after x's mutable range\n * - `x` is a context variable, which means its mutable range extends to all\n *    references / aliases.\n * - `a`, `b`, and `x` get the same mutable range due to potential aliasing.\n *\n * We currently bail out because `a` has a scope and is not transitively memoized\n * (as its scope is pruned due to a hook call)\n */\nfunction useBar(t0, cond) {\n  const $ = _c(6);\n  const { a, b } = t0;\n  let t1;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = { val: 3 };\n    $[0] = t1;\n  } else {\n    t1 = $[0];\n  }\n  let x;\n  x = useIdentity(t1);\n  if (cond) {\n    x = b;\n  }\n  let t2;\n  if ($[1] !== a || $[2] !== x) {\n    t2 = () => [a, x];\n    $[1] = a;\n    $[2] = x;\n    $[3] = t2;\n  } else {\n    t2 = $[3];\n  }\n  x;\n  const cb = t2;\n  let t3;\n  if ($[4] !== cb) {\n    t3 = <Stringify cb={cb} shouldInvoke={true} />;\n    $[4] = cb;\n    $[5] = t3;\n  } else {\n    t3 = $[5];\n  }\n  return t3;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useBar,\n  params: [{ a: 1, b: 2 }, true],\n};\n```\n\n----------------------------------------\n\nTITLE: Creating Nested Objects in React Component\nDESCRIPTION: A simple component function that creates nested objects and arrays. It initializes an empty array, creates object references, and returns a nested structure.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/alias-nested-member-path.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component() {\n  let z = [];\n  let y = {};\n  y.z = z;\n  let x = {};\n  x.y = y;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: React Component Definition with useFire Hook\nDESCRIPTION: This code defines a React component that uses the `useFire` hook from `react/compiler-runtime` to manage side effects. The `useFire` hook transforms the original `fire` calls. The component is wrapped with `React.forwardRef` to allow passing a ref. It shows how side effects are now managed using the new `useFire` hook.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/bailout-retry/bailout-validate-ref-current-access.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useFire } from \"react/compiler-runtime\";\nimport { fire } from \"react\";\nimport { print } from \"shared-runtime\";\n\nconst Component = React.forwardRef(Component_withRef);\nfunction Component_withRef(t0, ref) {\n  const { prop1 } = t0;\n  const foo = () => {\n    console.log(prop1);\n  };\n  const t1 = useFire(foo);\n  useEffect(() => {\n    t1(prop1);\n    bar();\n    t1();\n  });\n  print(ref.current);\n  return null;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with Conditional State Updates\nDESCRIPTION: This snippet defines a React functional component that uses the useState hook to manage state. It includes a conditional state update based on props and a nested function that modifies state. The component returns the current state value.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/conditional-set-state-in-render.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const [x, setX] = useState(0);\n\n  const foo = () => {\n    setX(1);\n  };\n\n  if (props.cond) {\n    setX(2);\n    foo();\n  }\n\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Using useMemo for Conditional Computation in React (JavaScript)\nDESCRIPTION: This snippet defines a React functional component that uses the useMemo hook to optimize rendering by caching calculated values based on the component's props. The function evaluates conditions and returns an array based on the boolean props 'cond' and 'cond2'. The expected input is an object containing numeric properties 'a' and 'b', and boolean flags 'cond' and 'cond2'. The output is an array consisting of the selected values or an empty array, based on the conditions. This aims to avoid unnecessary recalculations on rerenders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/useMemo-multiple-if-else.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enablePropagateDepsInHIR\nimport {useMemo} from 'react';\n\nfunction Component(props) {\n  const x = useMemo(() => {\n    let y = [];\n    if (props.cond) {\n      y.push(props.a);\n    }\n    if (props.cond2) {\n      return y;\n    }\n    y.push(props.b);\n    return y;\n  });\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{a: 1, b: 2, cond2: false}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiled FBT Component with React Compiler Runtime Optimization\nDESCRIPTION: This is the compiled output of the FBT component showing how React's compiler optimizes internationalization. It uses memoization via the compiler runtime to avoid recreating the FBT instance on re-renders when props haven't changed, improving performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-param-with-unicode.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport fbt from \"fbt\";\n\nfunction Component(props) {\n  const $ = _c(4);\n  let t0;\n  if ($[0] !== props.name) {\n    t0 = fbt._(\n      \"Hello {user name }\",\n      [fbt._param(\"user name \\u263A\", props.name)],\n      { hk: \"1En1lp\" },\n    );\n    $[0] = props.name;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const element = t0;\n  let t1;\n  if ($[2] !== element) {\n    t1 = element.toString();\n    $[2] = element;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ name: \"Jason\" }],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Inferred Effect Dependencies\nDESCRIPTION: The compiled output of the PrunedNonReactive component after React compiler has processed it. The compiler has transformed the code to properly handle the effect dependencies, adding obj.value as a dependency and implementing memoization for the effect callback.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/pruned-nonreactive-obj.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @inferEffectDependencies\nimport { useIdentity, mutate, makeObject } from \"shared-runtime\";\nimport { useEffect } from \"react\";\n\n/**\n * When a semantically non-reactive value has a pruned scope (i.e. the object\n * identity becomes reactive, but the underlying value it represents should be\n * constant), the compiler can choose to either\n * - add it as a dependency (and rerun the effect)\n * - not add it as a dependency\n *\n * We keep semantically non-reactive values in both memo block and effect\n * dependency arrays to avoid versioning invariants e.g. `x !== y.aliasedX`.\n * ```js\n * function Component() {\n *   // obj is semantically non-reactive, but its memo scope is pruned due to\n *   // the interleaving hook call\n *   const obj = {};\n *   useHook();\n *   write(obj);\n *\n *   const ref = useRef();\n *\n *   // this effect needs to be rerun when obj's referential identity changes,\n *   // because it might alias obj to a useRef / mutable store.\n *   useEffect(() => ref.current = obj, ???);\n *\n *   // in a custom hook (or child component), the user might expect versioning\n *   // invariants to hold\n *   useHook(ref, obj);\n * }\n *\n * // defined elsewhere\n * function useHook(someRef, obj) {\n *   useEffect(\n *     () => assert(someRef.current === obj),\n *     [someRef, obj]\n *   );\n * }\n * ```\n */\nfunction PrunedNonReactive() {\n  const $ = _c(2);\n  const obj = makeObject();\n  useIdentity(null);\n  mutate(obj);\n  let t0;\n  if ($[0] !== obj.value) {\n    t0 = () => print(obj.value);\n    $[0] = obj.value;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  useEffect(t0, [obj.value]);\n}\n```\n\n----------------------------------------\n\nTITLE: Error Handling for Incorrect useEffect Hook Usage\nDESCRIPTION: This error message indicates that the useEffect hook is being used incorrectly in the function nonReactFn. It highlights the need for a proper dependency array to avoid breaking the build, signaling developer attention to fix this issue. Understanding the implications of React's compiler diagnostics is crucial.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/bailout-retry/error.callsite-in-non-react-fn.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n  3 |\n  4 | function nonReactFn(arg) {\n> 5 |   useEffect(() => [1, 2, arg]);\n    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ InvalidReact: [InferEffectDependencies] React Compiler is unable to infer dependencies of this effect. This will break your build! To resolve, either pass your own dependency array or fix reported compiler bailout diagnostics. (5:5)\n  6 | }\n  7 |\n```\n\n----------------------------------------\n\nTITLE: Error Message for Invalid React Hook Usage in JavaScript\nDESCRIPTION: This snippet captures the error output generated when the 'useHook' function is executed. It indicates that hooks must be called in a consistent order and may not be called conditionally according to the React Hooks rules. The error message also provides a link to the relevant documentation for further reading. This is critical for developers to understand the consequences of hook violations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-rules-of-hooks-c906cace44e9.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n  5 | function useHook() {\n  6 |   if (a) return;\n> 7 |   useState();\n    |   ^^^^^^^^ InvalidReact: Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning) (7:7)\n  8 | }\n  9 |\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom React Hook with useMemo and useState\nDESCRIPTION: This snippet defines a custom React hook 'useFoo' that utilizes useState and useMemo for efficient state management and memoization. It calculates a style object based on input parameters and current state, demonstrating how useMemo can be used in nested reactive blocks.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useMemo-in-other-reactive-block.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees\nimport {useMemo, useState} from 'react';\nimport {arrayPush} from 'shared-runtime';\n\n// useMemo-produced values can exist in nested reactive blocks, as long\n// as their reactive dependencies are a subset of depslist from source\nfunction useFoo(minWidth, otherProp) {\n  const [width, setWidth] = useState(1);\n  const x = [];\n  const style = useMemo(() => {\n    return {\n      width: Math.max(minWidth, width),\n    };\n  }, [width, minWidth]);\n  arrayPush(x, otherProp);\n  return [style, x];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [2, 'other'],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with FBT and Memoization\nDESCRIPTION: This snippet defines a React component that uses FBT for internationalization and useMemo for performance optimization. It renders a user's name and validates the memoization using a ValidateMemoization component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-repro-invalid-mutable-range-destructured-prop.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {fbt} from 'fbt';\nimport {useMemo} from 'react';\nimport {ValidateMemoization} from 'shared-runtime';\n\nfunction Component({data}) {\n  const el = useMemo(\n    () => (\n      <fbt desc=\"user name\">\n        <fbt:param name=\"name\">{data.name ?? ''}</fbt:param>\n      </fbt>\n    ),\n    [data.name]\n  );\n  return <ValidateMemoization inputs={[data.name]} output={el} />;\n}\n\nconst props1 = {data: {name: 'Mike'}};\nconst props2 = {data: {name: 'Mofei'}};\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [props1],\n  sequentialRenders: [props1, props2, props2, props1, {...props1}],\n};\n```\n\n----------------------------------------\n\nTITLE: Initial VideoTab React Component Implementation\nDESCRIPTION: A basic React functional component that creates a ref and defines a function to modify the ref's current value, then renders a VideoList component\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ref-current-write-not-added-to-dep.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction VideoTab() {\n  const ref = useRef();\n  let x = () => {\n    ref.current = 1;\n  };\n\n  return <VideoList videos={x} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Component\nDESCRIPTION: This snippet defines a simple React component that retrieves and mutates data based on props passed to it. It uses `bar` to get items and modifies them with the `mutate` function. The component then returns the items and a computed count.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactivity-analysis-reactive-via-mutation-of-computed-load.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const items = bar();\n  mutate(items[props.key], props.a);\n\n  const count = foo(items.length + 1);\n\n  return {items, count};\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with useCallback and useRef\nDESCRIPTION: This snippet defines a React component using useCallback and useRef hooks. It creates an input element with an onChange handler that updates a ref value. However, there's an issue with accessing the ref value during render.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.useCallback-set-ref-nested-property-dont-preserve-memoization.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enablePreserveExistingMemoizationGuarantees:false\nimport {useCallback, useRef} from 'react';\n\nfunction Component(props) {\n  const ref = useRef({inner: null});\n\n  const onChange = useCallback(event => {\n    // The ref should still be mutable here even though function deps are frozen in\n    // @enablePreserveExistingMemoizationGuarantees mode\n    ref.current.inner = event.target.value;\n  });\n\n  ref.current.inner = null;\n\n  return <input onChange={onChange} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: Compiled version of the Foo component with memoization logic using React's compiler runtime. Implements cache checking using Symbol.for('react.memo_cache_sentinel') to optimize rendering performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/memoize-value-block-value-logical-no-sequence.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Foo(props) {\n  const $ = _c(1);\n  let x;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    true && (x = []);\n    $[0] = x;\n  } else {\n    x = $[0];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component Calling a Function (JavaScript)\nDESCRIPTION: This code defines a React component, `ComponentWithNormalFunction`, which calls a normal JavaScript function `doSomething()`. This demonstrates a standard way to integrate regular JavaScript functions within a React component's logic. It highlights that React components can directly call functions defined in the same scope or imported from other modules.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-7e52f5eec669.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Valid because components can call functions.\nfunction ComponentWithNormalFunction() {\n  doSomething();\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating a React Component Test Fixture in JavaScript\nDESCRIPTION: Defines a simple function 'foo' that manipulates arrays and exports a fixture entrypoint configuration for testing a 'TodoAdd' component. The fixture specifies the function, parameters, and component identification.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/overlapping-scopes-interleaved-by-terminal.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(a, b, c) {\n  const x = [];\n  const y = [];\n\n  if (x) {\n  }\n\n  y.push(a);\n  x.push(b);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(a, b, c) {\n  const x = [];\n  const y = [];\n  if (x) {\n  }\n\n  y.push(a);\n  x.push(b);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization and Mutation\nDESCRIPTION: This snippet shows the compiled version of the 'useFoo' component. It includes React's compiler-runtime and implements memoization using an array '_c(4)'. The component checks for changes in input parameters and updates memoized values accordingly, while preserving the original functionality.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/nonmutating-capture-in-unsplittable-memo-block.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { identity, mutate } from \"shared-runtime\";\n\n/**\n * Currently, InferReactiveScopeVariables do not ensure that maybe-aliased\n * values get assigned the same reactive scope. This is safe only when an\n * already-constructed value is captured, e.g.\n * ```js\n * const x = makeObj();   mutable range of x\n * mutate(x);            \n *                       <-- after this point, we can produce a canonical version\n *                           of x for all following aliases\n * const y = [];\n * y.push(x);            <-- y captures x\n * ```\n *\n * However, if a value is captured/aliased during its mutable range and the\n * capturing container is separately memoized, it becomes difficult to guarantee\n * that all aliases refer to the same value.\n *\n */\nfunction useFoo(t0) {\n  const $ = _c(4);\n  const { a, b } = t0;\n  let y;\n  let z;\n  if ($[0] !== a || $[1] !== b) {\n    const x = { a };\n    y = {};\n    mutate(x);\n    z = [identity(y), b];\n    mutate(y);\n    $[0] = a;\n    $[1] = b;\n    $[2] = y;\n    $[3] = z;\n  } else {\n    y = $[2];\n    z = $[3];\n  }\n  if (z[0] !== y) {\n    throw new Error(\"oh no!\");\n  }\n  return z;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ a: 2, b: 3 }],\n  sequentialRenders: [\n    { a: 2, b: 3 },\n    { a: 4, b: 3 },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: This snippet presents the compiled version of the `Component` function.  It utilizes `react/compiler-runtime` for memoization. The compiled function memoizes the result of `foo?.(props)` based on the input props, improving performance by avoiding redundant computations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-call-simple.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== props) {\n    t0 = foo?.(props);\n    $[0] = props;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining useHook Function Utilizing React Hooks\nDESCRIPTION: This snippet defines a function 'useHook' which demonstrates the valid use of React's useState hook within a custom hook. This illustrates the rule that hooks can be called inside other hooks, maintaining compliance with React's rules for hooks. The expected input scenario is a React component context where hooks are permitted.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-2e405c78cb80.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Valid because hooks can call hooks.\nfunction useHook() {\n  useState() && a;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Component with Dependency Extraction - JavaScript\nDESCRIPTION: This snippet defines a React component named 'Component' which utilizes functions to mutate props and handle reactive dependencies. It includes important comments about potential pitfalls with state management and optimizations. The dependencies involve several functions from shared-runtime to ensure proper handling of props and state.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/aliased-nested-scope-truncated-dep.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { Stringify, mutate, identity, shallowCopy, setPropertyByKey } from 'shared-runtime';\n\n/**\n * This fixture is similar to `bug-aliased-capture-aliased-mutate` and\n * `nonmutating-capture-in-unsplittable-memo-block`, but with a focus on\n * dependency extraction.\n *\n * NOTE: this fixture is currently valid, but will break with optimizations:\n * - Scope and mutable-range based reordering may move the array creation\n *     *after* the `mutate(aliasedObj)` call. This is invalid if mutate\n *     reassigns inner properties.\n * - RecycleInto or other deeper-equality optimizations may produce invalid\n *     output -- it may compare the array's contents / dependencies too early.\n * - Runtime validation for immutable values will break if `mutate` does\n *     interior mutation of the value captured into the array.\n *\n * Before scope block creation, HIR looks like this:\n *  //\n *  // $1 is unscoped as obj's mutable range will be\n *  // extended in a later pass\n *  //\n *  $1    = LoadLocal obj@0[0:12]\n *  $2    = PropertyLoad $1.id\n *  //\n *  // $3 gets assigned a scope as Array is an allocating\n *  // instruction, but this does *not* get extended or\n *  // merged into the later mutation site.\n *  // (explained in `bug-aliased-capture-aliased-mutate`)\n *  //\n *  $3@1  = Array[$2]\n *  ...\n *  $10@0 = LoadLocal shallowCopy@0[0, 12]\n *  $11   = LoadGlobal mutate\n *  $12   = $11($10@0[0, 12])\n *\n * When filling in scope dependencies, we find that it's incorrect to depend on\n * PropertyLoads from obj as it hasn't completed its mutable range. Following\n * the immutable / mutable-new typing system, we check the identity of obj to\n * detect whether it was newly created (and thus mutable) in this render pass.\n *\n * HIR with scopes looks like this.\n * bb0:\n *  $1    = LoadLocal obj@0[0:12]\n *  $2    = PropertyLoad $1.id\n *  scopeTerminal deps=[obj@0] block=bb1 fallt=bb2\n * bb1:\n *  $3@1  = Array[$2]\n *  goto bb2\n * bb2:\n *  ...\n *\n * This is surprising as deps now is entirely decoupled from temporaries used\n * by the block itself. scope @1's instructions now reference a value (1)\n * produced outside its scope range and (2) not represented in its dependencies\n *\n * The right thing to do is to ensure that all Loads from a value get assigned\n * the value's reactive scope. This also requires track mutating and aliasing\n * separately from scope range. In this example, that would correctly merge\n * the scopes of $3 with obj.\n * Runtime validation and optimizations such as ReactiveGraph-based reordering\n * require this as well.\n *\n * A tempting fix is to instead extend $3's ReactiveScope range up to include\n * $2 (the PropertyLoad). This fixes dependency deduping but not reordering\n * and mutability.\n */\nfunction Component({prop}) {\n  let obj = shallowCopy(prop);\n  const aliasedObj = identity(obj);\n\n  // [obj.id] currently is assigned its own reactive scope\n  const id = [obj.id];\n\n  // Writing to the alias may reassign to previously captured references.\n  // The compiler currently produces valid output, but this breaks with\n  // reordering, recycleInto, and other potential optimizations.\n  mutate(aliasedObj);\n  setPropertyByKey(aliasedObj, 'id', prop.id + 1);\n\n  return <Stringify id={id} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{prop: {id: 1}}],\n  sequentialRenders: [{prop: {id: 1}}, {prop: {id: 1}}, {prop: {id: 2}}],\n};\n\n```\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport {\n  Stringify,\n  mutate,\n  identity,\n  shallowCopy,\n  setPropertyByKey,\n} from \"shared-runtime\";\n\n/**\n * This fixture is similar to `bug-aliased-capture-aliased-mutate` and\n * `nonmutating-capture-in-unsplittable-memo-block`, but with a focus on\n * dependency extraction.\n *\n * NOTE: this fixture is currently valid, but will break with optimizations:\n * - Scope and mutable-range based reordering may move the array creation\n *     *after* the `mutate(aliasedObj)` call. This is invalid if mutate\n *     reassigns inner properties.\n * - RecycleInto or other deeper-equality optimizations may produce invalid\n *     output -- it may compare the array's contents / dependencies too early.\n * - Runtime validation for immutable values will break if `mutate` does\n *     interior mutation of the value captured into the array.\n *\n * Before scope block creation, HIR looks like this:\n *  //\n *  // $1 is unscoped as obj's mutable range will be\n *  // extended in a later pass\n *  //\n *  $1    = LoadLocal obj@0[0:12]\n *  $2    = PropertyLoad $1.id\n *  //\n *  // $3 gets assigned a scope as Array is an allocating\n *  // instruction, but this does *not* get extended or\n *  // merged into the later mutation site.\n *  // (explained in `bug-aliased-capture-aliased-mutate`)\n *  //\n *  $3@1  = Array[$2]\n *  ...\n *  $10@0 = LoadLocal shallowCopy@0[0, 12]\n *  $11   = LoadGlobal mutate\n *  $12   = $11($10@0[0, 12])\n *\n * When filling in scope dependencies, we find that it's incorrect to depend on\n * PropertyLoads from obj as it hasn't completed its mutable range. Following\n * the immutable / mutable-new typing system, we check the identity of obj to\n * detect whether it was newly created (and thus mutable) in this render pass.\n *\n * HIR with scopes looks like this.\n * bb0:\n *  $1    = LoadLocal obj@0[0:12]\n *  $2    = PropertyLoad $1.id\n *  scopeTerminal deps=[obj@0] block=bb1 fallt=bb2\n * bb1:\n *  $3@1  = Array[$2]\n *  goto bb2\n * bb2:\n *  ...\n *\n * This is surprising as deps now is entirely decoupled from temporaries used\n * by the block itself. scope @1's instructions now reference a value (1)\n * produced outside its scope range and (2) not represented in its dependencies\n *\n * The right thing to do is to ensure that all Loads from a value get assigned\n * the value's reactive scope. This also requires track mutating and aliasing\n * separately from scope range. In this example, that would correctly merge\n * the scopes of $3 with obj.\n * Runtime validation and optimizations such as ReactiveGraph-based reordering\n * require this as well.\n *\n * A tempting fix is to instead extend $3's ReactiveScope range up to include\n * $2 (the PropertyLoad). This fixes dependency deduping but not reordering\n * and mutability.\n */\nfunction Component(t0) {\n  const $ = _c(4);\n  const { prop } = t0;\n  let t1;\n  if ($[0] !== prop) {\n    const obj = shallowCopy(prop);\n    const aliasedObj = identity(obj);\n    let t2;\n    if ($[2] !== obj) {\n      t2 = [obj.id];\n      $[2] = obj;\n      $[3] = t2;\n    } else {\n      t2 = $[3];\n    }\n    const id = t2;\n\n    mutate(aliasedObj);\n    setPropertyByKey(aliasedObj, \"id\", prop.id + 1);\n\n    t1 = <Stringify id={id} />;\n    $[0] = prop;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ prop: { id: 1 } }],\n  sequentialRenders: [\n    { prop: { id: 1 } },\n    { prop: { id: 1 } },\n    { prop: { id: 2 } },\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Memo Caching\nDESCRIPTION: This snippet shows an optimized version of the React component using memo caching. It imports a compiler runtime function and implements caching for the onClick handler and the rendered JSX.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-mutating-ref-in-callback-passed-to-jsx.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @validateRefAccessDuringRender\nimport { useRef } from \"react\";\n\nfunction Component() {\n  const $ = _c(2);\n  const ref = useRef(null);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = () => {\n      if (ref.current !== null) {\n        ref.current = \"\";\n      }\n    };\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const onClick = t0;\n  let t1;\n  if ($[1] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = (\n      <>\n        <input ref={ref} />\n        <button onClick={onClick} />\n      </>\n    );\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Compiler Runtime\nDESCRIPTION: Transformed version of the React component using React compiler runtime, with memoization and cached effect handling\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/valid-setState-in-useEffect-listener-transitive.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @validateNoSetStateInPassiveEffects\nimport { useEffect, useState } from \"react\";\n\nfunction Component() {\n  const $ = _c(1);\n  const [state, setState] = useState(0);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = () => {\n      const f = () => {\n        setState();\n      };\n\n      setTimeout(() => f(), 10);\n    };\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  useEffect(t0);\n  return state;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Original useFoo Custom Hook Implementation in React\nDESCRIPTION: The original implementation of a custom hook that processes arrays. It creates a callback function that adds a value from arr2 to each element of arr1, then maps through arr1 applying this callback to build a new array which is returned.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/bug-invalid-array-map-manual.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction useFoo({arr1, arr2}) {\n  const cb = e => arr2[0].value + e.value;\n  const y = [];\n  for (let i = 0; i < arr1.length; i++) {\n    y.push(cb(arr1[i]));\n  }\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{arr1: [], arr2: []}],\n  sequentialRenders: [\n    {arr1: [], arr2: []},\n    {arr1: [], arr2: null},\n    {arr1: [{value: 1}, {value: 2}], arr2: [{value: -1}]},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with Compiler Runtime Memoization\nDESCRIPTION: A React component implementation that uses the compiler runtime for memoization optimization. The component renders a div with 'Hello World' text and implements memo caching using Symbol.for() to check cache state.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/apps/playground/__tests__/e2e/__snapshots__/page.spec.ts/02-default-output.txt#2025-04-21_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nexport default function MyApp() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = <div>Hello World</div>;\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing React Hook with Optional Chaining and Complex Props\nDESCRIPTION: A React hook function that demonstrates advanced optional chaining and dependency propagation with multiple nested prop types. Uses identity function and handles nested object access with optional chaining.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/nested-optional-chains.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction useFoo({\n  prop1,\n  prop2,\n  prop3,\n  prop4,\n  prop5,\n  prop6,\n}: {\n  prop1: null | {value: number};\n  prop2: null | {inner: {value: number}};\n  prop3: null | {fn: (val: any) => NonNullable<object>};\n  prop4: null | {inner: {value: number}};\n  prop5: null | {fn: (val: any) => NonNullable<object>};\n  prop6: null | {inner: {value: number}};\n}) {\n  const x = identity(prop1?.value)?.toString();\n  const y = identity(prop2?.inner.value)?.toString();\n  const z = prop3?.fn(prop4?.inner.value).toString();\n  const zz = prop5?.fn(prop6?.inner.value)?.toString();\n  return [x, y, z, zz];\n}\n```\n\n----------------------------------------\n\nTITLE: React useRef Hook Usage with Error Demonstration\nDESCRIPTION: This code snippet demonstrates the usage of the `useRef` hook in React. It initializes a ref and attempts to modify its `current` property directly within the component's render function. This is an anti-pattern in React and causes an error, as ref values should not be modified during the render phase.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.ref-initialization-linear.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n//@flow\nimport {useRef} from 'react';\n\ncomponent C() {\n  const r = useRef(null);\n  if (r.current == null) {\n    r.current = 42;\n    r.current = 42;\n  }\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: C,\n  params: [{}]],\n};\n```\n\n----------------------------------------\n\nTITLE: React Hook Definition: useFoo (Transpiled)\nDESCRIPTION: This is a transpiled version of the `useFoo` React hook. It destructures the `onClose` prop from the input object `t0`. Functionally, it's equivalent to the original, initializing a button with primary and secondary actions via `Stringify` and depending on a `dispatcher` obtained using `useHook`. The code demonstrates potential dependency injection or hoisting patterns since `dispatcher` is used before being defined.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisted-declaration-with-scope.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { StaticText1, Stringify, identity, useHook } from \"shared-runtime\";\n\n/**\n * `button` and `dispatcher` must end up in the same memo block. It would be\n * invalid for `button` to take a dependency on `dispatcher` as dispatcher\n * is created later.\n */\nfunction useFoo(t0) {\n  const { onClose } = t0;\n  const button = StaticText1 ?? (\n    <Stringify\n      primary={{ label: identity(\"label\"), onPress: onClose }}\n      secondary={{\n        onPress: () => {\n          dispatcher.go(\"route2\");\n        },\n      }}\n    />\n  );\n\n  const dispatcher = useHook();\n  return button;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ onClose: identity() }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Implementing useHook with Set and Array Manipulation in JavaScript\nDESCRIPTION: This snippet defines a custom React hook 'useHook' that uses Set and Array manipulation. It takes an object with 'el1' and 'el2' properties, creates a Set, manipulates arrays, and returns the size of the Set.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/global-types/set-add-mutate.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {makeArray} from 'shared-runtime';\n\nfunction useHook({el1, el2}) {\n  const s = new Set();\n  const arr = makeArray(el1);\n  s.add(arr);\n  // Mutate after store\n  arr.push(el2);\n\n  s.add(makeArray(el2));\n  return s.size;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useHook,\n  params: [{el1: 1, el2: 'foo'}],\n  sequentialRenders: [\n    {el1: 1, el2: 'foo'},\n    {el1: 2, el2: 'foo'},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Input React Component Definition\nDESCRIPTION: Original React component implementation showing state management with useFeature prop and nested Stringify component rendering\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/allow-props-named-like-hooks.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {Stringify} from 'shared-runtime';\n\nfunction Component({useFeature}) {\n  let x;\n  if (useFeature) {\n    x = [useFeature + useFeature].push(-useFeature);\n  }\n  let y = useFeature;\n  let z = useFeature.useProperty;\n  return (\n    <Stringify val={useFeature}>\n      {x}\n      {y}\n      {z}\n    </Stringify>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{useFeature: {useProperty: true}}],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: Simple React component that creates a function to render a div with a name prop. The component uses a function call pattern to return the rendered content.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/function-expression-prototype-call.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const f = function () {\n    return <div>{props.name}</div>;\n  };\n  return f.call();\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{name: 'Jason'}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a React Component with Logging\nDESCRIPTION: This JavaScript code defines a simple React component that changes its output behavior based on a function passed to it. It includes console logging to demonstrate the flow of execution and outputs 'A', 'arg', and 'original'. This snippet requires React to function appropriately as it is a part of a component structure.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/property-call-evaluation-order.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Should print A, arg, original\n\nfunction Component() {\n  const changeF = o => {\n    o.f = () => console.log('new');\n  };\n  const x = {\n    f: () => console.log('original'),\n  };\n\n  (console.log('A'), x).f((changeF(x), console.log('arg'), 1));\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  isComponent: false,\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Optimization - JavaScript\nDESCRIPTION: This snippet shows the compiled version of the React component. It introduces optimizations such as memoization checks and caching of computed values. The component logic remains the same, but with added performance enhancements.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-expression-computed-key-object-mutated-later.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { identity, mutate } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(5);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = {};\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const key = t0;\n  let t1;\n  if ($[1] !== props.value) {\n    t1 = identity([props.value]);\n    $[1] = props.value;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  let t2;\n  if ($[3] !== t1) {\n    t2 = { [key]: t1 };\n    $[3] = t1;\n    $[4] = t2;\n  } else {\n    t2 = $[4];\n  }\n  const context = t2;\n\n  mutate(key);\n  return context;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ value: 42 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Component with useState - JavaScript\nDESCRIPTION: This code snippet defines a functional React component that uses the useState hook to manage state. It includes three inner functions: foo to update the state, bar to conditionally call foo based on props, and baz to invoke bar. The useState hook initializes the state variable x to 0, and the component returns the current state value in an array. This example is designed to validate that setState is not called during the render cycle.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/validate-no-set-state-in-render-unconditional-lambda-which-conditionally-sets-state-ok.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validateNoSetStateInRender\nimport {useState} from 'react';\n\nfunction Component(props) {\n  const [x, setX] = useState(0);\n\n  const foo = () => {\n    setX(1);\n  };\n\n  const bar = () => {\n    if (props.cond) {\n      // This call is now conditional, so this should pass validation\n      foo();\n    }\n  };\n\n  const baz = () => {\n    bar();\n  };\n  baz();\n\n  return [x];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{cond: false}],\n};\n\n```\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @validateNoSetStateInRender\nimport { useState } from \"react\";\n\nfunction Component(props) {\n  const $ = _c(2);\n  const [x, setX] = useState(0);\n\n  const foo = () => {\n    setX(1);\n  };\n\n  const bar = () => {\n    if (props.cond) {\n      foo();\n    }\n  };\n\n  const baz = () => {\n    bar();\n  };\n\n  baz();\n  let t0;\n  if ($[0] !== x) {\n    t0 = [x];\n    $[0] = x;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ cond: false }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with Console Logging and Object Mutation (Input Version)\nDESCRIPTION: This code snippet defines a React component that demonstrates console logging, object mutation, and function invocation patterns. It creates an object with a method, mutates it, and invokes the method while logging various steps.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/computed-call-evaluation-order.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Should print A, B, arg, original\nfunction Component() {\n  const changeF = o => {\n    o.f = () => console.log('new');\n  };\n  const x = {\n    f: () => console.log('original'),\n  };\n\n  (console.log('A'), x)[(console.log('B'), 'f')](\n    (changeF(x), console.log('arg'), 1)\n  );\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Initializing React Component with useMemo\nDESCRIPTION: Initial implementation of a React component using React.useMemo for expensive number calculation and state management\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/babel-existing-react-runtime-import.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as React from 'react';\nimport {someImport} from 'react/compiler-runtime';\nimport {calculateExpensiveNumber} from 'shared-runtime';\n\nfunction Component(props) {\n  const [x] = React.useState(0);\n  const expensiveNumber = React.useMemo(() => calculateExpensiveNumber(x), [x]);\n\n  return (\n    <div>\n      {expensiveNumber}\n      {`${someImport}`}\n    </div>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Components with Optimization Logic\nDESCRIPTION: This snippet shows the compiled version of the React components, including the optimization logic for the 'use forget' directive. It uses the React compiler runtime and a feature flag to conditionally apply the optimization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/gating-test.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { isForgetEnabled_Fixtures } from \"ReactForgetFeatureFlag\"; // @gating @compilationMode(annotation)\nconst Bar = isForgetEnabled_Fixtures()\n  ? function Bar(props) {\n      \"use forget\";\n      const $ = _c(2);\n      let t0;\n      if ($[0] !== props.bar) {\n        t0 = <div>{props.bar}</div>;\n        $[0] = props.bar;\n        $[1] = t0;\n      } else {\n        t0 = $[1];\n      }\n      return t0;\n    }\n  : function Bar(props) {\n      \"use forget\";\n      return <div>{props.bar}</div>;\n    };\n\nfunction NoForget(props) {\n  return <Bar>{props.noForget}</Bar>;\n}\nconst Foo = isForgetEnabled_Fixtures()\n  ? function Foo(props) {\n      \"use forget\";\n      const $ = _c(2);\n      let t0;\n      if ($[0] !== props.bar) {\n        t0 = <Foo>{props.bar}</Foo>;\n        $[0] = props.bar;\n        $[1] = t0;\n      } else {\n        t0 = $[1];\n      }\n      return t0;\n    }\n  : function Foo(props) {\n      \"use forget\";\n      return <Foo>{props.bar}</Foo>;\n    };\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: eval(\"Bar\"),\n  params: [{ bar: 2 }],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with useMemo Hook\nDESCRIPTION: This React component utilizes the `useMemo` hook to memoize the value of `x` based on the input `a`. It returns a `<Foo>` component with the memoized `x` prop. The hook prevents unnecessary re-renders of the `<Foo>` component if `a` remains unchanged.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-simple.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component(a) {\n  let x = useMemo(() => [a], [a]);\n  return <Foo x={x}></Foo>;\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating defaultValue and value attribute relationship in JavaScript\nDESCRIPTION: Shows how defaultValue directly maps to the value attribute of an input element. When defaultValue is set, the attribute value reflects this change.\nSOURCE: https://github.com/facebook/react/blob/main/fixtures/dom/src/components/fixtures/text-inputs/README.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nvar input = document.createElement('input')\ninput.defaultValue = 'hello'\n\nconsole.log(input.getAttribute('value')) // => \"hello\"\n```\n\n----------------------------------------\n\nTITLE: Input React Component with Error Handling\nDESCRIPTION: Original React component implementation that throws and catches a value from props. Includes a fixture for testing with a value of 42.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-within-object-method-returns-caught-value.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {throwInput} from 'shared-runtime';\n\nfunction Component(props) {\n  const object = {\n    foo() {\n      try {\n        throwInput([props.value]);\n      } catch (e) {\n        return e;\n      }\n    },\n  };\n  return object.foo();\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: 42}],\n};\n```\n\n----------------------------------------\n\nTITLE: Initializing Map and Set Polyfills for React 16\nDESCRIPTION: Example code demonstrating the new JS environment requirements for React 16, including Map, Set, and requestAnimationFrame polyfills for older browser support.\nSOURCE: https://github.com/facebook/react/blob/main/CHANGELOG.md#2025-04-21_snippet_20\n\nLANGUAGE: javascript\nCODE:\n```\nMap && Set && requestAnimationFrame\n```\n\n----------------------------------------\n\nTITLE: Defining React Components with JSX\nDESCRIPTION: Defines several React components showcasing parent-child relationships, props spreading, and conditional rendering. This is the original JSX code before compilation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inline-jsx-transform.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @inlineJsxTransform\n\nfunction Parent({children, a: _a, b: _b, c: _c, ref}) {\n  return <div ref={ref}>{children}</div>;\n}\n\nfunction Child({children}) {\n  return <>{children}</>;\n}\n\nfunction GrandChild({className}) {\n  return (\n    <span className={className}>\n      <React.Fragment key=\"fragmentKey\">Hello world</React.Fragment>\n    </span>\n  );\n}\n\nfunction ParentAndRefAndKey(props) {\n  const testRef = useRef();\n  return <Parent a=\"a\" b={{b: 'b'}} c={C} key=\"testKey\" ref={testRef} />;\n}\n\nfunction ParentAndChildren(props) {\n  const render = () => {\n    return <div key=\"d\">{props.foo}</div>;\n  };\n  return (\n    <Parent>\n      <Child key=\"a\" {...props} />\n      <Child key=\"b\">\n        <GrandChild key=\"c\" className={props.foo} {...props} />\n        {render()}\n      </Child>\n    </Parent>\n  );\n}\n\nconst propsToSpread = {a: 'a', b: 'b', c: 'c'};\nfunction PropsSpread() {\n  return (\n    <>\n      <Test key=\"a\" {...propsToSpread} />\n      <Test key=\"b\" {...propsToSpread} a=\"z\" />\n    </>\n  );\n}\n\nfunction ConditionalJsx({shouldWrap}) {\n  let content = <div>Hello</div>;\n\n  if (shouldWrap) {\n    content = <Parent>{content}</Parent>;\n  }\n\n  return content;\n}\n\nfunction ComponentWithSpreadPropsAndRef({ref, ...other}) {\n  return <Foo ref={ref} {...other} />;\n}\n\n// TODO: Support value blocks\nfunction TernaryJsx({cond}) {\n  return cond ? <div /> : null;\n}\n\nglobal.DEV = true;\nexport const FIXTURE_ENTRYPOINT = {\n  fn: ParentAndChildren,\n  params: [{foo: 'abc'}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Components with Optimization Logic\nDESCRIPTION: This snippet shows the compiled version of the React components. It includes optimization logic based on the 'use forget' directive, using the isForgetEnabled_Fixtures flag to conditionally apply optimizations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/gating-test-export-default-function.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { isForgetEnabled_Fixtures } from \"ReactForgetFeatureFlag\"; // @gating @compilationMode(annotation)\nconst Bar = isForgetEnabled_Fixtures()\n  ? function Bar(props) {\n      \"use forget\";\n      const $ = _c(2);\n      let t0;\n      if ($[0] !== props.bar) {\n        t0 = <div>{props.bar}</div>;\n        $[0] = props.bar;\n        $[1] = t0;\n      } else {\n        t0 = $[1];\n      }\n      return t0;\n    }\n  : function Bar(props) {\n      \"use forget\";\n      return <div>{props.bar}</div>;\n    };\nexport default Bar;\n\nfunction NoForget(props) {\n  return <Bar>{props.noForget}</Bar>;\n}\nconst Foo = isForgetEnabled_Fixtures()\n  ? function Foo(props) {\n      \"use forget\";\n      const $ = _c(2);\n      let t0;\n      if ($[0] !== props.bar) {\n        t0 = <Foo>{props.bar}</Foo>;\n        $[0] = props.bar;\n        $[1] = t0;\n      } else {\n        t0 = $[1];\n      }\n      return t0;\n    }\n  : function Foo(props) {\n      \"use forget\";\n      return <Foo>{props.bar}</Foo>;\n    };\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: eval(\"Bar\"),\n  params: [{ bar: 2 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Creating an Internationalized React Component with FBT\nDESCRIPTION: This snippet demonstrates how to create a React component using the FBT library for internationalization. It includes a parameterized greeting and exports a fixture for testing.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-to-string.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport fbt from 'fbt';\n\nfunction Component(props) {\n  const element = (\n    <fbt desc={'Dialog to show to user'}>\n      Hello <fbt:param name=\"user name\">{props.name}</fbt:param>\n    </fbt>\n  );\n  return element.toString();\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{name: 'Jason'}],\n};\n```\n\n----------------------------------------\n\nTITLE: Simple Baz Component for Item Rendering\nDESCRIPTION: A minimal component that simply returns its input item, used for rendering individual elements\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-outlining-simple.expect.md#2025-04-21_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Baz({i}) {\n  return i;\n}\n```\n\n----------------------------------------\n\nTITLE: Memoizing object creation with useMemo in React\nDESCRIPTION: This code snippet demonstrates how to use `useMemo` to memoize the creation of an object in a React component. The `makeObject_Primitives` function is called only once, and the result is stored in the `object` variable. The `identity` function is called with the object as an argument. The `FIXTURE_ENTRYPOINT` is an exported object that defines the component and its parameters for testing or demonstration purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-maybe-modified-later-dont-preserve-memoization-guarantees.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enablePreserveExistingMemoizationGuarantees:false\nimport {useMemo} from 'react';\nimport {identity, makeObject_Primitives, mutate} from 'shared-runtime';\n\nfunction Component(props) {\n  const object = useMemo(() => makeObject_Primitives(), []);\n  identity(object);\n  return object;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}]\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Flow Type Annotations in JavaScript\nDESCRIPTION: This snippet defines a React component using Flow type annotations. It imports the 'identity' function, defines a component that takes props with an 'id' property, and exports a fixture for testing the component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-annotations/type-annotation-as-number_.flow.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @flow @enableUseTypeAnnotations\nimport {identity} from 'shared-runtime';\n\nfunction Component(props: {id: number}) {\n  const x = identity(props.id);\n  const y = (x: number);\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{id: 42}],\n};\n```\n\n----------------------------------------\n\nTITLE: Testing with a Specific URL\nDESCRIPTION: Speed up testing by passing a specific URL to the test script when launching the DevTools.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/CONTRIBUTING.md#2025-04-21_snippet_7\n\nLANGUAGE: sh\nCODE:\n```\nyarn build:chrome && yarn test:chrome --url=<url-to-test>\n```\n\n----------------------------------------\n\nTITLE: Using Compiler Runtime in React Component\nDESCRIPTION: This snippet demonstrates a React component with enhanced state management via a compiler runtime helper. It adapts the initial mutable state based on property changes, preserving state between renders with a cache-like mechanism. Dependencies include 'react/compiler-runtime'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-at-mutate-after-capture.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // x's mutable range should extend to `mutate(y)`\n\nfunction Component(props) {\n  const $ = _c(2);\n  let x;\n  if ($[0] !== props.b) {\n    x = [42, {}];\n    const idx = foo(props.b);\n    const y = x.at(idx);\n    mutate(y);\n    $[0] = props.b;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  return x;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing React Hooks\nDESCRIPTION: This snippet showcases multiple methods to define hooks using JavaScript functions and arrow functions in the context of a React application. Dependencies include the React library and its useState hook. Each function calls useState to demonstrate valid hook initialization patterns. The inputs and outputs are not explicitly detailed as the focus is on valid function definitions. Constraints include the necessity for the useState function to exist within the React context.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.bail.rules-of-hooks-e0a5db3ae21e.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n\n// @skip\n// Unsupported input\n\n// Valid because hooks can call hooks.\nfunction useHook() {\n  useState();\n}\nconst whatever = function useHook() {\n  useState();\n};\nconst useHook1 = () => {\n  useState();\n};\nlet useHook2 = () => useState();\nuseHook2 = () => {\n  useState();\n};\n({\n  useHook: () => {\n    useState();\n  },\n});\n({\n  useHook() {\n    useState();\n  },\n});\nconst {\n  useHook3 = () => {\n    useState();\n  },\n} = {};\n({\n  useHook = () => {\n    useState();\n  },\n} = {});\nNamespace.useHook = () => {\n  useState();\n};\n\n```\n\n----------------------------------------\n\nTITLE: Performance Optimized Rendering Component - React - JavaScript\nDESCRIPTION: This snippet imports React's compiler-runtime to optimize rendering. It defines a React component that utilizes memoization techniques to cache computed values, thus reducing redundant calculations. The component checks for a sentinel value to determine whether to recalculate rendering time and only updates the output if necessary.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/timers.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  const start = performance.now();\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = Date.now();\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const now = t0;\n  const time = performance.now() - start;\n  let t1;\n  if ($[1] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = (\n      <div>\n        rendering took\n        {time} at {now}\n      </div>\n    );\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Hooks and Stringify\nDESCRIPTION: This snippet defines a React component that uses the useHook custom hook and renders multiple Stringify components. It demonstrates the use of the identity function and component props.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-instruction-part-of-already-closed-scope.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableAssumeHooksFollowRulesOfReact\nimport {Stringify, identity, useHook} from 'shared-runtime';\n\nfunction Component({index}) {\n  const data = useHook();\n\n  const a = identity(data, index);\n  const b = identity(data, index);\n  const c = identity(data, index);\n\n  return (\n    <div>\n      <Stringify value={identity(b)} />\n      <Stringify value={identity(a)} />\n      <Stringify value={identity(c)} />\n    </div>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{index: 0}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic React Component in JavaScript\nDESCRIPTION: This snippet defines a simple React functional component that takes props and renders a div containing a prop value. It serves as a foundation for understanding component creation in React.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-empty-expression.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nexport function Component(props) {\n  return (\n    <div>\n      {}\n      {props.a}\n    </div>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{a: 'hello'}],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Compiler Runtime\nDESCRIPTION: This snippet shows an optimized version of the component using React's compiler runtime. It implements memoization to avoid unnecessary re-computations and array creations. The optimization includes conditional checks to update values only when necessary, potentially improving performance in re-renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-property-inference.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(5);\n  let x;\n  if ($[0] !== props.value) {\n    x = [];\n    x.push(props.value);\n    $[0] = props.value;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  const { length: y } = x;\n  foo(y);\n  let t0;\n  if ($[2] !== x || $[3] !== y) {\n    t0 = [x, y];\n    $[2] = x;\n    $[3] = y;\n    $[4] = t0;\n  } else {\n    t0 = $[4];\n  }\n  return t0;\n}\n```\n\n----------------------------------------\n\nTITLE: Original React Component with Default Parameter\nDESCRIPTION: Defines a simple React component using parameter destructuring with a default value of 2 for parameter 'a'. Includes an export of a fixture entry point for testing.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-object-param-default.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component({a = 2}) {\n  return a;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Error Handling for Mutating Props\nDESCRIPTION: The provided error message indicates that mutating the props that are passed into a React component is disallowed. It suggests using a local variable for modifications to avoid direct mutation of props, which aligns with React's state management and rendering principles.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-mutate-props-via-for-of-iterator.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n  2 |   const items = [];\n  3 |   for (const x of props.items) {\n> 4 |     x.modified = true;\n    |     ^ InvalidReact: Mutating component props or hook arguments is not allowed. Consider using a local variable instead (4:4)\n  5 |     items.push(x);\n  6 |   }\n  7 |   return items;\n```\n\n----------------------------------------\n\nTITLE: Initializing Memoized React Function Component with Array Mapping\nDESCRIPTION: A React function component using compiler runtime optimization to memoize array mapping functions and prevent unnecessary re-renders\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/array-map-named-callback-cross-context.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction useFoo({arr1, arr2}) {\n  const cb1 = e => arr1[0].value + e.value;\n  const getArrMap1 = () => arr1.map(cb1);\n  const cb2 = e => arr2[0].value + e.value;\n  const getArrMap2 = () => arr1.map(cb2);\n  return (\n    <Stringify\n      getArrMap1={getArrMap1}\n      getArrMap2={getArrMap2}\n      shouldInvokeFns={true}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a React Component with useRef\nDESCRIPTION: Original React component implementation that uses useRef to reference an input element and implements a function to modify the ref on button click. This code is annotated with '@validateRefAccessDuringRender' to enable validation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-mutating-ref-in-callback-passed-to-jsx-indirect.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validateRefAccessDuringRender\nimport {useRef} from 'react';\n\nfunction Component() {\n  const ref = useRef(null);\n\n  const setRef = () => {\n    if (ref.current !== null) {\n      ref.current = '';\n    }\n  };\n\n  const onClick = () => {\n    setRef();\n  };\n\n  return (\n    <>\n      <input ref={ref} />\n      <button onClick={onClick} />\n    </>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Hook with Memoization Using Compiler Runtime\nDESCRIPTION: This snippet shows the compiled output of the useFoo hook using React's compiler runtime. It implements memoization to avoid redundant calculations by tracking changes to inputs (cond and value). The compiled version uses a labeled block (bb0) instead of the original label statement and adds dependency tracking for optimization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/align-scopes-reactive-scope-overlaps-label.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { arrayPush } from \"shared-runtime\";\n\nfunction useFoo(t0) {\n  const $ = _c(3);\n  const { cond, value } = t0;\n  let items;\n  if ($[0] !== cond || $[1] !== value) {\n    bb0: {\n      items = [];\n      if (cond) {\n        break bb0;\n      }\n      arrayPush(items, value);\n    }\n\n    arrayPush(items, value);\n    $[0] = cond;\n    $[1] = value;\n    $[2] = items;\n  } else {\n    items = $[2];\n  }\n  return items;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ cond: true, value: 2 }],\n  sequentialRenders: [\n    { cond: true, value: 2 },\n    { cond: true, value: 2 },\n    { cond: true, value: 3 },\n    { cond: false, value: 3 },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component with FBT Implementation\nDESCRIPTION: A React component that uses FBT for internationalization, demonstrating parameter interpolation with a text value. The component wraps text content in FBT tags and includes a parameter placeholder.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-whitespace-within-text.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport fbt from 'fbt';\n\nconst _ = fbt;\nfunction Component({value}: {value: string}) {\n  return (\n    <fbt desc=\"descdesc\">\n      Before text <fbt:param name=\"paramName\">{value}</fbt:param> after text\n      more text and more and more and more and more and more and more and more\n      and more and blah blah blah blah\n    </fbt>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: 'hello world'}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled Output of FBT React Component\nDESCRIPTION: This snippet shows the compiled output of the FBT component after processing by the React compiler. It demonstrates how FBT syntax is transformed into function calls with memoization for performance optimization through the use of the _c compiler runtime function.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-params-complex-param-value.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport fbt from \"fbt\";\n\nfunction Component(props) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== props.name) {\n    t0 = fbt._(\n      \"Hello {user name}\",\n      [fbt._param(\"user name\", capitalize(props.name))],\n      { hk: \"2zEDKF\" },\n    );\n    $[0] = props.name;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled Component with Dependency Tracking (Code)\nDESCRIPTION: This is the compiled version of the `useOnlyConditionalDependencies` React component. It utilizes `react/compiler-runtime` for memoization and dependency tracking. The component checks if the `cond` or `props` have changed to determine if the conditional property reads need to be re-evaluated, optimizing rendering by avoiding unnecessary computations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/no-uncond.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n\"import { c as _c } from \\\"react/compiler-runtime\\\"; // When an object's properties are only read conditionally, we should\\n\\nimport { identity } from \\\"shared-runtime\\\";\\n\\n// track the base object as a dependency.\\nfunction useOnlyConditionalDependencies(t0) {\\n  const $ = _c(3);\\n  const { props, cond } = t0;\\n  let x;\\n  if ($[0] !== cond || $[1] !== props) {\\n    x = {};\\n    if (identity(cond)) {\\n      x.b = props.a.b;\\n      x.c = props.a.b.c;\\n    }\\n    $[0] = cond;\\n    $[1] = props;\\n    $[2] = x;\\n  } else {\\n    x = $[2];\\n  }\\n  return x;\\n}\\n\\nexport const FIXTURE_ENTRYPOINT = {\\n  fn: useOnlyConditionalDependencies,\\n  params: [{ props: { a: { b: 2 } }, cond: true }],\\n  sequentialRenders: [\\n    { props: { a: { b: 2 } }, cond: true },\\n    { props: null, cond: false },\\n    // check we preserve nullthrows\\n    { props: { a: { b: { c: undefined } } }, cond: true },\\n    { props: { a: { b: undefined } }, cond: true },\\n    { props: { a: { b: { c: undefined } } }, cond: true },\\n    { props: undefined, cond: true },\\n  ],\\n};\\n\"\n```\n\n----------------------------------------\n\nTITLE: React Context Access\nDESCRIPTION: This code snippet demonstrates a React component, App, that accesses values from a context called MyContext. It uses the useContext hook to retrieve the context and then destructures the context to extract foo and bar. These values are then passed as props to another component called Bar.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/todo.lower-context-access-mixed-array-obj.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @lowerContextAccess\nfunction App() {\n  const context = useContext(MyContext);\n  const [foo] = context;\n  const {bar} = context;\n  return <Bar foo={foo} bar={bar} />;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing useKeyCommand React Hook - Original Version\nDESCRIPTION: A custom React hook that manages cursor position and provides left/right movement handlers. It uses useRef to maintain position state and returns an array of movement command objects.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/original-reactive-scopes-fork/capture-ref-for-later-mutation.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableReactiveScopesInHIR:false\nimport {useRef} from 'react';\nimport {addOne} from 'shared-runtime';\n\nfunction useKeyCommand() {\n  const currentPosition = useRef(0);\n  const handleKey = direction => () => {\n    const position = currentPosition.current;\n    const nextPosition = direction === 'left' ? addOne(position) : position;\n    currentPosition.current = nextPosition;\n  };\n  const moveLeft = {\n    handler: handleKey('left'),\n  };\n  const moveRight = {\n    handler: handleKey('right'),\n  };\n  return [moveLeft, moveRight];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useKeyCommand,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: This snippet shows the compiled JavaScript version of the React component. It includes memoization logic using the '_c' function from 'react/compiler-runtime' to optimize performance by caching computed values.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-annotations/type-annotation-satisfies-array.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enableUseTypeAnnotations\nfunction Component(props) {\n  const $ = _c(4);\n  let t0;\n  if ($[0] !== props.id) {\n    t0 = makeArray(props.id);\n    $[0] = props.id;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const x = t0 satisfies number[];\n  let t1;\n  if ($[2] !== x) {\n    t1 = x.at(0);\n    $[2] = x;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  const y = t1;\n  return y;\n}\n\nfunction makeArray(x) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== x) {\n    t0 = [x];\n    $[0] = x;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ id: 42 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Hook with Dependency Management - React - JavaScript\nDESCRIPTION: This snippet defines a custom hook 'useFoo' that combines two input values using the 'useNoAlias' function from shared-runtime to ensure proper compilation and state management. It returns an object containing the computed value, ensuring efficient updates only when necessary. The hook is set up for potential optimization with a dependency array mechanism.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-compile-hooks-with-multiple-params.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @compilationMode(infer)\nimport {useNoAlias} from 'shared-runtime';\n\n// This should be compiled by Forget\nfunction useFoo(value1, value2) {\n  return {\n    value: useNoAlias(value1 + value2),\n  };\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [1, 2],\n};\n```\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @compilationMode(infer)\nimport { useNoAlias } from \"shared-runtime\";\n\n// This should be compiled by Forget\nfunction useFoo(value1, value2) {\n  const $ = _c(2);\n\n  const t0 = useNoAlias(value1 + value2);\n  let t1;\n  if ($[0] !== t0) {\n    t1 = { value: t0 };\n    $[0] = t0;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [1, 2],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimizing Component Reactivity with React Compiler Runtime\nDESCRIPTION: This snippet shows an optimized version of the previous component utilizing a React compiler runtime hook for reactivity. It includes logic for updating output based on changes to the input prop `cond`. The component retains its reactive nature and handles caching of values through compiler-specific constructs.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-switch-case-test.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  let x;\n  bb0: switch (props.cond) {\n    case true: {\n      x = 1;\n      break bb0;\n    }\n    case false: {\n      x = 2;\n      break bb0;\n    }\n    default: {\n      x = 3;\n    }\n  }\n  let t0;\n  if ($[0] !== x) {\n    t0 = [x];\n    $[0] = x;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  sequentialRenders: [\n    { cond: true },\n    { cond: true },\n    { cond: false },\n    { cond: false },\n    { cond: true },\n    { cond: false },\n    { cond: true },\n    { cond: false },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining useInvalidMutation Hook - JavaScript\nDESCRIPTION: This snippet defines a custom hook 'useInvalidMutation' that contains a nested function 'test'. The 'test' function tries to mutate the 'options.foo' property directly, which violates React's rule against mutating props or hook arguments. This example demonstrates a common pitfall in React development where developers might mistakenly modify these immutable values.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-mutation-in-closure.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction useInvalidMutation(options) {\n  function test() {\n    foo(options.foo); // error should not point on this line\n    options.foo = 'bar';\n  }\n  return test;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: React component that uses useMemo to cache computed values and handle array operations. Takes array props and a boolean flag to determine concatenation behavior.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useMemo-reordering-depslist-controlflow.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useMemo} from 'react';\nimport {Stringify} from 'shared-runtime';\n\nfunction Foo({arr1, arr2, foo}) {\n  const x = [arr1];\n\n  let y = [];\n\n  const val1 = useMemo(() => {\n    return {x: 2};\n  }, []);\n\n  const val2 = useMemo(() => {\n    return [y];\n  }, [foo ? (y = x.concat(arr2)) : y]);\n\n  return <Stringify val1={val1} val2={val2} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{arr1: [1, 2], arr2: [3, 4], foo: true}],\n  sequentialRenders: [\n    {arr1: [1, 2], arr2: [3, 4], foo: true},\n    {arr1: [1, 2], arr2: [3, 4], foo: false},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing useFoo Component with Memoization and Mutation in React\nDESCRIPTION: This snippet defines a React component 'useFoo' that demonstrates memoization and mutation. It includes logic to handle potential aliasing issues and throws an error if unexpected behavior occurs. The component takes an object with 'a' and 'b' properties as input and returns an array.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/nonmutating-capture-in-unsplittable-memo-block.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {identity, mutate} from 'shared-runtime';\n\n/**\n * Currently, InferReactiveScopeVariables do not ensure that maybe-aliased\n * values get assigned the same reactive scope. This is safe only when an\n * already-constructed value is captured, e.g.\n * ```js\n * const x = makeObj();   mutable range of x\n * mutate(x);            \n *                       <-- after this point, we can produce a canonical version\n *                           of x for all following aliases\n * const y = [];\n * y.push(x);            <-- y captures x\n * ```\n *\n * However, if a value is captured/aliased during its mutable range and the\n * capturing container is separately memoized, it becomes difficult to guarantee\n * that all aliases refer to the same value.\n *\n */\nfunction useFoo({a, b}) {\n  const x = {a};\n  const y = {};\n  mutate(x);\n  const z = [identity(y), b];\n  mutate(y);\n\n  if (z[0] !== y) {\n    throw new Error('oh no!');\n  }\n  return z;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{a: 2, b: 3}],\n  sequentialRenders: [\n    {a: 2, b: 3},\n    {a: 4, b: 3},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Using useNoAlias in a React Component - JavaScript\nDESCRIPTION: This snippet defines a React functional component that utilizes the 'useNoAlias' function from the 'shared-runtime' package. The purpose is to create an object 'item' using properties from 'props' and then pass it to 'useNoAlias' for efficient handling. Key functionality includes logging 'props' whenever 'props.a' changes, which demonstrates dependency tracking. It assumes that 'useNoAlias' is a custom hook that might handle side effects or optimization strategies, and requires 'shared-runtime' as a prerequisite.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hook-noAlias.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useNoAlias} from 'shared-runtime';\n\nfunction Component(props) {\n  const item = {a: props.a};\n  const x = useNoAlias(item, () => {\n    console.log(props);\n  }, [props.a]);\n  return [x, item];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{a: {id: 42}}],\n  isComponent: true,\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with useMemo\nDESCRIPTION: This snippet defines a React functional component that uses the useMemo hook. It attempts to create a memoized value based on an asynchronous operation, which is not valid as useMemo is meant for synchronous return values. The callback provided to useMemo cannot be an async function, leading to a runtime error.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-useMemo-async-callback.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component(a, b) {\n  let x = useMemo(async () => {\n    await a;\n  }, []);\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Input FBT Implementation for Pluralization\nDESCRIPTION: Original source code showing FBT usage for pluralization and parameter interpolation. Uses the useIdentity hook and handles plural forms of 'is/are' based on item count.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/repro-macro-property-not-handled.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport fbt from 'fbt';\nimport {useIdentity} from 'shared-runtime';\n\n/**\n * MemoizeFbtAndMacroOperandsInSameScope should also track PropertyLoads (e.g. fbt.plural).\n * This doesn't seem to be an issue for fbt, but affects other internal macros invoked as\n * `importSpecifier.funcName` (see https://fburl.com/code/72icxwmn)\n */\nfunction useFoo({items}: {items: Array<number>}) {\n  return fbt(\n    'There ' +\n      fbt.plural('is', useIdentity([...items]).length, {many: 'are'}) +\n      ' ' +\n      fbt.param('number of items', items.length) +\n      ' items',\n    'Error content when there are unsupported locales.',\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{items: [2, 3]}],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component Definition with Fixture Export\nDESCRIPTION: Defines a React functional component that renders 'Hello World' and exports it as a fixture with metadata. The component uses a custom directive 'use no forget' and is configured with an empty params array and isComponent flag.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/use-no-forget-with-no-errors.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component() {\n  'use no forget';\n  return <div>Hello World</div>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  isComponent: true,\n};\n```\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component() {\n  \"use no forget\";\n  return <div>Hello World</div>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  isComponent: true,\n};\n```\n\n----------------------------------------\n\nTITLE: Optimizing React Component with Compiler Runtime in JavaScript\nDESCRIPTION: This JavaScript snippet introduces optimizations for a React component by using runtime checks and compiler runtime constructs. It ensures efficient rendering by caching the items and their mapped JSX elements, reducing unnecessary re-rendering.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/todo.unnecessary-lambda-memoization.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(4);\n  const data = useFreeze();\n  let t0;\n  if ($[0] !== data.items) {\n    t0 = data.items.map(_temp);\n    $[0] = data.items;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const items = t0;\n  let t1;\n  if ($[2] !== items) {\n    t1 = <div>{items}</div>;\n    $[2] = items;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  return t1;\n}\nfunction _temp(item) {\n  return <Item item={item} />;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Hooks and Global State\nDESCRIPTION: This snippet defines a React component using useState, useCallback, and useEffect hooks. It interacts with a global state and renders the state value.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-global-mutation-in-effect-indirect-usecallback.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees\nimport {useCallback, useEffect, useState} from 'react';\n\nlet someGlobal = {};\n\nfunction Component() {\n  const [state, setState] = useState(someGlobal);\n\n  const setGlobal = useCallback(() => {\n    someGlobal.value = true;\n  }, []);\n  useEffect(() => {\n    setGlobal();\n  }, []);\n\n  useEffect(() => {\n    setState(someGlobal.value);\n  }, [someGlobal]);\n\n  return <div>{String(state)}</div>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Initializing React Component with Incorrect State Mutation\nDESCRIPTION: Example of an anti-pattern where state is directly mutated instead of using the setter function. This approach violates React's immutability principles and will trigger rendering issues.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.modify-state.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useState} from 'react';\n\nfunction Foo() {\n  let [state, setState] = useState({});\n  state.foo = 1;\n  return state;\n}\n```\n\nLANGUAGE: text\nCODE:\n```\n  3 | function Foo() {\n  4 |   let [state, setState] = useState({});\n> 5 |   state.foo = 1;\n    |   ^^^^^ InvalidReact: Mutating a value returned from 'useState()', which should not be mutated. Use the setter function to update instead (5:5)\n  6 |   return state;\n  7 | }\n```\n\n----------------------------------------\n\nTITLE: Input: React Hook with Conditional Dependency Superpath\nDESCRIPTION: A React hook function that demonstrates dependency tracking when an unconditional dependency (props.a) is the superpath of a conditional dependency (props.a.b). It includes test cases for various input scenarios including null and undefined values.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/superpath-order2.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// When an unconditional dependency `props.a` is the subpath of a conditional\n// dependency `props.a.b`, we can safely overestimate and only track `props.a`\n// as a dependency\n\nimport {identity} from 'shared-runtime';\n\n// ordering of accesses should not matter\nfunction useConditionalSuperpath2({props, cond}) {\n  const x = {};\n  if (identity(cond)) {\n    x.b = props.a.b;\n  }\n  x.a = props.a;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useConditionalSuperpath2,\n  params: [{props: {a: null}, cond: false}],\n  sequentialRenders: [\n    {props: {a: null}, cond: false},\n    {props: {a: {}}, cond: true},\n    {props: {a: {b: 3}}, cond: true},\n    {props: {}, cond: false},\n    // test that we preserve nullthrows\n    {props: {a: {b: undefined}}, cond: true},\n    {props: {a: undefined}, cond: true},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component with Map Function\nDESCRIPTION: A React functional component that takes props containing an items array and maps each item to a Stringify component. The component destructures the id and name from each item and uses them as props.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/outlined-destructured-params.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {Stringify} from 'shared-runtime';\n\nfunction Component(props) {\n  // test outlined functions with destructured parameters - the\n  // temporary for the destructured param must be promoted\n  return (\n    <>\n      {props.items.map(({id, name}) => (\n        <Stringify key={id} name={name} />\n      ))}\n    </>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{items: [{id: 1, name: 'one'}]}],\n};\n```\n\n----------------------------------------\n\nTITLE: Transformed React Component with Compiler Runtime\nDESCRIPTION: This is the transformed code of the React component using the React compiler runtime.  It shows how the compiler optimizes the component using memoization and caching to avoid unnecessary re-renders and re-creations of functions and elements.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useCallback-set-ref-nested-property-preserve-memoization.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enablePreserveExistingMemoizationGuarantees\nimport { useCallback, useRef } from \"react\";\n\nfunction Component(props) {\n  const $ = _c(3);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = { inner: null };\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const ref = useRef(t0);\n  let t1;\n  if ($[1] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = (event) => {\n      ref.current.inner = event.target.value;\n    };\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  const onChange = t1;\n  let t2;\n  if ($[2] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t2 = <input onChange={onChange} />;\n    $[2] = t2;\n  } else {\n    t2 = $[2];\n  }\n  return t2;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}]],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Memoized React Component with React Compiler Runtime\nDESCRIPTION: This React component uses `react/compiler-runtime` to optimize rendering.  It memoizes the result of mapping over `props.post.feedback.comments?.edges` using the `render` function. It conditionally renders the comments only if the `props.post.feedback.comments?.edges` has changed, preventing unnecessary re-renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-dependencies-non-optional-properties-inside-optional-chain.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== props.post.feedback.comments?.edges) {\n    t0 = props.post.feedback.comments?.edges?.map(render);\n    $[0] = props.post.feedback.comments?.edges;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Optimizations\nDESCRIPTION: Compiled version of the React component with added optimization logic including caching mechanisms and dependency tracking. Shows how the compiler transforms the code for better performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useEffect-arg-memoized.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(6);\n  const dispatch = useDispatch();\n  useFreeze(dispatch);\n  let t0;\n  if ($[0] !== dispatch) {\n    t0 = () => {\n      dispatch({ kind: \"update\" });\n    };\n    $[0] = dispatch;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const onUpdate = t0;\n  let t1;\n  let t2;\n  if ($[2] !== onUpdate) {\n    t1 = () => {\n      onUpdate();\n    };\n    t2 = [onUpdate];\n    $[2] = onUpdate;\n    $[3] = t1;\n    $[4] = t2;\n  } else {\n    t1 = $[3];\n    t2 = $[4];\n  }\n  useEffect(t1, t2);\n  let t3;\n  if ($[5] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t3 = <div />;\n    $[5] = t3;\n  } else {\n    t3 = $[5];\n  }\n  return t3;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Component with Array Manipulation - React - JavaScript\nDESCRIPTION: This snippet defines a React functional component that merges two arrays from props into a single array, inserting a null between them. It utilizes the 'makeArray' utility function for this transformation. The component is intended for integration in a testing fixture, which provides its parameters in a structured way.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/call-spread.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {makeArray} from 'shared-runtime';\n\nfunction Component(props) {\n  const x = makeArray(...props.a, null, ...props.b);\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{a: [1, 2], b: [2, 3, 4]}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Optimization\nDESCRIPTION: The compiled version of the React component using compiler runtime optimizations. Implements memoization and caching strategies through Symbol sentinels and temporary variables to improve performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-memoize-array-with-immutable-map-after-hook.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useEffect, useState } from \"react\";\n\nfunction Component(props) {\n  const $ = _c(10);\n  let t0;\n  if ($[0] !== props.value) {\n    t0 = [props.value];\n    $[0] = props.value;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const x = t0;\n  let t1;\n  if ($[2] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = [];\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  useEffect(_temp, t1);\n  let t2;\n  if ($[3] !== x.length) {\n    t2 = () => {\n      console.log(x.length);\n    };\n    $[3] = x.length;\n    $[4] = t2;\n  } else {\n    t2 = $[4];\n  }\n  const onClick = t2;\n  let t3;\n  if ($[5] !== x) {\n    t3 = x.map(_temp2);\n    $[5] = x;\n    $[6] = t3;\n  } else {\n    t3 = $[6];\n  }\n  let t4;\n  if ($[7] !== onClick || $[8] !== t3) {\n    t4 = <div onClick={onClick}>{t3}</div>;\n    $[7] = onClick;\n    $[8] = t3;\n    $[9] = t4;\n  } else {\n    t4 = $[9];\n  }\n  return t4;\n}\nfunction _temp2(item) {\n  return <span key={item}>{item}</span>;\n}\nfunction _temp() {}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ value: 42 }],\n  isComponent: true,\n};\n```\n\n----------------------------------------\n\nTITLE: Optimizing Component Logic in JavaScript\nDESCRIPTION: This snippet redefines the 'Component' function by introducing an optimization check via the '_c' function. This version utilizes a caching mechanism to avoid re-computing the component's output when the input props remain unchanged, enhancing performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-leave-case.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from 'react/compiler-runtime';\nimport { Stringify } from 'shared-runtime';\n\nfunction Component(props) {\n  const $ = _c(3);\n  let t0;\n  if ($[0] !== props.p0 || $[1] !== props.p1) {\n    const x = [];\n    let y;\n    if (props.p0) {\n      x.push(props.p1);\n      y = x;\n    }\n\n    t0 = (\n      <Stringify>\n        {x}\n        {y}\n      </Stringify>\n    );\n    $[0] = props.p0;\n    $[1] = props.p1;\n    $[2] = t0;\n  } else {\n    t0 = $[2];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ p0: false, p1: 2 }],\n  sequentialRenders: [\n    { p0: false, p1: 2 },\n    { p0: false, p1: 2 },\n    { p0: true, p1: 2 },\n    { p0: true, p1: 3 },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Creating a React Hook with Hook Usage (JavaScript)\nDESCRIPTION: This code defines a function `createHook` that returns another function, `useHookWithHook`. The returned function represents a custom React hook that internally calls the `useHook` function. This demonstrates that React hooks can indeed call other hooks within their implementation, which is a valid and common pattern for creating more complex and reusable hook logic.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-33a6e23edac1.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @compilationMode(infer)\n// Valid because hooks can use hooks.\nfunction createHook() {\n  return function useHookWithHook() {\n    useHook();\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with Memoization and Validation\nDESCRIPTION: This snippet defines a React component that uses useMemo for memoization and SharedRuntime for validation. It creates memoized objects based on props and validates the memoization using SharedRuntime.ValidateMemoization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-provider-store-capture-namespace-import.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useMemo} from 'react';\nimport * as SharedRuntime from 'shared-runtime';\n\nexport function Component({a, b}) {\n  const item1 = useMemo(() => ({a}), [a]);\n  const item2 = useMemo(() => ({b}), [b]);\n  const items = useMemo(() => {\n    const items = [];\n    SharedRuntime.typedArrayPush(items, item1);\n    SharedRuntime.typedArrayPush(items, item2);\n    return items;\n  }, [item1, item2]);\n\n  return (\n    <>\n      <SharedRuntime.ValidateMemoization inputs={[a]} output={items[0]} />\n      <SharedRuntime.ValidateMemoization inputs={[b]} output={items[1]} />\n      <SharedRuntime.ValidateMemoization inputs={[a, b]} output={items} />\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled useCallback with Compiler-Runtime\nDESCRIPTION: This is the compiled version of the previous code snippet. It demonstrates how the React compiler automatically memoizes the function based on the `propA` prop. The `_c` function from `react/compiler-runtime` is used to manage the memoization cache, storing the previous value of `propA` and the memoized function.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useCallback-with-no-depslist.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @validatePreserveExistingMemoizationGuarantees\nimport { useCallback } from \"react\";\n\n// Compiler can produce any memoization it finds valid if the\n// source listed no memo deps\nfunction Component(t0) {\n  const $ = _c(2);\n  const { propA } = t0;\n  let t1;\n  if ($[0] !== propA) {\n    t1 = () => [propA];\n    $[0] = propA;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ propA: 2 }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Optimized React Component with Compiler Runtime\nDESCRIPTION: A React component that uses compiler runtime for performance optimization. It conditionally renders a Button component based on changes to the 'x' prop, using array-based memoization through the compiler runtime.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/apps/playground/__tests__/e2e/__snapshots__/page.spec.ts/01-user-output.txt#2025-04-21_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nexport default function TestComponent(t0) {\n  const $ = _c(2);\n  const { x } = t0;\n  let t1;\n  if ($[0] !== x) {\n    t1 = <Button>{x}</Button>;\n    $[0] = x;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n```\n\n----------------------------------------\n\nTITLE: Direct Implementation of Custom Hook - JavaScript\nDESCRIPTION: The snippet provides a basic implementation of the custom hook useFoo without React-specific optimizations, focusing on managing object properties based on a null check. It does not require additional dependencies besides JavaScript execution environment. The hook logic involves conditionally populating an array with object properties. Expected input is an object with obj and objIsNull properties. The function outputs an array. This version directly highlights the functional behavior without external optimizations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-cond-deps-break-in-scope.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction useFoo({obj, objIsNull}) {\n  const x = [];\n  b0: {\n    if (objIsNull) {\n      break b0;\n    } else {\n      x.push(obj.a);\n    }\n    x.push(obj.b);\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{obj: null, objIsNull: true}],\n  sequentialRenders: [\n    {obj: null, objIsNull: true},\n    {obj: {a: 2}, objIsNull: false},\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Component with useEffect and State Update\nDESCRIPTION: This React component initializes a state variable `state` using `useState`. It then defines two functions, `f` and `g`, where `g` calls `f`, which updates the state using `setState`. The `useEffect` hook then calls `g`, which indirectly updates the state. This can cause performance issues as highlighted in the logs.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/invalid-setState-in-useEffect-transitive.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @logger @validateNoSetStateInPassiveEffects\nimport {useEffect, useState} from 'react';\n\nfunction Component() {\n  const [state, setState] = useState(0);\n  const f = () => {\n    setState(s => s + 1);\n  };\n  const g = () => {\n    f();\n  };\n  useEffect(() => {\n    g();\n  });\n  return state;\n}\n\n```\n\n----------------------------------------\n\nTITLE: React Component Compiled Output with Memoization\nDESCRIPTION: Compiled version of the component implementing memoization pattern. Uses compiler runtime utilities and Symbol.for() to implement caching. Shows how the mutable state and JSX are transformed into optimized code.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/global-jsx-tag-lowered-between-mutations.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const maybeMutable = new MaybeMutable();\n\n    t0 = <View>{maybeMutate(maybeMutable)}</View>;\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Reactive Component with Conditional Logic\nDESCRIPTION: A React component that demonstrates complex reactivity through array mutations and nested control flow. Shows how React's compiler tracks reactive dependencies across different code paths and array manipulations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-from-interleaved-reactivity-for-test.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  // a and b are independent but their mutations are interleaved, so\n  // they get grouped in a reactive scope. this means that a becomes\n  // reactive since it will effectively re-evaluate based on a reactive\n  // input\n  const a = [];\n  const b = [];\n  b.push(props.cond);\n  a.push(10);\n\n  // Downstream consumer of a, which initially seems non-reactive except\n  // that a becomes reactive, per above\n  const c = [a];\n\n  let x;\n  for (let i = 0; i < c[0][0]; i++) {\n    x = 1;\n  }\n  // The values assigned to `x` are non-reactive, but the value of `x`\n  // depends on the \"control\" value `c[0]` which becomes reactive via\n  // being interleaved with `b`.\n  // Therefore x should be treated as reactive too.\n  return [x];\n}\n```\n\n----------------------------------------\n\nTITLE: React Component with Mutable References using let\nDESCRIPTION: Example component showing mutable variable declarations using let. Demonstrates how variables can be aliased and mutated through references even when not directly modified in the code.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/mutable-liverange-loop.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction mutate() {}\nfunction cond() {}\n\nfunction Component(props) {\n  let a = {};\n  let b = {};\n  let c = {};\n  let d = {};\n  while (true) {\n    mutate(a, b);\n    if (cond(a)) {\n      break;\n    }\n  }\n\n  // all of these tests are seemingly readonly, since the values are never directly\n  // mutated again. but they are all aliased by `d`, which is later modified, and\n  // these are therefore mutable references:\n  if (a) {\n  }\n  if (b) {\n  }\n  if (c) {\n  }\n  if (d) {\n  }\n\n  mutate(d, null);\n}\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Memoization (JavaScript)\nDESCRIPTION: This snippet shows the compiler-optimized version of the 'Foo' component. It replaces the useMemo hook with a more efficient implementation using React's compiler runtime, preserving memoization guarantees while potentially improving performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useMemo-dep-array-literal-access.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @validatePreserveExistingMemoizationGuarantees\n\nimport { useMemo } from \"react\";\nimport { makeArray } from \"shared-runtime\";\n\n// We currently only recognize \"hoistable\" values (e.g. variable reads\n// and property loads from named variables) in the source depslist.\n// This makes validation logic simpler and follows the same constraints\n// from the eslint react-hooks-deps plugin.\nfunction Foo(props) {\n  const $ = _c(4);\n  let t0;\n  if ($[0] !== props) {\n    t0 = makeArray(props);\n    $[0] = props;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const x = t0;\n  let t1;\n  let t2;\n  if ($[2] !== x[0]) {\n    t2 = [x[0]];\n    $[2] = x[0];\n    $[3] = t2;\n  } else {\n    t2 = $[3];\n  }\n  t1 = t2;\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{ val: 1 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Using useMemo for Component Rendering in React\nDESCRIPTION: This snippet defines a React functional component that utilizes the useMemo hook to optimize rendering based on the props passed to it. It memoizes the output from a function prop, ensuring that the component only re-renders when the input prop changes. This is useful for performance optimization in larger applications. The component also uses ValidateMemoization to validate the memoized output against the current props inputs.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/props-method-dependency.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @compilationMode(infer)\nimport {useMemo} from 'react';\nimport {ValidateMemoization} from 'shared-runtime';\n\nfunction Component(props) {\n  const x = useMemo(() => props.x(), [props.x]);\n  return <ValidateMemoization inputs={[props.x]} output={x} />;\n}\n\nconst f = () => ['React'];\nconst g = () => ['Compiler'];\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{x: () => ['React']}],\n  sequentialRenders: [{x: f}, {x: g}, {x: g}, {x: f}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Debugging Unit Tests\nDESCRIPTION: Connect tests to a debugger for a more thorough testing experience.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/CONTRIBUTING.md#2025-04-21_snippet_9\n\nLANGUAGE: sh\nCODE:\n```\nyarn debug-test-build-devtools\n```\n\n----------------------------------------\n\nTITLE: Using Memoization in a Functional Component - JavaScript\nDESCRIPTION: This snippet demonstrates a React component utilizing memoization for performance optimization. It initializes arrays conditionally based on a cache sentinel and returns the processed arrays. This showcases advanced React features.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-map-frozen-array-noAlias.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = [];\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const x = t0;\n  let t1;\n  if ($[1] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const y = x.map(_temp);\n    t1 = [x, y];\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\nfunction _temp(item) {\n  return item;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Memoization using React.memo with Hooks - JavaScript\nDESCRIPTION: This snippet illustrates the valid use of hooks within anonymous function arguments to React.memo in JavaScript. It defines a functional component that utilizes a hook to render a button element. The snippet involves conditions to optimize the rendering process, crucial for performance improvements. The key dependency is React and an understanding of hooks is necessary.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.bail.rules-of-hooks-28a78701970c.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @skip\n// Unsupported input\n\n// Valid because hooks can be used in anonymous function arguments to\n// React.memo.\nconst MemoizedFunction = React.memo(props => {\n  useHook();\n  return <button {...props} />;\n});\n```\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @skip\n// Unsupported input\n\n// Valid because hooks can be used in anonymous function arguments to\n// React.memo.\nconst MemoizedFunction = React.memo((props) => {\n  const $ = _c(2);\n  useHook();\n  let t0;\n  if ($[0] !== props) {\n    t0 = <button {...props} />;\n    $[0] = props;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n});\n```\n\n----------------------------------------\n\nTITLE: Demonstrating React Component Ownership in JSX\nDESCRIPTION: This code example illustrates the concept of component ownership in React, showing how props are passed from an owner component to its rendered elements.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/CHANGELOG.md#2025-04-21_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\n<Parent><Child /></Parent>\n```\n\n----------------------------------------\n\nTITLE: Importing useCallback in JavaScript\nDESCRIPTION: Illustrates the import of useCallback from React, defining a custom hook function that returns a memoized function based on specified dependencies. The code snippet shows the function useFoo that takes two arguments and memoizes a function with the primary dependency being the first argument.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useCallback-infer-fewer-deps.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees\n\nimport {useCallback} from 'react';\n\n// It's correct to produce memo blocks with fewer deps than source\nfunction useFoo(a, b) {\n  return useCallback(() => [a], [a, b]);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [1, 2],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with Object Manipulation\nDESCRIPTION: This snippet defines a React component that creates an array of objects, iterates over them, and modifies the last item. It also exports a fixture for testing purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-of-capture-item-of-local-collection-mutate-later.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {makeObject_Primitives} from 'shared-runtime';\n\nfunction Component(props) {\n  let lastItem = {};\n  const items = [makeObject_Primitives(), makeObject_Primitives()];\n  for (const x of items) {\n    lastItem = x;\n  }\n  if (lastItem != null) {\n    lastItem.a += 1;\n  }\n  return items;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n  sequentialRenders: [{}, {}],\n};\n```\n\n----------------------------------------\n\nTITLE: Creating a useRef-based Custom Hook in React\nDESCRIPTION: This snippet defines a custom React hook named `useArrayOfRef` that utilizes the `useRef` hook to create a mutable reference. A callback function is defined to update the `current` property of the ref, which is then returned as part of an array. The purpose of this hook is to provide a way to access and modify a value without causing re-renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-ref-type-cast-in-render.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useRef} from 'react';\n\nfunction useArrayOfRef() {\n  const ref = useRef(null);\n  const callback = value => {\n    ref.current = value;\n  };\n  return [callback] as const;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: () => {\n    useArrayOfRef();\n    return 'ok';\n  },\n  params: [{}] \n};\n\n```\n\n----------------------------------------\n\nTITLE: Prepare Release from CI Script\nDESCRIPTION: This script downloads pre-built release artifacts from CI (e.g., CircleCI) for a specific commit. It is used in the process of publishing either a 'next' or 'experimental' release.  Before publishing, manual testing is recommended after running this script to verify the build.\nSOURCE: https://github.com/facebook/react/blob/main/scripts/release/README.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nscripts/release/prepare-release-from-ci.js -r stable --commit=0e526bc\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Runtime Optimization\nDESCRIPTION: This snippet shows the compiled version of the React component using `react/compiler-runtime`. It utilizes caching and conditional execution based on the input parameters 'foo' and 'bar'. The `_c` function from the compiler runtime is used to cache the component's state and avoid unnecessary re-execution if the inputs haven't changed.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-alias-captured-mutate-arr-iife.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nconst { mutate } = require(\"shared-runtime\");\n\nfunction component(foo, bar) {\n  const $ = _c(3);\n  let y;\n  if ($[0] !== bar || $[1] !== foo) {\n    const x = { foo };\n    y = { bar };\n\n    const a = [y];\n    const b = x;\n    a.x = b;\n\n    mutate(y);\n    $[0] = bar;\n    $[1] = foo;\n    $[2] = y;\n  } else {\n    y = $[2];\n  }\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: [\"foo\", \"bar\"],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Preserving Nullthrows Behavior in React JavaScript\nDESCRIPTION: This JavaScript snippet defines a React component that manages its internal state by conditionally accessing properties of the input props. The component creates an array, conditionally pushing the property 'props.a.b' based on its presence. The snippet emphasizes the preservation of nullthrows behavior and defining dependencies correctly. This approach ensures that the code remains reactive. No external dependencies are required beyond standard React imports.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/conditional-member-expr.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enablePropagateDepsInHIR\n// To preserve the nullthrows behavior and reactive deps of this code,\n// Forget needs to add `props.a` as a dependency (since `props.a.b` is\n// a conditional dependency, i.e. gated behind control flow)\n\nfunction Component(props) {\n  let x = [];\n  x.push(props.a?.b);\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{a: null}],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Memoization in a React Component using JavaScript\nDESCRIPTION: This code snippet enhances a React component with memoization capabilities. Utilizing the React compiler runtime, it checks for a memo cache sentinel symbol to determine if the component's output can be retrieved from cache, optimizing performance. Dependencies include React and the React compiler runtime.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/call-args-assignment.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(1);\n  let x;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    x = makeObject();\n    x.foo((x = makeObject()));\n    $[0] = x;\n  } else {\n    x = $[0];\n  }\n  return x;\n}\n\n```\n\n----------------------------------------\n\nTITLE: React Component Compiled Output\nDESCRIPTION: This code shows the compiled output for the React component `useFoo`. The compiler has introduced memoization using `_c` from `react/compiler-runtime` and `_makeReadOnly` from `react-compiler-runtime` to avoid re-rendering if the input `props.x` hasn't changed. The component now stores the result of `foo(props.x)` in a cache and reuses it if `props.x` is the same.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/emit-freeze-conflicting-imports.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { makeReadOnly as _makeReadOnly } from \"react-compiler-runtime\";\nimport { c as _c } from \"react/compiler-runtime\"; // @enableEmitFreeze @instrumentForget\n\nlet makeReadOnly = \"conflicting identifier\";\nfunction useFoo(props) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== props.x) {\n    t0 = foo(props.x);\n    $[0] = props.x;\n    $[1] = __DEV__ ? _makeReadOnly(t0, \"useFoo\") : t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with useMemo and useEffect\nDESCRIPTION: This code snippet presents a compiled version of the `useFoo` component, potentially optimized by the `react/compiler-runtime`.  It utilizes the `_c` function (likely a compiler runtime utility) to manage memoization and caching. The compiled code aims to achieve the same behavior as the original, where a function calling `someGlobal` is memoized and then called within `useEffect`.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useEffect-namespace-pruned.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport * as React from \"react\";\n\nfunction someGlobal() {}\nfunction useFoo() {\n  const $ = _c(2);\n  let t0;\n  t0 = _temp;\n  const fn = t0;\n  let t1;\n  let t2;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = () => {\n      fn();\n    };\n    t2 = [fn];\n    $[0] = t1;\n    $[1] = t2;\n  } else {\n    t1 = $[0];\n    t2 = $[1];\n  }\n  React.useEffect(t1, t2);\n  return null;\n}\nfunction _temp() {\n  someGlobal();\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [],\n  isComponent: false,\n};\n\n```\n\n----------------------------------------\n\nTITLE: Incorrect React Hook Usage\nDESCRIPTION: This JavaScript snippet demonstrates how a React hook (`Foo.useFoo`) should not be used. Instead of calling the hook directly, it's assigned to a variable `x`, and then `x` is called. This is an invalid usage of React hooks and will result in an error.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.propertyload-hook.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component() {\n  const x = Foo.useFoo;\n  return x();\n}\n\n```\n\n----------------------------------------\n\nTITLE: React Compiler Runtime Optimized Component\nDESCRIPTION: Compiled version of the React component using React compiler runtime with memoization and performance optimization techniques\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-outlining-simple.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(t0) {\n  const $ = _c(7);\n  const { arr } = t0;\n  const x = useX();\n  let t1;\n  if ($[0] !== arr || $[1] !== x) {\n    let t2;\n    if ($[3] !== x) {\n      t2 = (i, id) => {\n        const T0 = _temp;\n        return <T0 i={i} key={id} x={x} />;\n      };\n      $[3] = x;\n      $[4] = t2;\n    } else {\n      t2 = $[4];\n    }\n    t1 = arr.map(t2);\n    $[0] = arr;\n    $[1] = x;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  let t2;\n  if ($[5] !== t1) {\n    t2 = <>{t1}</>;\n    $[5] = t1;\n    $[6] = t2;\n  } else {\n    t2 = $[6];\n  }\n  return t2;\n}\n```\n\n----------------------------------------\n\nTITLE: React Error: Invalid Update\nDESCRIPTION: This error message indicates that a value used previously in JSX is being updated.  React's rendering process expects values used in JSX to remain immutable. The error suggests moving the mutation before the JSX usage to avoid the issue.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-mutate-after-aliased-freeze.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n  11 |   // y is MaybeFrozen at this point, since it may alias to x\n  12 |   // (which is the above line freezes)\n> 13 |   y.push(props.p2);\n     |   ^ InvalidReact: Updating a value used previously in JSX is not allowed. Consider moving the mutation before the JSX (13:13)\n  14 |\n  15 |   return <Component x={x} y={y} />;\n  16 | }\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component With Caching\nDESCRIPTION: Compiled version of the component that implements memoization using Symbol.for() checks and a cache array. Adds optimization for repeated computations and rendering.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/allow-locals-named-like-hooks.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { makeObject_Primitives, Stringify } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(2);\n  const useFeature = makeObject_Primitives();\n  let x;\n  if (useFeature) {\n    let t0;\n    if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n      t0 = [useFeature + useFeature].push(-useFeature);\n      $[0] = t0;\n    } else {\n      t0 = $[0];\n    }\n    x = t0;\n  }\n\n  const y = useFeature;\n  const z = useFeature.useProperty;\n  let t0;\n  if ($[1] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = (\n      <Stringify val={useFeature}>\n        {x}\n        {y}\n        {z}\n      </Stringify>\n    );\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining React Hook with Change Variable Codegen Enabled\nDESCRIPTION: This snippet defines a React hook 'useFoo' with Change Variable Codegen enabled. It imports the 'identity' function, defines some module-level constants, and exports a fixture entrypoint for testing.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rename-source-variables.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableChangeVariableCodegen\nimport {identity} from 'shared-runtime';\n\nconst $ = 'module_$';\nconst t0 = 'module_t0';\nconst c_0 = 'module_c_0';\nfunction useFoo(props: {value: number}): number {\n  const results = identity(props.value);\n  console.log($);\n  console.log(t0);\n  console.log(c_0);\n  return results;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{value: 0}],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component with Hook Calls\nDESCRIPTION: Input React component demonstrating object memoization with useNoAlias hook. Tests handling of non-reactive objects spanning hook calls and their impact on dependencies.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-invalid-reactivity-value-block.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {\n  CONST_TRUE,\n  identity,\n  makeObject_Primitives,\n  useNoAlias,\n} from 'shared-runtime';\n\n/**\n * Here the scope for `obj` is pruned because it spans the `useNoAlias()` hook call.\n * Because `obj` is non-reactive, it would by default be excluded as dependency for\n * `result = [...identity(obj)..., obj]`, but this could then cause the values in\n * `result` to be out of sync with `obj`.\n *\n * The fix is to consider pruned memo block outputs as reactive, since they will\n * recreate on every render. This means `thing` depends on both y and z.\n */\nfunction Foo() {\n  const obj = makeObject_Primitives();\n  // hook calls keeps the next two lines as its own reactive scope\n  useNoAlias();\n\n  const shouldCaptureObj = obj != null && CONST_TRUE;\n  const result = [shouldCaptureObj ? identity(obj) : null, obj];\n\n  useNoAlias(result, obj);\n\n  if (shouldCaptureObj && result[0] !== obj) {\n    throw new Error('Unexpected');\n  }\n  return result;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{}],\n  sequentialRenders: [{}, {}],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized Component Rendering in React with Memoization\nDESCRIPTION: This code snippet demonstrates a more optimized version of the 'Component' and child functions using a memoization technique via the internal state representation of arguments. This approach helps to minimize unnecessary re-renders by storing the last rendered values and checking against new input values before rendering.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-outlining-dupe-attr-after-rename.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enableJsxOutlining\nfunction Component(t0) {\n  const $ = _c(7);\n  const { arr } = t0;\n  const x = useX();\n  let t1;\n  if ($[0] !== arr || $[1] !== x) {\n    let t2;\n    if ($[3] !== x) {\n      t2 = (i, id) => {\n        const T0 = _temp;\n        return <T0 k={i + \"i\"} k1={i + \"j\"} k12={i + \"j\"} key={id} x={x} />;\n      };\n      $[3] = x;\n      $[4] = t2;\n    } else {\n      t2 = $[4];\n    }\n    t1 = arr.map(t2);\n    $[0] = arr;\n    $[1] = x;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  let t2;\n  if ($[5] !== t1) {\n    t2 = <>{t1}</>;\n    $[5] = t1;\n    $[6] = t2;\n  } else {\n    t2 = $[6];\n  }\n  return t2;\n}\nfunction _temp(t0) {\n  const $ = _c(11);\n  const { k: k, k1: k1, k12: k12, x: x } = t0;\n  let t1;\n  if ($[0] !== k) {\n    t1 = <Foo k={k} />;\n    $[0] = k;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  let t2;\n  if ($[2] !== k1) {\n    t2 = <Foo k={k1} />;\n    $[2] = k1;\n    $[3] = t2;\n  } else {\n    t2 = $[3];\n  }\n  let t3;\n  if ($[4] !== k12) {\n    t3 = <Baz k1={k12} />;\n    $[4] = k12;\n    $[5] = t3;\n  } else {\n    t3 = $[5];\n  }\n  let t4;\n  if ($[6] !== t1 || $[7] !== t2 || $[8] !== t3 || $[9] !== x) {\n    t4 = (\n      <Bar x={x}>\n        {t1}\n        {t2}\n        {t3}\n      </Bar>\n    );\n    $[6] = t1;\n    $[7] = t2;\n    $[8] = t3;\n    $[9] = x;\n    $[10] = t4;\n  } else {\n    t4 = $[10];\n  }\n  return t4;\n}\nfunction Bar(t0) {\n  const $ = _c(3);\n  const { x, children } = t0;\n  let t1;\n  if ($[0] !== children || $[1] !== x) {\n    t1 = (\n      <>\n        {x}\n        {children}\n      </>\n    );\n    $[0] = children;\n    $[1] = x;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  return t1;\n}\n\nfunction Baz(t0) {\n  const { k1 } = t0;\n  return k1;\n}\n\nfunction Foo(t0) {\n  const { k } = t0;\n  return k;\n}\n\nfunction useX() {\n  return \"x\";\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ arr: [\"foo\", \"bar\"] }],\n};\n```\n\n----------------------------------------\n\nTITLE: useRef Hook with React Compiler Runtime\nDESCRIPTION: This code shows how `useRef` is transformed when the React compiler runtime is enabled. It imports `_c` from the `react/compiler-runtime` and uses it to memoize the callback.  The compiler runtime manages caching of the returned value of the hook using `Symbol.for(\"react.memo_cache_sentinel\")` to optimize performance by avoiding re-creation on every render.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-ref-type-cast-in-render.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useRef } from \"react\";\n\nfunction useArrayOfRef() {\n  const $ = _c(1);\n  const ref = useRef(null);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const callback = (value) => {\n      ref.current = value;\n    };\n\n    t0 = [callback];\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0 as const;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: () => {\n    useArrayOfRef();\n    return \"ok\";\n  },\n\n  params: [{}]\n};\n\n```\n\n----------------------------------------\n\nTITLE: Traversing Tree to Find Element at Index N in React DevTools\nDESCRIPTION: Completes the algorithm for finding the Nth element by traversing the tree starting from the first child of the containing root. It navigates by comparing weights until it finds the element at the desired index.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/OVERVIEW.md#2025-04-21_snippet_11\n\nLANGUAGE: javascript\nCODE:\n```\nlet currentElement = this._idToElement.get(firstChildID);\nlet currentWeight = rootWeight;\nwhile (index !== currentWeight) {\n  for (let i = 0; i < currentElement.children.length; i++) {\n    const childID = currentElement.children[i];\n    const child = this._idToElement.get(childID);\n    const { weight } = child;\n    if (index <= currentWeight + weight) {\n      currentWeight++;\n      currentElement = child;\n      break;\n    } else {\n      currentWeight += weight;\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Managing Input State Using useRef in React\nDESCRIPTION: This snippet implements a React functional component that uses the useRef hook to manage the value of an input element. The component sets up a ref to store the input's value and updates that value when the input changes. The input field is rendered in response to interaction via an onChange event.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ref-current-field-write-not-added-to-dep.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useRef} from 'react';\n\nfunction Component() {\n  const ref = useRef({text: {value: null}});\n  const inputChanged = e => {\n    ref.current.text.value = e.target.value;\n  };\n\n  return <input onChange={inputChanged} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Input Component with useEffect and Member Expression\nDESCRIPTION: The original React component with a useEffect hook that uses nested object properties. The special comment @inferEffectDependencies indicates that React should automatically infer the dependencies.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/reactive-memberexpr-merge.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @inferEffectDependencies\nimport {useEffect} from 'react';\nimport {print} from 'shared-runtime';\n\nfunction ReactiveMemberExprMerge({propVal}) {\n  const obj = {a: {b: propVal}};\n  useEffect(() => print(obj.a, obj.a.b));\n}\n```\n\n----------------------------------------\n\nTITLE: React Component with Array.from Transformation\nDESCRIPTION: This React component demonstrates the use of `Array.from` to create a new array based on an existing one. The component takes a `value` prop, creates an array of objects, and then uses `Array.from` to add an `id` property to each object based on its index. The component then renders the last element of the transformed array using the `Stringify` component. Dependencies: `useIdentity`, `Stringify` from `shared-runtime`.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-from-arg1-captures-arg0.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useIdentity, Stringify} from 'shared-runtime';\n\n/**\n * TODO: Note that this `Array.from` is inferred to be mutating its first\n * argument. This is because React Compiler's typing system does not yet support\n * annotating a function with a set of argument match cases + distinct\n * definitions (polymorphism).\n * \n * In this case, we should be able to infer that the `Array.from` call is\n * not mutating its 0th argument.\n * The 0th argument should be typed as having `effect:Mutate` only when\n * (1) it might be a mutable iterable or\n * (2) the 1st argument might mutate its callee\n */\nfunction Component({value}) {\n  const arr = [{value: 'foo'}, {value: 'bar'}, {value}];\n  useIdentity();\n  const derived = Array.from(arr, (x, idx) => ({...x, id: idx}));\n  return <Stringify>{derived.at(-1)}</Stringify>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: 5}],\n  sequentialRenders: [{value: 5}, {value: 6}, {value: 6}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Original Component Function with Nested Objects and Mutation\nDESCRIPTION: A React component function that creates nested objects and arrays, then mutates the deeply nested array before returning the outermost object.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/alias-nested-member-path-mutate.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component() {\n  let z = [];\n  let y = {};\n  y.z = z;\n  let x = {};\n  x.y = y;\n  mutate(x.y.z);\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing CaptureNotMutate Component in React\nDESCRIPTION: This code defines a React component named CaptureNotMutate that demonstrates challenges with memoization when dealing with captured variables. It processes props, creates a function that captures a local variable, and mutates the result.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/lambda-capture-returned-alias.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction CaptureNotMutate(props) {\n  const idx = foo(props.x);\n  const element = bar(props.el);\n\n  const fn = function () {\n    const arr = {element};\n    return arr[idx];\n  };\n  const aliasedElement = fn();\n  mutate(aliasedElement);\n  return aliasedElement;\n}\n```\n\n----------------------------------------\n\nTITLE: Subscribing to RxJS ReplaySubject with use-subscription in React\nDESCRIPTION: Code example demonstrating how to use the useSubscription hook with an RxJS ReplaySubject. Since ReplaySubject lacks a sync data getter, it requires a temporary subscription to retrieve the current value.\nSOURCE: https://github.com/facebook/react/blob/main/packages/use-subscription/README.md#2025-04-21_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst subscription = useMemo(\n  () => ({\n    getCurrentValue: () => {\n      let currentValue;\n      // ReplaySubject does not have a sync data getter,\n      // So we need to temporarily subscribe to retrieve the most recent value.\n      replaySubject\n        .subscribe(value => {\n          currentValue = value;\n        })\n        .unsubscribe();\n      return currentValue;\n    },\n    subscribe: callback => {\n      const subscription = replaySubject.subscribe(callback);\n      return () => subscription.unsubscribe();\n    }\n  }),\n\n  // Re-subscribe any time the replaySubject changes\n  [replaySubject]\n);\n\nconst value = useSubscription(subscription);\n```\n\n----------------------------------------\n\nTITLE: React Compiler Output with Memoization Logic\nDESCRIPTION: The transformed output from React's compiler showing how memoization is implemented. It uses a cache sentinel and tracks dependencies to avoid recreating objects when props haven't changed.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/phi-type-inference-property-store.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @debug\nfunction Component(props) {\n  const $ = _c(4);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = {};\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const x = t0;\n  let t1;\n  if ($[1] !== props.a || $[2] !== props.cond) {\n    let y;\n    if (props.cond) {\n      y = {};\n    } else {\n      y = { a: props.a };\n    }\n\n    y.x = x;\n\n    t1 = [x, y];\n    $[1] = props.a;\n    $[2] = props.cond;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ cond: false, a: \"a!\" }],\n};\n```\n\n----------------------------------------\n\nTITLE: Initializing React Component with Context Access\nDESCRIPTION: Defines a React component 'App' that uses the useContext hook to access 'foo' and 'bar' from MyContext. The @lowerContextAccess directive is used to indicate optimization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/lower-context-selector-simple.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @lowerContextAccess\nfunction App() {\n  const {foo, bar} = useContext(MyContext);\n  return <Bar foo={foo} bar={bar} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Original React Component with Array Mapping\nDESCRIPTION: This snippet defines a React component that maps over an array of items from props and returns an array with a fixed value and the mapped items. It also exports a fixture for testing or demonstration purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-hoisting-variable-collision.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const items = props.items.map(x => x);\n  const x = 42;\n  return [x, items];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{items: [0, 42, null, undefined, {object: true}]}],\n};\n```\n\n----------------------------------------\n\nTITLE: Conditional Component Logic using useMemo in React JavaScript\nDESCRIPTION: This snippet demonstrates a React component function where `useMemo` is used to conditionally return one of the props based on a provided condition. The component favors `props.a` unless `props.cond` is true, in which case it will return `props.b`. Dependencies include React and `useMemo` hook.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-inverted-if.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nfunction Component(props) {\n  const x = useMemo(() => {\n    label: {\n      if (props.cond) {\n        break label;\n      }\n      return props.a;\n    }\n    return props.b;\n  });\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Counter Component\nDESCRIPTION: This snippet shows the compiled version of the React counter component. It includes optimizations and caching mechanisms for improved performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/function-expr-directive.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component() {\n  \"use strict\";\n  const $ = _c(3);\n\n  const [count, setCount] = React.useState(0);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = function update() {\n      \"worklet\";\n\n      setCount(_temp);\n    };\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const update = t0;\n  let t1;\n  if ($[1] !== count) {\n    t1 = <button onClick={update}>{count}</button>;\n    $[1] = count;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  return t1;\n}\nfunction _temp(count_0) {\n  return count_0 + 1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  isComponent: true,\n};\n```\n\n----------------------------------------\n\nTITLE: Utilizing Shared Runtime in React Component\nDESCRIPTION: This snippet defines the useFoo function, which manages state and performs conditional reading of object properties using shared runtime utils like shallowCopy and mutate. Dependencies include shared-runtime and modules for deep copying and modifying objects. It takes an object as input and returns a JSX component conditionally based on the input properties.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/infer-function-cond-access-local-var.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enablePropagateDepsInHIR\n\nimport {shallowCopy, mutate, Stringify} from 'shared-runtime';\n\nfunction useFoo({\n  a,\n  shouldReadA,\n}: {\n  a: {b: {c: number}; x: number};\n  shouldReadA: boolean;\n}) {\n  const local = shallowCopy(a);\n  mutate(local);\n  return (\n    <Stringify\n      fn={() => {\n        if (shouldReadA) return local.b.c;\n        return null;\n      }}\n      shouldInvokeFns={true}\n    />\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{a: null, shouldReadA: true}],\n  sequentialRenders: [\n    {a: null, shouldReadA: true},\n    {a: null, shouldReadA: false},\n    {a: {b: {c: 4}}, shouldReadA: true},\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Initializing React Component with Shared Runtime in JavaScript\nDESCRIPTION: This snippet demonstrates a React component that initializes with a status-based configuration and dynamically applies styles. It imports utilities from a shared runtime for identity checks and defines helper functions `foo` and `getStyles` to derive text and styles from a given status. The component is intended to be the entry point of a fixture, handling a status named \"Mofei\".\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/sequential-destructuring-assignment-to-scope-declarations.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {identity} from 'shared-runtime';\n\nfunction Component(statusName) {\n  const {status, text} = foo(statusName);\n  const {bg, color} = getStyles(status);\n  return (\n    <div className={identity(bg)}>\n      <span className={identity(color)}>{[text]}</span>\n    </div>\n  );\n}\n\nfunction foo(name) {\n  return {\n    status: `<status>`,\n    text: `${name}!`,\n  };\n}\n\nfunction getStyles(status) {\n  return {\n    bg: '#eee8d5',\n    color: '#657b83',\n  };\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: ['Mofei'],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Using Stringify for Conditional Rendering in React (JavaScript)\nDESCRIPTION: This snippet defines the `useFoo` function, which takes an object as an argument and returns a Stringify component that conditionally renders properties from nested objects based on their state. It demonstrates how to handle potentially undefined values using optional chaining.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/todo-infer-function-uncond-optionals-hoisted.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {Stringify} from 'shared-runtime';\n\nfunction useFoo({a}) {\n  return <Stringify fn={() => a.b?.c.d?.e} shouldInvokeFns={true} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{a: null}],\n  sequentialRenders: [\n    {a: null},\n    {a: {b: null}},\n    {a: {b: {c: {d: null}}}},\n    {a: {b: {c: {d: {e: 4}}}}},\n  ],\n};\n\n```\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { Stringify } from \"shared-runtime\";\n\nfunction useFoo(t0) {\n  const $ = _c(2);\n  const { a } = t0;\n  let t1;\n  if ($[0] !== a.b?.c.d?.e) {\n    t1 = <Stringify fn={() => a.b?.c.d?.e} shouldInvokeFns={true} />;\n    $[0] = a.b?.c.d?.e;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ a: null }],\n  sequentialRenders: [\n    { a: null },\n    { a: { b: null } },\n    { a: { b: { c: { d: null } } } },\n    { a: { b: { c: { d: { e: 4 } } } } },\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Initializing Mutable Array in React Component\nDESCRIPTION: Creates an empty array that is mutated using useNoAlias and mutate functions, then rendered in a div\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unmemoized-nonreactive-dependency-is-pruned-as-dependency.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {mutate, useNoAlias} from 'shared-runtime';\n\nfunction Component(props) {\n  // Here `x` cannot be memoized bc its mutable range spans a hook call:\n  const x = [];\n  useNoAlias();\n  mutate(x);\n\n  // However, `x` is non-reactive. It cannot semantically change, so we\n  // exclude it as a dependency of the JSX element:\n  return <div>{x}</div>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: 42}],\n};\n```\n\n----------------------------------------\n\nTITLE: Starting React Compiler Playground Development Server\nDESCRIPTION: Commands for starting the local development server and updating the playground when React Compiler changes locally.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/apps/playground/README.md#2025-04-21_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\n# Start the local development server with\n$ yarn dev\n\n# Or\n$ npm run dev\n\n# Rerun the following (in a separate terminal window) when React Compiler\n# is changed locally to keep Playground in sync.\n$ yarn\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with Hooks and Memoization\nDESCRIPTION: This snippet defines a React component using hooks and memoization techniques. It demonstrates the use of useEffect, state management with objects, and conditional rendering.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-dont-memoize-array-with-capturing-map-after-hook.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useEffect, useState} from 'react';\nimport {mutate} from 'shared-runtime';\n\nfunction Component(props) {\n  const x = [{...props.value}];\n  useEffect(() => {}, []);\n  const onClick = () => {\n    console.log(x.length);\n  };\n  let y;\n  return (\n    <div onClick={onClick}>\n      {x.map(item => {\n        y = item;\n        return <span key={item.id}>{item.text}</span>;\n      })}\n      {mutate(y)}\n    </div>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: {id: 0, text: 'Hello!'}}],\n  isComponent: true,\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with Primitive Dependency\nDESCRIPTION: This code defines a React component, `PrimitiveAsDep`, that takes `props` as input, computes `props.b + 1`, and uses it as a dependency for the `foo` function. The function uses React's compiler runtime (`_c`) to memoize the result of `foo(props.b + 1)` based on `props.b`. It demonstrates how the compiler can optimize primitive dependencies.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/primitive-as-dep.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// props.b + 1 is an non-allocating expression, which means Forget can\n// emit it trivially and repeatedly (e.g. no need to memoize props.b + 1\n// separately from props.b)\n// Correctness:\n//   y depends on either props.b or props.b + 1\nfunction PrimitiveAsDep(props) {\n  let y = foo(props.b + 1);\n  return y;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Input React Component with Object Property Iteration\nDESCRIPTION: Original React component that iterates through object properties, skipping the 'continue' property. Uses object spread operator to clone props.value.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-in-statement-continue.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let x;\n  const object = {...props.value};\n  for (const y in object) {\n    if (y === 'continue') {\n      continue;\n    }\n    x = object[y];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: {a: 'a', continue: 'skip', b: 'hello!'}}],\n  sequentialRenders: [\n    {value: {a: 'a', continue: 'skip', b: 'hello!'}},\n    {value: {a: 'a', continue: 'skip', b: 'hello!'}},\n    {value: {a: 'skip!', continue: true}},\n    {value: {a: 'a', continue: 'skip', b: 'hello!'}},\n    {value: {a: 'skip!', continue: true}},\n    {value: {a: 'a', continue: 'skip', b: 'hello!'}},\n    {value: {a: 'skip!', continue: true}},\n    {value: {a: 'skip!', continue: true}},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing a Basic React Hook with Conditional Object Creation\nDESCRIPTION: A custom React hook named useFoo that creates and returns an object with three properties (x, y, z) based on a boolean input parameter. When setOne is true, all properties are set to 1; otherwise, they're set to different values.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/const-propagation-phi-nodes.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction useFoo(setOne: boolean) {\n  let x;\n  let y;\n  let z;\n  if (setOne) {\n    x = y = z = 1;\n  } else {\n    x = 2;\n    y = 3;\n    z = 5;\n  }\n  return {x, y, z};\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [true],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization Using Compiler Runtime\nDESCRIPTION: The compiled version of the component using React's compiler-runtime for memoization. It implements a caching mechanism that tracks prop dependencies (cond and value) to avoid unnecessary recalculations and renders when the inputs haven't changed.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/phi-type-inference-array-push.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(4);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = {};\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const x = t0;\n  let t1;\n  if ($[1] !== props.cond || $[2] !== props.value) {\n    let y;\n    if (props.cond) {\n      y = [props.value];\n    } else {\n      y = [];\n    }\n\n    y.push(x);\n\n    t1 = [x, y];\n    $[1] = props.cond;\n    $[2] = props.value;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ cond: true, value: 42 }],\n  sequentialRenders: [\n    { cond: true, value: 3.14 },\n    { cond: false, value: 3.14 },\n    { cond: true, value: 42 },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Input React Component with Memoization Preservation\nDESCRIPTION: Demonstrates a React component using useMemo to create and memoize objects with controlled mutability and runtime optimizations\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-mabye-modified-free-variable-preserve-memoization-guarantees.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enablePreserveExistingMemoizationGuarantees\nimport {useMemo} from 'react';\nimport {identity, makeObject_Primitives, mutate, useHook} from 'shared-runtime';\n\nfunction Component(props) {\n  const free = makeObject_Primitives();\n  const free2 = makeObject_Primitives();\n  const part = free2.part;\n\n  useHook();\n\n  const object = useMemo(() => {\n    const x = makeObject_Primitives();\n    x.value = props.value;\n    mutate(x, free, part);\n    return x;\n  }, [props.value, free, part]);\n\n  identity(free);\n  identity(part);\n\n  return object;\n}\n```\n\n----------------------------------------\n\nTITLE: Original useMemo Hook Definition\nDESCRIPTION: This code defines a custom hook `useFoo` that uses `useMemo` to memoize a value. The intention is to produce memo blocks with fewer dependencies than the source code initially suggests, demonstrating a potential optimization by the React compiler. It takes two parameters, 'a' and 'b', but only 'a' is used in the returned memoized value.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useMemo-infer-fewer-deps.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees\n\nimport {useMemo} from 'react';\n\n// It's correct to produce memo blocks with fewer deps than source\nfunction useFoo(a, b) {\n  return useMemo(() => [a], [a, b]);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [1, 2],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Using useRef Hook in React Component\nDESCRIPTION: This code snippet defines a React functional component, `C`, which uses the `useRef` hook to create a mutable ref object. The component checks if the ref's current value is null and calls function `f` if it is. This snippet exemplifies component reference management in React and is intended to be used within a React application. It is crucial to note that accessing `r.current` during rendering can lead to an error, as indicated in the error section following the code.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.ref-initialization-call.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n//@flow\nimport {useRef} from 'react';\n\ncomponent C() {\n  const r = useRef(null);\n  if (r.current == null) {\n    f(r.current);\n  }\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: C,\n  params: [{}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Component with Conditional Props\nDESCRIPTION: This React component takes props and conditionally assigns a value to the `bar` prop based on the `cond` prop. The `bar` prop is either `props.foo` or `props.bar` depending on the value of `props.cond`. This component illustrates a common pattern in React where props are dynamically derived based on other props.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-spread.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  return (\n    <Component {...props} {...{bar: props.cond ? props.foo : props.bar}} />\n  );\n}\n\n```\n\n----------------------------------------\n\nTITLE: React Compiler Runtime Optimized Component\nDESCRIPTION: Enhanced version of the React component using React compiler runtime with memoization and cache optimization techniques\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useEffect-snap-test.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useEffect, useState } from \"react\";\n\nfunction Component() {\n  const $ = _c(4);\n  const [state, setState] = useState(\"hello\");\n  let t0;\n  let t1;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = () => {\n      setState(\"goodbye\");\n    };\n    t1 = [];\n    $[0] = t0;\n    $[1] = t1;\n  } else {\n    t0 = $[0];\n    t1 = $[1];\n  }\n  useEffect(t0, t1);\n  let t2;\n  if ($[2] !== state) {\n    t2 = <div>{state}</div>;\n    $[2] = state;\n    $[3] = t2;\n  } else {\n    t2 = $[3];\n  }\n  return t2;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring a Sandboxed `iframe` (Backend)\nDESCRIPTION: This JavaScript snippet configures the React DevTools backend within a sandboxed iframe.  It initializes the DevTools hook before React loads and listens for a message from the frontend to activate the backend.  This message-based activation is necessary due to the iframe's sandboxed environment.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools-inline/README.md#2025-04-21_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport { activate, initialize } from \"react-devtools-inline/backend\";\n\n// The DevTools hook needs to be installed before React is even required!\n// The safest way to do this is probably to install it in a separate script tag.\ninitialize(window);\n\n// Wait for the frontend to let us know that it's ready.\nfunction onMessage({ data }) {\n  switch (data.type) {\n    case \"activate-backend\":\n      window.removeEventListener(\"message\", onMessage);\n\n      activate(window);\n      break;\n    default:\n      break;\n  }\n}\n\nwindow.addEventListener(\"message\", onMessage);\n```\n\n----------------------------------------\n\nTITLE: Defining a React Hook\nDESCRIPTION: This code snippet defines a custom React hook named `useHook`. This hook demonstrates that hooks can call other hooks, such as `useHook1` and `useHook2`, which promotes code reusability and composability within React functional components.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-cfdfe5572fc7.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// Valid because hooks can call hooks.\nfunction useHook() {\n  useHook1();\n  useHook2();\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating a Functional Component - JavaScript\nDESCRIPTION: This snippet demonstrates the creation of a React functional component that accepts props and returns the uppercase version of the name prop. It includes a non-null assertion for type safety.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/non-null-assertion.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props: ComponentProps) {\n  return props.name!.toUpperCase();\n}\n\n```\n\n----------------------------------------\n\nTITLE: Managing State with React Compiler Runtime - React - JavaScript\nDESCRIPTION: This snippet illustrates a more intricate implementation of a React component using the compiler runtime for managing internal state and property mutation. The component checks the values of props against an internal array and ensures efficient mutation and rendering using unique identifiers for state tracking. It is optimized to avoid unnecessary re-renders by checking dependencies before mutating state.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-capture-ref-before-rename.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { mutate } from \"shared-runtime\";\n\nfunction Component(t0) {\n  const $ = _c(7);\n  const { a, b } = t0;\n  let z;\n  if ($[0] !== a) {\n    z = { a };\n\n    mutate(z);\n    $[0] = a;\n    $[1] = z;\n  } else {\n    z = $[1];\n  }\n\n  let y = z;\n  let t1;\n  if ($[2] !== b) {\n    t1 = { b };\n    $[2] = b;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  const z_0 = t1;\n  let t2;\n  if ($[4] !== y || $[5] !== z_0) {\n    t2 = { y, z: z_0 };\n    $[4] = y;\n    $[5] = z_0;\n    $[6] = t2;\n  } else {\n    t2 = $[6];\n  }\n  y = t2;\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ a: 2, b: 3 }],\n  sequentialRenders: [\n    { a: 2, b: 3 },\n    { a: 2, b: 3 },\n    { a: 2, b: 4 },\n    { a: 3, b: 4 },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Hoisting Function with Closure in JavaScript\nDESCRIPTION: This snippet defines a hoisting function that demonstrates variable scoping and closures in JavaScript. It initializes variables using `let` and `const`, ensuring expected results when called outside of temporal dead zones. The function returns the result of executing another function within its scope, utilizing inner function calls effectively.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-nested-let-declaration.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction hoisting() {\n  let qux = () => {\n    let result;\n    {\n      result = foo();\n    }\n    return result;\n  };\n  let foo = () => {\n    return bar + baz;\n  };\n  let bar = 3;\n  const baz = 2;\n  return qux(); // OK: called outside of TDZ\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: hoisting,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: Compiled version of the component that implements memoization using React's compiler runtime. It caches values between renders, tracks dependency changes, and only recalculates when needed. The compilation adds optimizations to prevent unnecessary re-renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/switch-non-final-default.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(8);\n  let t0;\n  let y;\n  if ($[0] !== props.p0 || $[1] !== props.p2) {\n    const x = [];\n    bb0: switch (props.p0) {\n      case 1: {\n        break bb0;\n      }\n      case true: {\n        x.push(props.p2);\n        let t1;\n        if ($[4] === Symbol.for(\"react.memo_cache_sentinel\")) {\n          t1 = [];\n          $[4] = t1;\n        } else {\n          t1 = $[4];\n        }\n        y = t1;\n      }\n      default: {\n        break bb0;\n      }\n      case false: {\n        y = x;\n      }\n    }\n\n    t0 = <Component data={x} />;\n    $[0] = props.p0;\n    $[1] = props.p2;\n    $[2] = t0;\n    $[3] = y;\n  } else {\n    t0 = $[2];\n    y = $[3];\n  }\n  const child = t0;\n  y.push(props.p4);\n  let t1;\n  if ($[5] !== child || $[6] !== y) {\n    t1 = <Component data={y}>{child}</Component>;\n    $[5] = child;\n    $[6] = y;\n    $[7] = t1;\n  } else {\n    t1 = $[7];\n  }\n  return t1;\n}\n```\n\n----------------------------------------\n\nTITLE: Using useMemo for Value Calculation in React (JavaScript)\nDESCRIPTION: This snippet defines a React component that calculates a sum of two properties from the passed props using the useMemo hook to memoize the computed result. Dependencies include React and a shared runtime for the sum function. The function expects propA and propB structured such that propA.x and propB.x.y are defined, returning the memoized sum of these values. The memoization optimizes performance by avoiding unnecessary recalculations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useMemo-alias-property-load-dep.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees\nimport {useMemo} from 'react';\nimport {sum} from 'shared-runtime';\n\nfunction Component({propA, propB}) {\n  const x = propB.x.y;\n  return useMemo(() => {\n    return sum(propA.x, x);\n  }, [propA.x, x]);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{propA: {x: 2}, propB: {x: {y: 3}}}],\n};\n\n```\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @validatePreserveExistingMemoizationGuarantees\nimport { useMemo } from \"react\";\nimport { sum } from \"shared-runtime\";\n\nfunction Component(t0) {\n  const $ = _c(3);\n  const { propA, propB } = t0;\n  const x = propB.x.y;\n  let t1;\n  let t2;\n  if ($[0] !== propA.x || $[1] !== x) {\n    t2 = sum(propA.x, x);\n    $[0] = propA.x;\n    $[1] = x;\n    $[2] = t2;\n  } else {\n    t2 = $[2];\n  }\n  t1 = t2;\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ propA: { x: 2 }, propB: { x: { y: 3 } } }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Component Definition\nDESCRIPTION: This code defines a React component named `Component` that renders static text elements. It imports a `StaticText1` component from 'shared-runtime' and uses it within the component's JSX structure. The component returns a div containing several `StaticText1` elements and plain text.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-preserve-whitespace.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {StaticText1} from 'shared-runtime';\n\nfunction Component() {\n  return (\n    <div>\n      Before text\n      <StaticText1 />\n      Middle text\n      <StaticText1>\n        Inner before text\n        <StaticText1 />\n        Inner middle text\n        <StaticText1 />\n        Inner after text\n      </StaticText1>\n      After text\n    </div>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Preparing Release Script - Shell\nDESCRIPTION: This script increments version numbers and updates the CHANGELOG for the React DevTools. It is expected to be run in the terminal to prepare for a new release.\nSOURCE: https://github.com/facebook/react/blob/main/scripts/devtools/README.md#2025-04-21_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n./prepare-release.js\n```\n\n----------------------------------------\n\nTITLE: Memoization in React Component with Custom Compiler\nDESCRIPTION: Implements a React component utilizing a custom compiler runtime to perform memoization. It maintains the state of memoized values across renders using an array-based cache, minimizing computational cost. This approach preserves memoization guarantees and optimizes rendering by checking dependencies before recalculating.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-member-expression-single-with-unconditional.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @validatePreserveExistingMemoizationGuarantees @enableOptionalDependencies\nimport { ValidateMemoization } from \"shared-runtime\";\nfunction Component(props) {\n  const $ = _c(7);\n  let t0;\n  let x;\n  if ($[0] !== props.items) {\n    x = [];\n    x.push(props?.items);\n    x.push(props.items);\n    $[0] = props.items;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  t0 = x;\n  const data = t0;\n  let t1;\n  if ($[2] !== props.items) {\n    t1 = [props.items];\n    $[2] = props.items;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  let t2;\n  if ($[4] !== data || $[5] !== t1) {\n    t2 = <ValidateMemoization inputs={t1} output={data} />;\n    $[4] = data;\n    $[5] = t1;\n    $[6] = t2;\n  } else {\n    t2 = $[6];\n  }\n  return t2;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Input React Hook Implementation with Test Fixture\nDESCRIPTION: Original implementation of useFoo hook that processes an array and returns both the processed array and callback function. Includes test fixture configuration for sequential renders with different inputs.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/assume-invoked/jsx-and-passed.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {createHookWrapper} from 'shared-runtime';\n\nfunction useFoo({arr1}) {\n  const cb1 = e => arr1[0].value + e.value;\n  const x = arr1.map(cb1);\n  return [x, cb1];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: createHookWrapper(useFoo),\n  params: [{arr1: [], arr2: []}],\n  sequentialRenders: [\n    {arr1: [], arr2: []},\n    {arr1: [], arr2: null},\n    {arr1: [{value: 1}, {value: 2}], arr2: [{value: -1}]},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Initializing Compiler-Transformed React Function\nDESCRIPTION: A React function demonstrating compiler runtime transformation with memoization and shallow copying of complex objects\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/infer-function-uncond-access-local-var.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction useFoo({a}: {a: {b: {c: number}}}) {\n  const local = shallowCopy(a);\n  mutate(local);\n  const fn = () => local.b.c;\n  return <Stringify fn={fn} shouldInvokeFns={true} />;\n}\n```\n\nLANGUAGE: javascript\nCODE:\n```\nfunction useFoo(t0) {\n  const $ = _c(6);\n  const { a } = t0;\n  let local;\n  if ($[0] !== a) {\n    local = shallowCopy(a);\n    mutate(local);\n    $[0] = a;\n    $[1] = local;\n  } else {\n    local = $[1];\n  }\n  // ... rest of transformed function\n}\n```\n\n----------------------------------------\n\nTITLE: Validating Ref Access During Render - React - Javascript\nDESCRIPTION: This snippet defines a React functional component that utilizes the useRef hook to create a reference. It attempts to access the current value of the reference during the render lifecycle, which results in an error, indicating that ref values cannot be accessed in this manner. This teaches the user about proper ref usage in React.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-access-ref-during-render.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validateRefAccessDuringRender\nfunction Component(props) {\n  const ref = useRef(null);\n  const value = ref.current;\n  return value;\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled Output of useBar Hook\nDESCRIPTION: React compiler-generated code showing the memoized implementation of the useBar hook. Includes compiler runtime imports and memoization logic using an array-based cache system.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-spread-mutable-iterator.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\n\nfunction useBar(t0) {\n  \"use memo\";\n  const $ = _c(2);\n  const { arg } = t0;\n  let t1;\n  if ($[0] !== arg) {\n    const s = new Set([1, 5, 4]);\n    const mutableIterator = s.values();\n\n    t1 = [arg, ...mutableIterator];\n    $[0] = arg;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useBar,\n  params: [{ arg: 3 }],\n  sequentialRenders: [{ arg: 3 }, { arg: 3 }, { arg: 4 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: Defines a React component that conditionally renders div elements with dynamic class names based on props and constants. Uses identity function for class name composition.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-separate-scopes-for-divs.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {identity} from 'shared-runtime';\n\nconst DISPLAY = true;\nfunction Component({cond = false, id}) {\n  return (\n    <>\n      <div className={identity(styles.a, id !== null ? styles.b : {})}></div>\n\n      {cond === false && (\n        <div className={identity(styles.c, DISPLAY ? styles.d : {})} />\n      )}\n    </>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{cond: false, id: 42}],\n  sequentialRenders: [\n    {cond: false, id: 4},\n    {cond: true, id: 4},\n    {cond: true, id: 42},\n  ],\n};\n\nconst styles = {\n  a: 'a',\n  b: 'b',\n  c: 'c',\n  d: 'd',\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Memoization\nDESCRIPTION: This snippet shows an optimized version of the 'useFoo' component using memoization techniques. It imports a compiler runtime function and implements caching logic to avoid unnecessary recomputation of nested functions.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rename-source-variables-nested-function.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enableChangeVariableCodegen\nimport { identity } from \"shared-runtime\";\n\nconst $ = \"module_$\";\nconst t0 = \"module_t0\";\nconst c_0 = \"module_c_0\";\nfunction useFoo(props) {\n  const $0 = _c(4);\n  const c_00 = $0[0] !== props.value;\n  let t1;\n  if (c_00) {\n    t1 = () => {\n      const b = () => {\n        const c = () => {\n          console.log($);\n          console.log(t0);\n          console.log(c_0);\n          return identity(props.value);\n        };\n        return c;\n      };\n      return b;\n    };\n    $0[0] = props.value;\n    $0[1] = t1;\n  } else {\n    t1 = $0[1];\n  }\n  const a = t1;\n  const c_2 = $0[2] !== a;\n  let t2;\n  if (c_2) {\n    t2 = a()()();\n    $0[2] = a;\n    $0[3] = t2;\n  } else {\n    t2 = $0[3];\n  }\n  return t2;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ value: 42 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Advanced Fixture Function with Compiler Runtime in React JavaScript\nDESCRIPTION: This snippet illustrates an advanced fixture function that optimizes state management using React's compiler runtime. It imports constants from both 'react/compiler-runtime' and 'shared-runtime' and employs a cached value to reduce unnecessary recalculations. This efficiently manages prop changes using a cached array and exports the function for fixed entry points. Dependency on 'react/compiler-runtime' and 'shared-runtime' is required.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/holey-array-expr.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { CONST_STRING0 } from \"shared-runtime\";\n\nfunction t(props) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== props) {\n    t0 = [, CONST_STRING0, props];\n    $[0] = props;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const x = t0;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: t,\n  params: [{ a: 1, b: 2 }],\n  isComponent: false,\n};\n\n```\n\n----------------------------------------\n\nTITLE: Optimized useFoo Hook with React Compiler Memoization\nDESCRIPTION: Compiler-optimized version of the useFoo hook that implements memoization using React's compiler runtime. It uses an array to track props dependencies and only recreates the array when the relevant props change, improving performance across renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-renaming-unconditional-ternary-with-mutation.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { arrayPush } from \"shared-runtime\";\nfunction useFoo(props) {\n  const $ = _c(4);\n  let x;\n  if ($[0] !== props.bar || $[1] !== props.cond || $[2] !== props.foo) {\n    x = [];\n    x.push(props.bar);\n    props.cond ? ((x = []), x.push(props.foo)) : ((x = []), x.push(props.bar));\n    arrayPush(x, 4);\n    $[0] = props.bar;\n    $[1] = props.cond;\n    $[2] = props.foo;\n    $[3] = x;\n  } else {\n    x = $[3];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ cond: false, foo: 2, bar: 55 }],\n  sequentialRenders: [\n    { cond: false, foo: 2, bar: 55 },\n    { cond: false, foo: 3, bar: 55 },\n    { cond: true, foo: 3, bar: 55 },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component using fire in useEffect\nDESCRIPTION: This code defines a React component that uses the 'fire' function within a useEffect hook to execute a function (foo) with props.  It imports 'fire' from 'react'. The hook attempts to include 'foo' and 'props' as dependencies, triggering an error when using spread syntax.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/error.invalid-rewrite-deps-spread.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableFire\nimport {fire} from 'react';\n\nfunction Component(props) {\n  const foo = props => {\n    console.log(props);\n  };\n\n  const deps = [foo, props];\n\n  useEffect(\n    () => {\n      fire(foo(props));\n    },\n    ...deps\n  );\n\n  return null;\n}\n```\n\n----------------------------------------\n\nTITLE: Managing Control Flow and Exports in JavaScript\nDESCRIPTION: The snippet defines a JavaScript function 'foo' that uses labeled blocks to intelligently manage control flow based on function parameters. The function is exported via a constant 'FIXTURE_ENTRYPOINT' with specified parameters. This pattern facilitates clear block-level exits and modular exporting. Dependencies include ECMAScript 6 (ES6) or later for 'const' and 'export'. Inputs to 'foo' are three parameters 'a', 'b', and 'c', with an output determined by conditional logic. It requires 'TodoAdd' to implement the expected pattern.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inverted-if-else.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nfunction foo(a, b, c) {\n  let x = null;\n  label: {\n    if (a) {\n      x = b;\n      break label;\n    }\n    x = c;\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\nfunction foo(a, b, c) {\n  let x;\n  bb0: {\n    if (a) {\n      x = b;\n      break bb0;\n    }\n\n    x = c;\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component\nDESCRIPTION: This code presents the compiled version of the React component. It uses the '_c' function from 'react/compiler-runtime' to memoize intermediate values and optimize rendering. The compiler replaces the original component with a more efficient version that avoids unnecessary re-renders by checking if the props have changed.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/dont-merge-overlapping-scopes-store-const-used-later.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { Stringify, makeObject_Primitives } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(6);\n  let t0;\n  if ($[0] !== props.count) {\n    t0 = [props.count];\n    $[0] = props.count;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const array = t0;\n  const x = makeObject_Primitives();\n  let t1;\n  if ($[2] !== array) {\n    t1 = <div>{array}</div>;\n    $[2] = array;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  const element = t1;\n  console.log(x);\n  let t2;\n  if ($[4] !== element) {\n    t2 = <div>{element}</div>;\n    $[4] = element;\n    $[5] = t2;\n  } else {\n    t2 = $[5];\n  }\n  return t2;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ count: 42 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: Compiled version of the React component with added memoization logic using Symbol.for('react.memo_cache_sentinel'). Includes compiler runtime imports and maintains the same error handling pattern.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nconst { throwErrorWithMessage } = require(\"shared-runtime\");\n\nfunction Component(props) {\n  const $ = _c(1);\n  let x;\n  try {\n    let t0;\n    if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n      t0 = throwErrorWithMessage(\"oops\");\n      $[0] = t0;\n    } else {\n      t0 = $[0];\n    }\n    x = t0;\n  } catch {\n    x = null;\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a Component with Non-Reactive Logic in React\nDESCRIPTION: This snippet defines a React component that uses a loop and a switch statement to assign values based on a prop. The values are determined by the prop `cond`, and although the value of `x` is set non-reactively, it depends on a reactive variable `value`, which affects the overall outcome. Inputs include the `props` object with a `cond` property. The output is an array containing the value of `x` determined during execution.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-reactive-after-fixpoint.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let x = 0;\n\n  let value = null;\n  loop: for (let i = 0; i < 10; i++) {\n    switch (value) {\n      case true: {\n        x = 1;\n        break loop;\n      }\n      case false: {\n        x = 2;\n        break loop;\n      }\n    }\n\n    value = props.cond;\n  }\n\n  // The values assigned to `x` are non-reactive, but the value of `x`\n  // depends on the \"control\" variable `value` used as the switch test\n  // condition. That variable is initially null on the first iteration\n  // of the loop, but is later set to `props.value` which is reactive.\n  // Therefore x should be treated as reactive.\n  return [x];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  sequentialRenders: [\n    {cond: true},\n    {cond: true},\n    {cond: false},\n    {cond: false},\n    {cond: true},\n    {cond: false},\n    {cond: true},\n    {cond: false},\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Managing State with Hooks in React - JavaScript\nDESCRIPTION: This snippet defines a React component using hooks to manage state. It imports a hook from a shared runtime, processes a list of items from props, and dynamically renders them with attached click handlers that update the state. It requires React to be installed and expects 'props.data' to be an array of objects with 'id' properties. The output is a rendered list of items encapsulated in a 'div'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-for-of-loop-with-context-variable-iterator.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport {useHook} from 'shared-runtime';\n\nfunction Component(props) {\n  const data = useHook();\n  const items = [];\n  // NOTE: `item` is a context variable because it's reassigned and also referenced\n  // within a closure, the `onClick` handler of each item\n  for (let item of props.data) {\n    item = item ?? {}; // reassignment to force a context variable\n    items.push(\n      <div key={item.id} onClick={() => data.set(item)}>\n        {item.id}\n      </div>\n    );\n  }\n  return <div>{items}</div>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{data: [{id: '1'}, {id: '2'}]}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: This JavaScript code shows the compiled version of the React component, leveraging React's compiler runtime. The `_c` function is used for memoization, caching the result of the array construction based on the values of `props.foo` and `props.bar`. This avoids unnecessary re-renders if the props haven't changed, optimizing performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-expression-spread.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(3);\n  let t0;\n  if ($[0] !== props.bar || $[1] !== props.foo) {\n    t0 = [0, ...props.foo, null, ...props.bar, \"z\"];\n    $[0] = props.bar;\n    $[1] = props.foo;\n    $[2] = t0;\n  } else {\n    t0 = $[2];\n  }\n  const x = t0;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ foo: [1, 2, 3], bar: [4, 5, 6] }],\n  isComponent: false,\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Compiler Output for Reactive Component\nDESCRIPTION: This code shows the transformed React component generated by the React compiler.  It utilizes `_c` from \"react/compiler-runtime\" for memoization. The compiler memoizes the returned array based on the value of `x`, ensuring that the component only re-renders when `x` changes, optimizing performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-for-update.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  let x;\n  for (let i = 0; i < 10; i = i + props.update, i) {\n    if (i > 0 && i % 2 === 0) {\n      x = 2;\n    } else {\n      x = 1;\n    }\n  }\n  let t0;\n  if ($[0] !== x) {\n    t0 = [x];\n    $[0] = x;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  sequentialRenders: [\n    { update: 2 },\n    { update: 2 },\n    { update: 1 },\n    { update: 1 },\n    { update: 2 },\n    { update: 1 },\n    { update: 2 },\n    { update: 1 },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Using Created Objects in a React Component - JavaScript\nDESCRIPTION: Defines the 'MyApp' function component that uses 'makeObj' to get an object with a specific structure. It retrieves the property 'b' from the created object and manipulates the array. This demonstrates usage of functions within React components and handles potential memoization logic.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/issue933-disjoint-set-infinite-loop.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// This caused an infinite loop in the compiler\nfunction MyApp(props) {\n  const y = makeObj();\n  const tmp = y.a;\n  const tmp2 = tmp.b;\n  y.push(tmp2);\n  return y;\n}\n```\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction makeObj() {\n  \"use no forget\";\n  const result = [];\n  result.a = { b: 2 };\n\n  return result;\n}\n\n// This caused an infinite loop in the compiler\nfunction MyApp(props) {\n  const $ = _c(1);\n  let y;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    y = makeObj();\n    const tmp = y.a;\n    const tmp2 = tmp.b;\n    y.push(tmp2);\n    $[0] = y;\n  } else {\n    y = $[0];\n  }\n  return y;\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing React DevTools Frontend with React and Socket.io\nDESCRIPTION: This snippet sets up the frontend for React DevTools using React and Socket.io. It creates a bridge between the frontend and backend, initializes the DevTools store, and renders the DevTools component.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools-inline/README.md#2025-04-21_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createElement } from 'react';\nimport { createRoot } from 'react-dom/client';\nimport {\n  createBridge,\n  createStore,\n  initialize as createDevTools,\n} from 'react-devtools-inline/frontend';\nimport { io } from \"socket.io-client\";\n\nlet root = null;\n\nconst socket = io(`http://${HOST}:${PORT}`);\nsocket.on(\"connect\", () => {\n  const wall = {\n    listen(listener) {\n      socket.on(\"message\", (data) => {\n        if (data.uid === UID) {\n          listener(data);\n        }\n      });\n    },\n    send(event, payload) {\n      const data = { event, payload, uid: UID };\n      socket.emit('message', data);\n    },\n  };\n\n  const bridge = createBridge(window, wall);\n  const store = createStore(bridge);\n  const DevTools = createDevTools(window, { bridge, store });\n\n  root = createRoot(document.getElementById('root'));\n  root.render(createElement(DevTools));\n});\nsocket.on(\"disconnect\", () => {\n  root.unmount();\n  root = null;\n});\n```\n\n----------------------------------------\n\nTITLE: Optimizing Context Rendering in React JavaScript\nDESCRIPTION: This snippet refines the context access pattern by incorporating memoization to optimize rendering. It uses an array from the useContext hook to determine when to update the component, reducing unnecessary renders. The App function compares current context values with previously stored values to decide if the component needs to re-render. Dependencies include a React component named Bar and an imported helper _c from the react/compiler-runtime package.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/todo.lower-context-access-array-destructuring.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @lowerContextAccess\nfunction App() {\n  const $ = _c(3);\n  const [foo, bar] = useContext(MyContext);\n  let t0;\n  if ($[0] !== bar || $[1] !== foo) {\n    t0 = <Bar foo={foo} bar={bar} />;\n    $[0] = bar;\n    $[1] = foo;\n    $[2] = t0;\n  } else {\n    t0 = $[2];\n  }\n  return t0;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Running ESLint v9 Test Fixture for React Hooks\nDESCRIPTION: Shell commands to set up and test the eslint-plugin-react-hooks with ESLint version 9. The commands navigate to the fixture directory, install dependencies, build the project, and run linting.\nSOURCE: https://github.com/facebook/react/blob/main/fixtures/eslint-v9/README.md#2025-04-21_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ncd fixtures/eslint-v9\nyarn\nyarn build\nyarn lint\n```\n\n----------------------------------------\n\nTITLE: Initializing React Component with Memoized Array\nDESCRIPTION: Creates a React component that generates an array using useMemo and makeArray function. Designed to optimize array creation and prevent unnecessary re-renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-named-function.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useMemo} from 'react';\nimport {makeArray} from 'shared-runtime';\n\nfunction Component() {\n  const x = useMemo(makeArray, []);\n  return x;\n}\n```\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useMemo } from \"react\";\nimport { makeArray } from \"shared-runtime\";\n\nfunction Component() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = makeArray();\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const x = t0;\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing React Component with Memoized Data\nDESCRIPTION: Creates a React functional component that uses useMemo to generate an array based on conditional props, with validation of memoization behavior\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/error.todo-optional-member-expression-with-conditional.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees @enableOptionalDependencies @enablePropagateDepsInHIR\nimport {ValidateMemoization} from 'shared-runtime';\nfunction Component(props) {\n  const data = useMemo(() => {\n    const x = [];\n    x.push(props?.items);\n    if (props.cond) {\n      x.push(props.items);\n    }\n    return x;\n  }, [props?.items, props.cond]);\n  return (\n    <ValidateMemoization inputs={[props?.items, props.cond]} output={data} />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Flow-typed React Component Definition\nDESCRIPTION: Original Flow-typed component definition using destructuring and nullish coalescing operator for default value handling.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/logical-reorder.flow.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst foo = undefined;\n\ncomponent C(...{scope = foo ?? null}: any) {\n  return scope;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: C,\n  params: [{scope: undefined}],\n};\n```\n\n----------------------------------------\n\nTITLE: Mutating Component Props with useEffect - React - JavaScript\nDESCRIPTION: This React functional component attempts to directly mutate its props, specifically altering the 'foo' property of the 'y' variable, which is derived from props. The component demonstrates the misuse of state by mutating props, which violates React's principles and leads to a runtime error. The useEffect hook is utilized to trigger the mutation, but this approach is discouraged.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-mutate-props-in-effect-fixpoint.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useEffect} from 'react';\n\nfunction Component(props) {\n  let x = null;\n  while (x == null) {\n    x = props.value;\n  }\n  let y = x;\n  let mutateProps = () => {\n    y.foo = true;\n  };\n  let mutatePropsIndirect = () => {\n    mutateProps();\n  };\n  useEffect(() => mutatePropsIndirect(), [mutatePropsIndirect]);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Error Handling (JavaScript)\nDESCRIPTION: This code defines a React component that demonstrates error handling. It attempts to throw an input, catches the error, and manipulates an array. The component is exported as part of a FIXTURE_ENTRYPOINT object.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-alias-try-values.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst {throwInput} = require('shared-runtime');\n\nfunction Component(props) {\n  let y;\n  let x = [];\n  try {\n    // throws x\n    throwInput(x);\n  } catch (e) {\n    // e = x\n    y = e; // y = x\n  }\n  y.push(null);\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Compiler Runtime\nDESCRIPTION: This snippet shows an optimized version of the React component, likely generated by a compiler. It includes memoization and conditional rendering optimizations while maintaining the same functionality as the original component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/controlled-input.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useState } from \"react\";\nfunction component() {\n  const $ = _c(3);\n  const [x, setX] = useState(0);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = (event) => setX(event.target.value);\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const handler = t0;\n  let t1;\n  if ($[1] !== x) {\n    t1 = <input onChange={handler} value={x} />;\n    $[1] = x;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: [],\n  isComponent: true,\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Component with useMemo\nDESCRIPTION: This code defines a React functional component that attempts to use the useMemo hook with an async function. However, the code violates React's rules since the callback for useMemo cannot be an async function. The error message illustrates this violation and indicates that the async function should be refactored.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-ReactUseMemo-async-callback.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component(a, b) {\n  let x = React.useMemo(async () => {\n    await a;\n  }, []);\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Error Output for Using Hook - Documented Output\nDESCRIPTION: This represents the error output encountered when the invalid hook configuration is detected during the return statement in the component. It highlights the specific issue of the type configuration mismatch for the hook being used. This is crucial for debugging and understanding the need for correct hook typing.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-type-provider-hook-name-not-typed-as-hook.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n  2 |\n  3 | function Component() {\n> 4 |   return useHookNotTypedAsHook();\n    |          ^^^^^^^^^^^^^^^^^^^^^ InvalidConfig: Invalid type configuration for module. Expected type for object property 'useHookNotTypedAsHook' from module 'ReactCompilerTest' to be a hook based on the property name (4:4)\n  5 | }\n  6 |\n\n```\n\n----------------------------------------\n\nTITLE: Invalid Hook Usage\nDESCRIPTION: This snippet demonstrates the invalid usage of a hook within a named function in React. Such usage violates the rules of hooks, which state that hooks can only be called at the top level of a functional component or custom hook. The snippet includes an example that is expected to fail validation but passes mistakenly due to the testing setup.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.invalid.invalid-rules-of-hooks-a63fd4f9dcc0.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @skip\n// Passed but should have failed\n\n// This is invalid because \"use\"-prefixed functions used in named\n// functions are assumed to be hooks.\nReact.unknownFunction(function notAComponent(foo, bar) {\n  useProbablyAHook(bar);\n});\n```\n\n----------------------------------------\n\nTITLE: Input React Components with Forget Feature\nDESCRIPTION: Original React component definitions using the 'forget' directive. Includes Bar, NoForget, and recursive Foo components with basic props handling.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/codegen-instrument-forget-gating-test.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableEmitInstrumentForget @compilationMode(annotation) @gating\n\nfunction Bar(props) {\n  'use forget';\n  return <div>{props.bar}</div>;\n}\n\nfunction NoForget(props) {\n  return <Bar>{props.noForget}</Bar>;\n}\n\nfunction Foo(props) {\n  'use forget';\n  if (props.bar < 0) {\n    return props.children;\n  }\n  return (\n    <Foo bar={props.bar - 1}>\n      <NoForget />\n    </Foo>\n  );\n}\n\nglobal.DEV = true;\nexport const FIXTURE_ENTRYPOINT = {\n  fn: eval('Foo'),\n  params: [{bar: 2}],\n};\n```\n\n----------------------------------------\n\nTITLE: Initializing React Component with Fire Event\nDESCRIPTION: Defines a React functional component using a custom fire event with useEffect and dependency tracking. The component logs props and triggers a fire event within the effect hook.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/error.invalid-rewrite-deps-no-array-literal.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableFire\nimport {fire} from 'react';\n\nfunction Component(props) {\n  const foo = props => {\n    console.log(props);\n  };\n\n  const deps = [foo, props];\n\n  useEffect(() => {\n    fire(foo(props));\n  }, deps);\n\n  return null;\n}\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with FBT and Memoization\nDESCRIPTION: This snippet shows an optimized version of the React component, likely produced by a compiler. It implements the same functionality as the original component but with additional optimizations for memoization and rendering efficiency.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-repro-invalid-mutable-range-destructured-prop.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { fbt } from \"fbt\";\nimport { useMemo } from \"react\";\nimport { ValidateMemoization } from \"shared-runtime\";\n\nfunction Component(t0) {\n  const $ = _c(7);\n  const { data } = t0;\n  let t1;\n  let t2;\n  if ($[0] !== data.name) {\n    t2 = fbt._(\"{'name'}\", [fbt._param(\"name\", data.name ?? \"\")], {\n      hk: \"csQUH\",\n    });\n    $[0] = data.name;\n    $[1] = t2;\n  } else {\n    t2 = $[1];\n  }\n  t1 = t2;\n  const el = t1;\n  let t3;\n  if ($[2] !== data.name) {\n    t3 = [data.name];\n    $[2] = data.name;\n    $[3] = t3;\n  } else {\n    t3 = $[3];\n  }\n  let t4;\n  if ($[4] !== el || $[5] !== t3) {\n    t4 = <ValidateMemoization inputs={t3} output={el} />;\n    $[4] = el;\n    $[5] = t3;\n    $[6] = t4;\n  } else {\n    t4 = $[6];\n  }\n  return t4;\n}\n\nconst props1 = { data: { name: \"Mike\" } };\nconst props2 = { data: { name: \"Mofei\" } };\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [props1],\n  sequentialRenders: [props1, props2, props2, props1, { ...props1 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with FBT\nDESCRIPTION: Compiled output of the FBT component showing runtime optimizations including memoization using the compiler runtime. Implements the same functionality with additional performance improvements.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-call.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport fbt from \"fbt\";\n\nfunction Component(props) {\n  const $ = _c(4);\n  let t0;\n  if ($[0] !== props.count) {\n    t0 = fbt._(\n      \"{(key) count} items\",\n      [fbt._param(\"(key) count\", props.count)],\n      { hk: \"3yW91j\" },\n    );\n    $[0] = props.count;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const text = t0;\n  let t1;\n  if ($[2] !== text) {\n    t1 = <div>{text}</div>;\n    $[2] = text;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  return t1;\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled React.forwardRef Output\nDESCRIPTION: Compiled version of the component showing React's internal caching mechanism using Symbol.for() and compiler runtime utilities. Implements memo caching for the div element.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-function-forwardRef.expect.md#2025-04-22_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @compilationMode(infer)\nReact.forwardRef((props) => {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = <div />;\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n});\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with FBT Internationalization\nDESCRIPTION: This snippet defines a React component that uses FBT for internationalization. It demonstrates how to insert dynamic content into a translated string using FBT parameters.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-whitespace-around-param-value.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport fbt from 'fbt';\n\nconst _ = fbt;\nfunction Component({value}: {value: string}) {\n  return (\n    <fbt desc=\"descdesc\">\n      Before text <fbt:param name=\"paramName\"> {value} </fbt:param> after text\n    </fbt>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: 'hello world'}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining useMakeCallback Hook\nDESCRIPTION: This code defines a React hook `useMakeCallback` that conditionally returns a callback function based on the `shouldMakeCb` prop. The callback updates the state using the `setState` function with the `obj.value`.  The hook takes an object with `obj`, `shouldMakeCb`, and `setState` properties.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/assume-invoked/conditionally-return-fn.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {createHookWrapper} from 'shared-runtime';\n\n/**\n * Assume that conditionally returned functions can be invoked and that their\n * property loads are hoistable to the function declaration site.\n */\nfunction useMakeCallback({\n  obj,\n  shouldMakeCb,\n  setState,\n}: {\n  obj: {value: number};\n  shouldMakeCb: boolean;\n  setState: (newState: number) => void;\n}) {\n  const cb = () => setState(obj.value);\n  if (shouldMakeCb) return cb;\n  else return null;\n}\n\nconst setState = (arg: number) => {\n  'use no memo';\n  return arg;\n};\nexport const FIXTURE_ENTRYPOINT = {\n  fn: createHookWrapper(useMakeCallback),\n  params: [{obj: {value: 1}, shouldMakeCb: true, setState}],\n  sequentialRenders: [\n    {obj: {value: 1}, shouldMakeCb: true, setState},\n    {obj: {value: 2}, shouldMakeCb: true, setState},\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Dynamic Item Generation in React Component\nDESCRIPTION: This snippet shows a React component that generates a list of div elements based on a range of values. It uses a custom hook 'useData' and creates onClick handlers for each item. The component demonstrates the use of context variables and closure.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-loop-with-context-variable-iterator.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component() {\n  const data = useData();\n  const items = [];\n  // NOTE: `i` is a context variable because it's reassigned and also referenced\n  // within a closure, the `onClick` handler of each item\n  for (let i = MIN; i <= MAX; i += INCREMENT) {\n    items.push(<div key={i} onClick={() => data.set(i)} />);\n  }\n  return <>{items}</>;\n}\n\nconst MIN = 0;\nconst MAX = 3;\nconst INCREMENT = 1;\n\nfunction useData() {\n  return new Map();\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  params: [],\n  fn: Component,\n};\n```\n\n----------------------------------------\n\nTITLE: Error Handling in React Component Memoization\nDESCRIPTION: This portion of the file highlights an error related to memoization preservation within a React component. It suggests that the dependencies inferred for the 'useMemo' hook do not align with those specified manually, which can lead to unexpected behavior in rendering. The error indicates that existing manual memoization has been bypassed, necessitating a review of the dependency array passed to 'useMemo'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/error.todo-optional-member-expression-with-conditional-optional.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n   2 | import {ValidateMemoization} from 'shared-runtime';\n   3 | function Component(props) {\n>  4 |   const data = useMemo(() => {\n     |                        ^^^^^^^\n>  5 |     const x = [];\n     | ^^^^^^^^^^^^^^^^^\n>  6 |     x.push(props?.items);\n     | ^^^^^^^^^^^^^^^^^\n>  7 |     if (props.cond) {\n     | ^^^^^^^^^^^^^^^^^\n>  8 |       x.push(props?.items);\n     | ^^^^^^^^^^^^^^^^^\n>  9 |     }\n     | ^^^^^^^^^^^^^^^^^\n> 10 |     return x;\n     | ^^^^^^^^^^^^^^^^^\n> 11 |   }, [props?.items, props.cond]);\n     | ^^^^ CannotPreserveMemoization: React Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. The inferred dependencies did not match the manually specified dependencies, which could cause the value to change more or less frequently than expected (4:11)\n  12 |   return (\n  13 |     <ValidateMemoization inputs={[props?.items, props.cond]} output={data} />\n  14 |   );\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing useMemo and useEffect in React Component - JavaScript\nDESCRIPTION: This snippet defines a React component utilizing the `useMemo` hook to memoize a function that calls `someGlobal`, and the `useEffect` hook to invoke the memoized function. The component is designed to serve as a fixture entry point. It requires React's `useEffect` and custom `useMemo` implementation, and returns null indicating it's a non-visual component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useEffect-global-pruned.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useEffect} from 'react';\n\nfunction someGlobal() {}\nfunction useFoo() {\n  const fn = React.useMemo(\n    () =>\n      function () {\n        someGlobal();\n      },\n    []\n  );\n  useEffect(() => {\n    fn();\n  }, [fn]);\n\n  return null;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [],\n  isComponent: false,\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Component Source Code with useCallback and useRef\nDESCRIPTION: Original React component implementation showing usage of useRef for mutable state and useCallback for event handlers. Demonstrates pattern for maintaining mutable references while using callback memoization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useCallback-multiple-callbacks-modifying-same-ref-preserve-memoization.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enablePreserveExistingMemoizationGuarantees\nimport {useCallback, useRef} from 'react';\n\nfunction Component(props) {\n  const ref = useRef({inner: null});\n\n  const onChange = useCallback(event => {\n    // The ref should still be mutable here even though function deps are frozen in\n    // @enablePreserveExistingMemoizationGuarantees mode\n    ref.current.inner = event.target.value;\n  });\n\n  const onReset = useCallback(() => {\n    ref.current.inner = null;\n  });\n\n  return <input onChange={onChange} onReset={onReset} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Component in JavaScript\nDESCRIPTION: This function defines a simple React component that receives an object with properties 'a' and 'b' and returns an object containing 'y' and 'z'. It is used in conjunction with the FIXTURE_ENTRYPOINT object to specify parameters and component identity for 'TodoAdd'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-pattern-params.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nfunction component({a, b}) {\n  let y = {a};\n  let z = {b};\n  return {y, z};\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: Compiled version of the component with added memoization logic. Implements caching for computed values and props using a sentinel pattern to track changes and avoid unnecessary recalculations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/mege-consecutive-scopes-dont-merge-with-different-deps.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nconst { getNumber, identity } = require(\"shared-runtime\");\n\nfunction Component(props) {\n  const $ = _c(6);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = getNumber();\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  let t1;\n  if ($[1] !== props.id) {\n    t1 = identity(props.id);\n    $[1] = props.id;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  let t2;\n  if ($[3] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t2 = [\"static\"];\n    $[3] = t2;\n  } else {\n    t2 = $[3];\n  }\n  let t3;\n  if ($[4] !== t1) {\n    t3 = { a: t0, b: t1, c: t2 };\n    $[4] = t1;\n    $[5] = t3;\n  } else {\n    t3 = $[5];\n  }\n  return t3;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ id: 42 }],\n};\n```\n\n----------------------------------------\n\nTITLE: JSX Transformation Change\nDESCRIPTION: This snippet describes a breaking change in the JSX transformation process. The `class` attribute is no longer automatically transformed to `className`. Developers must manually update their code to use `className` to avoid visual issues in their components.\nSOURCE: https://github.com/facebook/react/blob/main/CHANGELOG.md#2025-04-21_snippet_24\n\nLANGUAGE: none\nCODE:\n```\n\"No longer transform `class` to `className` as part of the transform! This is a breaking change - if you were using `class`, you *must* change this to `className` or your components will be visually broken.\"\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization Logic\nDESCRIPTION: The compiled version of the React component showing the internal memoization implementation. Contains detailed caching logic using a compiler-generated array for storing memoized values and dependencies.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-provider-log.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useMemo } from \"react\";\nimport { typedLog, ValidateMemoization } from \"shared-runtime\";\n\nexport function Component(t0) {\n  const $ = _c(17);\n  const { a, b } = t0;\n  let t1;\n  let t2;\n  if ($[0] !== a) {\n    t2 = { a };\n    $[0] = a;\n    $[1] = t2;\n  } else {\n    t2 = $[1];\n  }\n  t1 = t2;\n  const item1 = t1;\n  let t3;\n  let t4;\n  if ($[2] !== b) {\n    t4 = { b };\n    $[2] = b;\n    $[3] = t4;\n  } else {\n    t4 = $[3];\n  }\n  t3 = t4;\n  const item2 = t3;\n  typedLog(item1, item2);\n  let t5;\n  if ($[4] !== a) {\n    t5 = [a];\n    $[4] = a;\n    $[5] = t5;\n  } else {\n    t5 = $[5];\n  }\n  let t6;\n  if ($[6] !== item1 || $[7] !== t5) {\n    t6 = <ValidateMemoization inputs={t5} output={item1} />;\n    $[6] = item1;\n    $[7] = t5;\n    $[8] = t6;\n  } else {\n    t6 = $[8];\n  }\n  let t7;\n  if ($[9] !== b) {\n    t7 = [b];\n    $[9] = b;\n    $[10] = t7;\n  } else {\n    t7 = $[10];\n  }\n  let t8;\n  if ($[11] !== item2 || $[12] !== t7) {\n    t8 = <ValidateMemoization inputs={t7} output={item2} />;\n    $[11] = item2;\n    $[12] = t7;\n    $[13] = t8;\n  } else {\n    t8 = $[13];\n  }\n  let t9;\n  if ($[14] !== t6 || $[15] !== t8) {\n    t9 = (\n      <>\n        {t6}\n        {t8}\n      </>\n    );\n    $[14] = t6;\n    $[15] = t8;\n    $[16] = t9;\n  } else {\n    t9 = $[16];\n  }\n  return t9;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ a: 0, b: 0 }],\n  sequentialRenders: [\n    { a: 0, b: 0 },\n    { a: 1, b: 0 },\n    { a: 1, b: 1 },\n    { a: 1, b: 2 },\n    { a: 2, b: 2 },\n    { a: 3, b: 2 },\n    { a: 0, b: 0 },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Optimized Memoization\nDESCRIPTION: This code shows the compiled version of the React component `Component`, where the `useMemo` hook has been transformed by the React compiler. The compiler introduces a `_c` function and an array `$` to store the previous values and the memoized result. This optimization avoids the overhead of calling the original `useMemo` hook and performs a direct comparison to determine if the memoized value needs to be updated.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useMemo-conditional-access-noAlloc.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @validatePreserveExistingMemoizationGuarantees\nimport { useMemo } from \"react\";\n\nfunction Component(t0) {\n  const $ = _c(3);\n  const { propA, propB } = t0;\n  let t1;\n\n  const t2 = propB?.x.y;\n  let t3;\n  if ($[0] !== propA || $[1] !== t2) {\n    t3 = { value: t2, other: propA };\n    $[0] = propA;\n    $[1] = t2;\n    $[2] = t3;\n  } else {\n    t3 = $[2];\n  }\n  t1 = t3;\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ propA: 2, propB: { x: { y: [] } } }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: Input source code showing a React function component that creates an array with logging functionality. Uses makeArray and print utilities from shared-runtime.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/codegen-inline-iife.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {makeArray, print} from 'shared-runtime';\n\nfunction useTest() {\n  return makeArray<number | void>(\n    print(1),\n    (function foo() {\n      print(2);\n      return 2;\n    })(),\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useTest,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Creating and Managing Refs in a React Component\nDESCRIPTION: This snippet defines a React functional component that utilizes local references and memoization. The useMemo hook is employed to determine the merged reference based on the disableLocalRef flag. The identity function ensures the correct reference is maintained unless disabled. This example emphasizes correct ref handling during component rendering, focusing on avoiding invalid access to ref properties within the React render phase.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.useMemo-with-refs.flow.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @flow @validatePreserveExistingMemoizationGuarantees\nimport {identity} from 'shared-runtime';\n\ncomponent Component(disableLocalRef, ref) {\n  const localRef = useFooRef();\n  const mergedRef = useMemo(() => {\n    return disableLocalRef ? ref : identity(ref, localRef);\n  }, [disableLocalRef, ref, localRef]);\n  return <div ref={mergedRef} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Setting up and running React SSR fixtures in development mode\nDESCRIPTION: Commands to set up and run the server-side rendering fixtures in development mode with hot reloading after building React locally.\nSOURCE: https://github.com/facebook/react/blob/main/fixtures/ssr2/README.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncd fixtures/ssr2\nyarn\nyarn start\n```\n\n----------------------------------------\n\nTITLE: React Error Handling for Ref Access\nDESCRIPTION: This snippet outlines the error message resulting from invalid access of the `current` property of a ref during the render phase in React. It indicates the specific line of code causing the issue and provides a link for further reference on React's rules regarding ref access.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-write-but-dont-read-ref-in-render.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n  3 |   const ref = useRef(null);\n  4 |   // Writing to a ref in render is against the rules:\n> 5 |   ref.current = value;\n    |   ^^^^^^^^^^^ InvalidReact: Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef) (5:5)\n  6 |   // returning a ref is allowed, so this alone doesn't trigger an error:\n  7 |   return ref;\n  8 | }\n```\n\n----------------------------------------\n\nTITLE: Creating Hook Wrapper using Shared Runtime JavaScript\nDESCRIPTION: This code snippet defines a function `useHook` that creates a custom hook with properties `x`, `y`, and `z` using a shared runtime utility. Dependencies include the `createHookWrapper` from the 'shared-runtime'. Parameters include `a`, `b`, and `c`, which are input to the hook, functioning as the source of reactive data. The output is an object with properties `x`, `y`, and `z`, reflecting the inputs. Additional limitations include its use within a shared-runtime compatible setup.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-shorthand-method-2.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport {createHookWrapper} from 'shared-runtime';\n\nfunction useHook({a, b, c}) {\n  return {\n    x: [a],\n    y() {\n      return [b];\n    },\n    z: {c},\n  };\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: createHookWrapper(useHook),\n  params: [{a: 1, b: 2, c: 2}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Original React Component with Dynamic Context\nDESCRIPTION: This snippet shows the original React component that creates a dynamic context object based on props. It uses a constant SCALE and the identity function from a shared runtime.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-expression-computed-key-non-reactive.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {identity} from 'shared-runtime';\n\nconst SCALE = 2;\n\nfunction Component(props) {\n  const key = SCALE;\n  const context = {\n    [key]: identity([props.value]),\n  };\n  return context;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{key: 'Sathya', value: 'Compiler'}],\n};\n```\n\n----------------------------------------\n\nTITLE: Conditional Memoization with Custom Checks\nDESCRIPTION: This snippet contains a component that checks if the memo cache sentinel is present and either creates or retrieves a memoized object. It enhances performance and avoids unnecessary re-computation using shared functions and React's memoization strategy.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-maybe-modified-later-preserve-memoization-guarantees.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enablePreserveExistingMemoizationGuarantees\nimport { useMemo } from \"react\";\nimport { identity, makeObject_Primitives, mutate } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(1);\n  let t0;\n  let t1;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = makeObject_Primitives();\n    $[0] = t1;\n  } else {\n    t1 = $[0];\n  }\n  t0 = t1;\n  const object = t0;\n  identity(object);\n  return object;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Original Array.at Implementation in React Component\nDESCRIPTION: Demonstrates a React component that uses Array.at() method with props. The component creates an array with a single element and accesses it using the at() method with dynamic indices.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-at-effect.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// arrayInstance.at should have the following effects:\n//  - read on arg0\n//  - read on receiver\n//  - mutate on lvalue\nfunction ArrayAtTest(props) {\n  const arr = [foo(props.x)];\n  const result = arr.at(bar(props.y));\n  return result;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining useFoo Hook\nDESCRIPTION: This snippet defines a custom hook 'useFoo' that takes an object and a boolean indicating if the object is null. It checks the null status, pushes the object's property 'b' to an array when not null, and returns that array.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-poisoned/return-in-scope.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction useFoo({obj, objIsNull}) {\n  const x = [];\n  if (objIsNull) {\n    return;\n  }\n  x.push(obj.b);\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Foo Component with Stringify - Initial Version\nDESCRIPTION: This snippet defines the Foo component in React using a functional approach. It uses the Stringify component to conditionally return the value of 'a.b.c' based on the prop 'shouldReadA'. The FIXTURE_ENTRYPOINT constant is prepared for testing with an initial setup of parameters.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/infer-function-cond-access-not-hoisted.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enablePropagateDepsInHIR\n\nimport {Stringify} from 'shared-runtime';\n\nfunction Foo({a, shouldReadA}) {\n  return (\n    <Stringify\n      fn={() => {\n        if (shouldReadA) return a.b.c;\n        return null;\n      }}\n      shouldInvokeFns={true}\n    />\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{a: null, shouldReadA: true}],\n  sequentialRenders: [\n    {a: null, shouldReadA: true},\n    {a: null, shouldReadA: false},\n    {a: {b: {c: 4}}, shouldReadA: true},\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Initial Component Definition with JSX in Try-Catch\nDESCRIPTION: Original React component attempting to render JSX within a try-catch block, which triggers a compilation warning about potential rendering errors\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/invalid-jsx-in-try-with-catch.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @logger @validateNoJSXInTryStatements\nfunction Component(props) {\n  let el;\n  try {\n    el = <div />;\n  } catch {\n    return null;\n  }\n  return el;\n}\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: Basic React component that creates an array with fixed and dynamic values, uses identity hook, and filters the array before rendering with Stringify component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/global-types/repro-array-filter-known-nonmutate-Boolean.expect.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {Stringify, useIdentity} from 'shared-runtime';\n\n/**\n * Also see repro-array-map-known-mutate-shape, which calls a global function\n * that mutates its operands.\n */\nfunction Component({value}) {\n  const arr = [{value: 'foo'}, {value: 'bar'}, {value}];\n  useIdentity(null);\n  const derived = arr.filter(Boolean);\n  return (\n    <Stringify>\n      {derived.at(0)}\n      {derived.at(-1)}\n    </Stringify>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: 5}],\n  sequentialRenders: [{value: 5}, {value: 6}, {value: 6}],\n};\n```\n\n----------------------------------------\n\nTITLE: Initializing React Component with useRef and useEffect - JavaScript\nDESCRIPTION: This snippet initializes a React component using the useEffect and useRef hooks. It defines a useFoo function that is intended to perform an action on a ref value, setting it to 42. The Component function is exported as part of a FIXTURE_ENTRYPOINT for integration or testing purposes. Dependencies include react and the custom useFoo hook. Inputs include component props, and changes are reflected in the current value of the ref.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hook-ref-callback.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useEffect, useRef} from 'react';\n\nfunction Component(props) {\n  const ref = useRef();\n  useFoo(() => {\n    ref.current = 42;\n  });\n}\n\nfunction useFoo(x) {}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Validating Capitalized Function Calls - JavaScript\nDESCRIPTION: This snippet defines a function 'Foo' that incorrectly invokes a capitalized function 'Bar'. This triggers a validation error, indicating that capitalized functions are reserved for React components. The error message provides guidance on how to correct the issue or allowlist the function.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.capitalized-function-call-aliased.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validateNoCapitalizedCalls\nfunction Foo() {\n  let x = Bar;\n  x(); // ERROR\n}\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Optimization Techniques\nDESCRIPTION: This snippet shows the compiled version of the React component. It includes various optimization techniques, such as memoization and conditional rendering, to improve performance and efficiency.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-dont-memoize-array-with-mutable-map-after-hook.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useEffect, useState } from \"react\";\nimport { mutate } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(7);\n  const x = [{ ...props.value }];\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = [];\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  useEffect(_temp, t0);\n  const onClick = () => {\n    console.log(x.length);\n  };\n\n  let y;\n\n  const t1 = x.map(_temp2);\n  let t2;\n  if ($[1] !== y) {\n    t2 = mutate(y);\n    $[1] = y;\n    $[2] = t2;\n  } else {\n    t2 = $[2];\n  }\n  let t3;\n  if ($[3] !== onClick || $[4] !== t1 || $[5] !== t2) {\n    t3 = (\n      <div onClick={onClick}>\n        {t1}\n        {t2}\n      </div>\n    );\n    $[3] = onClick;\n    $[4] = t1;\n    $[5] = t2;\n    $[6] = t3;\n  } else {\n    t3 = $[6];\n  }\n  return t3;\n}\nfunction _temp2(item) {\n  item.flag = true;\n  return <span key={item.id}>{item.text}</span>;\n}\nfunction _temp() {}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ value: { id: 0, text: \"Hello\", flag: false } }],\n  isComponent: true,\n};\n```\n\n----------------------------------------\n\nTITLE: Optimizing React Component with Compiler Runtime in JavaScript\nDESCRIPTION: This snippet shows an optimized version of the 'useFoo' component using a compiler runtime. It introduces memoization to prevent unnecessary re-renders and object creations. The optimization uses an array '$' to store and retrieve memoized values based on input conditions.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/mutation-within-jsx-and-break.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport {\n  Stringify,\n  makeObject_Primitives,\n  mutate,\n  mutateAndReturn,\n} from \"shared-runtime\";\n\nfunction useFoo(t0) {\n  const $ = _c(3);\n  const { data } = t0;\n  let obj;\n  let myDiv = null;\n  bb0: if (data.cond) {\n    if ($[0] !== data.cond1) {\n      obj = makeObject_Primitives();\n      if (data.cond1) {\n        myDiv = <Stringify value={mutateAndReturn(obj)} />;\n        break bb0;\n      }\n\n      mutate(obj);\n      $[0] = data.cond1;\n      $[1] = obj;\n      $[2] = myDiv;\n    } else {\n      obj = $[1];\n      myDiv = $[2];\n    }\n  }\n  return myDiv;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ data: { cond: true, cond1: true } }],\n  sequentialRenders: [\n    { data: { cond: true, cond1: true } },\n    { data: { cond: true, cond1: true } },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining StoreLandingUnseenGiftModalContainer Function Component\nDESCRIPTION: This snippet defines the StoreLandingUnseenGiftModalContainer function which takes a parameter 'a' representing the gifts seen. It returns a function that checks if a gift is seen or not. It is a simple utility component that checks the visibility status of gifts.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-skip-computed-path.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction StoreLandingUnseenGiftModalContainer(a) {\n  const giftsSeen = {a};\n  return (gift => (gift.id ? giftsSeen[gift.id] : false))();\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: StoreLandingUnseenGiftModalContainer,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Using Non-Reactive Dependencies in React Effect Hooks - JavaScript\nDESCRIPTION: This snippet defines the function NonReactiveDepInEffect, which utilizes the useEffect hook from React to manage non-reactive dependencies. It prints an object created by makeObject_Primitives using both React's useEffect and a custom SharedRuntime hook. It is required to have 'react' and 'shared-runtime' libraries available.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/import-namespace-useEffect.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @inferEffectDependencies\nimport * as React from 'react';\nimport * as SharedRuntime from 'shared-runtime';\n\nfunction NonReactiveDepInEffect() {\n  const obj = makeObject_Primitives();\n  React.useEffect(() => print(obj));\n  SharedRuntime.useSpecialEffect(() => print(obj), [obj]);\n}\n\n```\n\n----------------------------------------\n\nTITLE: React Component Implementation with String Directives\nDESCRIPTION: Alternative syntax version of the React component showing memo directives with double quotes. Functionally identical to the previous snippet but uses different string notation for the directives.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/use-no-memo-module-scope-usememo-function-scope.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// @compilationMode(all)\n\"use no memo\";\n\nfunction TestComponent({ x }) {\n  \"use memo\";\n  return <Button>{x}</Button>;\n}\n```\n\n----------------------------------------\n\nTITLE: Utilizing React Compiler Runtime Caching\nDESCRIPTION: This JavaScript snippet leverages React's compiler runtime for memoization. The function uses runtime cache checks to optimize conditional object creation within a React component, returning a memoized object based on the input condition. This enhances performance by avoiding unnecessary recomputation of unchanged states.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-property-alias-if.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction foo(a) {\n  const $ = _c(4);\n  let x;\n  if ($[0] !== a) {\n    x = {};\n    if (a) {\n      let t0;\n      if ($[2] === Symbol.for(\"react.memo_cache_sentinel\")) {\n        t0 = {};\n        $[2] = t0;\n      } else {\n        t0 = $[2];\n      }\n      const y = t0;\n      x.y = y;\n    } else {\n      let t0;\n      if ($[3] === Symbol.for(\"react.memo_cache_sentinel\")) {\n        t0 = {};\n        $[3] = t0;\n      } else {\n        t0 = $[3];\n      }\n      const z = t0;\n      x.z = z;\n    }\n    $[0] = a;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Forget Feature Flag\nDESCRIPTION: This snippet shows an optimized version of the component using the Forget feature flag. It includes conditional rendering based on the feature flag, and implements memoization for the rendered content when the feature is enabled.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/infer-function-expression-React-memo-gating.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { isForgetEnabled_Fixtures } from \"ReactForgetFeatureFlag\"; // @gating @compilationMode(infer)\nimport React from \"react\";\nexport default React.forwardRef(\n  isForgetEnabled_Fixtures()\n    ? function notNamedLikeAComponent(props) {\n        const $ = _c(1);\n        let t0;\n        if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n          t0 = <div />;\n          $[0] = t0;\n        } else {\n          t0 = $[0];\n        }\n        return t0;\n      }\n    : function notNamedLikeAComponent(props) {\n        return <div />;\n      },\n);\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with Dynamic Theming in JavaScript\nDESCRIPTION: This snippet defines a React component that uses a custom theming system. It utilizes a 'useTheme' hook and a 'cx' utility for dynamic class name generation based on the current theme.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/meta-isms/repro-cx-namespace-assigned-to-temporary.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @compilationMode(infer) @enableAssumeHooksFollowRulesOfReact:false @customMacros(cx)\nimport {identity} from 'shared-runtime';\n\nconst DARK = 'dark';\n\nfunction Component() {\n  const theme = useTheme();\n  return (\n    <div\n      className={cx.foo({\n        'styles/light': true,\n        'styles/dark': identity([theme.getTheme()]),\n      })}\n    />\n  );\n}\n\nconst cx = {\n  foo(obj) {\n    const classes = [];\n    for (const [key, value] of Object.entries(obj)) {\n      if (value) {\n        classes.push(key);\n      }\n    }\n    return classes.join(' ');\n  },\n};\n\nfunction useTheme() {\n  return {\n    getTheme() {\n      return DARK;\n    },\n  };\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with Conditional Refs in JavaScript\nDESCRIPTION: This snippet demonstrates using React's useRef hook in a React component to conditionally assign ref objects and return a component that responds to changes in these refs. Dependencies are imported from external React libraries. It features a 'Component' function which returns a 'Stringify' component based on ref conditions. The expected input is a boolean 'cond', with outputs being 'Stringify' components for each state of 'cond'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-ref.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useRef} from 'react';\nimport {Stringify} from 'shared-runtime';\n\n/**\n * Fixture showing that Ref types may be reactive.\n * We should always take a dependency on ref values (the outer box) as\n * they may be reactive. Pruning should be done in\n * `pruneNonReactiveDependencies`\n */\nfunction Component({cond}) {\n  const ref1 = useRef(1);\n  const ref2 = useRef(2);\n  const ref = cond ? ref1 : ref2;\n  const cb = () => ref.current;\n  return <Stringify cb={cb} shouldInvokeFns={true} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{cond: true}],\n  sequentialRenders: [{cond: true}, {cond: false}],\n};\n```\n\n----------------------------------------\n\nTITLE: Initial React Component with Mutable State\nDESCRIPTION: A basic React component showing initial implementation with MaybeMutable and nested rendering\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-memo-value-not-promoted-to-outer-scope-static.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const count = new MaybeMutable();\n  return (\n    <View>\n      <View>\n        {<span>Text</span>}\n        {<span>{maybeMutate(count)}</span>}\n      </View>\n    </View>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Object Manipulation\nDESCRIPTION: This snippet defines a React component that creates an object from props, deletes a specific key, and returns the modified object. It also exports a constant for component testing.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/delete-computed-property.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const x = {a: props.a, b: props.b};\n  const key = 'b';\n  delete x[key];\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Hook Implementation\nDESCRIPTION: Original implementation of useBar hook that creates a Set, iterates over it using values(), and handles object mutation. Notable for demonstrating mutable iterator behavior with Set values.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-spread-later-mutated.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction useBar({arg}) {\n  /**\n   * Note that mutableIterator is mutated by the later object spread. Therefore,\n   * `s.values()` should be memoized within the same block as the object spread.\n   * In terms of compiler internals, they should have the same reactive scope.\n   */\n  const obj = {};\n  const s = new Set([obj, 5, 4]);\n  const mutableIterator = s.values();\n  const arr = [...mutableIterator];\n\n  obj.x = arg;\n  return arr;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useBar,\n  params: [{arg: 3}],\n  sequentialRenders: [{arg: 3}, {arg: 3}, {arg: 4}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining React Component Using useEffect\nDESCRIPTION: This snippet defines a simple React component that utilizes the useEffect hook to set a property on an object. The component does not take any parameters, and its main purpose is to showcase how useEffect can be used to manipulate external objects upon rendering. Since React is a fundamental library for building UI components, it is essential to have it as a dependency.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useEffect-method-call.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nlet x = {};\nfunction Component() {\n  React.useEffect(() => {\n    x.foo = 1;\n  });\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Increment/Decrement Operations with Flow in React\nDESCRIPTION: This snippet defines a Foo component using Flow type annotations. It demonstrates pre-increment, post-increment, and decrement operations on an object property, logging the results at various stages. The code also exports a FIXTURE_ENTRYPOINT object for testing purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/member-inc.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n//@flow\n\ncomponent Foo() {\n  let x = {a: 1};\n  x.a++;\n  x.a--;\n  console.log(++x.a);\n  console.log(x.a++);\n\n  console.log(x.a);\n  let y = x.a++;\n  console.log(y);\n  console.log(x.a);\n\n  console.log((++x.a).toString(), (x.a++).toString(), x.a);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Creating React Components with Conditional Hooks - JavaScript\nDESCRIPTION: This snippet illustrates the improper implementation of React hooks within a component function, specifically showing how a hook is used conditionally, which violates the React Rules of Hooks. The expected warning is highlighted in the accompanying error output.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid.invalid-rules-of-hooks-d842d36db450.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Invalid because it's dangerous and might not warn otherwise.\n// This *must* be invalid.\nfunction createComponent() {\n  return function ComponentWithConditionalHook() {\n    if (cond) {\n      useConditionalHook();\n    }\n  };\n}\n\n\n```\n\nLANGUAGE: javascript\nCODE:\n```\n  4 |   return function ComponentWithConditionalHook() {\n  5 |     if (cond) {\n> 6 |       useConditionalHook();\n    |       ^^^^^^^^^^^^^^^^^^ InvalidReact: Hooks must be called at the top level in the body of a function component or custom hook, and may not be called within function expressions. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning). Cannot call Custom within a function component (6:6)\n  7 |     }\n  8 |   };\n  9 | }\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with Dependency Propagation\nDESCRIPTION: This snippet defines a React component that demonstrates dependency propagation and nullthrows behavior. It uses optional chaining and nested object access to showcase reactive dependencies.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/memberexpr-join-optional-chain.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enablePropagateDepsInHIR\n// To preserve the nullthrows behavior and reactive deps of this code,\n// Forget needs to add `props.a.b` or a subpath as a dependency.\n//\n// (1) Since the reactive block producing x unconditionally read props.a.<...>,\n//     reading `props.a.b` outside of the block would still preserve nullthrows\n//     semantics of source code\n// (2) Technically, props.a, props.a.b, and props.a.b.c are all reactive deps.\n//     However, `props.a?.b` is only dependent on whether `props.a` is nullish,\n//     not its actual value. Since we already preserve nullthrows on `props.a`,\n//     we technically do not need to add `props.a` as a dependency.\n\nfunction Component(props) {\n  let x = [];\n  x.push(props.a?.b);\n  x.push(props.a.b.c);\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{a: {b: {c: 1}}}],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: A basic React component that creates an array by multiplying each item in a source array by 2. This represents the code before compiler optimization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-of-simple.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component() {\n  let x = [];\n  let items = [0, 1, 2];\n  for (const ii of items) {\n    x.push(ii * 2);\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with Error Handling\nDESCRIPTION: Implementation of a React component that includes error handling with try-catch block. The component accepts props and returns the default value, with error fallback.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-empty-try.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let x = props.default;\n  try {\n  } catch (e) {\n    x = e;\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{default: 42}],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimizing React Component Function with Compiler-Runtime in JavaScript\nDESCRIPTION: This snippet shows an optimized version of the 'foo' function using React's compiler-runtime. It implements memoization to avoid unnecessary recalculations and improve performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/dependencies.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction foo(x, y, z) {\n  const $ = _c(3);\n  const items = [z];\n  items.push(x);\n  let items2;\n  if ($[0] !== x || $[1] !== y) {\n    items2 = [];\n    if (x) {\n      items2.push(y);\n    }\n    $[0] = x;\n    $[1] = y;\n    $[2] = items2;\n  } else {\n    items2 = $[2];\n  }\n  if (y) {\n    items.push(x);\n  }\n  return items2;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with FBT Internationalization\nDESCRIPTION: This snippet defines a React component that uses the FBT framework for internationalization. It renders a div with a hover title that includes a parameterized greeting. The component also exports a fixture for testing or demonstration purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbs-params.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {fbs} from 'fbt';\n\nfunction Component(props) {\n  return (\n    <div\n      title={\n        <fbs desc={'Dialog to show to user'}>\n          Hello <fbs:param name=\"user name\">{props.name}</fbs:param>\n        </fbs>\n      }>\n      Hover me\n    </div>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{name: 'Sathya'}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Stringify\nDESCRIPTION: This snippet defines a React function component 'useFoo' that takes an object with a property 'a'. It returns a Stringify component that attempts to render a nested property path. It ensures the function is invoked only when dependencies change, as managed by the imported compiler runtime.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/todo-infer-function-uncond-optionals-hoisted.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enablePropagateDepsInHIR\n\nimport {Stringify} from 'shared-runtime';\n\nfunction useFoo({a}) {\n  return <Stringify fn={() => a.b?.c.d?.e} shouldInvokeFns={true} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{a: null}],\n  sequentialRenders: [\n    {a: null},\n    {a: {b: null}},\n    {a: {b: {c: {d: null}}}},\n    {a: {b: {c: {d: {e: 4}}}}},\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Component with useMemo and useEffect\nDESCRIPTION: This code snippet demonstrates a React component `useFoo` that utilizes the `useMemo` hook to memoize a function. This memoized function then invokes `someGlobal`. The `useEffect` hook is used to call the memoized function, ensuring it runs only when the function reference changes. This pattern can be used to prevent unnecessary re-renders or side effects.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useEffect-namespace-pruned.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as React from 'react';\n\nfunction someGlobal() {}\nfunction useFoo() {\n  const fn = React.useMemo(\n    () =>\n      function () {\n        someGlobal();\n      },\n    []\n  );\n  React.useEffect(() => {\n    fn();\n  }, [fn]);\n\n  return null;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [],\n  isComponent: false,\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Component with useImperativeHandle and useRef\nDESCRIPTION: This code defines a React component named `Component` that uses `useRef` to create mutable ref objects and `useImperativeHandle` to customize the instance value that is exposed to parent components when using `ref`. The `useImperativeHandle` hook's callback computes a value based on the component's props and ref values. The component also exports a `FIXTURE_ENTRYPOINT` constant, which configures the component's initial props for testing or demonstration purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useImperativeHandle-ref-mutate.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @flow\n\nimport {useImperativeHandle, useRef} from 'react';\n\ncomponent Component(prop: number) {\n  const ref1 = useRef(null);\n  const ref2 = useRef(1);\n  useImperativeHandle(ref1, () => {\n    const precomputed = prop + ref2.current;\n    return {\n      foo: () => prop + ref2.current + precomputed,\n    };\n  }, [prop]);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{prop: 1}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Implementing React Function Component with Optional Chaining in JavaScript\nDESCRIPTION: This snippet defines a React function component 'useFoo' that accepts a props object with a nullable value property. It uses optional chaining to access nested properties and passes them to a custom hook called 'useNoAlias'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-optional-call-chain-in-ternary.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useNoAlias} from 'shared-runtime';\n\nfunction useFoo(props: {value: {x: string; y: string} | null}) {\n  const value = props.value;\n  return useNoAlias(value?.x, value?.y) ? {} : null;\n}\n\nexport const FIXTURE_ENTRYPONT = {\n  fn: useFoo,\n  props: [{value: null}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiler-Optimized Component Implementation\nDESCRIPTION: Optimized version of the component using React's compiler runtime for memoization. Uses Symbol.for('react.memo_cache_sentinel') to cache object creation and prevent unnecessary recreations between renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-field-load.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction component() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = { t: 1 };\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const x = t0;\n  const p = x.t;\n  return p;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with Conditional Reassignment - JavaScript\nDESCRIPTION: This code snippet defines a React component that conditionally reassigns a variable based on a prop. It uses the 'invoke' function from a shared runtime and includes a fixture for testing with different prop values.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/context-variable-reactive-explicit-control-flow.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {invoke} from 'shared-runtime';\n\nfunction Component({shouldReassign}) {\n  let x = null;\n  const reassign = () => {\n    if (shouldReassign) {\n      x = 2;\n    }\n  };\n  invoke(reassign);\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{shouldReassign: true}],\n  sequentialRenders: [{shouldReassign: false}, {shouldReassign: true}],\n};\n```\n\n----------------------------------------\n\nTITLE: Component Implementation with Internal State Management - JavaScript\nDESCRIPTION: This snippet showcases a more complex version of the 'Component' function that integrates internal state management through the '_c' function from 'react/compiler-runtime'. It optimizes rendering based on input changes and caching of previously generated outputs.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-outlining-duplicate-prop.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enableJsxOutlining\nfunction Component(t0) {\n  const $ = _c(7);\n  const { arr } = t0;\n  const x = useX();\n  let t1;\n  if ($[0] !== arr || $[1] !== x) {\n    let t2;\n    if ($[3] !== x) {\n      t2 = (i, id) => {\n        const T0 = _temp;\n        return <T0 i={i} i1={i} key={id} x={x} />;\n      };\n      $[3] = x;\n      $[4] = t2;\n    } else {\n      t2 = $[4];\n    }\n    t1 = arr.map(t2);\n    $[0] = arr;\n    $[1] = x;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  let t2;\n  if ($[5] !== t1) {\n    t2 = <>{t1}</>;\n    $[5] = t1;\n    $[6] = t2;\n  } else {\n    t2 = $[6];\n  }\n  return t2;\n}\nfunction _temp(t0) {\n  const $ = _c(8);\n  const { i: i, i1: i1, x: x } = t0;\n  let t1;\n  if ($[0] !== i) {\n    t1 = <Baz i={i} />;\n    $[0] = i;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  let t2;\n  if ($[2] !== i1) {\n    t2 = <Foo i={i1} />;\n    $[2] = i1;\n    $[3] = t2;\n  } else {\n    t2 = $[3];\n  }\n  let t3;\n  if ($[4] !== t1 || $[5] !== t2 || $[6] !== x) {\n    t3 = (\n      <Bar x={x}>\n        {t1}\n        {t2}\n      </Bar>\n    );\n    $[4] = t1;\n    $[5] = t2;\n    $[6] = x;\n    $[7] = t3;\n  } else {\n    t3 = $[7];\n  }\n  return t3;\n}\n\nfunction Bar(t0) {\n  const $ = _c(3);\n  const { x, children } = t0;\n  let t1;\n  if ($[0] !== children || $[1] !== x) {\n    t1 = (\n      <>\n        {x}\n        {children}\n      </>\n    );\n    $[0] = children;\n    $[1] = x;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  return t1;\n}\n\nfunction Baz(t0) {\n  const { i } = t0;\n  return i;\n}\n\nfunction Foo(t0) {\n  const { i } = t0;\n  return i;\n}\n\nfunction useX() {\n  return \"x\";\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ arr: [\"foo\", \"bar\"] }],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized useTest Function with Memoization in JavaScript\nDESCRIPTION: This snippet shows an optimized version of the 'useTest' function with memoization. It uses the '_c' function from 'react/compiler-runtime' to create a memoization cache, improving performance by avoiding unnecessary recalculations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-slow-validate-preserve-memo.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @validatePreserveExistingMemoizationGuarantees\n\nimport { Builder } from \"shared-runtime\";\nfunction useTest(t0) {\n  const $ = _c(3);\n  const { isNull, data } = t0;\n  let t1;\n  if ($[0] !== data || $[1] !== isNull) {\n    t1 = Builder.makeBuilder(isNull, \"hello world\")\n      ?.push(\"1\", 2)\n      ?.push(3, { a: 4, b: 5, c: data })\n      ?.push(\n        6,\n\n        data,\n      )\n      ?.push(7, \"8\")\n      ?.push(\"8\", Builder.makeBuilder(!isNull)?.push(9).vals)?.vals;\n    $[0] = data;\n    $[1] = isNull;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  const result = t1;\n  return result;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useTest,\n  params: [{ isNull: false, data: \"param\" }],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with Conditional State Updates\nDESCRIPTION: This code defines a React component `Component` that uses `useState` to manage two boolean state variables `x` and `y`. The `setState` function is conditionally assigned to either `setX` or `setY` based on the `props.cond` value. The resulting `setState` function is then passed as a prop to a child component `Foo`.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-phi-setState-type.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport invariant from 'invariant';\nimport {useState} from 'react';\n\nfunction Component(props) {\n  const [x, setX] = useState(false);\n  const [y, setY] = useState(false);\n  let setState;\n  if (props.cond) {\n    setState = setX;\n  } else {\n    setState = setY;\n  }\n  const setState2 = setState;\n  const stateObject = {setState: setState2};\n  return (\n    <Foo\n      cond={props.cond}\n      setX={setX}\n      setY={setY}\n      setState={stateObject.setState}\n    />\n  );\n}\n\nfunction Foo({cond, setX, setY, setState}) {\n  if (cond) {\n    invariant(setState === setX, 'Expected the correct setState function');\n  } else {\n    invariant(setState === setY, 'Expected the correct setState function');\n  }\n  return 'ok';\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  sequentialRenders: [\n    {cond: true},\n    {cond: true},\n    {cond: false},\n    {cond: false},\n    {cond: true},\n    {cond: false},\n    {cond: true},\n    {cond: false},\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization in JavaScript\nDESCRIPTION: This snippet shows the compiled version of the previous React component. It uses the React compiler runtime for memoization and pre-calculates the array of values. The Stringify component is used to render the pre-calculated array.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/constant-propagation-bit-ops.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { Stringify } from \"shared-runtime\";\n\nfunction foo() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = (\n      <Stringify\n        value={[\n          123, 0, 123, 123, 123, 123, 123, 1, 122, 246, 61, 61, 9,\n          15.588457268119896, 12.25, 3.3219970854839125, 0, 1.5, 1, 0.5,\n        ]}\n      />\n    );\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: React Component Definition\nDESCRIPTION: This snippet defines a functional React component that accepts a `name` prop and renders a string containing \"hello world\" and the value of the `name` prop. It imports a `SharedRuntime` module and uses its `Stringify` component. The component is exported as `FIXTURE_ENTRYPOINT`.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-lowercase-localvar-memberexpr.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as SharedRuntime from 'shared-runtime';\nfunction Component({name}) {\n  const localVar = SharedRuntime;\n  return <localVar.Stringify>hello world {name}</localVar.Stringify>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{name: 'sathya'}],\n};\n```\n\n----------------------------------------\n\nTITLE: Using useRef in React Component - JavaScript\nDESCRIPTION: This snippet defines a React component using the useRef hook to handle mutable references within a functional component. The function f is invoked with the ref object if the current property is null. It demonstrates managing component state with useRef but improperly accesses the ref during render, leading to an error. Dependencies include the React library and its hooks. Inputs are parameters within the FIXTURE_ENTRYPOINT, and outputs are manipulations based on the ref's state.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.ref-initialization-call-2.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n//@flow\nimport {useRef} from 'react';\n\ncomponent C() {\n  const r = useRef(null);\n  if (r.current == null) {\n    f(r);\n  }\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: C,\n  params: [{}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Cloning the React Repository\nDESCRIPTION: Clone the React repository from GitHub to get started with the DevTools project.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/CONTRIBUTING.md#2025-04-21_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ngit clone git@github.com:facebook/react.git\n```\n\n----------------------------------------\n\nTITLE: React Component with useReducer\nDESCRIPTION: This code defines a React component named `f` that utilizes the `useReducer` hook to manage state. It also includes a simple `onClick` handler that dispatches an action when the `div` element is clicked. The component is then exported as `FIXTURE_ENTRYPOINT` with metadata indicating it is a React component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useReducer-returned-dispatcher-is-non-reactive.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useReducer} from 'react';\n\nfunction f() {\n  const [state, dispatch] = useReducer();\n\n  const onClick = () => {\n    dispatch();\n  };\n\n  return <div onClick={onClick} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: f,\n  params: [],\n  isComponent: true,\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Props and JSX in JavaScript\nDESCRIPTION: This snippet defines a React component named 'Component' that renders a div element with props. It also includes a helper function 'Foo' and demonstrates object creation and JSX usage.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/constructor.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Foo() {}\n\nfunction Component(props) {\n  const a = [];\n  const b = {};\n  new Foo(a, b);\n  let _ = <div a={a} />;\n  new Foo(b);\n  return <div a={a} b={b} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Using useEffect with Mutable Dependencies in React\nDESCRIPTION: This snippet defines a functional React component that attempts to use `useEffect` to log a list of items derived from props. However, the items array is not memoized, leading to potential issues with infinite loops during component updates. It illustrates how to manage dependencies within side effects when mutable values are involved.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-useEffect-dep-not-memoized-bc-range-overlaps-hook.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validateMemoizedEffectDependencies\nfunction Component(props) {\n  // Items cannot be memoized bc its mutation spans a hook call\n  const items = [props.value];\n  const [state, _setState] = useState(null);\n  mutate(items);\n\n  // Items is no longer mutable here, but it hasn't been memoized\n  useEffect(() => {\n    console.log(items);\n  }, [items]);\n\n  return [items, state];\n}\n\n\n```\n\n----------------------------------------\n\nTITLE: React Compiler-Transformed Function with Memoization\nDESCRIPTION: The compiler-transformed version of the original React function. It uses a cache array for memoization to avoid recalculating values when inputs haven't changed, dramatically improving performance by preventing unnecessary re-renders and computations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reassignment-separate-scopes.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction foo(a, b, c) {\n  const $ = _c(10);\n  let t0;\n  let x;\n  if ($[0] !== a) {\n    x = [];\n    if (a) {\n      x.push(a);\n    }\n\n    t0 = <div>{x}</div>;\n    $[0] = a;\n    $[1] = t0;\n    $[2] = x;\n  } else {\n    t0 = $[1];\n    x = $[2];\n  }\n  const y = t0;\n  bb0: switch (b) {\n    case 0: {\n      if ($[3] !== b) {\n        x = [];\n        x.push(b);\n        $[3] = b;\n        $[4] = x;\n      } else {\n        x = $[4];\n      }\n      break bb0;\n    }\n    default: {\n      if ($[5] !== c) {\n        x = [];\n        x.push(c);\n        $[5] = c;\n        $[6] = x;\n      } else {\n        x = $[6];\n      }\n    }\n  }\n  let t1;\n  if ($[7] !== x || $[8] !== y) {\n    t1 = (\n      <div>\n        {y}\n        {x}\n      </div>\n    );\n    $[7] = x;\n    $[8] = y;\n    $[9] = t1;\n  } else {\n    t1 = $[9];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Using State and Optional Chaining in React Component\nDESCRIPTION: This snippet demonstrates a more complex React component function that uses the React compiler runtime for state management. It checks if the props have changed and utilizes optional chaining to invoke an object's method safely. The function optimizes performance by storing the previous result of the computation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-method-call.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== props) {\n    const x = makeObject(props);\n    const y = makeObject(props);\n    t0 = x.optionalMethod?.(y.a, props.a, foo(y.b), bar(props.b));\n    $[0] = props;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const z = t0;\n  return z;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with onClick Handler\nDESCRIPTION: This code defines a React component named `Component` with an `onClick` handler. The handler attempts to modify two global variables, `someUnknownGlobal` and `moduleLocal`. The component returns a div element with the `onClick` handler attached. This is expected to be used in an event handler or effect where modifying globals is allowed.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-reassignment-to-global-function-jsx-prop.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component() {\n  const onClick = () => {\n    // Cannot assign to globals\n    someUnknownGlobal = true;\n    moduleLocal = true;\n  };\n  // It's possible that this could be an event handler / effect function,\n  // but we don't know that and optimistically assume it will only be\n  // called by an event handler or effect, where it is allowed to modify globals\n  return <div onClick={onClick} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}]\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Compiler Error for Disabled ESLint Rule\nDESCRIPTION: Error message indicating that React Compiler skipped optimizing the component due to disabled ESLint rule react-hooks/exhaustive-deps\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.sketchy-code-exhaustive-deps.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n  4 |     () => {\n  5 |       item.push(1);\n> 6 |     }, // eslint-disable-next-line react-hooks/exhaustive-deps\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ InvalidReact: React Compiler has skipped optimizing this component because one or more React ESLint rules were disabled. React Compiler only works when your components follow all the rules of React, disabling them may result in unexpected or incorrect behavior. eslint-disable-next-line react-hooks/exhaustive-deps (6:6)\n  7 |     []\n  8 |   );\n  9 |\n```\n\n----------------------------------------\n\nTITLE: Input React Component with Error Handling\nDESCRIPTION: Original React component implementation that creates a callback function to handle thrown inputs. The component attempts to throw a value from props and catches any resulting errors.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-within-function-expression-returns-caught-value.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {throwInput} from 'shared-runtime';\n\nfunction Component(props) {\n  const callback = () => {\n    try {\n      throwInput([props.value]);\n    } catch (e) {\n      return e;\n    }\n  };\n  return callback();\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: 42}],\n};\n```\n\n----------------------------------------\n\nTITLE: React Compiler Optimized Implementation\nDESCRIPTION: The React compiler-transformed version of the function that implements memoization using a cache array. It checks if the dependencies have changed before creating new objects, improving performance by reusing previous results when possible.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/obj-literal-mutated-after-if-else.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction foo(a, b, c, d) {\n  const $ = _c(3);\n  let x;\n  if ($[0] !== b || $[1] !== c) {\n    if (someVal) {\n      x = { b };\n    } else {\n      x = { c };\n    }\n\n    x.f = 1;\n    $[0] = b;\n    $[1] = c;\n    $[2] = x;\n  } else {\n    x = $[2];\n  }\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Memoizing React Component with Context\nDESCRIPTION: This code snippet demonstrates memoizing a React component using `react/compiler-runtime` and context. The `_c` function is used to create a memoized version of the component that only re-renders if the `bar` or `foo` context values have changed. It initializes a cache `$` and updates it with the new values, preventing unnecessary re-renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/todo.lower-context-access-property-load.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @lowerContextAccess\nfunction App() {\n  const $ = _c(3);\n  const context = useContext(MyContext);\n  const foo = context.foo;\n  const bar = context.bar;\n  let t0;\n  if ($[0] !== bar || $[1] !== foo) {\n    t0 = <Bar foo={foo} bar={bar} />;\n    $[0] = bar;\n    $[1] = foo;\n    $[2] = t0;\n  } else {\n    t0 = $[2];\n  }\n  return t0;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Original React Component with Context Access\nDESCRIPTION: A React component that uses the useContext hook to access values from MyContext and passes them as props to a child component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/todo.lower-context-access-destructure-multiple.expect.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @lowerContextAccess\nfunction App() {\n  const context = useContext(MyContext);\n  const {foo} = context;\n  const {bar} = context;\n  return <Bar foo={foo} bar={bar} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Conditional React Component (Input Version)\nDESCRIPTION: This snippet defines a React component that renders different content based on the value of 'v1' prop and other conditions. It uses ternary operators for conditional rendering within JSX.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-propagate-type-of-ternary-nested.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction V0({v1}: V2<{v1?: V3}>): V2b.V2a {\n  const v4 = v5(V6.v7({v8: V9.va}));\n  const vb = (\n    <ComponentC cd=\"TxqUy\" ce=\"oh`]uc\" cf=\"Bdbo\" c10={!V9.va && v11.v12}>\n      gmhubcw\n      {v1 === V3.V13 ? (\n        <c14 c15=\"L^]w\\T\\qrGmqrlQyrvBgf\\inuRdkEqwVPwixiriYGSZmKJf]E]RdT{N[WyVPiEJIbdFzvDohJV[BV`H[[K^xoy[HOGKDqVzUJ^h\">\n          iawyneijcgamsfgrrjyvhjrrqvzexxwenxqoknnilmfloafyvnvkqbssqnxnexqvtcpvjysaiovjxyqrorqskfph\n        </c14>\n      ) : v16.v17('pyorztRC]EJzVuP^e') ? (\n        <c14 c15=\"CRinMqvmOknWRAKERI]RBzB_LXGKQe{SUpoN[\\gL[`bLMOhvFqDVVMNOdY\">\n          goprinbjmmjhfserfuqyluxcewpyjihektogc\n        </c14>\n      ) : (\n        <c14 c15=\"H\\\\GAcTc\\lfGMW[yHriCpvW`w]niSIKj\\kdgFI\">\n          yejarlvudihqdrdgpvahovggdnmgnueedxpbwbkdvvkdhqwrtoiual\n        </c14>\n      )}\n      hflmn\n    </ComponentC>\n  );\n  return vb;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Reactive Component in JavaScript\nDESCRIPTION: This code snippet defines a function `Component` that conditionally updates an array and uses switch-case statements to set a boolean variable based on the array's content. It is designed to exemplify basic reactive programming techniques within a JavaScript context, particularly in a React application. No external dependencies beside React are required, and inputs are expected to be object literals defining conditional flags.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-via-mutation-switch.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nfunction Component(props) {\n  // x is mutated conditionally based on a reactive value,\n  // so it needs to be considered reactive\n  let x = [];\n  if (props.cond) {\n    x.push(1);\n  }\n  // Since x is reactive, y is now reactively controlled too:\n  let y = false;\n  switch (x[0]) {\n    case 1: {\n      y = true;\n      break;\n    }\n  }\n  // Thus this value should be reactive on `y`:\n  return [y];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  sequentialRenders: [\n    {cond: true},\n    {cond: true},\n    {cond: false},\n    {cond: false},\n    {cond: true},\n    {cond: false},\n    {cond: true},\n    {cond: false},\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Optimized App Component with Compiler-Generated Code\nDESCRIPTION: This snippet presents an optimized version of the App component, likely generated by a React compiler. It uses specialized hooks and guards to improve context access performance and includes memoization logic.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/lower-context-access-hook-guard.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport {\n  $dispatcherGuard,\n  useContext_withSelector,\n} from \"react-compiler-runtime\";\nimport { c as _c } from \"react/compiler-runtime\"; // @lowerContextAccess @enableEmitHookGuards\nfunction App() {\n  const $ = _c(3);\n  try {\n    $dispatcherGuard(0);\n    const { foo } = (function () {\n      try {\n        $dispatcherGuard(2);\n        return useContext_withSelector(MyContext, _temp);\n      } finally {\n        $dispatcherGuard(3);\n      }\n    })();\n    const { bar } = (function () {\n      try {\n        $dispatcherGuard(2);\n        return useContext_withSelector(MyContext, _temp2);\n      } finally {\n        $dispatcherGuard(3);\n      }\n    })();\n    let t0;\n    if ($[0] !== bar || $[1] !== foo) {\n      t0 = <Bar foo={foo} bar={bar} />;\n      $[0] = bar;\n      $[1] = foo;\n      $[2] = t0;\n    } else {\n      t0 = $[2];\n    }\n    return t0;\n  } finally {\n    $dispatcherGuard(1);\n  }\n}\nfunction _temp2(t0) {\n  return [t0.bar];\n}\nfunction _temp(t0) {\n  return [t0.foo];\n}\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Compiler Runtime\nDESCRIPTION: This snippet shows an optimized version of the Component function, likely produced by a React compiler. It includes memoization and more explicit destructuring logic.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-assignment-array-default.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  let x;\n  if (props.cond) {\n    const [t0] = props.y;\n    let t1;\n    if ($[0] !== t0) {\n      t1 = t0 === undefined ? [\"default\"] : t0;\n      $[0] = t0;\n      $[1] = t1;\n    } else {\n      t1 = $[1];\n    }\n    [x] = t1;\n  } else {\n    x = props.fallback;\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component with Array Destructuring\nDESCRIPTION: A React component implementing array destructuring with default values from props. Shows pattern matching syntax with nested array destructuring.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-array-default.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const [[x] = ['default']] = props.y;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Function Component with Dynamic Scoping\nDESCRIPTION: Initial implementation of a React component demonstrating scope dependencies, state mutations, and conditional rendering\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/same-variable-as-dep-and-redeclare-maybe-frozen.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(props) {\n  // scope 0: deps=[props.a] decl=[x] reassign=none\n  let x = [];\n  x.push(props.a);\n\n  // scope 1: deps=[x] decl=[header] reassign=none\n  const header = props.showHeader ? <div>{x}</div> : null;\n\n  // scope 2:\n  // deps=[x, props.b, props.c]\n  // decl=none\n  // reassign=[x]\n  const y = [x]; // y depends on the earlier x\n  x = []; // x reassigned\n  y.push(props.b); // interleaved mutation of x/y\n  x.push(props.c); // interleaved mutation\n\n  // scope 3 ...\n  const content = (\n    <div>\n      {x}\n      {y}\n    </div>\n  );\n\n  // scope 4 ...\n  return (\n    <>\n      {header}\n      {content}\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled React Hook Implementation\nDESCRIPTION: The compiled version of the hook using React's compiler runtime, implementing memoization using an array-based cache. Includes the same fixture setup as the original.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-literal-method-derived-in-ternary-consequent.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { identity, createHookWrapper } from \"shared-runtime\";\n\nfunction useHook(t0) {\n  const $ = _c(3);\n  const { isCond, value } = t0;\n  let t1;\n  if ($[0] !== isCond || $[1] !== value) {\n    t1 = isCond\n      ? identity({\n          getValue() {\n            return value;\n          },\n        })\n      : 42;\n    $[0] = isCond;\n    $[1] = value;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: createHookWrapper(useHook),\n  params: [{ isCond: true, value: 0 }],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component Definition and Export (Input)\nDESCRIPTION: Defines a functional React component named `Component` that renders a div containing the text \"Hello world\".  It exports this component as `FIXTURE_ENTRYPOINT` with metadata indicating it's a component and requires no parameters. This version is intended for internal meta usage.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/target-flag-meta-internal.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @target=\"donotuse_meta_internal\"\n\nfunction Component() {\n  return <div>Hello world</div>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  isComponent: true,\n};\n\n```\n\n----------------------------------------\n\nTITLE: Original React Component with GraphQL Fragment\nDESCRIPTION: A React component that defines and renders a GraphQL fragment within a div element. Includes test fixtures for component rendering with various prop combinations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-provider-tagged-template-expression.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {graphql} from 'shared-runtime';\n\nexport function Component({a, b}) {\n  const fragment = graphql`\n    fragment Foo on User {\n      name\n    }\n  `;\n  return <div>{fragment}</div>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{a: 0, b: 0}],\n  sequentialRenders: [\n    {a: 0, b: 0},\n    {a: 1, b: 0},\n    {a: 1, b: 1},\n    {a: 1, b: 2},\n    {a: 2, b: 2},\n    {a: 3, b: 2},\n    {a: 0, b: 0},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Custom Hook in React\nDESCRIPTION: Defines a simple React hook 'useFoo' that returns the current state of a boolean value. It uses React's 'useState' to manage the state and returns an object with a function to access that state. No external dependencies beyond React are required.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-method-shorthand-hook-dep.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {createHookWrapper} from 'shared-runtime';\nimport {useState} from 'react';\nfunction useFoo() {\n  const [state, _setState] = useState(false);\n  return {\n    func() {\n      return state;\n    },\n  };\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: createHookWrapper(useFoo),\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Compiler-Generated Memo Blocks\nDESCRIPTION: This snippet presents an optimized version of the 'MyApp' component with compiler-generated memo blocks. It uses the '_c' function from 'react/compiler-runtime' to create and manage memo blocks, ensuring proper dependency tracking and optimization of reactive and non-reactive variables.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-invalid-pruned-scope-leaks-value.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport invariant from \"invariant\";\nimport {\n  makeObject_Primitives,\n  mutate,\n  sum,\n  useIdentity,\n} from \"shared-runtime\";\n\n/**\n * Here, `z`'s original memo block is removed due to the inner hook call.\n * However, we also infer that `z` is non-reactive, so by default we would create\n * the memo block for `thing = [y, z]` as only depending on `y`.\n *\n * This could then mean that `thing[1]` and `z` may not refer to the same value,\n * since z recreates every time but `thing` doesn't correspondingly invalidate.\n *\n * The fix is to consider pruned memo block outputs as reactive, since they will\n * recreate on every render. This means `thing` depends on both y and z.\n */\nfunction MyApp(t0) {\n  const $ = _c(6);\n  const { count } = t0;\n  const z = makeObject_Primitives();\n  const x = useIdentity(2);\n  let t1;\n  if ($[0] !== count || $[1] !== x) {\n    t1 = sum(x, count);\n    $[0] = count;\n    $[1] = x;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  const y = t1;\n  mutate(z);\n  let t2;\n  if ($[3] !== y || $[4] !== z) {\n    t2 = [y, z];\n    $[3] = y;\n    $[4] = z;\n    $[5] = t2;\n  } else {\n    t2 = $[5];\n  }\n  const thing = t2;\n  if (thing[1] !== z) {\n    invariant(false, \"oh no!\");\n  }\n  return thing;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: MyApp,\n  params: [{ count: 2 }],\n  sequentialRenders: [{ count: 2 }, { count: 2 }, { count: 3 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a React Hook\nDESCRIPTION: This code snippet defines a custom React hook named `useHook`. This hook demonstrates that hooks can call other hooks, such as `useHook1` and `useHook2`, which promotes code reusability and composability within React functional components.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-cfdfe5572fc7.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Valid because hooks can call hooks.\nfunction useHook() {\n  useHook1();\n  useHook2();\n}\n\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: A React component that uses useCallback and custom primitives for memoization. It creates objects using makeObject_Primitives and handles mutations with a callback function.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useCallback-maybe-modify-free-variable-preserve-memoization-guarantee.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enablePreserveExistingMemoizationGuarantees\nimport {useCallback} from 'react';\nimport {identity, makeObject_Primitives, mutate, useHook} from 'shared-runtime';\n\nfunction Component(props) {\n  const free = makeObject_Primitives();\n  const free2 = makeObject_Primitives();\n  const part = free2.part;\n  useHook();\n  const callback = useCallback(() => {\n    const x = makeObject_Primitives();\n    x.value = props.value;\n    mutate(x, free, part);\n  }, [props.value]);\n  mutate(free, part);\n  return callback;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: 42}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining React Components with Different Prop Dependencies\nDESCRIPTION: This snippet defines four React components (ComponentA, ComponentB, ComponentC, and ComponentD) that demonstrate different patterns of how props influence component behavior. It also exports a fixture entrypoint for testing.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/conditional-early-return.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enablePropagateDepsInHIR\n/**\n * props.b does *not* influence `a`\n */\nfunction ComponentA(props) {\n  const a_DEBUG = [];\n  a_DEBUG.push(props.a);\n  if (props.b) {\n    return null;\n  }\n  a_DEBUG.push(props.d);\n  return a_DEBUG;\n}\n\n/**\n * props.b *does* influence `a`\n */\nfunction ComponentB(props) {\n  const a = [];\n  a.push(props.a);\n  if (props.b) {\n    a.push(props.c);\n  }\n  a.push(props.d);\n  return a;\n}\n\n/**\n * props.b *does* influence `a`, but only in a way that is never observable\n */\nfunction ComponentC(props) {\n  const a = [];\n  a.push(props.a);\n  if (props.b) {\n    a.push(props.c);\n    return null;\n  }\n  a.push(props.d);\n  return a;\n}\n\n/**\n * props.b *does* influence `a`\n */\nfunction ComponentD(props) {\n  const a = [];\n  a.push(props.a);\n  if (props.b) {\n    a.push(props.c);\n    return a;\n  }\n  a.push(props.d);\n  return a;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: ComponentA,\n  params: [{a: 1, b: false, d: 3}],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component: Using Hooks Incorrectly\nDESCRIPTION: This React component attempts to conditionally assign a hook (`useA` or `useB`) to a variable `x` and then call `x`. This is an invalid usage pattern because React hooks must be called directly within the component and not assigned to variables for later execution. The component receives `props` as input, including a `cond` property to determine which hook to use.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-ternary-with-hook-values.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const x = props.cond ? useA : useB;\n  return x();\n}\n\n```\n\n----------------------------------------\n\nTITLE: Using useFire in a Conditional Component - JavaScript\nDESCRIPTION: This snippet demonstrates an alternative implementation of a React component that uses the useFire hook along with useEffect to manage side effects based on props.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/bailout-validate-conditional-hook.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useFire } from \"react/compiler-runtime\"; // @enableFire @panicThreshold(none)\nimport { fire, useEffect } from \"react\";\nimport { Stringify } from \"shared-runtime\";\n\n/**\n * When @enableFire is specified, retry compilation with validation passes (e.g.\n * hook usage) disabled\n */\nfunction Component(props) {\n  const foo = _temp;\n  if (props.cond) {\n    const t0 = useFire(foo);\n    useEffect(() => {\n      t0(props);\n    });\n  }\n  return <Stringify />;\n}\nfunction _temp(props_0) {\n  console.log(props_0);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with React Compiler Runtime\nDESCRIPTION: This code represents the compiled version of the React component, utilizing the `_c` function from the `react/compiler-runtime` module.  It uses memoization techniques to optimize rendering based on prop changes, accessing potentially nested data through the `idx` macro variations.  Helper functions like `_temp`, `_temp2`, and `_temp3` are generated to extract the desired data.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/idx-method-no-outlining-wildcard.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n```javascript\nimport { c as _c } from \"react/compiler-runtime\"; // @customMacros(idx.*.b)\n\nfunction Component(props) {\n  const $ = _c(16);\n  let t0;\n  if ($[0] !== props) {\n    t0 = idx(props, _temp);\n    $[0] = props;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const groupName1 = t0;\n  let t1;\n  if ($[2] !== props) {\n    t1 = idx.a(props, _temp2);\n    $[2] = props;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  const groupName2 = t1;\n  let t2;\n  if ($[4] !== props) {\n    t2 = idx.a.b(props, (__1) => __1.group.label);\n    $[4] = props;\n    $[5] = t2;\n  } else {\n    t2 = $[5];\n  }\n  const groupName3 = t2;\n  let t3;\n  if ($[6] !== props) {\n    t3 = idx.hello_world.b(props, (__2) => __2.group.label);\n    $[6] = props;\n    $[7] = t3;\n  } else {\n    t3 = $[7];\n  }\n  const groupName4 = t3;\n  let t4;\n  if ($[8] !== props) {\n    t4 = idx.hello_world.b.c(props, _temp3);\n    $[8] = props;\n    $[9] = t4;\n  } else {\n    t4 = $[9];\n  }\n  const groupName5 = t4;\n  let t5;\n  if (\n    $[10] !== groupName1 ||\n    $[11] !== groupName2 ||\n    $[12] !== groupName3 ||\n    $[13] !== groupName4 ||\n    $[14] !== groupName5\n  ) {\n    t5 = (\n      <div>\n        {groupName1}\n        {groupName2}\n        {groupName3}\n        {groupName4}\n        {groupName5}\n      </div>\n    );\n    $[10] = groupName1;\n    $[11] = groupName2;\n    $[12] = groupName3;\n    $[13] = groupName4;\n    $[14] = groupName5;\n    $[15] = t5;\n  } else {\n    t5 = $[15];\n  }\n  return t5;\n}\nfunction _temp3(__3) {\n  return __3.group.label;\n}\nfunction _temp2(__0) {\n  return __0.group.label;\n}\nfunction _temp(_) {\n  return _.group.label;\n}\n\n```\n```\n\n----------------------------------------\n\nTITLE: Input: React Component with Passive Effect State Update\nDESCRIPTION: Initial React component demonstrating a state update within a useEffect and setTimeout mechanism, with a validation annotation for passive effects\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/valid-setState-in-useEffect-listener-transitive.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validateNoSetStateInPassiveEffects\nimport {useEffect, useState} from 'react';\n\nfunction Component() {\n  const [state, setState] = useState(0);\n  useEffect(() => {\n    const f = () => {\n      setState();\n    };\n    setTimeout(() => f(), 10);\n  });\n  return state;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: This is the compiled version of the component with React's compiler-runtime memoization applied. It shows how the compiler creates a memoization cache ($) and uses it to store and retrieve values across renders, handling the object mutation scenario carefully.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/uncond-access-in-mutable-range.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // x.a.b was accessed unconditionally within the mutable range of x.\n// As a result, we cannot infer anything about whether `x` or `x.a`\n// may be null. This means that it's not safe to hoist reads from x\n// (e.g. take `x.a` or `x.a.b` as a dependency).\n\nimport { identity, makeObject_Primitives, setProperty } from \"shared-runtime\";\n\nfunction Component(t0) {\n  const $ = _c(8);\n  const { cond, other } = t0;\n  let x;\n  if ($[0] !== cond || $[1] !== other) {\n    x = makeObject_Primitives();\n    setProperty(x, { b: 3, other }, \"a\");\n    identity(x.a.b);\n    if (!cond) {\n      x.a = null;\n    }\n    $[0] = cond;\n    $[1] = other;\n    $[2] = x;\n  } else {\n    x = $[2];\n  }\n  let t1;\n  if ($[3] !== cond || $[4] !== x) {\n    t1 = identity(cond) && x.a.b;\n    $[3] = cond;\n    $[4] = x;\n    $[5] = t1;\n  } else {\n    t1 = $[5];\n  }\n  let t2;\n  if ($[6] !== t1) {\n    t2 = [t1];\n    $[6] = t1;\n    $[7] = t2;\n  } else {\n    t2 = $[7];\n  }\n  const y = t2;\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ cond: false }],\n  sequentialRenders: [\n    { cond: false },\n    { cond: false },\n    { cond: false, other: 8 },\n    { cond: true },\n    { cond: true },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Initialization of a React Component with Hooks in JavaScript\nDESCRIPTION: This snippet illustrates an incorrect usage of a React hook, where it is conditionally called. Hooks must be called unconditionally within the component body. Here, `React.useNonexistentHook` is incorrectly used, causing a runtime error. Dependencies include React library that provides hook functionality.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.conditional-hook-unknown-hook-react-namespace.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nfunction Component(props) {\n  let x = null;\n  if (props.cond) {\n    x = React.useNonexistentHook();\n  }\n  return x;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining React Functional Component for Post Displaying Author and Text\nDESCRIPTION: This snippet defines a React functional component named Component that renders a Post component with predefined author and text properties. It demonstrates basic component usage within React.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-string-attribute-non-ascii.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component() {\n  return (\n    <Post\n      author=\"potetotes\"\n      text=\"in addition to understanding JavaScript semantics and the rules of React, the compiler team also understands , , ,  and i think thats pretty cool\"\n    />\n  );\n}\n\nfunction Post({author, text}) {\n  return (\n    <div>\n      <h1>{author}</h1>\n      <span>{text}</span>\n    </div>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component Definition\nDESCRIPTION: This snippet defines a React component that uses props to conditionally push values into arrays `a` and `b`. The values assigned to x depend on `c[0]`, which becomes reactive as `b` is interleaved with `a`, making `x` reactive as well.  The component returns an array containing `x`.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-from-interleaved-reactivity-for-of.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  // a and b are independent but their mutations are interleaved, so\n  // they get grouped in a reactive scope. this means that a becomes\n  // reactive since it will effectively re-evaluate based on a reactive\n  // input\n  const a = [];\n  const b = [];\n  b.push(props.cond);\n  a.push(null);\n\n  // Downstream consumer of a, which initially seems non-reactive except\n  // that a becomes reactive, per above\n  const c = [a];\n\n  let x;\n  for (const i of c[0]) {\n    x = 1;\n  }\n  // The values assigned to `x` are non-reactive, but the value of `x`\n  // depends on the \"control\" value `c[0]` which becomes reactive via\n  // being interleaved with `b`.\n  // Therefore x should be treated as reactive too.\n  return [x];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{cond: true}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Hook with React Compiler Runtime\nDESCRIPTION: This is the compiled version of the `useFoo` hook, employing `react/compiler-runtime`'s `_c` function for memoization. The compiled hook uses an array `$` to store memoized values based on input parameters like `value` and `cond`. This optimization aims to reduce re-renders by caching intermediate calculations and state values.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/hoist-deps-diff-ssa-instance.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { makeObject_Primitives, setPropertyByKey } from \"shared-runtime\";\n\nfunction useFoo(t0) {\n  const $ = _c(10);\n  const { value, cond } = t0;\n  let x;\n  if ($[0] !== cond) {\n    x = makeObject_Primitives();\n    if (cond) {\n      setPropertyByKey(x, \"a\", null);\n    } else {\n      setPropertyByKey(x, \"a\", { b: 2 });\n    }\n    $[0] = cond;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  let y;\n  if ($[2] !== cond || $[3] !== x) {\n    y = [];\n    if (!cond) {\n      y.push(x.a.b);\n    }\n    $[2] = cond;\n    $[3] = x;\n    $[4] = y;\n  } else {\n    y = $[4];\n  }\n  if ($[5] !== value) {\n    x = makeObject_Primitives();\n    setPropertyByKey(x, \"a\", { b: value });\n    $[5] = value;\n    $[6] = x;\n  } else {\n    x = $[6];\n  }\n  let t1;\n  if ($[7] !== x.a.b || $[8] !== y) {\n    t1 = [y, x.a.b];\n    $[7] = x.a.b;\n    $[8] = y;\n    $[9] = t1;\n  } else {\n    t1 = $[9];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ value: 3, cond: true }],\n  sequentialRenders: [\n    { value: 3, cond: true },\n    { value: 3, cond: false },\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Implementing useMakeCallback Hook with Nested Callback Functions in React\nDESCRIPTION: A custom React hook that demonstrates callback handling with conditional execution. This hook creates a callback that accesses object properties, showcasing how React compiler can optimize property loads in nested functions.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/assume-invoked/function-with-conditional-callsite-in-another-function.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {createHookWrapper} from 'shared-runtime';\n\n/**\n * (Given that the returned lambda is assumed to be invoked, see\n * return-function)\n *\n * If lambda A conditionally calls lambda B, optimistically assume that property\n * loads from lambda B has the same hoistability of ones from lambda A. This\n * helps optimize components / hooks that create and chain many helper\n * functions.\n *\n * Type systems and code readability encourage developers to colocate length and\n * null checks values in the same function as where values are used. i.e.\n * developers are unlikely to write the following code.\n * ```js\n * function useFoo(obj, objNotNullAndHasElements) {\n *   // ...\n *   const get0th = () => obj.arr[0].value;\n *   return () => objNotNullAndHasElements ? get0th : undefined;\n * }\n * ```\n *\n * In Meta code, this assumption helps reduce the number of memo dependency\n * deopts.\n */\nfunction useMakeCallback({\n  obj,\n  cond,\n  setState,\n}: {\n  obj: {value: number};\n  cond: boolean;\n  setState: (newState: number) => void;\n}) {\n  const cb = () => setState(obj.value);\n  // cb's property loads are assumed to be hoistable to the start of this lambda\n  return () => (cond ? cb() : undefined);\n}\n\nconst setState = (arg: number) => {\n  'use no memo';\n  return arg;\n};\nexport const FIXTURE_ENTRYPOINT = {\n  fn: createHookWrapper(useMakeCallback),\n  params: [{obj: {value: 1}, cond: true, setState}],\n  sequentialRenders: [\n    {obj: {value: 1}, cond: true, setState},\n    {obj: {value: 2}, cond: true, setState},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Original Component with Console Logging\nDESCRIPTION: The original component implementation that shallow copies props and logs them using various console methods. This code demonstrates how React's compiler will handle console logging operations outside of reactive scopes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/console-readonly.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {shallowCopy} from 'shared-runtime';\n\nfunction Component(props) {\n  const x = shallowCopy(props);\n  // These calls should view x as readonly and be grouped outside of the reactive scope for x:\n  console.log(x);\n  console.info(x);\n  console.warn(x);\n  console.error(x);\n  console.trace(x);\n  console.table(x);\n  global.console.log(x);\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{a: 1, b: 2}],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Enhanced Memoization in React with Compiler Runtime\nDESCRIPTION: This snippet showcases an advanced version of the `useFoo` hook utilizing React's compiler runtime for memoization. It introduces a caching mechanism with checks against a sentinel value, allowing for more complex state management. The dependency on the React library and the compiler runtime is required, and the hook takes no parameters.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/todo-ensure-constant-prop-decls-get-removed.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @validatePreserveExistingMemoizationGuarantees\n\nimport { useMemo } from \"react\";\n\n// Todo: we currently only generate a `constVal` declaration when\n// validatePreserveExistingMemoizationGuarantees is enabled, as the\n// StartMemoize instruction uses `constVal`.\n// Fix is to rewrite StartMemoize instructions to remove constant\n// propagated values\nfunction useFoo() {\n  const $ = _c(1);\n  const constVal = 0;\n  let t0;\n  let t1;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = [0];\n    $[0] = t1;\n  } else {\n    t1 = $[0];\n  }\n  t0 = t1;\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with Unknown Hooks Implementation\nDESCRIPTION: A React component implementation demonstrating the use of unknown hooks where Forget bailout behavior occurs when detecting potential mutations to immutable values. The component chains two unknown hooks together, passing props through the first hook and its result to the second hook.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unknown-hooks-do-not-assert.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Forget currently bails out when it detects a potential mutation (Effect.Mutate)\n// to an immutable value. This should not apply to unknown / untyped hooks.\nfunction Component(props) {\n  const x = useUnknownHook1(props);\n  const y = useUnknownHook2(x);\n  return y;\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Inferred Effect Dependencies\nDESCRIPTION: The compiled output of the React component after the dependency inference transformation. It shows how React's compiler adds the selected ref as a dependency to useEffect and uses memoization to optimize re-renders and effect executions based on the reactive ref.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/reactive-ref.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @inferEffectDependencies\nimport { useEffect, useRef } from \"react\";\nimport { print } from \"shared-runtime\";\n\n/*\n * Ref types are not enough to determine to omit from deps. Must also take reactivity into account.\n */\nfunction ReactiveRefInEffect(props) {\n  const $ = _c(4);\n  const ref1 = useRef(\"initial value\");\n  const ref2 = useRef(\"initial value\");\n  let ref;\n  if ($[0] !== props.foo) {\n    if (props.foo) {\n      ref = ref1;\n    } else {\n      ref = ref2;\n    }\n    $[0] = props.foo;\n    $[1] = ref;\n  } else {\n    ref = $[1];\n  }\n  let t0;\n  if ($[2] !== ref) {\n    t0 = () => print(ref);\n    $[2] = ref;\n    $[3] = t0;\n  } else {\n    t0 = $[3];\n  }\n  useEffect(t0, [ref]);\n}\n```\n\n----------------------------------------\n\nTITLE: React Component Definition and Export\nDESCRIPTION: This code defines a functional React component named `Component` that accepts `props` as input. The component returns an object containing `props` passed into a function `f`. The result is assigned to the `foo` property. The component and its default parameters are exported as `FIXTURE_ENTRYPOINT`.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-no-component-obj-return.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// @compilationMode(infer)\nfunction Component(props) {\n  const ignore = <foo />;\n  return { foo: f(props) };\n}\n\nfunction f(props) {\n  return props;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}]\n};\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Ref and Callback in React\nDESCRIPTION: This snippet defines a custom ref hook and a React component using that hook with a callback. It demonstrates the use of useRef and useCallback hooks.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ref-like-name-in-useCallback.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableTreatRefLikeIdentifiersAsRefs @validatePreserveExistingMemoizationGuarantees\nimport {useRef, useCallback} from 'react';\n\nfunction useCustomRef() {\n  return useRef({click: () => {}});\n}\n\nfunction Foo() {\n  const customRef = useCustomRef();\n\n  const onClick = useCallback(() => {\n    customRef.current?.click();\n  }, []);\n\n  return <button onClick={onClick} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [],\n  isComponent: true,\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Compiler Runtime Memoization\nDESCRIPTION: A React component using compiler runtime memoization with symbol-based caching mechanism to optimize rendering and prevent unnecessary re-renders\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-memo-value-not-promoted-to-outer-scope-static.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const count = new MaybeMutable();\n\n    t0 = (\n      <View>\n        <View>\n          <span>Text</span>\n          <span>{maybeMutate(count)}</span>\n        </View>\n      </View>\n    );\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n```\n\n----------------------------------------\n\nTITLE: Building the React Chrome Extension from Command Line\nDESCRIPTION: Commands for building the React Chrome extension from either the extension directory or the root directory.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools-extensions/chrome/README.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnode build\n```\n\nLANGUAGE: bash\nCODE:\n```\nyarn run build:extension:chrome\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization Optimizations\nDESCRIPTION: Compiled version of the React component showing the implementation of memoization caching. Uses Symbol.for('react.memo_cache_sentinel') to check and maintain cached values for refs and callbacks.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useCallback-multiple-callbacks-modifying-same-ref-preserve-memoization.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enablePreserveExistingMemoizationGuarantees\nimport { useCallback, useRef } from \"react\";\n\nfunction Component(props) {\n  const $ = _c(4);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = { inner: null };\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const ref = useRef(t0);\n  let t1;\n  if ($[1] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = (event) => {\n      ref.current.inner = event.target.value;\n    };\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  const onChange = t1;\n  let t2;\n  if ($[2] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t2 = () => {\n      ref.current.inner = null;\n    };\n    $[2] = t2;\n  } else {\n    t2 = $[2];\n  }\n  const onReset = t2;\n  let t3;\n  if ($[3] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t3 = <input onChange={onChange} onReset={onReset} />;\n    $[3] = t3;\n  } else {\n    t3 = $[3];\n  }\n  return t3;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with Memoization and Mutation (Input)\nDESCRIPTION: This code snippet defines a React component that creates objects, manipulates an array, and uses mutation. It demonstrates the use of the 'enablePreserveExistingMemoizationGuarantees' directive and the 'mutate' function from a shared runtime.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transitive-freeze-array.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enablePreserveExistingMemoizationGuarantees\nconst {mutate} = require('shared-runtime');\n\nfunction Component(props) {\n  const x = {};\n  const y = {};\n  const items = [x, y];\n  items.pop();\n  <div>{items}</div>; // note: enablePreserveExistingMemoizationGuarantees only visits function expressions, not arrays, so this doesn't freeze x/y\n  mutate(y); // ok! not part of `items` anymore bc of items.pop()\n  return [x, y, items];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Optimization\nDESCRIPTION: The compiled version of the component with React compiler optimizations. It uses memoization and change detection to avoid unnecessary re-renders and calculations, maintaining references to previous values using an array cache.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-memo-value-not-promoted-to-outer-scope-dynamic.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(15);\n  const item = useFragment(FRAGMENT, props.item);\n  useFreeze(item);\n  let T0;\n  let T1;\n  let t0;\n  let t1;\n  if ($[0] !== item) {\n    const count = new MaybeMutable(item);\n\n    T1 = View;\n    T0 = View;\n    if ($[5] === Symbol.for(\"react.memo_cache_sentinel\")) {\n      t1 = <span>Text</span>;\n      $[5] = t1;\n    } else {\n      t1 = $[5];\n    }\n    t0 = maybeMutate(count);\n    $[0] = item;\n    $[1] = T0;\n    $[2] = T1;\n    $[3] = t0;\n    $[4] = t1;\n  } else {\n    T0 = $[1];\n    T1 = $[2];\n    t0 = $[3];\n    t1 = $[4];\n  }\n  let t2;\n  if ($[6] !== t0) {\n    t2 = <span>{t0}</span>;\n    $[6] = t0;\n    $[7] = t2;\n  } else {\n    t2 = $[7];\n  }\n  let t3;\n  if ($[8] !== T0 || $[9] !== t1 || $[10] !== t2) {\n    t3 = (\n      <T0>\n        {t1}\n        {t2}\n      </T0>\n    );\n    $[8] = T0;\n    $[9] = t1;\n    $[10] = t2;\n    $[11] = t3;\n  } else {\n    t3 = $[11];\n  }\n  let t4;\n  if ($[12] !== T1 || $[13] !== t3) {\n    t4 = <T1>{t3}</T1>;\n    $[12] = T1;\n    $[13] = t3;\n    $[14] = t4;\n  } else {\n    t4 = $[14];\n  }\n  return t4;\n}\n```\n\n----------------------------------------\n\nTITLE: React Component Context Dependency Verification in JavaScript\nDESCRIPTION: This snippet is an enhanced version of the Foo function where a compiler-runtime cache is utilized to track changes. It manages conditional context variables using useCallback and preserves memoization guarantees. Dependencies include react/compiler-runtime and shared-runtime.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useCallback-captures-reassigned-context-property.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @validatePreserveExistingMemoizationGuarantees\nimport { useCallback } from \"react\";\nimport { Stringify } from \"shared-runtime\";\n\n/**\n * TODO: we're currently bailing out because `contextVar` is a context variable\n * and not recorded into the PropagateScopeDeps LoadLocal / PropertyLoad\n * sidemap. Previously, we were able to avoid this as `BuildHIR` hoisted\n * `LoadContext` and `PropertyLoad` instructions into the outer function, which\n * we took as eligible dependencies.\n *\n * One solution is to simply record `LoadContext` identifiers into the\n * temporaries sidemap when the instruction occurs *after* the context\n * variable's mutable range.\n */\nfunction Foo(props) {\n  const $ = _c(6);\n  let contextVar;\n  if ($[0] !== props.cond) {\n    if (props.cond) {\n      contextVar = { val: 2 };\n    } else {\n      contextVar = {};\n    }\n    $[0] = props.cond;\n    $[1] = contextVar;\n  } else {\n    contextVar = $[1];\n  }\n  let t0;\n  if ($[2] !== contextVar.val) {\n    t0 = () => [contextVar.val];\n    $[2] = contextVar.val;\n    $[3] = t0;\n  } else {\n    t0 = $[3];\n  }\n  contextVar;\n  const cb = t0;\n  let t1;\n  if ($[4] !== cb) {\n    t1 = <Stringify cb={cb} shouldInvokeFns={true} />;\n    $[4] = cb;\n    $[5] = t1;\n  } else {\n    t1 = $[5];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{ cond: true }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining and Exporting useFoo Hook - React - JavaScript\nDESCRIPTION: This snippet imports a shared runtime and defines a hook called useFoo. It returns a callback rendering a text element with a value of '4'. The hook is exported as part of a fixture entry point. Dependencies include 'shared-runtime'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-memberexpr-tag-in-lambda.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as SharedRuntime from 'shared-runtime';\nfunction useFoo() {\n  const MyLocal = SharedRuntime;\n  const callback = () => {\n    return <MyLocal.Text value={4} />;\n  };\n  return callback();\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Memoizing Components with React Compiler Runtime - JavaScript\nDESCRIPTION: This snippet imports from 'react/compiler-runtime' to handle component memoization. It defines the 'Component' function to manipulate array reactivity using special compiler symbols. Dependencies include React, and 'props' with a 'cond' property. The memoization logic checks for a sentinel symbol to cache component outputs, returning a memoized 'x'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-from-interleaved-reactivity-while.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(1);\n\n  const a = [];\n  const b = [];\n  b.push(props.cond);\n  a.push(null);\n\n  const c = [a];\n\n  let x;\n  while (c[0][0]) {\n    x = 1;\n  }\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = [x];\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ cond: true }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Component Definition with useHook\nDESCRIPTION: This React component utilizes the `useHook` function from the `shared-runtime` module.  The hook call is intentionally interspersed within the component's logic to prevent memoization of the 'x' variable. The component accepts 'props' as input, specifically expecting a 'value' property, and returns a nested array containing this value.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/prune-scopes-whose-deps-invalidate-array.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useHook } from \"shared-runtime\";\n\nfunction Component(props) {\n  const x = [];\n  useHook();\n  x.push(props.value);\n\n  const y = [x];\n  return [y];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ value: \"sathya\" }],\n};\n```\n\n----------------------------------------\n\nTITLE: Invalid React Hook Call in Callback (JavaScript)\nDESCRIPTION: This code demonstrates an invalid use of a React hook (`useHookInsideCallback`) within a `useEffect` callback function inside a component. This violates the Rules of Hooks, which stipulate that hooks must be called at the top level of a component or custom hook, not within callbacks or other function expressions. The expected outcome is a runtime error indicating the invalid hook call.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid.invalid-rules-of-hooks-d952b82c2597.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Invalid because it's a common misunderstanding.\n// We *could* make it valid but the runtime error could be confusing.\nfunction ComponentWithHookInsideCallback() {\n  useEffect(() => {\n    useHookInsideCallback();\n  });\n}\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Hook with Memoization\nDESCRIPTION: Transformed version of the hook using React's compiler runtime for memoization. Implements caching logic using Symbol.for() to optimize repeated executions of baz().\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/assignment-in-nested-if.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction useBar(props) {\n  const $ = _c(1);\n  let z;\n  if (props.a) {\n    if (props.b) {\n      let t0;\n      if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n        t0 = baz();\n        $[0] = t0;\n      } else {\n        t0 = $[0];\n      }\n      z = t0;\n    }\n  }\n  return z;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a React Component with Fragment and Conditional Rendering\nDESCRIPTION: Defines a React functional component 'Foo' that conditionally renders a Fragment with a div and a Stringify component based on props. It demonstrates scope alignment and mutable value handling in the React compiler.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/align-scopes-within-nested-valueblock-in-array.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {Stringify, identity, makeArray, mutate} from 'shared-runtime';\n\n/**\n * Here, identity('foo') is an immutable allocating instruction.\n * `arr` is a mutable value whose mutable range ends at `arr.map`.\n *\n * The previous (reactive function) version of alignScopesToBlocks set the range of\n * both scopes to end at value blocks within the <></> expression.\n * However, both scope ranges should be aligned to the outer value block\n * (e.g. `cond1 ? <>: null`). The HIR version of alignScopesToBlocks\n * handles this correctly.\n */\nfunction Foo({cond1, cond2}) {\n  const arr = makeArray<any>({a: 2}, 2, []);\n\n  return cond1 ? (\n    <>\n      <div>{identity('foo')}</div>\n      <Stringify value={cond2 ? arr.map(mutate) : null} />\n    </>\n  ) : null;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{cond1: true, cond2: true}],\n};\n```\n\n----------------------------------------\n\nTITLE: Advanced Component State Management with Compiler Runtime - JavaScript\nDESCRIPTION: This snippet shows an advanced React component using a customized method with compiler runtime. It uses a memoization technique to cache and reuse the effect function, improving performance by avoiding unnecessary reconstructions. The snippet relies on 'react/compiler-runtime' along with useEffect and useState from React. Parameters involve initial state setup and effect function caching.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/valid-setState-in-useEffect-listener.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @validateNoSetStateInPassiveEffects\nimport { useEffect, useState } from \"react\";\n\nfunction Component() {\n  const $ = _c(1);\n  const [state, setState] = useState(0);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = () => {\n      setTimeout(setState, 10);\n    };\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  useEffect(t0);\n  return state;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing React Memoization Test Input\nDESCRIPTION: Defines the input code for testing memoization behavior using React context and useMemo hook. Includes a Component that provides context and an Inner component that consumes and validates the memoization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/use-operator-method-call.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {ValidateMemoization} from 'shared-runtime';\nimport {useMemo} from 'react';\nimport * as React from 'react';\n\nconst FooContext = React.createContext(null);\nfunction Component(props) {\n  return (\n    <FooContext.Provider value={props.value}>\n      <Inner />\n    </FooContext.Provider>\n  );\n}\n\nfunction Inner(props) {\n  const input = React.use(FooContext);\n  const output = useMemo(() => [input], [input]);\n  return <ValidateMemoization inputs={[input]} output={output} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: 42}],\n  sequentialRenders: [\n    {value: null},\n    {value: 42},\n    {value: 42},\n    {value: null},\n    {value: null},\n    {value: 42},\n    {value: null},\n    {value: 42},\n    {value: null},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Using Hooks in React Enabling AssumeHooksFollowRulesOfReact\nDESCRIPTION: This code snippet demonstrates a React component implementing hooks while assuming that hooks follow certain React rules. It imports a compiler-runtime function and handles input freezing and memoization through conditional logic. The main dependencies for this snippet include React and React hooks, specifically the \"useFoo\" hook. Inputs involve props supplied to the component, and outputs are frozen objects returned from the component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/immutable-hooks.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableAssumeHooksFollowRulesOfReact true\nfunction Component(props) {\n  const x = {};\n  // In enableAssumeHooksFollowRulesOfReact mode hooks freeze their inputs and return frozen values\n  const y = useFoo(x);\n  // Thus both x and y are frozen here, and x can be independently memoized\n  bar(x, y);\n  return [x, y];\n}\n```\n\n----------------------------------------\n\nTITLE: React Component with Conditional Hook Call\nDESCRIPTION: This code snippet defines a React component named `Component` that receives `props`. Inside the component, `makeObject_Primitives()` is called, and its returned object's `useFoo()` method is called conditionally based on `props.cond`. This conditional hook call violates React's rules, leading to an error because hook calls must be consistent across renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-conditionally-methodcall-hooklike-property-of-local.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {makeObject_Primitives} from 'shared-runtime';\n\nfunction Component(props) {\n  const local = makeObject_Primitives();\n  if (props.cond) {\n    local.useFoo();\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Original Component Implementation with Primitive Handling\nDESCRIPTION: Original component function showing primitive value handling and object property assignment. Demonstrates type inference through usage patterns.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-test-polymorphic.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component() {\n  let p = makePrimitive();\n  p + p; // infer p as primitive\n  let o = {};\n\n  let x = {};\n\n  x.t = p; // infer x.t as primitive\n  let z = x.t;\n\n  x.t = o; // generalize x.t\n  let y = x.t;\n  return y;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining and Exporting a React Component in JavaScript\nDESCRIPTION: The snippet defines a React component that converts an object to a boolean and returns both values. It exports a constant to serve as a fixture entry point for a React component named 'TodoAdd'. The function depends on standard JavaScript and React structures. It mainly initializes a component with given parameters and handles basic data manipulations as part of its key functionality.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/globals-Boolean.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const x = {};\n  const y = Boolean(x);\n  return [x, y];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Memoization\nDESCRIPTION: This snippet shows an optimized version of the 'Foo' component using memoization techniques. It uses a Symbol-based caching mechanism to store and reuse function and object references, potentially improving performance in subsequent renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/return-ref-callback-structure.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\n\nimport { useRef } from \"react\";\n\nfunction Foo(t0) {\n  const $ = _c(4);\n  const { cond, cond2 } = t0;\n  const ref = useRef();\n  let t1;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = () => ref.current;\n    $[0] = t1;\n  } else {\n    t1 = $[0];\n  }\n  const s = t1;\n  if (cond) {\n    let t2;\n    if ($[1] === Symbol.for(\"react.memo_cache_sentinel\")) {\n      t2 = [s];\n      $[1] = t2;\n    } else {\n      t2 = $[1];\n    }\n    return t2;\n  } else {\n    if (cond2) {\n      let t2;\n      if ($[2] === Symbol.for(\"react.memo_cache_sentinel\")) {\n        t2 = { s };\n        $[2] = t2;\n      } else {\n        t2 = $[2];\n      }\n      return t2;\n    } else {\n      let t2;\n      if ($[3] === Symbol.for(\"react.memo_cache_sentinel\")) {\n        t2 = { s: [s] };\n        $[3] = t2;\n      } else {\n        t2 = $[3];\n      }\n      return t2;\n    }\n  }\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{ cond: false, cond2: false }],\n};\n```\n\n----------------------------------------\n\nTITLE: Initializing Mutated Object Context in React Component\nDESCRIPTION: Creates a dynamic object context with mutated keys using identity and mutate utility functions from shared runtime. The component demonstrates experimental key generation and mutation techniques.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-object-expression-computed-key-modified-during-after-construction-sequence-expr.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {identity, mutate, mutateAndReturn} from 'shared-runtime';\n\nfunction Component(props) {\n  const key = {};\n  const context = {\n    [(mutate(key), key)]: identity([props.value]),\n  };\n  mutate(key);\n  return context;\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Dynamic Component Creation in React\nDESCRIPTION: This code shows an anti-pattern where a component is constructed during render using 'new ComponentFactory()'. This approach causes state to reset on each render and is flagged as invalid by React's compiler.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/static-components/invalid-dynamically-constructed-component-new.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @logger @validateStaticComponents\nfunction Example(props) {\n  const Component = new ComponentFactory();\n  return <Component />;\n}\n```\n\n----------------------------------------\n\nTITLE: React Component with Compiler Runtime\nDESCRIPTION: This code shows the compiled version of a React component using the 'react/compiler-runtime'.  The '_c' function seems to be responsible for memoization and caching of values and elements to optimize rendering.  The code checks for changes in 'props.value' and the 'onClick' handler to determine if re-renders are necessary, storing the results in the '$' array.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/drop-methodcall-usecallback.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport * as React from \"react\";\n\nfunction Component(props) {\n  const $ = _c(4);\n  let t0;\n  if ($[0] !== props.value) {\n    t0 = () => {\n      console.log(props.value);\n    };\n    $[0] = props.value;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const onClick = t0;\n  let t1;\n  if ($[2] !== onClick) {\n    t1 = <div onClick={onClick} />;\n    $[2] = onClick;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ value: 42 }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Using new Context API in React 16.3+\nDESCRIPTION: Example of using the new officially supported context API introduced in React 16.3.\nSOURCE: https://github.com/facebook/react/blob/main/CHANGELOG.md#2025-04-21_snippet_18\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst MyContext = React.createContext(defaultValue);\n\n// In a class component:\nstatic contextType = MyContext;\n\n// In a function component:\nconst value = useContext(MyContext);\n```\n\n----------------------------------------\n\nTITLE: Optimizing React Component with Const Variables\nDESCRIPTION: This snippet demonstrates an optimized version of the React component using 'const' for variable declarations. It performs the same operations as the previous version but with improved variable declarations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/nested-scopes-hook-call.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component(props) {\n  const x = [];\n  const y = [];\n  y.push(useHook(props.foo));\n  x.push(y);\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: Initial implementation of a React component that uses the Stringify component to render values. The component takes an 'id' prop and renders two Stringify components with different title values.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-duplicate-instruction-from-merge-consecutive-scopes.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {Stringify} from 'shared-runtime';\n\nfunction Component({id}) {\n  const bar = (() => {})();\n\n  return (\n    <>\n      <Stringify title={bar} />\n      <Stringify title={id ? true : false} />\n    </>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiler-Transformed Component with Memoization\nDESCRIPTION: The React compiler-transformed version of the component that implements memoization. It uses a cache sentinel to determine if object creation is needed or if a previously cached result can be returned.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/alias-nested-member-path-mutate.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction component() {\n  const $ = _c(1);\n  let x;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const z = [];\n    const y = {};\n    y.z = z;\n    x = {};\n    x.y = y;\n    mutate(x.y.z);\n    $[0] = x;\n  } else {\n    x = $[0];\n  }\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: React Memo Input Component Definition\nDESCRIPTION: Defines React components using memo with different rendered content, showcasing basic component memoization setup.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/reassigned-fnexpr-variable.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @gating\nimport * as React from 'react';\n\n/**\n * Test that the correct `Foo` is printed\n */\nlet Foo = () => <div>hello world 1!</div>;\nconst MemoOne = React.memo(Foo);\nFoo = () => <div>hello world 2!</div>;\nconst MemoTwo = React.memo(Foo);\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: () => {\n    'use no memo';\n    return (\n      <>\n        <MemoOne />\n        <MemoTwo />\n      </>\n    );\n  },\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Importing and Initializing Component with Static Text Elements in JavaScript\nDESCRIPTION: This snippet defines a functional React component named `Component` that takes props with a value property, and it involves conditional rendering of static text elements (`StaticText1` and `StaticText2`). The snippet highlights the simple embedding of prop values within JSX elements and exports an object with the component's configuration. Dependencies are `shared-runtime` for the static text components.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-tag-evaluation-order.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {StaticText1, StaticText2} from 'shared-runtime';\n\nfunction Component(props: {value: string}) {\n  let Tag = StaticText1;\n\n  // Currently, Forget preserves jsx whitespace in the source text.\n  // prettier-ignore\n  return (\n    <Tag>{((Tag = StaticText2), props.value)}<Tag /></Tag>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: 'string value 1'}],\n  isComponent: true,\n};\n\n```\n\n----------------------------------------\n\nTITLE: Invalid Conditional React Hook Call\nDESCRIPTION: This JavaScript code snippet demonstrates the incorrect usage of React's `useState` hook within a conditional statement. The `useState` hook is called conditionally based on the value of the `bar` prop, which violates the rules of hooks and leads to an \"InvalidReact\" error. React hooks must be called in the same order on every render.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-rules-of-hooks-f69800950ff0.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Expected to fail\n\n// Invalid because it's dangerous and might not warn otherwise.\n// This *must* be invalid.\nfunction useHook({bar}) {\n  let foo1 = bar && useState();\n  let foo2 = bar || useState();\n  let foo3 = bar ?? useState();\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining a React Functional Component with Hooks\nDESCRIPTION: This snippet defines a React functional component that uses the useEffect hook. The component incorrectly attempts to nest useEffect calls, which leads to a hook call violation error. The props are logged to the console inside a nested function that is executed within the useEffect phase.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/error.invalid-nested-use-effect.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enable\nimport {fire} from 'react';\n\nfunction Component(props) {\n  const foo = props => {\n    console.log(props);\n  };\n  useEffect(() => {\n    useEffect(() => {\n      function nested() {\n        fire(foo(props));\n      }\n\n      nested();\n    });\n  });\n\n  return null;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Managing Functional Components in React - JavaScript\nDESCRIPTION: This snippet defines a React component `Component` where a prop is incorrectly mutated within a function. It highlights a common pitfall of directly changing `props`, which should be avoided as it results in an error. The proper approach is to use a local state or derive the value from the props without mutation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-prop-mutation-indirect.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const f = () => {\n    props.value = true;\n  };\n  const g = () => {\n    f();\n  };\n  g();\n}\n```\n\n----------------------------------------\n\nTITLE: React Component with FBT Internationalization - Source\nDESCRIPTION: Original source code for a React component that uses FBT for internationalization. Handles pluralization of vote counts and parameter interpolation for voting options.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-param-with-trailing-whitespace.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport fbt from 'fbt';\nimport {identity} from 'shared-runtime';\n\nfunction Component(props) {\n  return (\n    <span>\n      <fbt desc=\"Title\">\n        <fbt:plural count={identity(props.count)} name=\"count\" showCount=\"yes\">\n          vote\n        </fbt:plural>{' '}\n        for <fbt:param name=\"option\">{props.option} </fbt:param>\n      </fbt>\n      !\n    </span>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{count: 42, option: 'thing'}],\n  sequentialRenders: [\n    {count: 42, option: 'thing'},\n    {count: 42, option: 'thing'},\n    {count: 1, option: 'other'},\n    {count: 1, option: 'other'},\n    {count: 42, option: 'thing'},\n    {count: 1, option: 'other'},\n    {count: 42, option: 'thing'},\n    {count: 1, option: 'other'},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimizing React Component with Compiler Enhancements in JavaScript\nDESCRIPTION: This snippet showcases an optimized version of a React component using the `react/compiler-runtime`. It employs compiler utilities to efficiently handle prop changes and JSX rendering. The component uses an array `$` for maintaining state between renders and leverages caching to only update the DOM when `props.text` changes. Dependencies include the `react/compiler-runtime` and any implementations needed for `makeFunction`. The component expects `props` with `text` and returns a potentially memoized JSX element.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/call-with-independently-memoizable-arg.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(4);\n  let t0;\n  if ($[0] !== props) {\n    const x = makeFunction(props);\n    let t1;\n    if ($[2] !== props.text) {\n      t1 = (\n        <div>\n          <span>{props.text}</span>\n        </div>\n      );\n      $[2] = props.text;\n      $[3] = t1;\n    } else {\n      t1 = $[3];\n    }\n    t0 = x(t1);\n    $[0] = props;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const y = t0;\n  return y;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining Functional Component with JSX - JavaScript\nDESCRIPTION: This snippet defines a simple functional React component named 'Component' that receives props and returns JSX. The component renders a nested component 'Sathya.Codes.Forget' which wraps around 'Foo.Bar.Baz'. No external dependencies are mentioned. The expected output is a valid React element.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-member-expression.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  return (\n    <Sathya.Codes.Forget>\n      <Foo.Bar.Baz />\n    </Sathya.Codes.Forget>\n  );\n}\n\n```\n\n----------------------------------------\n\nTITLE: Using Compiler Runtime for State Management in Custom React Hook - JavaScript\nDESCRIPTION: This snippet enhances the previous hook by incorporating a compiler runtime utility to manage state updates efficiently. It ensures that state is only updated when necessary by comparing previous values. This custom hook also requires React and shared runtime imports. The output behavior remains similar, where functions can be invoked to access current state values.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-shorthand-method-nested.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useState } from \"react\";\nimport { createHookWrapper } from \"shared-runtime\";\n\nfunction useHook(t0) {\n  const $ = _c(3);\n  const { value } = t0;\n  const [state] = useState(false);\n  let t1;\n  if ($[0] !== state || $[1] !== value) {\n    t1 = {\n      getX() {\n        return {\n          a: [],\n          getY() {\n            return value;\n          },\n          state,\n        };\n      },\n    };\n    $[0] = state;\n    $[1] = value;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: createHookWrapper(useHook),\n  params: [{ value: 0 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component\nDESCRIPTION: Simplified version of the same component that removes the continue statement and uses basic assignment operators. Maintains identical functionality while improving code readability.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-empty-update-with-continue.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let x = 0;\n  for (let i = 0; i < props.count; ) {\n    x = x + i;\n    i = i + 1;\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Setting up React DOM Fixtures\nDESCRIPTION: Commands to set up and run DOM fixtures for testing React in different browser environments. First builds React, then navigates to the fixtures directory, installs dependencies, and runs the development script.\nSOURCE: https://github.com/facebook/react/blob/main/fixtures/dom/README.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncd fixtures/dom\nyarn\nyarn dev\n```\n\n----------------------------------------\n\nTITLE: React Component with Incorrect useRef Usage\nDESCRIPTION: Example React component that demonstrates incorrect usage of useRef by directly mutating ref.current outside of event handlers or effects. Contains an ESLint rule disable comment for hooks rules violation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/use-no-forget-with-eslint-suppression.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useRef} from 'react';\n\nfunction Component() {\n  'use no forget';\n  const ref = useRef(null);\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  ref.current = 'bad';\n  return <button ref={ref} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n};\n```\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useRef } from \"react\";\n\nfunction Component() {\n  \"use no forget\";\n  const ref = useRef(null);\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  ref.current = \"bad\";\n  return <button ref={ref} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Creating React Component with Memo Cache - JavaScript\nDESCRIPTION: Implements a React component with a memoization caching system using a Symbol-based cache. The component inspects cache slots before processing and updating. The component uses an imported variable and returns a cached result. It requires react/compiler-runtime and symbol usage.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-map-frozen-array.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\n\"import { c as _c } from \\\"react/compiler-runtime\\\";\\nfunction Component(props) {\\n  const $ = _c(2);\\n  let t0;\\n  if ($[0] === Symbol.for(\\\"react.memo_cache_sentinel\\\")) {\\n    t0 = [];\\n    $[0] = t0;\\n  } else {\\n    t0 = $[0];\\n  }\\n  const x = t0;\\n  let t1;\\n  if ($[1] === Symbol.for(\\\"react.memo_cache_sentinel\\\")) {\\n    const y = x.map(_temp);\\n    t1 = [x, y];\\n    $[1] = t1;\\n  } else {\\n    t1 = $[1];\\n  }\\n  return t1;\\n}\\nfunction _temp(item) {\\n  return item;\\n}\\n\\nexport const FIXTURE_ENTRYPOINT = {\\n  fn: Component,\\n  params: [{}],\\n  isComponent: false,\\n};\"\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Runtime Optimization\nDESCRIPTION: Transformed version of the component using React compiler runtime with memoization optimization for the filter operation. Includes separate filter predicate function and same test fixture.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/noAlias-filter-on-array-prop.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== props.items) {\n    t0 = props.items.filter(_temp);\n    $[0] = props.items;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const filtered = t0;\n  return filtered;\n}\nfunction _temp(item) {\n  return item != null;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\n    {\n      items: [\n        { a: true },\n        null,\n        true,\n        false,\n        null,\n        \"string\",\n        3.14,\n        null,\n        [null],\n      ],\n    },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Array Mutation (JavaScript)\nDESCRIPTION: This snippet defines a React component that creates an array, mutates it using a map function, and renders the results. It demonstrates potential issues with function calls that capture their callee when applying an operand.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/global-types/repro-array-map-capture-mutate-bug.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {mutateAndReturn, Stringify, useIdentity} from 'shared-runtime';\n\n/**\n * Copy of repro-array-map-capture-mutate-bug, showing that the same issue applies to any\n * function call which captures its callee when applying an operand.\n */\nfunction Component({value}) {\n  const arr = [{value: 'foo'}, {value: 'bar'}, {value}];\n  useIdentity(null);\n  const derived = arr.map(mutateAndReturn);\n  return (\n    <Stringify>\n      {derived.at(0)}\n      {derived.at(-1)}\n    </Stringify>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: 5}],\n  sequentialRenders: [{value: 5}, {value: 6}, {value: 6}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization Logic\nDESCRIPTION: The React compiler output for the component, showing how the memoization is implemented. It includes the compiler-runtime logic that tracks dependencies and handles memoized values across renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/context-var-granular-dep.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { throwErrorWithMessage, ValidateMemoization } from \"shared-runtime\";\n\n/**\n * Context variables are local variables that (1) have at least one reassignment\n * and (2) are captured into a function expression. These have a known mutable\n * range: from first declaration / assignment to the last direct or aliased,\n * mutable reference.\n *\n * This fixture validates that forget can take granular dependencies on context\n * variables when the reference to a context var happens *after* the end of its\n * mutable range.\n */\nfunction Component(t0) {\n  const $ = _c(10);\n  const { cond, a } = t0;\n  let contextVar;\n  if ($[0] !== a || $[1] !== cond) {\n    if (cond) {\n      contextVar = { val: a };\n    } else {\n      contextVar = {};\n      throwErrorWithMessage(\"\");\n    }\n    $[0] = a;\n    $[1] = cond;\n    $[2] = contextVar;\n  } else {\n    contextVar = $[2];\n  }\n  let t1;\n  if ($[3] !== contextVar) {\n    t1 = { cb: () => contextVar.val * 4 };\n    $[3] = contextVar;\n    $[4] = t1;\n  } else {\n    t1 = $[4];\n  }\n  const cb = t1;\n\n  const t2 = cond ? a : undefined;\n  let t3;\n  if ($[5] !== t2) {\n    t3 = [t2];\n    $[5] = t2;\n    $[6] = t3;\n  } else {\n    t3 = $[6];\n  }\n  let t4;\n  if ($[7] !== cb || $[8] !== t3) {\n    t4 = (\n      <ValidateMemoization inputs={t3} output={cb} onlyCheckCompiled={true} />\n    );\n    $[7] = cb;\n    $[8] = t3;\n    $[9] = t4;\n  } else {\n    t4 = $[9];\n  }\n  return t4;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ cond: false, a: undefined }],\n  sequentialRenders: [\n    { cond: true, a: 2 },\n    { cond: true, a: 2 },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Caching\nDESCRIPTION: Compiled version of the component with React's compiler runtime caching implementation. Uses an array for caching previous values and conditionally rebuilds arrays only when dependencies change.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/dependencies-outputs.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction foo(a, b) {\n  const $ = _c(5);\n  let x;\n  if ($[0] !== a) {\n    x = [];\n    x.push(a);\n    $[0] = a;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  let y;\n  if ($[2] !== b || $[3] !== x) {\n    y = [];\n    if (x.length) {\n      y.push(x);\n    }\n    if (b) {\n      y.push(b);\n    }\n    $[2] = b;\n    $[3] = x;\n    $[4] = y;\n  } else {\n    y = $[4];\n  }\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Compiler Runtime\nDESCRIPTION: This code shows the compiled version of the React component, utilizing React's compiler runtime for potential performance optimizations. The component uses _c from \"react/compiler-runtime\", memoizing the rendering result. This memoization helps avoid unnecessary re-renders of the <Foo> component improving performance when the props haven't changed.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-passing-refs-as-props.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(1);\n  const ref = useRef(null);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = <Foo ref={ref} />;\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic React Component - JavaScript\nDESCRIPTION: This snippet defines a functional React component named 'Component' that initializes a text variable containing double quotes and passes it as a prop to a child component. The 'Child' component simply returns the received text. This is useful for testing string interpolation in React components.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/quoted-strings-jsx-attribute-escaped-constant-propagation.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nexport function Component() {\n  // Test what happens if a string with double-quotes is interpolated via constant propagation\n  const text = 'Some \"text\"';\n  return <Child text={text} />;\n}\n\nfunction Child(props) {\n  return props.text;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Original React Component with useMemo\nDESCRIPTION: Source code showing a React component using useMemo hook without explicit dependency array. The component takes a propA parameter and returns it in an array.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useMemo-with-no-depslist.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees\nimport {useMemo} from 'react';\n\n// Compiler can produce any memoization it finds valid if the\n// source listed no memo deps\nfunction Component({propA}) {\n  // @ts-ignore\n  return useMemo(() => {\n    return [propA];\n  });\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{propA: 2}],\n};\n```\n\n----------------------------------------\n\nTITLE: React Functional Component Compilation with Memoization\nDESCRIPTION: This snippet presents the compiled code for a React functional component (TestComponent2) that uses a compiler runtime function (`_c`) for memoization. Similar to TestComponent, it avoids re-rendering the `<Button>` component unless the `x` prop has changed, retrieving the cached result when possible.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/apps/playground/__tests__/e2e/__snapshots__/page.spec.ts/use-memo-output.txt#2025-04-21_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst TestComponent2 = (t0) => {\n  \"usememo\";\n  const $ = _c(2);\n  const { x } = t0;\n  let t1;\n  if ($[0] !== x) {\n    t1 = <Button>{x}</Button>;\n    $[0] = x;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with react/compiler-runtime\nDESCRIPTION: This snippet shows the compiled version of the React component. It uses the `_c` function from `react/compiler-runtime` to achieve memoization. The compiled code optimizes the component by storing previous values and only re-rendering when necessary, avoiding unnecessary computations and re-renders of its children.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-simple.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction component(a) {\n  const $ = _c(4);\n  let t0;\n  let t1;\n  if ($[0] !== a) {\n    t1 = [a];\n    $[0] = a;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  t0 = t1;\n  const x = t0;\n  let t2;\n  if ($[2] !== x) {\n    t2 = <Foo x={x} />;\n    $[2] = x;\n    $[3] = t2;\n  } else {\n    t2 = $[3];\n  }\n  return t2;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Components Conditionally with React\nDESCRIPTION: This snippet defines a React functional component that conditionally assigns a component type based on the 'cond' prop. It showcases a basic implementation without optimizations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/static-components/invalid-conditionally-assigned-dynamically-constructed-component-in-render.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @logger @validateStaticComponents\nfunction Example(props) {\n  let Component;\n  if (props.cond) {\n    Component = createComponent();\n  } else {\n    Component = DefaultComponent;\n  }\n  return <Component />;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Original React Hook Implementation with Conditional Logic\nDESCRIPTION: Implements a custom React hook 'useFoo' that manages state based on a condition parameter. Uses labeled blocks and conditional logic to handle state mutations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/align-scopes-reactive-scope-overlaps-if.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction useFoo({cond}) {\n  let items: any = {};\n  b0: {\n    if (cond) {\n      // Mutable range of `items` begins here, but its reactive scope block\n      // should be aligned to above the if-branch\n      items = [];\n    } else {\n      break b0;\n    }\n    items.push(2);\n  }\n  return items;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{cond: true}],\n  sequentialRenders: [\n    {cond: true},\n    {cond: true},\n    {cond: false},\n    {cond: false},\n    {cond: true},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: React Compiler Runtime Memoization Implementation\nDESCRIPTION: Demonstrates the React compiler's runtime memoization strategy using a cache sentinel and conditional caching mechanism. Shows how complex reactive dependencies are tracked and memoized to optimize performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-from-interleaved-reactivity-for-test.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const $ = _c(1);\n\n  const a = [];\n  const b = [];\n  b.push(props.cond);\n  a.push(10);\n\n  const c = [a];\n\n  let x;\n  for (let i = 0; i < c[0][0]; i++) {\n    x = 1;\n  }\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = [x];\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Compiler Runtime\nDESCRIPTION: This snippet shows the optimized version of the Component function, using React's compiler runtime for improved performance. It implements memoization to avoid unnecessary re-renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-alias-declaration.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== props.name) {\n    t0 = { name: props.name };\n    $[0] = props.name;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const user = t0;\n  return user;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ name: \"Mofei\" }],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component 'Foo' with Memoization\nDESCRIPTION: This snippet shows the compiled and optimized version of the 'Foo' component. It uses the React compiler runtime to implement memoization, caching the result of the component's computation for improved performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/lambda-array-access-member-expr-captured.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { CONST_NUMBER0, invoke } from \"shared-runtime\";\n\nfunction Foo() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const x = [{ value: 0 }, { value: 1 }, { value: 2 }];\n\n    const foo = () => x[CONST_NUMBER0].value;\n\n    t0 = invoke(foo);\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Initializing React Component with useRef in JavaScript\nDESCRIPTION: The snippet illustrates how to use the useRef hook to create a mutable ref object in a React component. Its current property should be accessed outside the render phase to avoid errors. The example demonstrates a common issue where ref.current is set during rendering, which is flagged as invalid. No specific dependencies beyond React and JavaScript are required.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-disallow-mutating-ref-in-render.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validateRefAccessDuringRender\nfunction Component() {\n  const ref = useRef(null);\n  ref.current = false;\n\n  return <button ref={ref} />;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Input React Component with Conditionally Selected Ref in useEffect\nDESCRIPTION: A React component that demonstrates a case where ref selection depends on props, making the ref reactive despite refs typically being stable. The component conditionally selects between two refs based on a prop value and uses the selected ref in an effect.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/reactive-ref.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @inferEffectDependencies\nimport {useEffect, useRef} from 'react';\nimport {print} from 'shared-runtime';\n\n/*\n * Ref types are not enough to determine to omit from deps. Must also take reactivity into account.\n */\nfunction ReactiveRefInEffect(props) {\n  const ref1 = useRef('initial value');\n  const ref2 = useRef('initial value');\n  let ref;\n  if (props.foo) {\n    ref = ref1;\n  } else {\n    ref = ref2;\n  }\n  useEffect(() => print(ref));\n}\n```\n\n----------------------------------------\n\nTITLE: React Component with Reactive Handling in JavaScript\nDESCRIPTION: This snippet shows an enhanced version of the React component that includes a mechanism for handling reactive state using a custom reactive system. It utilizes an imported function from 'react/compiler-runtime' to manage changes to the value 'x' more efficiently and returns the computed state reactively.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-while-test.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  let x;\n  let i = 0;\n  while (i < props.test) {\n    if (i > 10) {\n      x = 10;\n    } else {\n      x = 1;\n    }\n\n    i++;\n  }\n  let t0;\n  if ($[0] !== x) {\n    t0 = [x];\n    $[0] = x;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  sequentialRenders: [\n    { test: 12 },\n    { test: 12 },\n    { test: 1 },\n    { test: 1 },\n    { test: 12 },\n    { test: 1 },\n    { test: 12 },\n    { test: 1 },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Error Message for Optional Chaining in Ternary Expression\nDESCRIPTION: This snippet shows an error message indicating an unexpected terminal kind 'optional' for a ternary test block. The error occurs at line 5 where optional chaining is used in the useNoAlias function call.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-optional-call-chain-in-ternary.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n  3 | function useFoo(props: {value: {x: string; y: string} | null}) {\n  4 |   const value = props.value;\n> 5 |   return useNoAlias(value?.x, value?.y) ? {} : null;\n    |                               ^^^^^^^^ Todo: Unexpected terminal kind `optional` for ternary test block (5:5)\n  6 | }\n  7 |\n  8 | export const FIXTURE_ENTRYPONT = {\n```\n\n----------------------------------------\n\nTITLE: Error Reporting for Reassignment in React Component - JavaScript\nDESCRIPTION: This snippet captures the error reported when the component tries to reassign a variable that is not locally defined. It explains that components should be pure and suggests using the React hook `useState` for state management instead of variable reassignment.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.reassignment-to-global.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n  1 | function Component() {\n  2 |   // Cannot assign to globals\n> 3 |   someUnknownGlobal = true;\n    |   ^^^^^^^^^^^^^^^^^ InvalidReact: Unexpected reassignment of a variable which was defined outside of the component. Components and hooks should be pure and side-effect free, but variable reassignment is a form of side-effect. If this variable is used in rendering, use useState instead. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#side-effects-must-run-outside-of-render) (3:3)\n  4 |   moduleLocal = true;\n  5 | }\n  6 |\n```\n\n----------------------------------------\n\nTITLE: Defining Original React Component with Compute Function\nDESCRIPTION: This snippet shows the original React component that computes values based on props and renders a Foo component. It includes comments describing the expected scope analysis.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/independent.expect.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n/**\n * Should produce 3 scopes:\n *\n * a: inputs=props.a, outputs=a\n *   a = compute(props.a);\n * b: inputs=props.b, outputs=b\n *   b = compute(props.b);\n * return: inputs=a, b outputs=return\n *   return = <Foo a={a} b={b} />\n */\nfunction Component(props) {\n  const a = compute(props.a);\n  const b = compute(props.b);\n  return <Foo a={a} b={b} />;\n}\n\nfunction compute() {}\nfunction foo() {}\nfunction Foo() {}\n```\n\n----------------------------------------\n\nTITLE: React useFoo Hook - Initial Input\nDESCRIPTION: This is the initial implementation of the `useFoo` hook. It conditionally pushes `props.foo` to an array `x` based on `props.cond`. The `@enablePropagateDepsInHIR` directive suggests that this code will be transformed by the React compiler to optimize dependency tracking.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/ssa-renaming-ternary-destruction.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enablePropagateDepsInHIR\nfunction useFoo(props) {\n  let x = [];\n  x.push(props.bar);\n  props.cond ? (({x} = {x: {}}), ([x] = [[]]), x.push(props.foo)) : null;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{cond: false, foo: 2, bar: 55}],\n  sequentialRenders: [\n    {cond: false, foo: 2, bar: 55},\n    {cond: false, foo: 3, bar: 55},\n    {cond: true, foo: 3, bar: 55},\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with Optional Chaining in JavaScript\nDESCRIPTION: This snippet defines a React component that uses optional chaining to access a nested property. It demonstrates the difference between `a?.b.c` and `(a?.b).c`, where the latter performs an unconditional load on `.b`. The component expects 'props' as an input and returns the value of `props.a.b`.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/nonoptional-load-from-optional-memberexpr.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Note that `a?.b.c` is semantically different from `(a?.b).c`\n// Here, 'props?.a` is an optional chain, and `.b` is an unconditional load\n// (nullthrows if a is nullish)\n\nfunction Component(props) {\n  const x = (props?.a).b;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Using useMemo for Conditional Calculation in React\nDESCRIPTION: This snippet defines a custom hook 'useFoo' that utilizes 'useMemo' from React to memoize values based on a condition. It imports necessary functions from 'react' and 'shared-runtime'. The hook takes a boolean parameter, where it computes and returns 10 if true or 5 if false. The memoized value is recalculated only when the condition changes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/prune-nonescaping-useMemo-mult-returns.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees\n\nimport {useMemo} from 'react';\nimport {identity} from 'shared-runtime';\n\nfunction useFoo(cond) {\n  useMemo(() => {\n    if (cond) {\n      return identity(10);\n    } else {\n      return identity(5);\n    }\n  }, [cond]);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [true],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized Hook Function with React Compiler Runtime JavaScript\nDESCRIPTION: This optimized JavaScript code snippet involves creating a custom hook with dynamic properties `x`, `y`, and `z`, utilizing caching mechanisms for performance. It imports `_c` from `react/compiler-runtime` and `createHookWrapper` from `shared-runtime`. The function takes `a`, `b`, and `c` as parameters and returns an object based on cache states to minimize recalculation. Dependencies include specific modules for runtime and caching, with the expected output being an optimized reactive object representation. The usage is constrained to environments with React compiler-runtime support.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-shorthand-method-2.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { createHookWrapper } from \"shared-runtime\";\n\nfunction useHook(t0) {\n  const $ = _c(8);\n  const { a, b, c } = t0;\n  let t1;\n  if ($[0] !== a) {\n    t1 = [a];\n    $[0] = a;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  let t2;\n  if ($[2] !== b || $[3] !== c || $[4] !== t1) {\n    let t3;\n    if ($[6] !== c) {\n      t3 = { c };\n      $[6] = c;\n      $[7] = t3;\n    } else {\n      t3 = $[7];\n    }\n    t2 = {\n      x: t1,\n      y() {\n        return [b];\n      },\n      z: t3,\n    };\n    $[2] = b;\n    $[3] = c;\n    $[4] = t1;\n    $[5] = t2;\n  } else {\n    t2 = $[5];\n  }\n  return t2;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: createHookWrapper(useHook),\n  params: [{ a: 1, b: 2, c: 2 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing React Functional Component with Conditional Rendering\nDESCRIPTION: This snippet implements a React functional component that conditionally renders its children based on the 'entity' prop. It uses the 'useCallback' hook for memoization of the 'showMessage' function, which checks the presence of the entity. The component is designed to preserve memoization guarantees outlined in React's best practices.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useCallback-nonescaping.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees @enableAssumeHooksFollowRulesOfReact @enableTransitivelyFreezeFunctionExpressions\nimport {useCallback} from 'react';\n\nfunction Component({entity, children}) {\n  // showMessage doesn't escape so we don't memoize it.\n  // However, validatePreserveExistingMemoizationGuarantees only sees that the scope\n  // doesn't exist, and thinks the memoization was missed instead of being intentionally dropped.\n  const showMessage = useCallback(() => entity != null, [entity]);\n\n  if (!showMessage()) {\n    return children;\n  }\n\n  return <div>{children}</div>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\n    {\n      entity: {name: 'Sathya'},\n      children: [<div key=\"gsathya\">Hi Sathya!</div>],\n    },\n  ],\n};\n\n```\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @validatePreserveExistingMemoizationGuarantees @enableAssumeHooksFollowRulesOfReact @enableTransitivelyFreezeFunctionExpressions\nimport { useCallback } from \"react\";\n\nfunction Component(t0) {\n  const $ = _c(2);\n  const { entity, children } = t0;\n\n  const showMessage = () => entity != null;\n  if (!showMessage()) {\n    return children;\n  }\n  let t1;\n  if ($[0] !== children) {\n    t1 = <div>{children}</div>;\n    $[0] = children;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\n    {\n      entity: { name: \"Sathya\" },\n      children: [<div key=\"gsathya\">Hi Sathya!</div>],\n    },\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Incorrect Hook Usage in React Component - JavaScript\nDESCRIPTION: This JavaScript snippet illustrates an incorrect pattern of using the `useState` hook within a callback function inside a React component. Hooks in React must be called at the top level of a function component or a custom hook and not inside nested functions to ensure consistent behavior. The example showcases a common misunderstanding that could lead to runtime errors.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid.invalid-rules-of-hooks-76a74b4666e9.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Invalid because it's a common misunderstanding.\\n// We *could* make it valid but the runtime error could be confusing.\\nfunction ComponentWithHookInsideCallback() {\\n  function handleClick() {\\n    useState();\\n  }\\n}\n```\n\n----------------------------------------\n\nTITLE: Compiler-Optimized React Component with Memoization\nDESCRIPTION: The transformed version of the App component with the @lowerContextAccess directive applied. The React compiler has added memoization to avoid recreating the Bar component when its props haven't changed.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/todo.lower-context-access-destructure-multiple.expect.md#2025-04-22_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @lowerContextAccess\nfunction App() {\n  const $ = _c(3);\n  const context = useContext(MyContext);\n  const { foo } = context;\n  const { bar } = context;\n  let t0;\n  if ($[0] !== bar || $[1] !== foo) {\n    t0 = <Bar foo={foo} bar={bar} />;\n    $[0] = bar;\n    $[1] = foo;\n    $[2] = t0;\n  } else {\n    t0 = $[2];\n  }\n  return t0;\n}\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component\nDESCRIPTION: This JavaScript code represents the compiled and optimized version of the original React component. It uses a compiler runtime `_c` to memoize the results of calculations based on the component's props. This optimization avoids unnecessary re-renders and improves the component's performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactivity-analysis-reactive-via-mutation-of-property-load.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(7);\n  let items;\n  if ($[0] !== props.a) {\n    items = bar();\n    mutate(items.a, props.a);\n    $[0] = props.a;\n    $[1] = items;\n  } else {\n    items = $[1];\n  }\n\n  const t0 = items.length + 1;\n  let t1;\n  if ($[2] !== t0) {\n    t1 = foo(t0);\n    $[2] = t0;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  const count = t1;\n  let t2;\n  if ($[4] !== count || $[5] !== items) {\n    t2 = { items, count };\n    $[4] = count;\n    $[5] = items;\n    $[6] = t2;\n  } else {\n    t2 = $[6];\n  }\n  return t2;\n}\n```\n\n----------------------------------------\n\nTITLE: React Component Definition\nDESCRIPTION: This JavaScript snippet defines a React component named `Foo`. The component includes a function `x` that attempts to modify the global `window.href` property.  The component then passes this function as a prop named `y` to another component called `Bar`.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.object-capture-global-mutation.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Foo() {\n  const x = () => {\n    window.href = 'foo';\n  };\n  const y = {x};\n  return <Bar y={y} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Mutation and Component Logic in JavaScript\nDESCRIPTION: This snippet defines a mutate function for array manipulation and a Component function that demonstrates various object and array operations. It also includes a FIXTURE_ENTRYPOINT export for testing purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/mutable-lifetime-with-aliasing.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction mutate(x, y) {\n  'use no forget';\n  if (!Array.isArray(x.value)) {\n    x.value = [];\n  }\n  x.value.push(y);\n  if (y != null) {\n    y.value = x;\n  }\n}\n\nfunction Component(props) {\n  const a = {};\n  const b = [a]; // array elements alias\n  const c = {};\n  const d = {c}; // object values alias\n\n  // capture all the values into this object\n  const x = {};\n  x.b = b;\n  const y = mutate(x, d); // mutation aliases the arg and return value\n\n  // all of these tests are seemingly readonly, since the values are never directly\n  // mutated again. but they are all aliased by `x`, which is later modified, and\n  // these are therefore mutable references:\n  if (a) {\n  }\n  if (b) {\n  }\n  if (c) {\n  }\n  if (d) {\n  }\n  if (y) {\n  }\n\n  // could in theory mutate any of a/b/c/x/z, so the above should be inferred as mutable\n  mutate(x, null);\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Optimizing React Component without Destructuring\nDESCRIPTION: This snippet shows an optimized version of the Component function. It achieves the same result as the previous version but without using destructuring. It directly accesses the first element of props.value and uses a ternary operator for the default value assignment.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-default-at-explicit-undefined.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const [t0] = props.value;\n  const x = t0 === undefined ? 42 : t0;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ value: [undefined] }],\n};\n```\n\n----------------------------------------\n\nTITLE: Invalid React Mutation Error Message - JavaScript\nDESCRIPTION: The error message signals that mutating component props or hook arguments is not permitted in React. Instead, it suggests that developers should use local variables to maintain state without breaking React's reactivity model. The error points specifically to the line where 'y.foo' is being modified.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-mutate-props-in-effect-fixpoint.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n   8 |   let y = x;\n   9 |   let mutateProps = () => {\n> 10 |     y.foo = true;\n     |     ^ InvalidReact: Mutating component props or hook arguments is not allowed. Consider using a local variable instead. Found mutation of `y` (10:10)\n  11 |   };\n  12 |   let mutatePropsIndirect = () => {\n  13 |     mutateProps();\n\n```\n\n----------------------------------------\n\nTITLE: Initializing Forwarded Reference React Component with Hooks\nDESCRIPTION: Creates a React component using forwardRef and an anonymous arrow function, demonstrating hook integration and prop forwarding\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.bail.rules-of-hooks-e9f9bac89f8f.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst FancyButton = React.forwardRef((props, ref) => {\n  useHook();\n  return <button {...props} ref={ref} />;\n});\n```\n\n----------------------------------------\n\nTITLE: Original Function Implementation\nDESCRIPTION: Original function implementation showing a simple component that uses shallowCopy and performs a method call. Includes test fixture setup for the function.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/method-call.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {addOne, shallowCopy} from 'shared-runtime';\n\nfunction foo(a, b, c) {\n  // Construct and freeze x\n  const x = shallowCopy(a);\n  <div>{x}</div>;\n\n  // y should depend on `x` and `b`\n  const y = x.foo(b);\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [{foo: addOne}, 3],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: React useState Hook Usage in Component\nDESCRIPTION: This code snippet demonstrates the correct usage of the `useState` hook within a React component.  It highlights how the hook can be used in a component that contains loops and conditional statements, as long as the hook itself is not placed inside the loop or condition. It showcases a valid scenario where the `useState` hook is called only once and outside of the control flow structures.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-69521d94fa03.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// Valid because the neither the condition nor the loop affect the hook call.\nfunction App(props) {\n  const someObject = { propA: true };\n  for (const propName in someObject) {\n    if (propName === true) {\n    }\n  }\n\n  useState(null);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component\nDESCRIPTION: This is the compiled output of the React component using the React compiler runtime.  It uses the `_c` function from \"react/compiler-runtime\" to manage reactivity.  It includes logic to memoize the output of the component using a cache.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-from-interleaved-reactivity-for-of.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(1);\n\n  const a = [];\n  const b = [];\n  b.push(props.cond);\n  a.push(null);\n\n  const c = [a];\n\n  let x;\n  for (const i of c[0]) {\n    x = 1;\n  }\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = [x];\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ cond: true }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Optimization\nDESCRIPTION: The compiled version of the component with React runtime optimizations. Shows how array destructuring is transformed into direct property access with caching mechanism.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-array-default.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  const [t0] = props.y;\n  let t1;\n  if ($[0] !== t0) {\n    t1 = t0 === undefined ? [\"default\"] : t0;\n    $[0] = t0;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  const [x] = t1;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: React Component Definition with idx macro\nDESCRIPTION: This code defines a React component that uses the `idx` macro to safely access nested properties within the `props` object. The `idx` macro is used with different variations (`idx`, `idx.a`, `idx.a.b`, `idx.hello_world.b`, `idx.hello_world.b.c`) to access the `group.label` property.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/idx-method-no-outlining-wildcard.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n```javascript\n// @customMacros(idx.*.b)\n\nfunction Component(props) {\n  // outlined\n  const groupName1 = idx(props, _ => _.group.label);\n  // outlined\n  const groupName2 = idx.a(props, _ => _.group.label);\n  // not outlined\n  const groupName3 = idx.a.b(props, _ => _.group.label);\n  // not outlined\n  const groupName4 = idx.hello_world.b(props, _ => _.group.label);\n  // outlined\n  const groupName5 = idx.hello_world.b.c(props, _ => _.group.label);\n  return (\n    <div>\n      {groupName1}\n      {groupName2}\n      {groupName3}\n      {groupName4}\n      {groupName5}\n    </div>\n  );\n}\n\n```\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component Output\nDESCRIPTION: Compiled version of the React component showing optimization transformations including memo caching and temporary variable management. Includes compiler runtime imports and memoization logic.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-global-mutation-in-effect-indirect.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useEffect, useState } from \"react\";\n\nlet someGlobal = {};\n\nfunction Component() {\n  const $ = _c(6);\n  const [state, setState] = useState(someGlobal);\n\n  const setGlobal = _temp;\n  let t0;\n  let t1;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = () => {\n      setGlobal();\n    };\n    t1 = [];\n    $[0] = t0;\n    $[1] = t1;\n  } else {\n    t0 = $[0];\n    t1 = $[1];\n  }\n  useEffect(t0, t1);\n  let t2;\n  let t3;\n  if ($[2] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t2 = () => {\n      setState(someGlobal.value);\n    };\n    t3 = [someGlobal];\n    $[2] = t2;\n    $[3] = t3;\n  } else {\n    t2 = $[2];\n    t3 = $[3];\n  }\n  useEffect(t2, t3);\n\n  const t4 = String(state);\n  let t5;\n  if ($[4] !== t4) {\n    t5 = <div>{t4}</div>;\n    $[4] = t4;\n    $[5] = t5;\n  } else {\n    t5 = $[5];\n  }\n  return t5;\n}\nfunction _temp() {\n  someGlobal.value = true;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Original React Component Function\nDESCRIPTION: This snippet defines a function 'foo' that creates a conditional JSX structure based on input parameters. It also exports a FIXTURE_ENTRY POINT object for testing or demonstration purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/escape-analysis-jsx-child.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(a, b, c) {\n  const x = [];\n  if (a) {\n    const y = [];\n    if (b) {\n      y.push(c);\n    }\n    x.push(<div>{y}</div>);\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: React Compiler Optimized useFoo Hook with Memoization\nDESCRIPTION: Compiler-optimized version of the useFoo hook with memoization using React's compiler-runtime. The compiled code caches previous values in the $ array to avoid recalculations when props haven't changed, improving performance through dependency tracking.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-renaming-unconditional-ternary.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction useFoo(props) {\n  const $ = _c(6);\n  let x;\n  if ($[0] !== props.bar) {\n    x = [];\n    x.push(props.bar);\n    $[0] = props.bar;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  if ($[2] !== props.bar || $[3] !== props.cond || $[4] !== props.foo) {\n    props.cond ? ((x = []), x.push(props.foo)) : ((x = []), x.push(props.bar));\n    $[2] = props.bar;\n    $[3] = props.cond;\n    $[4] = props.foo;\n    $[5] = x;\n  } else {\n    x = $[5];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ cond: false, foo: 2, bar: 55 }],\n  sequentialRenders: [\n    { cond: false, foo: 2, bar: 55 },\n    { cond: false, foo: 3, bar: 55 },\n    { cond: true, foo: 3, bar: 55 },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized Component Logic with Props in JavaScript\nDESCRIPTION: This snippet presents an optimized version of a React component that processes properties using a cached approach. It checks if incoming prop values have changed and conditionally populates an array `a`. This includes handling of `props.b` and ensures efficient updates by utilizing an array `$` to store previous prop values. Dependencies include React Compiler Runtime.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/conditional-break-labeled.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enablePropagateDepsInHIR\n/**\n * props.b *does* influence `a`\n */\nfunction Component(props) {\n  const $ = _c(5);\n  let a;\n  if (\n    $[0] !== props.a ||\n    $[1] !== props.b ||\n    $[2] !== props.c ||\n    $[3] !== props.d\n  ) {\n    a = [];\n    a.push(props.a);\n    bb0: {\n      if (props.b) {\n        break bb0;\n      }\n\n      a.push(props.c);\n    }\n\n    a.push(props.d);\n    $[0] = props.a;\n    $[1] = props.b;\n    $[2] = props.c;\n    $[3] = props.d;\n    $[4] = a;\n  } else {\n    a = $[4];\n  }\n  return a;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Handling Errors in React Hook Accessing Ref During Render\nDESCRIPTION: This snippet includes the error messages generated when attempting to access the '.current' property of a ref during the rendering phase. The error indicates that manipulating ref values directly within the component render is not permissible in React, providing links to the React documentation for further guidance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.capture-ref-for-mutation.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n  10 |   };\n  11 |   const moveLeft = {\n> 12 |     handler: handleKey('left')(),\n     |              ^^^^^^^^^^^^^^^^^ InvalidReact: This function accesses a ref value (the `current` property), which may not be accessed during render. (https://react.dev/reference/react/useRef) (12:12)\n\nInvalidReact: Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef) (12:12)\n\nInvalidReact: This function accesses a ref value (the `current` property), which may not be accessed during render. (https://react.dev/reference/react/useRef) (15:15)\n\nInvalidReact: Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef) (15:15)\n  13 |   };\n  14 |   const moveRight = {\n  15 |     handler: handleKey('right')(),\n```\n\n----------------------------------------\n\nTITLE: React Compiler Error Message for Memoization Issues\nDESCRIPTION: The error message from React Compiler indicating that it skipped optimizing the component due to memoization preservation issues. It highlights three specific locations where memoization could not be preserved, primarily due to potential mutations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-repro-missed-memoization-from-inferred-mutation-in-logger.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n   9 |   const [index, setIndex] = useState(0);\n  10 |\n> 11 |   const logData = useMemo(() => {\n     |                   ^^^^^^^^^^^^^^^\n> 12 |     const item = items[index];\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 13 |     return {\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 14 |       key: item.key,\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 15 |     };\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 16 |   }, [index, items]);\n     | ^^^^^^^^^^^^^^^^^^^^^ CannotPreserveMemoization: React Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. This value was memoized in source but not in compilation output. (11:16)\n\nCannotPreserveMemoization: React Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. This dependency may be mutated later, which could cause the value to change unexpectedly (28:28)\n\nCannotPreserveMemoization: React Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. This value was memoized in source but not in compilation output. (19:27)\n  17 |\n  18 |   const setCurrentIndex = useCallback(\n  19 |     (index: number) => {\n```\n\n----------------------------------------\n\nTITLE: React Component Definition with Mutation\nDESCRIPTION: Defines a React component that accepts props 'a' and 'b', initializes local variables 'z' and 'y', and defines a function 'x' that mutates 'z' and calls 'mutate' on 'y.b'. The component returns an array containing 'y' and 'z'.  It's designed to test how mutation affects rendering and to be used with a fixture entrypoint.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-mutate.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {mutate} from 'shared-runtime';\n\nfunction Component({a, b}) {\n  let z = {a};\n  let y = {b: {b}};\n  let x = function () {\n    z.a = 2;\n    mutate(y.b);\n  };\n  x();\n  return [y, z];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{a: 2, b: 3}],\n  sequentialRenders: [\n    {a: 2, b: 3},\n    {a: 2, b: 3},\n    {a: 4, b: 3},\n    {a: 4, b: 5},\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Testing Callback Relaxation in React JavaScript\nDESCRIPTION: The snippet demonstrates a regression test for internal code in React, showcasing how the callback rule is designed to be more relaxed unless it's certain that the code is within a component or a hook. This utilizes inferred events and extends selector functionality with specific conditions to trigger a function call. Dependencies include the functions 'each', 'useExtendedSelector', 'extendedButton', and 'foo'. It requires pixel data for operation and doesn't apply the callback unless the conditions are satisfied.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-0592bd574811.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @compilationMode(infer)\n// Regression test for some internal code.\n// This shows how the \"callback rule\" is more relaxed,\n// and doesn't kick in unless we're confident we're in\n// a component or a hook.\nfunction makeListener(instance) {\n  each(pixelsWithInferredEvents, (pixel) => {\n    if (useExtendedSelector(pixel.id) && extendedButton) {\n      foo();\n    }\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: React Hook Final Implementation\nDESCRIPTION: Final implementation of the hook with destructured parameter handling. The code maintains the same functionality but uses explicit parameter destructuring in the hook function signature.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-literal-method-call-in-ternary-test.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport {\n  createHookWrapper,\n  identity,\n  CONST_STRING0,\n  CONST_STRING1,\n} from \"shared-runtime\";\n\nfunction useHook(t0) {\n  const { value } = t0;\n  return {\n    getValue() {\n      return identity(value);\n    },\n  }.getValue()\n    ? CONST_STRING0\n    : CONST_STRING1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: createHookWrapper(useHook),\n  params: [{ value: 0 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Starting the React DevTools Shell Test Harness\nDESCRIPTION: Commands to navigate to the react-devtools-shell package directory and start the test harness server. This should be run in parallel with the react-devtools-inline package for complete testing.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools-shell/README.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncd packages/react-devtools-shell\n\nyarn start\n```\n\n----------------------------------------\n\nTITLE: Defining a React Component with 'use' Directives\nDESCRIPTION: This snippet defines a simple React component named 'Component' that uses two 'use' directives and renders a div element. It also exports a FIXTURE_ENTRYPOINT object for testing purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/multi-directive.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component() {\n  'use foo';\n  'use bar';\n  return <div>\"foo\"</div>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  isComponent: true,\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with Undefined Return\nDESCRIPTION: A React functional component that conditionally returns undefined or props.value based on props.cond. Includes fixture configuration for testing.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/return-undefined.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  if (props.cond) {\n    return undefined;\n  }\n  return props.value;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Custom Hook\nDESCRIPTION: This code defines a React component `SomeName` that uses a custom hook `useSomeHook`. The component also demonstrates conditional rendering, returning `null` if `anyConditionCanEvenBeFalse` is true. The hook call is placed before the conditional return to ensure it's always called in the same order.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.bail.rules-of-hooks-6949b255e7eb.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @skip\n// Unsupported input\n\n// Valid because the neither the conditions before or after the hook affect the hook call\n// Failed prior to implementing BigInt because pathsFromStartToEnd and allPathsFromStartToEnd were too big and had rounding errors\nconst useSomeHook = () => {};\n\nconst SomeName = () => {\n  const filler = FILLER ?? FILLER ?? FILLER;\n  const filler2 = FILLER ?? FILLER ?? FILLER;\n  const filler3 = FILLER ?? FILLER ?? FILLER;\n  const filler4 = FILLER ?? FILLER ?? FILLER;\n  const filler5 = FILLER ?? FILLER ?? FILLER;\n  const filler6 = FILLER ?? FILLER ?? FILLER;\n  const filler7 = FILLER ?? FILLER ?? FILLER;\n  const filler8 = FILLER ?? FILLER ?? FILLER;\n\n  useSomeHook();\n\n  if (anyConditionCanEvenBeFalse) {\n    return null;\n  }\n\n  return (\n    <React.Fragment>\n      {FILLER ? FILLER : FILLER}\n      {FILLER ? FILLER : FILLER}\n      {FILLER ? FILLER : FILLER}\n      {FILLER ? FILLER : FILLER}\n      {FILLER ? FILLER : FILLER}\n      {FILLER ? FILLER : FILLER}\n      {FILLER ? FILLER : FILLER}\n      {FILLER ? FILLER : FILLER}\n      {FILLER ? FILLER : FILLER}\n      {FILLER ? FILLER : FILLER}\n      {FILLER ? FILLER : FILLER}\n      {FILLER ? FILLER : FILLER}\n      {FILLER ? FILLER : FILLER}\n      {FILLER ? FILLER : FILLER}\n      {FILLER ? FILLER : FILLER}\n      {FILLER ? FILLER : FILLER}\n      {FILLER ? FILLER : FILLER}\n      {FILLER ? FILLER : FILLER}\n      {FILLER ? FILLER : FILLER}\n      {FILLER ? FILLER : FILLER}\n      {FILLER ? FILLER : FILLER}\n      {FILLER ? FILLER : FILLER}\n      {FILLER ? FILLER : FILLER}\n      {FILLER ? FILLER : FILLER}\n      {FILLER ? FILLER : FILLER}\n      {FILLER ? FILLER : FILLER}\n      {FILLER ? FILLER : FILLER}\n      {FILLER ? FILLER : FILLER}\n      {FILLER ? FILLER : FILLER}\n      {FILLER ? FILLER : FILLER}\n      {FILLER ? FILLER : FILLER}\n      {FILLER ? FILLER : FILLER}\n      {FILLER ? FILLER : FILLER}\n      {FILLER ? FILLER : FILLER}\n      {FILLER ? FILLER : FILLER}\n      {FILLER ? FILLER : FILLER}\n      {FILLER ? FILLER : FILLER}\n      {FILLER ? FILLER : FILLER}\n      {FILLER ? FILLER : FILLER}\n      {FILLER ? FILLER : FILLER}\n      {FILLER ? FILLER : FILLER}\n      {FILLER ? FILLER : FILLER}\n    </React.Fragment>\n  );\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Hook with State Updates and Memoization\nDESCRIPTION: This code defines a React hook `useFoo` that manages state and returns a component and an onClick handler. It uses `useState` to manage the state and `useCallback` to memoize the `handleLogout` function, preventing unnecessary re-renders. The `getComponent` function returns a `ColumnItem` component that triggers the `handleLogout` function when pressed, with the hook ensuring memoization guarantees.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-setstate-captured-indirectly-jsx.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees\nfunction useFoo() {\n  const onClick = response => {\n    setState(DISABLED_FORM);\n  };\n\n  const [state, setState] = useState();\n  const handleLogout = useCallback(() => {\n    setState(DISABLED_FORM);\n  }, [setState]);\n  const getComponent = () => {\n    return <ColumnItem onPress={() => handleLogout()} />;\n  };\n\n  // this `getComponent` call should not be inferred as mutating setState\n  return [getComponent(), onClick]; // pass onClick to avoid dce\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a React Component with Invalid Ref Access - JavaScript\nDESCRIPTION: This snippet defines a functional React component that attempts to access the 'current' property of a ref during the render phase, which is against React's rules. It highlights an invalid operation that generates a specific error message when executed. Key parameters include 'props' which should contain a 'ref'. The expected output is an error message indicating that accessing 'current' during render is invalid.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-write-ref-prop-in-render.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validateRefAccessDuringRender @compilationMode(infer)\nfunction Component(props) {\n  const ref = props.ref;\n  ref.current = true;\n  return <div>{value}</div>;\n}\n\n```\n\n----------------------------------------\n\nTITLE: React Compiler Runtime Memoization Implementation\nDESCRIPTION: Advanced implementation showing React compiler's runtime memoization technique using _c function for tracking and conditionally updating function references\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/array-map-named-callback-cross-context.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction useFoo(t0) {\n  const $ = _c(13);\n  const { arr1, arr2 } = t0;\n  // Memoization logic with runtime tracking\n  let t1;\n  if ($[0] !== arr1[0]) {\n    t1 = (e) => arr1[0].value + e.value;\n    $[0] = arr1[0];\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  // Additional memoization and conditional re-computation\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Using Memoization in React Functional Component Rendering\nDESCRIPTION: This snippet showcases a more complex implementation of the Component which utilizes the memoization technique with React's compiler-runtime. It improves performance by reducing the number of times component content is recalculated and re-rendered by caching previous values.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-string-attribute-non-ascii.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = (\n      <Post\n        author=\"potetotes\"\n        text={\n          \"in addition to understanding JavaScript semantics and the rules of React, the compiler team also understands \\u0BA4\\u0BAE\\u0BBF\\u0BB4\\u0BCD, \\u4E2D\\u6587, \\u65E5\\u672C\\u8A9E, \\uD55C\\uAD6D\\uC5B4 and i think that\\u2019s pretty cool\"\n        }  \n      />\n    );\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nfunction Post(t0) {\n  const $ = _c(7);\n  const { author, text } = t0;\n  let t1;\n  if ($[0] !== author) {\n    t1 = <h1>{author}</h1>;\n    $[0] = author;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  let t2;\n  if ($[2] !== text) {\n    t2 = <span>{text}</span>;\n    $[2] = text;\n    $[3] = t2;\n  } else {\n    t2 = $[3];\n  }\n  let t3;\n  if ($[4] !== t1 || $[5] !== t2) {\n    t3 = (\n      <div>\n        {t1}\n        {t2}\n      </div>\n    );\n    $[4] = t1;\n    $[5] = t2;\n    $[6] = t3;\n  } else {\n    t3 = $[6];\n  }\n  return t3;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component Output\nDESCRIPTION: Compiled version of the component with runtime optimizations. Uses caching mechanism to prevent unnecessary object recreation when props.name hasn't changed.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-alias.flow.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== props.name) {\n    t0 = { name: props.name };\n    $[0] = props.name;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const user = t0;\n  return user;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ name: \"Mofei\" }],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Optimization Logic\nDESCRIPTION: Compiled version of the React component with added optimization logic. Includes memoization using compiler runtime and conditional rendering based on state changes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/module-scoped-bindings.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport React from \"react\";\nimport { useState } from \"react\";\n\nconst CONST = true;\n\nlet NON_REASSIGNED_LET = true;\n\nlet REASSIGNED_LET = false;\nREASSIGNED_LET = true;\n\nfunction reassignedFunction() {}\nreassignedFunction = true;\n\nfunction nonReassignedFunction() {}\n\nclass ReassignedClass {}\nReassignedClass = true;\n\nclass NonReassignedClass {}\n\nfunction Component() {\n  const $ = _c(2);\n  const [state] = useState(null);\n  let t0;\n  if ($[0] !== state) {\n    t0 = [\n      React,\n\n      state,\n      CONST,\n      NON_REASSIGNED_LET,\n      REASSIGNED_LET,\n      reassignedFunction,\n      nonReassignedFunction,\n      ReassignedClass,\n      NonReassignedClass,\n    ];\n    $[0] = state;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Component Logic in React JavaScript\nDESCRIPTION: This snippet implements a React component named 'Component'. It manages internal state through variables 'a' and 'b', ensuring that 'a' becomes reactive when 'b' changes. Key inputs include 'props.b', which is pushed into an array, and outputs are the internal states 'c' and 'a'. Dependencies include React's library functionalities.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactivity-analysis-interleaved-reactivity.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  // a and b are technically independent, but their mutation is interleaved\n  // so they are grouped in a single reactive scope. a does not have any\n  // reactive inputs, but b does. therefore, we have to treat a as reactive,\n  // since it will be recreated based on a reactive input.\n  const a = {};\n  const b = [];\n  b.push(props.b);\n  a.a = null;\n\n  // because a may recreate when b does, it becomes reactive. we have to recreate\n  // c if a changes.\n  const c = [a];\n\n  // Example usage that could fail if we didn't treat a as reactive:\n  //  const [c, a] = Component({b: ...});\n  //  assert(c[0] === a);\n  return [c, a];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining a React Component with JSX\nDESCRIPTION: This code defines a React component `Component` that receives an array `arr` as a prop and renders a list of `Bar` components, each containing two `Foo` components. The `useX` hook provides a value that's passed to each `Bar` component. This snippet showcases the initial component structure before any compilation or optimization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-outlining-dupe-key-dupe-component.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableJsxOutlining\nfunction Component({arr}) {\n  const x = useX();\n  return (\n    <>\n      {arr.map((i, id) => {\n        return (\n          <Bar key={id} x={x}>\n            <Foo k={i + 'i'}></Foo>\n            <Foo k={i + 'j'}></Foo>\n          </Bar>\n        );\n      })}\n    </>\n  ); \n}\nfunction Bar({x, children}) {\n  return (\n    <>\n      {x}\n      {children}\n    </>\n  ); \n}\n\nfunction Foo({k}) {\n  return k;\n}\n\nfunction useX() {\n  return 'x';\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{arr: ['foo', 'bar']}],\n};\n```\n\n----------------------------------------\n\nTITLE: Input React Component with Memo\nDESCRIPTION: Initial React component implementation using memo HOC and Stringify component. Includes fixture setup for testing.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/gating-use-before-decl.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @gating\nimport {memo} from 'react';\nimport {Stringify} from 'shared-runtime';\n\nexport default memo(Foo);\nfunction Foo({prop1, prop2}) {\n  'use memo';\n  return <Stringify prop1={prop1} prop2={prop2} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: eval('Foo'),\n  params: [{prop1: 1, prop2: 2}],\n};\n```\n\n----------------------------------------\n\nTITLE: React Compiler Error Logs\nDESCRIPTION: Compiler logs showing the detection of an invalid JSX element within a try statement, along with compilation statistics including memoization slots and blocks used. The error directs developers to use proper error boundaries instead.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/invalid-jsx-in-catch-in-outer-try-with-catch.expect.md#2025-04-21_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\"kind\":\"CompileError\",\"detail\":{\"options\":{\"reason\":\"Unexpected JSX element within a try statement. To catch errors in rendering a given component, wrap that component in an error boundary. (https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary)\",\"description\":null,\"severity\":\"InvalidReact\",\"loc\":{\"start\":{\"line\":11,\"column\":11,\"index\":214},\"end\":{\"line\":11,\"column\":32,\"index\":235},\"filename\":\"invalid-jsx-in-catch-in-outer-try-with-catch.ts\"}}}},\"fnLoc\":null}\n{\"kind\":\"CompileSuccess\",\"fnLoc\":{\"start\":{\"line\":4,\"column\":0,\"index\":83},\"end\":{\"line\":17,\"column\":1,\"index\":290},\"filename\":\"invalid-jsx-in-catch-in-outer-try-with-catch.ts\"},\"fnName\":\"Component\",\"memoSlots\":4,\"memoBlocks\":2,\"memoValues\":2,\"prunedMemoBlocks\":0,\"prunedMemoValues\":0}\n```\n\n----------------------------------------\n\nTITLE: Creating useFoo with Memoization - React - JavaScript\nDESCRIPTION: This snippet expands on the previous useFoo definition, utilizing a compiler runtime for memoization. It checks for a cache sentinel and returns either a cached value or calls a function to create and cache a new value. The snippet ultimately also returns a text element displaying '4'. It depends on 'react/compiler-runtime' and 'shared-runtime'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-memberexpr-tag-in-lambda.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport * as SharedRuntime from \"shared-runtime\";\nfunction useFoo() {\n  const $ = _c(1);\n\n  const callback = _temp;\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = callback();\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\nfunction _temp() {\n  return <SharedRuntime.Text value={4} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Conditional Component in React - JavaScript\nDESCRIPTION: This snippet defines a simple React component that checks a condition from props to determine its return value. It initializes a variable based on the condition and calls utility functions to enforce immutability on the output value. Key parameters include 'cond', which dictates the flow, and 'x', the output value when the condition is true.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hooks-freeze-possibly-mutable-arguments.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const cond = props.cond;\n  const x = props.x;\n  let a;\n  if (cond) {\n    a = x;\n  } else {\n    a = [];\n  }\n  useFreeze(a); // should freeze, value *may* be mutable\n  useFreeze(a); // should be readonly\n  call(a); // should be readonly\n  return a;\n}\n\nfunction useFreeze(x) {}\nfunction call(x) {}\n```\n\n----------------------------------------\n\nTITLE: Optimizing React Component with Compiler Runtime\nDESCRIPTION: This snippet shows an optimized version of the React component using React's compiler runtime. It implements memoization and caching techniques to improve rendering performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-dont-memoize-array-with-capturing-map-after-hook.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useEffect, useState } from \"react\";\nimport { mutate } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(5);\n  const x = [{ ...props.value }];\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = [];\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  useEffect(_temp, t0);\n  const onClick = () => {\n    console.log(x.length);\n  };\n\n  let y;\n\n  const t1 = x.map((item) => {\n    y = item;\n    return <span key={item.id}>{item.text}</span>;\n  });\n  const t2 = mutate(y);\n  let t3;\n  if ($[1] !== onClick || $[2] !== t1 || $[3] !== t2) {\n    t3 = (\n      <div onClick={onClick}>\n        {t1}\n        {t2}\n      </div>\n    );\n    $[1] = onClick;\n    $[2] = t1;\n    $[3] = t2;\n    $[4] = t3;\n  } else {\n    t3 = $[4];\n  }\n  return t3;\n}\nfunction _temp() {}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ value: { id: 0, text: \"Hello!\" } }],\n  isComponent: true,\n};\n```\n\n----------------------------------------\n\nTITLE: Defining React Component - JavaScript\nDESCRIPTION: This snippet defines a React functional component named 'Component'. It initializes a variable 'x', modifies its value based on a logical condition, and returns the final value. The component takes 'props' as an argument but does not currently use it.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unused-conditional.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let x = 0;\n  (x = 1) && (x = 2);\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing React Component with useState and useMemo - JavaScript\nDESCRIPTION: This snippet demonstrates the creation of a React component using hooks to manage local state and compute a memoized value based on that state. It uses useMemo to optimize the rendering process for potentially expensive calculations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/babel-existing-react-kitchensink-import.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as React from 'react';\nimport {useState, useMemo} from 'react';\n\nfunction Component(props) {\n  const [x] = useState(0);\n  const expensiveNumber = useMemo(() => calculateExpensiveNumber(x), [x]);\n\n  return <div>{expensiveNumber}</div>;\n}\n\nfunction Component2(props) {\n  const [x] = useState(0);\n  const expensiveNumber = useMemo(() => calculateExpensiveNumber(x), [x]);\n\n  return <div>{expensiveNumber}</div>;\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering React Component with Props\nDESCRIPTION: This React component receives `props` as an argument. It accesses the `post` property, then navigates through `feedback`, `comments`, and `edges` to potentially map over these edges using the `render` function. The optional chaining operator (`?.`) is used to avoid errors if any of the intermediate properties are null or undefined.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-dependencies-non-optional-properties-inside-optional-chain.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  return props.post.feedback.comments?.edges?.map(render);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a React Hook with Flow and Compilation Mode\nDESCRIPTION: This snippet defines a React hook called `useFoo` that takes a number as input (`bar`) and returns an array containing that number. It uses Flow for type checking and specifies the compilation mode as `infer`.  This seems to be the hook definition before any compilation or transformation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hook-declaration-basic.flow.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @flow @compilationMode(infer)\nexport default hook useFoo(bar: number) {\n  return [bar];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [42],\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Component Compiled Output\nDESCRIPTION: Compiled version of the component with React compiler runtime optimizations, implementing memoization using an internal state array and explicit value tracking.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/context-variable-reactive-implicit-control-flow.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { conditionalInvoke } from \"shared-runtime\";\n\n// same as context-variable-reactive-explicit-control-flow.js, but make\n// the control flow implicit\n\nfunction Component(t0) {\n  const $ = _c(2);\n  const { shouldReassign } = t0;\n  let x;\n  if ($[0] !== shouldReassign) {\n    x = null;\n    const reassign = () => {\n      x = 2;\n    };\n\n    conditionalInvoke(shouldReassign, reassign);\n    $[0] = shouldReassign;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ shouldReassign: true }],\n  sequentialRenders: [{ shouldReassign: false }, { shouldReassign: true }],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a Component with Reactivity in JavaScript\nDESCRIPTION: The snippet defines a JavaScript function `Component` that uses a `for` loop to assign different values to `x` based on `props.test`, a reactive property. The purpose is to demonstrate how reactivity can affect variable assignment based on control flow. The component returns an array with the value of `x`. The component relies on standard JavaScript and React-like behavior, with care needed around the 'reactive' context.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-for-test.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let x;\n  for (let i = 0; i < props.test; i++) {\n    if (i > 10) {\n      x = 10;\n    } else {\n      x = 1;\n    }\n  }\n  // The values assigned to `x` are non-reactive, but the value of `x`\n  // depends on the \"control\" variable `i`, whose value is capped by\n  // `props.test` which is reactive.\n  // Therefore x should be treated as reactive too.\n  return [x];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  sequentialRenders: [\n    {test: 12},\n    {test: 12},\n    {test: 1},\n    {test: 1},\n    {test: 12},\n    {test: 1},\n    {test: 12},\n    {test: 1},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with Nested Message Renderer\nDESCRIPTION: Demonstrates a React component that uses an arrow function to define a nested Message component which renders the message from component state. The component uses class fields syntax and arrow functions for method definitions.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/class-component-with-render-helper.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @compilationMode(infer)\nclass Component {\n  _renderMessage = () => {\n    const Message = () => {\n      const message = this.state.message;\n      return <div>{message}</div>;\n    };\n    return <Message />;\n  };\n\n  render() {\n    return this._renderMessage();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Composable React Custom Hook\nDESCRIPTION: Demonstrates how hooks can be nested and call other hooks, enabling complex hook interactions and logic reuse in React applications\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-23dc7fffde57.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Valid because hooks can call hooks.\\nfunction useHook() {\\n  return useHook1() + useHook2();\\n}\n```\n\n----------------------------------------\n\nTITLE: Original React Component with Destructuring\nDESCRIPTION: A React component that performs object and array destructuring on props, demonstrating the need for memoization of derived objects and arrays.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/escape-analysis-destructured-rest-element.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  // b is an object, must be memoized even though the input is not memoized\n  const {a, ...b} = props.a;\n  // d is an array, mut be memoized even though the input is not memoized\n  const [c, ...d] = props.c;\n  return <div b={b} d={d}></div>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Validating Component Calls in React\nDESCRIPTION: This JavaScript snippet defines a function `Component` which erroneously calls a capitalized function `SomeFunc()` without using JSX. The function demonstrates a common pattern in React where capitalized functions suggest components, leading to a validation error if not properly used. Dependencies include React's validation mechanisms. Inputs and outputs involve calling functions with appropriate notation, either as JSX components or standard functions. The highlighted limitation is that capitalized functions should only be used as components with JSX, else they trigger validation errors.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.capitalized-function-call.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validateNoCapitalizedCalls\nfunction Component() {\n  const x = SomeFunc();\n\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled Output of React Hook with Dependency Tracking (Code)\nDESCRIPTION: The compiled version of the custom hook showing how React's compiler transforms the code to track dependencies. It uses the _c utility from compiler-runtime to memoize the result based on tracked dependencies (cond and props.a.b) that appear in all code paths.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/cfg-nested-ifelse.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // props.a.b should be added as a unconditional dependency to the reactive\n// scope that produces x, since it is accessed unconditionally in all cfg\n// paths\n\nimport { getNull, identity } from \"shared-runtime\";\n\nfunction useCondDepInNestedIfElse(props, cond) {\n  const $ = _c(3);\n  let x;\n  if ($[0] !== cond || $[1] !== props.a.b) {\n    x = {};\n    if (identity(cond)) {\n      if (getNull()) {\n        x.a = props.a.b;\n      } else {\n        x.b = props.a.b;\n      }\n    } else {\n      if (identity(cond)) {\n        x.c = props.a.b;\n      } else {\n        x.d = props.a.b;\n      }\n    }\n    $[0] = cond;\n    $[1] = props.a.b;\n    $[2] = x;\n  } else {\n    x = $[2];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useCondDepInNestedIfElse,\n  params: [{ a: { b: 2 } }, true],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining MyApp Component - JavaScript\nDESCRIPTION: This snippet defines a functional React component, MyApp, which returns an input element with a pattern attribute. It serves as a fixture to demonstrate a bug in Babel's generator when dealing with escape sequences within JSX attributes. The component is exported alongside its entry point metadata.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-preserve-escape-character.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n/**\n * Fixture showing `@babel/generator` bug with jsx attribute strings containing\n * escape sequences. Note that this is only a problem when generating jsx\n * literals.\n *\n * When using the jsx transform to correctly lower jsx into\n * `React.createElement` calls, the escape sequences are preserved correctly\n * (see evaluator output).\n */\nfunction MyApp() {\n  return <input pattern=\"\\w\" />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: MyApp,\n  params: [],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Compiler Runtime\nDESCRIPTION: The React compiler-optimized version of the component that implements memoization based on props.foo. It uses React's compiler runtime to cache and reuse the object between renders when props haven't changed.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/constant-computed.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  let x;\n  if ($[0] !== props.foo) {\n    x = {};\n    x.foo = x.foo + x.bar;\n    x.foo(props.foo);\n    $[0] = props.foo;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Fire Usage - JavaScript\nDESCRIPTION: This snippet defines a React functional component that uses the fire function to log the 'bar' prop and executes fire with the results of functions called with 'bar' and 'baz'. It utilizes useEffect for side-effect management and requires React and its hooks.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/shared-hook-calls.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableFire\nimport {fire} from 'react';\n\nfunction Component({bar, baz}) {\n  const foo = () => {\n    console.log(bar);\n  };\n  useEffect(() => {\n    fire(foo(bar));\n    fire(baz(bar));\n  });\n\n  useEffect(() => {\n    fire(foo(bar));\n  });\n\n  return null;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Importing and Memoization of React Component - JavaScript\nDESCRIPTION: This snippet shows a React component utilizing memoization to cache rendered elements for performance improvement. The component checks a cache sentinel symbol and updates or returns a cached JSX element. It relies on a custom import from 'react/compiler-runtime'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-within-lambda.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(t0) {\n  const $ = _c(1);\n  const outer = _temp;\n  let t1;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = <div>{outer()}</div>;\n    $[0] = t1;\n  } else {\n    t1 = $[0];\n  }\n  return t1;\n}\nfunction _temp() {\n  const inner = () => x;\n  const x = 3;\n  return inner();\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Input React useMemo Implementation\nDESCRIPTION: Original React code showing a useMemo hook implementation with a constant string dependency. The function useFoo returns a memoized array containing a constant string.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useMemo-infer-scope-global.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees\n\nimport {useMemo} from 'react';\nimport {CONST_STRING0} from 'shared-runtime';\n\n// It's correct to infer a useMemo block has no reactive dependencies\nfunction useFoo() {\n  return useMemo(() => [CONST_STRING0], [CONST_STRING0]);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining useKeyedState Hook in React (JavaScript)\nDESCRIPTION: This snippet defines the 'useKeyedState' custom hook that receives a key and an initial state value to manage state in a functional component using React's hooks. It leverages 'useState' to hold the current state and 'useMemo' to update the state when the key or initial value changes. Note that the use of 'setState' within 'useMemo' may lead to an infinite loop, as indicated by the accompanying error.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-setState-in-useMemo.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction useKeyedState({key, init}) {\n  const [prevKey, setPrevKey] = useState(key);\n  const [state, setState] = useState(init);\n\n  useMemo(() => {\n    setPrevKey(key);\n    setState(init);\n  }, [key, init]);\n\n  return state;\n}\n```\n\n----------------------------------------\n\nTITLE: Compiler-Optimized React Component with Memoization\nDESCRIPTION: The compiler-optimized version of the Component that includes memoization logic using React's compiler runtime. It caches derived values and component outputs to prevent unnecessary recalculations when props haven't changed.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/global-types/repro-array-map-known-mutate-shape.expect.md#2025-04-22_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { Stringify, useIdentity } from \"shared-runtime\";\n\n/**\n * Also see repro-array-map-known-nonmutate-Boolean, which calls a global\n * function that does *not* mutate its operands.\n */\nfunction Component(t0) {\n  const $ = _c(7);\n  const { value } = t0;\n  const arr = [\n    new Set([[\"foo\", 2]]).values(),\n    new Set([[\"bar\", 4]]).values(),\n    [[\"baz\", value]],\n  ];\n\n  useIdentity(null);\n  const derived = arr.map(Object.fromEntries);\n  let t1;\n  if ($[0] !== derived) {\n    t1 = derived.at(0);\n    $[0] = derived;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  let t2;\n  if ($[2] !== derived) {\n    t2 = derived.at(-1);\n    $[2] = derived;\n    $[3] = t2;\n  } else {\n    t2 = $[3];\n  }\n  let t3;\n  if ($[4] !== t1 || $[5] !== t2) {\n    t3 = (\n      <Stringify>\n        {t1}\n        {t2}\n      </Stringify>\n    );\n    $[4] = t1;\n    $[5] = t2;\n    $[6] = t3;\n  } else {\n    t3 = $[6];\n  }\n  return t3;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ value: 5 }],\n  sequentialRenders: [{ value: 5 }, { value: 6 }, { value: 6 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Mutating Object Properties in Functional Component - React - JavaScript\nDESCRIPTION: This snippet demonstrates a React functional component that uses an immediately invoked function expression (IIFE) to mutate an object based on its parameters. The function accepts props 'a' and 'b', mutates them, and manages a returned object that encapsulates both mutated values. It showcases variable shadowing within a block scope and its effect on the outer scope.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-capture-ref-before-rename.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport {mutate} from 'shared-runtime';\n\nfunction Component({a, b}) {\n  let z = {a};\n  (function () {\n    mutate(z);\n  })();\n  let y = z;\n\n  {\n    // z is shadowed & renamed but the lambda is unaffected.\n    let z = {b};\n    y = {y, z};\n  }\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{a: 2, b: 3}],\n  sequentialRenders: [\n    {a: 2, b: 3},\n    {a: 2, b: 3},\n    {a: 2, b: 4},\n    {a: 3, b: 4},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Compiler-Runtime\nDESCRIPTION: This code shows the compiled version of the React component using `react/compiler-runtime`.  The compiler memoizes the Stringify component render.  The function `_temp` is equivalent to the function `x` in the previous snippet and also uses `mutate` from `shared-runtime` to modify the variable `z_0`.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-shadow-captured.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { mutate, Stringify } from \"shared-runtime\";\nfunction Component(t0) {\n  const $ = _c(1);\n\n  const x = _temp;\n  let t1;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = <Stringify fn={x} shouldInvokeFns={true} />;\n    $[0] = t1;\n  } else {\n    t1 = $[0];\n  }\n  return t1;\n}\nfunction _temp() {\n  let z_0;\n  mutate(z_0);\n  return z_0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ a: 1 }],\n  sequentialRenders: [{ a: 1 }, { a: 1 }, { a: 2 }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Fixture Entrypoint Export\nDESCRIPTION: Exports a fixture configuration object containing the component function, parameters, and component identifier for testing or compilation purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/prop-capturing-function-1.expect.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\"\n};\n```\n\n----------------------------------------\n\nTITLE: Compiler-Optimized React Hook Implementation\nDESCRIPTION: The React compiler-transformed version of the useMakeCallback hook with memoization optimizations. This optimized code uses the React compiler runtime to cache the callback function and returned object to prevent unnecessary re-renders and function recreations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/assume-invoked/conditional-call.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useState } from \"react\";\nimport { useIdentity } from \"shared-runtime\";\n\n/**\n * Assume that conditionally called functions can be invoked and that their\n * property loads are hoistable to the function declaration site.\n */\nfunction useMakeCallback(t0) {\n  const $ = _c(4);\n  const { obj } = t0;\n  const [state, setState] = useState(0);\n  let t1;\n  if ($[0] !== obj.value) {\n    t1 = () => {\n      if (obj.value !== 0) {\n        setState(obj.value);\n      }\n    };\n    $[0] = obj.value;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  const cb = t1;\n\n  useIdentity(null);\n  if (state === 0) {\n    cb();\n  }\n  let t2;\n  if ($[2] !== cb) {\n    t2 = { cb };\n    $[2] = cb;\n    $[3] = t2;\n  } else {\n    t2 = $[3];\n  }\n  return t2;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useMakeCallback,\n  params: [{ obj: { value: 1 } }],\n  sequentialRenders: [{ obj: { value: 1 } }, { obj: { value: 2 } }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Error: Invalid Ref Access During Render\nDESCRIPTION: This error message highlights the violation of accessing a ref's `current` property during the rendering phase. Specifically, the error points to the line where `renderItem` is called within the `map` function. This practice is discouraged in React because it can lead to unexpected side effects and make debugging difficult.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-aliased-ref-in-callback-invoked-during-render-.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n   7 |     return <Foo item={item} current={current} />;\n   8 |   };\n>  9 |   return <Items>{props.items.map(item => renderItem(item))}</Items>;\n     |                                  ^^^^^^^^^^^^^^^^^^^^^^^^ InvalidReact: Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef) (9:9)\n  10 | }\n  11 |\n\n```\n\n----------------------------------------\n\nTITLE: Defining Foo Component with Stringify - Enhanced Version\nDESCRIPTION: This snippet provides an enhanced version of the Foo component using the react/compiler-runtime's _c function to optimize rendering. It captures previous props in an array to prevent unnecessary renders. The same FIXTURE_ENTRYPOINT is retained for testing, showcasing sequential rendering scenarios.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/infer-function-cond-access-not-hoisted.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enablePropagateDepsInHIR\n\nimport { Stringify } from \"shared-runtime\";\n\nfunction Foo(t0) {\n  const $ = _c(3);\n  const { a, shouldReadA } = t0;\n  let t1;\n  if ($[0] !== a || $[1] !== shouldReadA) {\n    t1 = (\n      <Stringify\n        fn={() => {\n          if (shouldReadA) {\n            return a.b.c;\n          }\n          return null;\n        }}\n        shouldInvokeFns={true}\n      />\n    );\n    $[0] = a;\n    $[1] = shouldReadA;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{ a: null, shouldReadA: true }],\n  sequentialRenders: [\n    { a: null, shouldReadA: true },\n    { a: null, shouldReadA: false },\n    { a: { b: { c: 4 } }, shouldReadA: true },\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Memoization-Ready Structure\nDESCRIPTION: This snippet defines a React component that returns an object with a session_id. The component is structured to allow for easy memoization by the React compiler.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/merge-consecutive-scopes-no-deps.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst {getNumber} = require('shared-runtime');\n\nfunction Component(props) {\n  // Two scopes: one for `getNumber()`, one for the object literal.\n  // Neither has dependencies so they should merge\n  return {session_id: getNumber()};\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Function Implementation\nDESCRIPTION: Simple conditional function that creates and mutates an object based on a condition parameter. Uses early returns and mutation patterns common in React hooks.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/align-scope-starts-within-cond.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {mutate} from 'shared-runtime';\n\n/**\n * Similar fixture to `align-scopes-nested-block-structure`, but\n * a simpler case.\n */\nfunction useFoo(cond) {\n  let s = null;\n  if (cond) {\n    s = {};\n  } else {\n    return null;\n  }\n  mutate(s);\n  return s;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [true],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with Destructuring and Default Value\nDESCRIPTION: This snippet defines a React component that uses array destructuring with a default value. It extracts the first element of props.value, defaulting to 42 if undefined. The component returns this value.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-default-at-explicit-undefined.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  // destructure slot index has an explicit undefined in the input, should return default\n  const [x = 42] = props.value;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: [undefined]}],\n};\n```\n\n----------------------------------------\n\nTITLE: Tracking Overlapping Dependencies in React - JavaScript\nDESCRIPTION: This function tracks and returns overlapping property dependencies from nested objects passed as props. It modifies the behavior based on whether the current props have been previously tracked, providing optimized access to the nested properties.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/uncond-overlap-direct.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Test that we correctly track a subpath if the subpath itself is accessed as\n// a dependency\nfunction TestOverlappingTracked(props) {\n  let x = {};\n  x.b = props.a.b;\n  x.c = props.a.c;\n  x.a = props.a;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: TestOverlappingTracked,\n  params: [{a: {c: 2}}],\n};\n```\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // Test that we correctly track a subpath if the subpath itself is accessed as\n// a dependency\nfunction TestOverlappingTracked(props) {\n  const $ = _c(2);\n  let x;\n  if ($[0] !== props.a) {\n    x = {};\n    x.b = props.a.b;\n    x.c = props.a.c;\n    x.a = props.a;\n    $[0] = props.a;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: TestOverlappingTracked,\n  params: [{ a: { c: 2 } }],\n};\n```\n\n----------------------------------------\n\nTITLE: React Hook Error Message\nDESCRIPTION: Detailed error message explaining why the current implementation is invalid. The error highlights that variable reassignment is a side effect that breaks the pure function principles of React components and hooks.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-destructure-assignment-to-global.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n1 | function useFoo(props) {\n> 2 |   [x] = props;\n    |    ^ InvalidReact: Unexpected reassignment of a variable which was defined outside of the component. Components and hooks should be pure and side-effect free, but variable reassignment is a form of side-effect. If this variable is used in rendering, use useState instead. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#side-effects-must-run-outside-of-render) (2:2)\n3 |   return {x};\n4 | }\n```\n\n----------------------------------------\n\nTITLE: React Hook: Using a Hook Within Another Hook (JavaScript)\nDESCRIPTION: This code snippet demonstrates a valid React custom hook, `useHookWithHook`, which internally calls another hook, `useHook`.  This pattern is permitted and allows for the composition of hook logic. The assumption is that `useHook` is a previously defined hook in the same scope or imported from elsewhere.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-844a496db20b.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Valid because hooks can use hooks.\nfunction useHookWithHook() {\n  useHook();\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with Global State\nDESCRIPTION: This snippet defines a React component that uses useState and useEffect hooks to manage and synchronize with a global variable. It demonstrates how to update local state based on global changes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-global-reassignment-in-effect.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useEffect, useState} from 'react';\n\nlet someGlobal = false;\n\nfunction Component() {\n  const [state, setState] = useState(someGlobal);\n\n  useEffect(() => {\n    someGlobal = true;\n  }, []);\n\n  useEffect(() => {\n    setState(someGlobal);\n  }, [someGlobal]);\n\n  return <div>{String(state)}</div>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Transformed React Hook Test Code\nDESCRIPTION: Transformed/compiled version of the hook test fixture with parameter destructuring moved into the function body. Maintains the same core functionality of returning a constant string based on the evaluation of an object with a getValue method.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-literal-method-in-ternary-test.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport {\n  createHookWrapper,\n  CONST_STRING0,\n  CONST_STRING1,\n} from \"shared-runtime\";\n\nfunction useHook(t0) {\n  const { value } = t0;\n  return {\n    getValue() {\n      return identity(value);\n    },\n  }\n    ? CONST_STRING0\n    : CONST_STRING1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: createHookWrapper(useHook),\n  params: [{ value: 0 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Optimized React Component with Conditional State Handling - JavaScript\nDESCRIPTION: This code snippet defines an optimized version of the 'Component' which includes a mechanism to track previous state values and update the component's state only when necessary, thus potentially improving performance in rendering processes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-fun-alias-captured-mutate-2.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { mutate } from \"shared-runtime\";\n\nfunction Component(t0) {\n  const $ = _c(3);\n  const { foo, bar } = t0;\n  let x;\n  if ($[0] !== bar || $[1] !== foo) {\n    x = { foo };\n    const y = { bar };\n    const f0 = function () {\n      const a = { y };\n      const b = x;\n      a.x = b;\n    };\n\n    f0();\n    mutate(y);\n    $[0] = bar;\n    $[1] = foo;\n    $[2] = x;\n  } else {\n    x = $[2];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ foo: 2, bar: 3 }],\n  sequentialRenders: [\n    { foo: 2, bar: 3 },\n    { foo: 2, bar: 3 },\n    { foo: 2, bar: 4 },\n    { foo: 3, bar: 4 },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Set Operations with Memoization\nDESCRIPTION: Compiled version of the Set operations hook with React's memoization implementation. Shows how React internally handles caching of values and Set operations using compiler runtime utilities.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/global-types/set-constructor-arg.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nconst MODULE_LOCAL = new Set([4, 5, 6]);\nfunction useFoo(t0) {\n  const $ = _c(15);\n  const { propArr } = t0;\n  let t1;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = [1, 2, 3];\n    $[0] = t1;\n  } else {\n    t1 = $[0];\n  }\n  let s1;\n  if ($[1] !== propArr[0]) {\n    s1 = new Set(t1);\n    s1.add(propArr[0]);\n    $[1] = propArr[0];\n    $[2] = s1;\n  } else {\n    s1 = $[2];\n  }\n  let s2;\n  let s3;\n  if ($[3] !== propArr[1] || $[4] !== propArr[2]) {\n    s2 = new Set(MODULE_LOCAL.values());\n    s2.add(propArr[1]);\n\n    s3 = new Set(s2.values());\n    s3.add(propArr[2]);\n    $[3] = propArr[1];\n    $[4] = propArr[2];\n    $[5] = s2;\n    $[6] = s3;\n  } else {\n    s2 = $[5];\n    s3 = $[6];\n  }\n  let s4;\n  if ($[7] !== propArr[3] || $[8] !== s3) {\n    s4 = new Set(s3);\n    s4.add(propArr[3]);\n    $[7] = propArr[3];\n    $[8] = s3;\n    $[9] = s4;\n  } else {\n    s4 = $[9];\n  }\n  let t2;\n  if ($[10] !== s1 || $[11] !== s2 || $[12] !== s3 || $[13] !== s4) {\n    t2 = [s1, s2, s3, s4];\n    $[10] = s1;\n    $[11] = s2;\n    $[12] = s3;\n    $[13] = s4;\n    $[14] = t2;\n  } else {\n    t2 = $[14];\n  }\n  return t2;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ propArr: [7, 8, 9] }],\n  sequentialRenders: [{ propArr: [7, 8, 9] }, { propArr: [7, 8, 10] }],\n};\n```\n\n----------------------------------------\n\nTITLE: Initializing Inefficient Loop Function in JavaScript\nDESCRIPTION: This snippet defines a function 'foo' with an infinite loop and exports it as part of a FIXTURE_ENTRYPOINT object. The function initializes two variables and contains a while loop that never terminates.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/constant-propagation-while.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo() {\n  let x = 100;\n  let y = 0;\n  while (x < 10) {\n    y += 1;\n  }\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Aborting Request in React\nDESCRIPTION: Method to stop rendering and abandon incomplete work. Behavior differs based on request creation method - createRequest encodes errors in unfinished slots, while createPrerenderRequest omits unfinished content.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-server/README.md#2025-04-21_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nabort(request: Request): void\n```\n\n----------------------------------------\n\nTITLE: React Invalid Reassignment Error\nDESCRIPTION: This error message highlights the invalid reassignment of the `local` variable within the `reassignLocal` function.  It indicates that reassigning a variable after render has completed can lead to inconsistent behavior. The suggestion is to use state instead of local variables for values needing persistence across renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-reassign-local-variable-in-jsx-callback.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n  3 |\n  4 |   const reassignLocal = newValue => {\n> 5 |     local = newValue;\n    |     ^^^^^ InvalidReact: Reassigning a variable after render has completed can cause inconsistent behavior on subsequent renders. Consider using state instead. Variable `local` cannot be reassigned after render (5:5)\n  6 |   };\n  7 |\n  8 |   const onClick = newValue => {\n```\n\n----------------------------------------\n\nTITLE: Testing useState Hook in a Class Component - JavaScript\nDESCRIPTION: This snippet defines a class component that includes a method which calls the useState hook. The purpose is to demonstrate testing scenarios where the expectation is that the tests should fail, highlighting potential issues in the testing setup.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.invalid.invalid-rules-of-hooks-ddeca9708b63.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @skip\n// Passed but should have failed\n(class {\n  i() {\n    useState();\n  }\n});\n\n```\n\n----------------------------------------\n\nTITLE: Fixture Entrypoint Configuration\nDESCRIPTION: Defines a test fixture with function and predefined input parameters for testing and evaluation\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-alias-computed-load-3.expect.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nexport const FIXTURE_ENTRYPOINT = {\n  fn: bar,\n  params: [\n    [1, 2],\n    [2, 3],\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Reactivity Handling in React Component with Compiler Runtime\nDESCRIPTION: The snippet uses a compiler runtime function `_c` in JavaScript to support reactivity in the `Component` function. It checks and updates the state of `x` based on changing prop values, using an internal `$` array to track and react to state changes. The setup is similar to the previous snippet but includes reactivity checks and updates for enhanced performance and accuracy during renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-forin-collection.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  let x;\n  for (const key in props.values) {\n    const i = parseInt(key, 10);\n    if (i > 10) {\n      x = 10;\n    } else {\n      x = 1;\n    }\n  }\n  let t0;\n  if ($[0] !== x) {\n    t0 = [x];\n    $[0] = x;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  sequentialRenders: [\n    { values: { \"12\": true } },\n    { values: { \"12\": true } },\n    { values: { \"1\": true } },\n    { values: { \"1\": true } },\n    { values: { \"12\": true } },\n    { values: { \"1\": true } },\n    { values: { \"12\": true } },\n    { values: { \"1\": true } },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Incrementing Render Count without React Hooks - JavaScript\nDESCRIPTION: A React component is defined using a simple function that increments a global render count variable each time it renders. No hooks are used in the component. 'renderCount' is a global variable that tracks the render count for this component. It takes no inputs and returns a simple HTML 'div' element.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.mutate-global-increment-op-invalid-react.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nlet renderCount = 0;\n\nfunction NoHooks() {\n  renderCount++;\n  return <div />;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Runtime Optimizations\nDESCRIPTION: The compiled version of the React component that includes runtime optimizations and caching mechanism using the compiler runtime utilities. Implements the same functionality with performance improvements.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructure-default-array-with-unary.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  const [t0] = props.value;\n  let t1;\n  if ($[0] !== t0) {\n    t1 = t0 === undefined ? [-1, 1] : t0;\n    $[0] = t0;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  const x = t1;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ value: [] }],\n};\n```\n\n----------------------------------------\n\nTITLE: Initializing React DevTools Backend with Node.js and Socket.io\nDESCRIPTION: This snippet sets up a Node.js server with Socket.io to create a backend for React DevTools. It initializes the DevTools bridge and handles client connections and disconnections.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools-inline/README.md#2025-04-21_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nconst {\n  activate,\n  createBridge,\n  initialize,\n} = require('react-devtools-inline/backend');\nconst { createServer } = require('http');\nconst SocketIO = require('socket.io');\n\nconst server = createServer();\nconst socket = SocketIO(server, {\n  cors: {\n    origin: \"*\",\n    methods: [\"GET\", \"POST\"],\n    allowedHeaders: [],\n    credentials: true\n  }\n});\nsocket.on('connection', client => {\n  const wall = {\n    listen(listener) {\n      client.on('message', data => {\n        if (data.uid === UID) {\n          listener(data);\n        }\n      });\n    },\n    send(event, payload) {\n      const data = {event, payload, uid: UID};\n      client.emit('message', data);\n    },\n  };\n\n  const bridge = createBridge(global, wall);\n\n  client.on('disconnect', () => {\n    bridge.shutdown();\n  });\n\n  activate(global, { bridge });\n});\nsocket.listen(PORT);\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: This snippet shows the compiled version of the `Component` function, which includes memoization using the `_c` helper from the `react/compiler-runtime`. The code checks if the value of `props.a?.b.c.d` has changed since the last render. If the value has changed, it calls `foo` and updates the memoized value. This prevents unnecessary re-computation of the `foo` function.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/nested-optional-member-expr.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // We should codegen nested optional properties correctly\n// (i.e. placing `?` in the correct PropertyLoad)\nfunction Component(props) {\n  const $ = _c(2);\n  const t0 = props.a?.b.c.d;\n  let t1;\n  if ($[0] !== t0) {\n    t1 = foo(t0);\n    $[0] = t0;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  const x = t1;\n  return x;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Generated React Component with Optimization\nDESCRIPTION: This JavaScript code represents the compiled version of the `Component` using `react/compiler-runtime`. It caches previous prop values and compares them with current ones, updating only when they differ.  It uses `_c(3)` to create a cache array with a size of 3. The component aims to minimize re-renders by only updating the returned array if the props have changed.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/option-enable-change-variable-codegen.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enableChangeVariableCodegen\nfunction Component(props) {\n  const $ = _c(3);\n  const c_00 = $[0] !== props.a;\n  const c_1 = $[1] !== props.b.c;\n  let t0;\n  if (c_00 || c_1) {\n    t0 = [props.a, props.b.c];\n    $[0] = props.a;\n    $[1] = props.b.c;\n    $[2] = t0;\n  } else {\n    t0 = $[2];\n  }\n  const c_0 = t0;\n  return c_0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ a: 3.14, b: { c: true } }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Component Definition with Multiplication Assignment\nDESCRIPTION: This code defines a React functional component named `foo`. The component takes `props` as input, initializes a variable `x` to 0, and enters a while loop that continues as long as `x` is greater than `props.min` and less than `props.max`. Inside the loop, `x` is multiplied by 2 and assigned back to x. Finally, the component returns the final value of `x`.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/while-logical.expect.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(props) {\n  let x = 0;\n  while (x > props.min && x < props.max) {\n    x = x * 2;\n  }\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Initial React Component Implementation\nDESCRIPTION: A React component using hooks for state management, event listening, and dispatching actions with conditional rendering\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useEffect-nested-lambdas.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableTransitivelyFreezeFunctionExpressions:false\n\nfunction Component(props) {\n  const item = useMutable(props.itemId);\n  const dispatch = useDispatch();\n  useFreeze(dispatch);\n\n  const exit = useCallback(() => {\n    dispatch(createExitAction());\n  }, [dispatch]);\n\n  useEffect(() => {\n    const cleanup = GlobalEventEmitter.addListener('onInput', () => {\n      if (item.value) {\n        exit();\n      }\n    });\n    return () => cleanup.remove();\n  }, [exit, item]);\n\n  maybeMutate(item);\n\n  return <div />;\n}\n```\n\n----------------------------------------\n\nTITLE: Setting up and running React View Transition test in development mode\nDESCRIPTION: Commands to build React locally, install dependencies, and start a development server with hot reloading for testing View Transitions.\nSOURCE: https://github.com/facebook/react/blob/main/fixtures/view-transition/README.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncd fixtures/view-transition\nyarn\nyarn start\n```\n\n----------------------------------------\n\nTITLE: Defining a Functional Component in React\nDESCRIPTION: This snippet defines a functional component 'Component' that takes an array as a prop and uses a custom hook 'useX'. It maps through the array to render child components 'Bar', 'Baz', 'Joe', and 'Foo' while passing the necessary props.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-outlining-separate-nested.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableJsxOutlining\nfunction Component({arr}) {\n  const x = useX();\n  return (\n    <>\n      {arr.map((i, id) => {\n        return (\n          <Bar key={id} x={x}>\n            <Baz i={i}></Baz>\n            <Joe j={i}></Joe>\n            <Foo k={i}></Foo>\n          </Bar>\n        );\n      })}\n    </>\n  );\n}\nfunction Bar({x, children}) {\n  return (\n    <>\n      {x}\n      {children}\n    </>\n  );\n}\n\nfunction Baz({i}) {\n  return i;\n}\n\nfunction Joe({j}) {\n  return j;\n}\n\nfunction Foo({k}) {\n  return k;\n}\n\nfunction useX() {\n  return 'x';\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{arr: ['foo', 'bar']}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: This snippet shows the compiled version of the React component, utilizing 'react/compiler-runtime' for memoization and optimization. It takes props 'a' and 'b', checks if they have changed since the last render using the compiler's cache ('_c'), and re-executes the component logic only if there are changes. The compiled component effectively caches the result based on input props.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-mutate.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { mutate } from \"shared-runtime\";\n\nfunction Component(t0) {\n  const $ = _c(3);\n  const { a, b } = t0;\n  let t1;\n  if ($[0] !== a || $[1] !== b) {\n    const z = { a };\n    const y = { b: { b } };\n    const x = function () {\n      z.a = 2;\n      mutate(y.b);\n    };\n\n    x();\n    t1 = [y, z];\n    $[0] = a;\n    $[1] = b;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ a: 2, b: 3 }],\n  sequentialRenders: [\n    { a: 2, b: 3 },\n    { a: 2, b: 3 },\n    { a: 4, b: 3 },\n    { a: 4, b: 5 },\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Original JavaScript Function\nDESCRIPTION: This is the original JavaScript function `foo` that takes an argument `a`. It initializes an empty object `b`, aliases it to `x`, conditionally creates objects `y` or `z` based on `a`, and assigns them as properties of `x`. Finally, it calls `mutate(b)` and returns `x`.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-property-alias-alias-mutate-if.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(a) {\\n  const b = {};\\n  const x = b;\\n  if (a) {\\n    let y = {};\\n    x.y = y;\\n  } else {\\n    let z = {};\\n    x.z = z;\\n  }\\n  mutate(b); // aliases x, y & z\\n  return x;\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Defining Original React Component with Memoization\nDESCRIPTION: This snippet defines a React component with a memoized callback function. It uses the 'mutate' function from 'shared-runtime' and renders a 'Foo' component with the memoized callback.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/maybe-mutate-object-in-callback.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst {mutate} = require('shared-runtime');\n\nfunction Component(props) {\n  const object = {};\n  // We optimistically assume function calls within callbacks don't mutate (unless the function\n  // is known to be called during render), so this should get memoized\n  const onClick = () => {\n    mutate(object);\n  };\n  return <Foo callback={onClick}>{props.children}</Foo>;\n}\n\nfunction Foo({children}) {\n  return children;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{children: <div>Hello</div>}],\n};\n```\n\n----------------------------------------\n\nTITLE: Using useRef and useEffect in React Component\nDESCRIPTION: This snippet illustrates the use of React's useRef and useEffect hooks to manipulate a ref and state within a functional component. It forces a re-render to ensure the useEffect executes as expected. Dependencies include React and usage of hooks from React library. Inputs include initial component parameters, and it outputs the rendered component with potential ref updates visible in the child component. The primary constraint is violating React's rules by accessing a ref in a child component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-ref-access-in-unused-callback-nested.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validateRefAccessDuringRender\nimport {useEffect, useRef, useState} from 'react';\n\nfunction Component() {\n  const ref = useRef(null);\n  const [state, setState] = useState(false);\n  useEffect(() => {\n    const callback = () => {\n      ref.current = 'Ok';\n    };\n  }, []);\n\n  useEffect(() => {\n    setState(true);\n  }, []);\n\n  // We use state to force a re-render and observe whether the\n  // ref updated. This lets us check that the effect actually ran\n  // and wasn't DCE'd\n  return <Child key={String(state)} ref={ref} />;\n}\n\nfunction Child({ref}) {\n  // This violates the rules of React, so we access the ref in a child\n  // component\n  return ref.current;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Optimizing React Component with Compiler-Runtime\nDESCRIPTION: This snippet shows an optimized version of the component using React's compiler-runtime. It implements memoization for the outer 'x' variable and maintains proper scoping for the inner 'x' variable.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/lambda-mutate-shadowed-object.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = {};\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const x = t0;\n\n  const x_0 = [];\n  const fn = function () {\n    mutate(x_0);\n  };\n\n  fn();\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Compiler-Optimized React Component\nDESCRIPTION: The compiler-transformed version of the React component with memoization optimizations. Uses array-based caching to prevent unnecessary recalculations and re-renders of values and components.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useContext-read-context-in-callback-if-condition.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { createContext, useContext } from \"react\";\nimport { Stringify } from \"shared-runtime\";\n\nconst FooContext = createContext({ current: true });\n\nfunction Component(props) {\n  const $ = _c(6);\n  const foo = useContext(FooContext);\n  let t0;\n  if ($[0] !== foo.current) {\n    t0 = () => {\n      if (foo.current) {\n        return {};\n      } else {\n        return null;\n      }\n    };\n    $[0] = foo.current;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const getValue = t0;\n  let t1;\n  if ($[2] !== getValue) {\n    t1 = getValue();\n    $[2] = getValue;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  const value = t1;\n  let t2;\n  if ($[4] !== value) {\n    t2 = <Stringify value={value} />;\n    $[4] = value;\n    $[5] = t2;\n  } else {\n    t2 = $[5];\n  }\n  return t2;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React useFoo Function and Fixture\nDESCRIPTION: This code represents the compiled version of the `useFoo` function using `react/compiler-runtime`. It introduces memoization using `_c` to optimize re-renders based on changes to `cond` and `input`.  The `FIXTURE_ENTRYPOINT` remains the same, providing the test scenarios.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-unpoisoned/else-branch-scope-unpoisoned.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { identity } from \"shared-runtime\";\n\nfunction useFoo(t0) {\n  const $ = _c(5);\n  const { input, cond } = t0;\n  let x;\n  if ($[0] !== cond || $[1] !== input) {\n    x = [];\n    bb0: if (cond) {\n      break bb0;\n    } else {\n      let t1;\n      if ($[3] !== input.a.b) {\n        t1 = identity(input.a.b);\n        $[3] = input.a.b;\n        $[4] = t1;\n      } else {\n        t1 = $[4];\n      }\n      x.push(t1);\n    }\n    $[0] = cond;\n    $[1] = input;\n    $[2] = x;\n  } else {\n    x = $[2];\n  }\n  return x[0];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ input: { a: { b: 2 } }, cond: false }],\n  sequentialRenders: [\n    { input: null, cond: true },\n    { input: { a: { b: 2 } }, cond: false },\n    { input: null, cond: true },\n    // preserve nullthrows\n    { input: {}, cond: false },\n    { input: { a: { b: null } }, cond: false },\n    { input: { a: null }, cond: false },\n    { input: { a: { b: 3 } }, cond: false },\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Component with useRef Implementation\nDESCRIPTION: A React component that demonstrates useRef hook usage, including a potential hooks rule violation by mutating ref.current directly. The code includes helper functions and a fixture export for testing purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/use-no-forget-multiple-with-eslint-suppression.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useRef} from 'react';\n\nconst useControllableState = options => {};\nfunction NoopComponent() {}\n\nfunction Component() {\n  'use no forget';\n  const ref = useRef(null);\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  ref.current = 'bad';\n  return <button ref={ref} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n};\n```\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useRef } from \"react\";\n\nconst useControllableState = (options) => {};\nfunction NoopComponent() {}\n\nfunction Component() {\n  \"use no forget\";\n  const ref = useRef(null);\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  ref.current = \"bad\";\n  return <button ref={ref} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with Optional Function Call (Input)\nDESCRIPTION: This React component demonstrates calling an optional function (`x`) with arguments derived from props and the result of other function calls (`foo`, `bar`). The optional chaining operator (`?.`) ensures that the function is only called if it exists.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-call.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const x = makeOptionalFunction(props);\n  const y = makeObject(props);\n  const z = x?.(y.a, props.a, foo(y.b), bar(props.b));\n  return z;\n}\n```\n\n----------------------------------------\n\nTITLE: React Component Definition with useCallback\nDESCRIPTION: This snippet defines a React component that utilizes `useCallback` to memoize a function that calculates the sum of `propA.x` and `propB.x.y`. The `useCallback` hook ensures that the function is only re-created when either `propA.x` or `propB.x.y` changes, optimizing performance by preventing unnecessary re-renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useCallback-alias-property-load-dep.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees\nimport {useCallback} from 'react';\nimport {sum} from 'shared-runtime';\n\nfunction Component({propA, propB}) {\n  const x = propB.x.y;\n  return useCallback(() => {\n    return sum(propA.x, x);\n  }, [propA.x, x]);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{propA: {x: 2}, propB: {x: {y: 3}}}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining Component with Optional Chaining in React JavaScript\nDESCRIPTION: This snippet defines a React component in JavaScript that leverages optional chaining to safely access deeply nested properties in props. No external dependencies are required, and it returns an object with properties x and y that may be undefined if the optional chains do not resolve.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-member-expression-chain.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Note that `a?.b.c` is semantically different from `(a?.b).c`\n// We should codegen the correct member expressions\nfunction Component(props) {\n  let x = props?.b.c;\n  let y = props?.b.c.d?.e.f.g?.h;\n  return {x, y};\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Memoization\nDESCRIPTION: This snippet shows the compiler-optimized version of the Component. It uses memoization to cache results and avoid unnecessary re-computations. The optimization includes checks for changed props and caching of intermediate results.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-hoisting-variable-collision.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(4);\n  let t0;\n  if ($[0] !== props.items) {\n    t0 = props.items.map(_temp);\n    $[0] = props.items;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const items = t0;\n  let t1;\n  if ($[2] !== items) {\n    t1 = [42, items];\n    $[2] = items;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  return t1;\n}\nfunction _temp(x) {\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ items: [0, 42, null, undefined, { object: true }] }],\n};\n```\n\n----------------------------------------\n\nTITLE: Error Message for Invalid Component Naming in JavaScript\nDESCRIPTION: This error message describes the constraints and intended usage of component names in React. It specifies that capitalized function names are reserved for components and must be rendered with JSX. The message guides users on how to rename their functions or allowlist them in the compiler config if they are not components.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.capitalized-method-call.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n  1 | // @validateNoCapitalizedCalls\n  2 | function Component() {\n> 3 |   const x = someGlobal.SomeFunc();\n    |             ^^^^^^^^^^^^^^^^^^^^^ InvalidReact: Capitalized functions are reserved for components, which must be invoked with JSX. If this is a component, render it with JSX. Otherwise, ensure that it has no hook calls and rename it to begin with a lowercase letter. Alternatively, if you know for a fact that this function is not a component, you can allowlist it via the compiler config. SomeFunc may be a component. (3:3)\n  4 |\n  5 |   return x;\n  6 | }\n\n```\n\n----------------------------------------\n\nTITLE: Extracting Error Codes with Node.js Script\nDESCRIPTION: Node.js script that traverses React codebase and updates error codes JSON file. Requires build artifacts and supports partial builds.\nSOURCE: https://github.com/facebook/react/blob/main/scripts/error-codes/README.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// extract-errors.js\nconst traverseCodebase = () => {\n  // Crawl build artifacts\n  // Update codes.json\n}\n```\n\n----------------------------------------\n\nTITLE: React Component with Memoization - Source Code\nDESCRIPTION: Original React component implementation using useMemo hook to memoize values based on props 'a' and 'b'. Includes validation components to verify memoization behavior.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-provider-log-default-import.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useMemo} from 'react';\nimport {ValidateMemoization} from 'shared-runtime';\nimport typedLog from 'shared-runtime';\n\nexport function Component({a, b}) {\n  const item1 = useMemo(() => ({a}), [a]);\n  const item2 = useMemo(() => ({b}), [b]);\n  typedLog(item1, item2);\n\n  return (\n    <>\n      <ValidateMemoization inputs={[a]} output={item1} />\n      <ValidateMemoization inputs={[b]} output={item2} />\n    </>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{a: 0, b: 0}],\n  sequentialRenders: [\n    {a: 0, b: 0},\n    {a: 1, b: 0},\n    {a: 1, b: 1},\n    {a: 1, b: 2},\n    {a: 2, b: 2},\n    {a: 3, b: 2},\n    {a: 0, b: 0},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled Version of useMakeCallback Hook with React Compiler Runtime\nDESCRIPTION: The optimized version of the useMakeCallback hook after processing by React's compiler runtime. It replaces useMemo with an explicit caching mechanism using the _c utility for storing and retrieving cached values based on dependencies.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/assume-invoked/use-memo-returned.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useState, useMemo } from \"react\";\nimport { useIdentity } from \"shared-runtime\";\n\n/**\n * Assume that conditionally called functions can be invoked and that their\n * property loads are hoistable to the function declaration site.\n */\nfunction useMakeCallback(t0) {\n  const $ = _c(2);\n  const { obj, shouldSynchronizeState } = t0;\n\n  const [, setState] = useState(0);\n  let t1;\n  let t2;\n  if ($[0] !== obj.value) {\n    t2 = () => {\n      if (obj.value !== 0) {\n        setState(obj.value);\n      }\n    };\n    $[0] = obj.value;\n    $[1] = t2;\n  } else {\n    t2 = $[1];\n  }\n  t1 = t2;\n  const cb = t1;\n\n  useIdentity(null);\n  return cb;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useMakeCallback,\n  params: [{ obj: { value: 1 } }],\n  sequentialRenders: [{ obj: { value: 1 } }, { obj: { value: 2 } }],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with useFire hook\nDESCRIPTION: This code defines a React component that uses the 'useFire' hook to execute a function 'foo' on every render. The 'foo' function logs the value of the 'prop1' prop. The useEffect hook is used to call 't1' (which is the fired function) with 'prop1'. Also, the prop1.value is being incremented on every render.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/bailout-retry/bailout-validate-prop-write.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useFire } from \"react/compiler-runtime\"; // @enableFire @panicThreshold(none)\nimport { fire } from \"react\";\n\nfunction Component(t0) {\n  const { prop1 } = t0;\n  const foo = () => {\n    console.log(prop1);\n  };\n  const t1 = useFire(foo);\n\n  useEffect(() => {\n    t1(prop1);\n  });\n  prop1.value = prop1.value + 1;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Rendering FBT Content in React Component\nDESCRIPTION: This snippet shows a React functional component that uses the FBT library for internationalization. It requires the 'fbt' module and renders an FBT element with a description and text content.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/error.todo-locally-require-fbt.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const fbt = require('fbt');\n\n  return <fbt desc=\"Description\">{'Text'}</fbt>;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Conditional Rendering in JavaScript\nDESCRIPTION: This snippet defines a React component 'Foo' that uses conditional rendering based on a 'cond' prop. It also includes a fixture for testing sequential renders with different conditions.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/nested-scopes-begin-same-instr-valueblock.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {identity, mutate} from 'shared-runtime';\n\nfunction Foo({cond}) {\n  const x = identity(identity(cond)) ? {a: 2} : {b: 2};\n\n  mutate(x);\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{cond: false}],\n  sequentialRenders: [{cond: false}, {cond: false}, {cond: true}, {cond: true}],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimizing React Component with Memoization\nDESCRIPTION: This snippet shows an optimized version of the 'Foo' component using memoization. It prevents unnecessary re-renders by caching the result when the input 'userIds' hasn't changed. The FIXTURE_ENTRYPOINT remains the same for testing.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-backedge-reference-effect.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { Stringify } from \"shared-runtime\";\n\nfunction Foo(t0) {\n  const $ = _c(2);\n  const { userIds } = t0;\n  let t1;\n  if ($[0] !== userIds) {\n    t1 = (\n      <Stringify\n        fn={() => {\n          const arr = [];\n          for (const selectedUser of userIds) {\n            arr.push(selectedUser);\n          }\n          return arr;\n        }}\n        shouldInvokeFns={true}\n      />\n    );\n    $[0] = userIds;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{ userIds: [1, 2, 3] }],\n  sequentialRenders: [{ userIds: [1, 2, 4] }],\n};\n```\n\n----------------------------------------\n\nTITLE: React Hook inside Loop (Valid)\nDESCRIPTION: This JavaScript snippet shows a valid example of using `React.useLayoutEffect` inside a `for` loop. The loop's condition ensures that the number of hook calls remains consistent across renders, avoiding issues with hook ordering. The additionalCond variable allows for conditional loop execution.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-93dc5d5e538a.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Valid because the loop doesn't change the order of hooks calls.\nfunction RegressionTest() {\n  const res = [];\n  const additionalCond = true;\n  for (let i = 0; i !== 10 && additionalCond; ++i) {\n    res.push(i);\n  }\n  React.useLayoutEffect(() => {});\n}\n\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: Source code for a React component that demonstrates prop destructuring, renaming, and the identity function. Uses ES6 destructuring syntax and exports a test fixture.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-same-property-identifier-names.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {identity} from 'shared-runtime';\n\nfunction Component(props) {\n  const {\n    x: {destructured},\n    sameName: renamed,\n  } = props;\n  const sameName = identity(destructured);\n\n  return [sameName, renamed];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{x: {destructured: 0}, sameName: 2}],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component Definition with SharedRuntime\nDESCRIPTION: This code defines a React component `useFoo` that conditionally renders a `SharedRuntime.Text` component based on the `cond` prop.  It imports `SharedRuntime` and utilizes it within the component's logic. The `FIXTURE_ENTRYPOINT` object defines the component's entry point with predefined parameters for testing.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-local-memberexpr-tag-conditional.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as SharedRuntime from 'shared-runtime';\nfunction useFoo({cond}) {\n  const MyLocal = SharedRuntime;\n  if (cond) {\n    return <MyLocal.Text value={4} />;\n  } else {\n    return null;\n  }\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{cond: true}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Implementing HomeDiscoStoreItemTileRating Component in React\nDESCRIPTION: This snippet shows the original implementation of a React component that calculates and displays a rating count based on aggregated data. It uses the useFragment hook and iterates over an array to compute the total count.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-scope-missing-mutable-range.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction HomeDiscoStoreItemTileRating(props) {\n  const item = useFragment();\n  let count = 0;\n  const aggregates = item?.aggregates || [];\n  aggregates.forEach(aggregate => {\n    count += aggregate.count || 0;\n  });\n\n  return <Text>{count}</Text>;\n}\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Memoization\nDESCRIPTION: This snippet demonstrates the optimized version of the component using React's compiler runtime for memoization. It caches the result of the computation to avoid unnecessary recalculations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/do-while-simple.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component() {\n  const $ = _c(1);\n  let ret;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const x = [1, 2, 3];\n    ret = [];\n    do {\n      const item = x.pop();\n      ret.push(item * 2);\n    } while (x.length);\n    $[0] = ret;\n  } else {\n    ret = $[0];\n  }\n  return ret;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Enhanced React Component with Compiler Runtime - JavaScript\nDESCRIPTION: This snippet showcases an enhanced version of the React component that integrates React's compiler runtime. It optimizes the item handling by leveraging internal state comparisons to minimize re-calculations. The conditionally generated items are either initialized or fetched from a cached state based on prop changes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/iife-return-modified-later-phi.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enablePropagateDepsInHIR\nfunction Component(props) {\n  const $ = _c(3);\n  let items;\n  if ($[0] !== props.a || $[1] !== props.cond) {\n    let t0;\n    if (props.cond) {\n      t0 = [];\n    } else {\n      t0 = null;\n    }\n    items = t0;\n\n    items?.push(props.a);\n    $[0] = props.a;\n    $[1] = props.cond;\n    $[2] = items;\n  } else {\n    items = $[2];\n  }\n  return items;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ a: {} }],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with useMemo\nDESCRIPTION: This React component uses `useMemo` to memoize the creation of an array based on the component's props.  The array is conditionally populated with `props.a` and `props.b` based on `props.cond` and `props.cond2`. The component returns the memoized array.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-multiple-if-else.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useMemo} from 'react';\n\nfunction Component(props) {\n  const x = useMemo(() => {\n    let y = [];\n    if (props.cond) {\n      y.push(props.a);\n    }\n    if (props.cond2) {\n      return y;\n    }\n    y.push(props.b);\n    return y;\n  });\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{a: 1, b: 2, cond2: false}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component\nDESCRIPTION: This code presents the compiled version of the `Component` function using `react/compiler-runtime`. It imports `_c` from the runtime, which is used for memoization. The component now uses `_c(4)` to create a memoized scope (`$`) and checks if the input `c`, calculated `h` and `i` have changed. If they have, it updates the memoized result; otherwise, it returns the cached result, improving performance by avoiding unnecessary recalculations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/update-expression-on-function-parameter-3.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(t0) {\n  const $ = _c(4);\n  let { c } = t0;\n  const h = c++;\n  const i = --c;\n  let t1;\n  if ($[0] !== c || $[1] !== h || $[2] !== i) {\n    t1 = [c, h, i];\n    $[0] = c;\n    $[1] = h;\n    $[2] = i;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ c: 4 }],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing a Counter Function with Direct Assignment in JavaScript\nDESCRIPTION: Defines a function 'foo' that initializes a variable to 1, increments it 10 times using direct assignment (x = x + 1), and returns the final value. The function is exported as part of a fixture entrypoint configuration.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-for.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo() {\n  let x = 1;\n  for (let i = 0; i < 10; i++) {\n    x = x + 1;\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Conditional Hook Call in React Component (JavaScript)\nDESCRIPTION: This code shows a React component `Component` that conditionally calls the `useArray` hook based on the `props.cond` value. This violates the Rules of Hooks, as hooks must be called in the same order on every render. The `useArray` hook is imported as `makeArray` from the `other` module.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-conditional-call-non-hook-imported-as-hook.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {makeArray as useArray} from 'other';\n\nfunction Component(props) {\n  let data;\n  if (props.cond) {\n    data = useArray();\n  }\n  return data;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining ComponentA with Greeting Message in JavaScript\nDESCRIPTION: The function 'componentA' takes 'props' as an argument and constructs a greeting message using template literals. It appends an empty string to demonstrate string operations. The function returns the constructed message string. No external dependencies are required, and it expects 'props' to have 'a' and 'b' properties, which are used in the message.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/template-literal.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction componentA(props) {\n  let t = `hello ${props.a}, ${props.b}!`;\n  t += ``;\n  return t;\n}\n\n```\n\nLANGUAGE: javascript\nCODE:\n```\nfunction componentA(props) {\n  let t = `hello ${props.a}, ${props.b}!`;\n  t = t + ``;\n  return t;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Initializing React Component with Memoized Helper\nDESCRIPTION: Example of using useMemo hook with an incorrect implementation that triggers a React validation error. The snippet demonstrates an improper memoization pattern where the first argument is not an inline function expression.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.validate-useMemo-named-function.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const x = useMemo(someHelper, []);\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Compiler Runtime\nDESCRIPTION: This code represents the compiled and optimized version of the `PrimitiveAsDep` component, utilizing React's compiler runtime. The `_c` function manages memoization, checking if `props.b + 1` has changed. If it has, `foo(props.b + 1)` is recomputed, and the result is stored; otherwise, the cached result is used. The optimized component efficiently handles the primitive dependency.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/primitive-as-dep.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // props.b + 1 is an non-allocating expression, which means Forget can\n// emit it trivially and repeatedly (e.g. no need to memoize props.b + 1\n// separately from props.b)\n// Correctness:\n//   y depends on either props.b or props.b + 1\nfunction PrimitiveAsDep(props) {\n  const $ = _c(2);\n  const t0 = props.b + 1;\n  let t1;\n  if ($[0] !== t0) {\n    t1 = foo(t0);\n    $[0] = t0;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  const y = t1;\n  return y;\n}\n\n```\n\n----------------------------------------\n\nTITLE: React Compiler Runtime Memoized Function\nDESCRIPTION: Optimized version using React compiler runtime to cache and retrieve computed values, implementing memoization pattern with Symbol-based cache sentinel\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-property-call.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction foo() {\n  const $ = _c(1);\n  let y;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const x = [];\n    y = { x };\n    y.x.push([]);\n    $[0] = y;\n  } else {\n    y = $[0];\n  }\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with Default Parameter\nDESCRIPTION: This snippet defines a React component function that uses array destructuring and default parameters. It takes an array as input and returns the first element or a default value of 2 if the array is empty.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-array-param-default.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component([a = 2]) {\n  return a;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: React useRef Hook and onClick Handler\nDESCRIPTION: This snippet demonstrates the usage of the `useRef` hook in React to access a DOM element and modify its value via an onClick handler. The `useRef` hook is initialized with `null`, and the current property of the ref is accessed to interact with the DOM node.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-mutating-ref-property-in-callback-passed-to-jsx.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validateRefAccessDuringRender\nimport {useRef} from 'react';\n\nfunction Component() {\n  const ref = useRef(null);\n\n  const onClick = () => {\n    if (ref.current !== null) {\n      ref.current.value = '';\n    }\n  };\n\n  return (\n    <>\n      <input ref={ref} />\n      <button onClick={onClick} />\n    </>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}]\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: Optimized version with compiler runtime integration. Implements memoization checks for component renders and props changes using a cache array.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/renaming-jsx-tag-lowercase.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { Stringify, identity, useIdentity } from \"shared-runtime\";\n\nfunction Foo(t0) {\n  const $ = _c(9);\n  const x = {};\n  const y = {};\n  useIdentity(0);\n\n  const T0 = Stringify;\n  const t1 = identity(y);\n  let t2;\n  if ($[0] !== T0 || $[1] !== t1) {\n    t2 = <T0 value={t1} />;\n    $[0] = T0;\n    $[1] = t1;\n    $[2] = t2;\n  } else {\n    t2 = $[2];\n  }\n  const T1 = Stringify;\n  const t3 = identity(x);\n  let t4;\n  if ($[3] !== T1 || $[4] !== t3) {\n    t4 = <T1 value={t3} />;\n    $[3] = T1;\n    $[4] = t3;\n    $[5] = t4;\n  } else {\n    t4 = $[5];\n  }\n  let t5;\n  if ($[6] !== t2 || $[7] !== t4) {\n    t5 = (\n      <>\n        {t2}\n        {t4}\n      </>\n    );\n    $[6] = t2;\n    $[7] = t4;\n    $[8] = t5;\n  } else {\n    t5 = $[8];\n  }\n  return t5;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Components with Memoization (Output)\nDESCRIPTION: Transformed React components with memoization applied using the React compiler runtime. The code uses the '_c' function to create a cache array and checks if values are already computed using a special Symbol. This optimization prevents redundant recursive calculations on re-renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/recursive-function-expression.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component1() {\n  const $ = _c(1);\n  let x;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    x = callback(10);\n    function callback(x_0) {\n      if (x_0 == 0) {\n        return null;\n      }\n      return callback(x_0 - 1);\n    }\n    $[0] = x;\n  } else {\n    x = $[0];\n  }\n  return x;\n}\n\nfunction Component() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    function callback(x) {\n      if (x == 0) {\n        return null;\n      }\n      return callback(x - 1);\n    }\n\n    t0 = callback(10);\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining React Component Function in JavaScript\nDESCRIPTION: This snippet implements a basic React component function that handles input data and uses props to conditionally render child components. The function utilizes a switch statement to determine behavior based on props, encapsulates input data, and passes it down to rendered child components, demonstrating fundamental component design patterns in React.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/switch.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\n// @enablePropagateDepsInHIR\nfunction Component(props) {\n  let x = [];\n  let y;\n  switch (props.p0) {\n    case true: {\n      x.push(props.p2);\n      x.push(props.p3);\n      y = [];\n    }\n    case false: {\n      y = x;\n      break;\n    }\n  }\n  const child = <Component data={x} />;\n  y.push(props.p4);\n  return <Component data={y}>{child}</Component>;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Optimized React Compiler Function\nDESCRIPTION: This snippet shows the optimized version of the 'foo' function using React's compiler runtime. It introduces caching mechanisms to avoid redundant computations and object creations, potentially improving performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/obj-mutated-after-nested-if-else-with-alias.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction foo(a, b, c, d) {\n  const $ = _c(3);\n  someObj();\n  let x;\n  if ($[0] !== a || $[1] !== b) {\n    if (a) {\n      let z;\n      if (b) {\n        const w = someObj();\n        z = w;\n      } else {\n        z = someObj();\n      }\n\n      x = z;\n    } else {\n      x = someObj();\n    }\n\n    x.f = 1;\n    $[0] = a;\n    $[1] = b;\n    $[2] = x;\n  } else {\n    x = $[2];\n  }\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing useHook Function in React JavaScript\nDESCRIPTION: The JavaScript function useHook showcases a custom hook in a React application. It operates based on a switch statement that checks the first parameter. If the condition is met, it logs the second parameter. This function is associated with a FIXTURE_ENTRYPOINT export that defines its usage context within the application. The function requires no external dependencies and accepts numerical and variable inputs.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/block-scoping-switch-dead-code.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction useHook(a, b) {\n  switch (a) {\n    case 1:\n      if (b == null) {\n        return;\n      }\n      console.log(b);\n      break;\n    case 2:\n      return;\n    default:\n      return;\n  }\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useHook,\n  params: [1, 'foo'],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Original useMakeCallback Hook Implementation in React\nDESCRIPTION: A React custom hook that creates a callback function to update state when an object's value doesn't match the current state. The hook uses useState and an external useIdentity hook, and immediately executes the callback.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/assume-invoked/direct-call.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useState} from 'react';\nimport {useIdentity} from 'shared-runtime';\n\nfunction useMakeCallback({obj}: {obj: {value: number}}) {\n  const [state, setState] = useState(0);\n  const cb = () => {\n    if (obj.value !== state) setState(obj.value);\n  };\n  useIdentity();\n  cb();\n  return [cb];\n}\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useMakeCallback,\n  params: [{obj: {value: 1}}],\n  sequentialRenders: [{obj: {value: 1}}, {obj: {value: 2}}],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: Simple React component that returns an object with three properties. Uses external functions getNumber and identity, with props.id as an input parameter.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/mege-consecutive-scopes-dont-merge-with-different-deps.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst {getNumber, identity} = require('shared-runtime');\n\nfunction Component(props) {\n  // Two scopes: one for `getNumber()`, one for the object literal.\n  // Neither has dependencies so they should merge\n  return {a: getNumber(), b: identity(props.id), c: ['static']};\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{id: 42}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: Compiled version of the component that includes React's memoization logic using Symbol.for('react.memo_cache_sentinel'). The map operation is extracted into a separate function for optimization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-map-mutable-array-mutating-lambda.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const x = [];\n    const y = x.map(_temp);\n    t0 = [x, y];\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\nfunction _temp(item) {\n  item.updated = true;\n  return item;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Input Component with Mutation and Closure\nDESCRIPTION: An initial implementation of a component that creates nested objects, uses a closure, and calls a mutate function on the object\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-fun-alias-captured-mutate-2-iife.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {mutate} from 'shared-runtime';\n\nfunction component(foo, bar) {\n  let x = {foo};\n  let y = {bar};\n  (function () {\n    let a = {y};\n    let b = x;\n    a.x = b;\n  })();\n  mutate(y);\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: ['foo', 'bar'],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with Multiple Parameters\nDESCRIPTION: Defines a React component named `Component` that accepts two parameters, `foo` and `bar`. The component returns a simple `div` element. It also defines and exports a constant `FIXTURE_ENTRYPOINT` which is an object containing the component function and a `params` array to be passed to the component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-dont-compile-components-with-multiple-params.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @compilationMode(infer)\n// Takes multiple parameters - not a component!\nfunction Component(foo, bar) {\n  return <div />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [null, null],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Initializing React Component with Object Mutation\nDESCRIPTION: A React functional component that creates an object, renders it in JSX, and then attempts to modify the object, which is not allowed in React's rendering lifecycle\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-computed-store-to-frozen-value.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const x = makeObject();\n  // freeze\n  <div>{x}</div>;\n  x[0] = true;\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Enhanced Props Logging with Dispatcher Guard in React\nDESCRIPTION: This snippet provides a more complex React component that uses dispatcher guards and structured logging of props. It employs useFire and useEffect to control side effects based on props changes, ensuring that the component behaves correctly between renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/hook-guard.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { $dispatcherGuard } from \"react-compiler-runtime\";\nimport { c as _c, useFire } from \"react/compiler-runtime\"; // @enableFire @enableEmitHookGuards\nimport { fire } from \"react\";\n\nfunction Component(props) {\n  const $ = _c(3);\n  try {\n    $dispatcherGuard(0);\n    const foo = _temp;\n    const t0 = (function () {\n      try {\n        $dispatcherGuard(2);\n        return useFire(foo);\n      } finally {\n        $dispatcherGuard(3);\n      }\n    })();\n    let t1;\n    if ($[0] !== props || $[1] !== t0) {\n      t1 = () => {\n        t0(props);\n      };\n      $[0] = props;\n      $[1] = t0;\n      $[2] = t1;\n    } else {\n      t1 = $[2];\n    }\n    (function () {\n      try {\n        $dispatcherGuard(2);\n        return useEffect(t1);\n      } finally {\n        $dispatcherGuard(3);\n      }\n    })();\n    return null;\n  } finally {\n    $dispatcherGuard(1);\n  }\n}\nfunction _temp(props_0) {\n  console.log(props_0);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Initializing Component with Shared Runtime and Conditional Logic in JavaScript\nDESCRIPTION: The snippet initializes a React component, 'Component', that checks a condition (props.cond) to assign a value to an 'object'. It depends on the 'makeObject_Primitives' from 'shared-runtime' to construct the object. The component returns an object with the value altered based on props.cond. The input includes component props and outputs an object with 'value' property set.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-mutated-in-consequent-alternate-both-return.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {makeObject_Primitives} from 'shared-runtime';\n\nfunction Component(props) {\n  const object = makeObject_Primitives();\n  if (props.cond) {\n    object.value = 1;\n    return object;\n  } else {\n    object.value = props.value;\n    return object;\n  }\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{cond: false, value: [0, 1, 2]}],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component Function Implementation in JavaScript\nDESCRIPTION: This snippet presents an optimized version of the React component function. It improves variable declarations and assignments, removing unnecessary initializations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/primitive-alias-mutate.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component(a) {\n  let x;\n  if (a) {\n    x = \"bar\";\n  } else {\n    x = \"baz\";\n  }\n\n  const y = x;\n  mutate(y);\n  return y;\n}\n```\n\n----------------------------------------\n\nTITLE: React Component using useSharedValue Hook\nDESCRIPTION: This code defines a React component `SomeComponent` that uses the `useSharedValue` hook to create a shared value. The component includes a button that, when pressed, attempts to directly mutate the `.value` property of this shared value. This is intended to demonstrate a common pitfall when working with shared values in React and is included for illustrative purposes to highlight the error produced by attempting to mutate this value directly.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-non-imported-reanimated-shared-value-writes.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableCustomTypeDefinitionForReanimated\n\n/**\n * Test that a global (i.e. non-imported) useSharedValue is treated as an\n * unknown hook.\n */\nfunction SomeComponent() {\n  const sharedVal = useSharedValue(0);\n  return (\n    <Button\n      onPress={() => (sharedVal.value = Math.random())}\n      title=\"Randomize\"\n    />\n  );\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining Component Function with Shared Runtime - JavaScript\nDESCRIPTION: This code snippet defines a React component named 'Component' that utilizes the 'makeArray' function from 'shared-runtime' to create an array based on a numeric input. It also uses 'SharedRuntime.Stringify' to render the result. Required dependencies include 'shared-runtime'. The component accepts a single parameter 'num' and returns JSX that incorporates the generated array. It includes a note regarding global property loading.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/todo-global-property-load-cached.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as SharedRuntime from 'shared-runtime';\nimport {makeArray} from 'shared-runtime';\n\n/**\n * Here, we don't need to memoize SharedRuntime.Stringify as it is a PropertyLoad\n * off of a global.\n * TODO: in PropagateScopeDeps (hir), we should produce a sidemap of global rvals\n * and avoid adding them to `temporariesUsedOutsideDefiningScope`.\n */\nfunction Component({num}: {num: number}) {\n  const arr = makeArray(num);\n  return (\n    <SharedRuntime.Stringify value={arr.push(num)}></SharedRuntime.Stringify>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{num: 2}],\n};\n```\n\n----------------------------------------\n\nTITLE: Creating a React Component with Props and Switch Statement\nDESCRIPTION: Defines a React functional component that accepts props and uses a switch statement to conditionally set variables. The component returns a value that may be modified based on the switch condition.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/escape-analysis-not-switch-test.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const a = [props.a];\n  let x = props.b;\n  switch (a) {\n    case true: {\n      x = props.c;\n    }\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled Version of useFoo Function with Memoization in JavaScript\nDESCRIPTION: This snippet shows the compiled version of the useFoo function, including memoization logic. It uses React's compiler runtime to optimize the function, caching results based on input changes and implementing the same logic as the original function.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/mutate-outer-scope-within-value-block.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { CONST_TRUE, identity, shallowCopy } from \"shared-runtime\";\n\nfunction mutate(_) {}\n\n/**\n * There are three values with their own scopes in this fixture.\n * - arr, whose mutable range extends to the `mutate(...)` call\n * - cond, which has a mutable range of exactly 1 (e.g. created but not\n *   mutated)\n * - { val: CONST_TRUE }, which is also not mutated after creation. However,\n *   its scope range becomes extended to the value block.\n *\n * After AlignScopesToBlockScopes, our scopes look roughly like this\n * ```js\n *  [1] arr = shallowCopy()            @0\n *  [2] cond = identity()        <- @1 |\n *  [3] $0 = Ternary test=cond     @2 |\n *  [4]        {val : CONST_TRUE}  |   |\n *  [5]        mutate(arr)         |   |\n *  [6] return $0                     \n * ```\n *\n * Observe that instruction 5 mutates scope 0, which means that scopes 0 and 2\n * should be merged.\n */\nfunction useFoo(t0) {\n  const $ = _c(2);\n  const { input } = t0;\n  let t1;\n  if ($[0] !== input) {\n    const arr = shallowCopy(input);\n\n    const cond = identity(false);\n    t1 = cond ? { val: CONST_TRUE } : mutate(arr);\n    $[0] = input;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ input: 3 }],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with useMemo (Input)\nDESCRIPTION: This snippet defines a React component named `Component` that uses `useMemo` to memoize the value of `[a]`. The memoized value is then rendered within a `div`. The `FIXTURE_ENTRYPOINT` object configures the component for testing or demonstration purposes, specifying the component function, initial parameters, and indicating that it's a component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-simple-preserved-nomemo.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @disableMemoizationForDebugging\nimport {useMemo} from 'react';\n\nfunction Component({a}) {\n  let x = useMemo(() => [a], []);\n  return <div>{x}</div>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{a: 42}],\n  isComponent: true,\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Optimized FBT Translations\nDESCRIPTION: This snippet shows the compiled version of the React component. It demonstrates how FBT translations are optimized and converted to efficient runtime code.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/lambda-with-fbt.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { fbt } from \"fbt\";\n\nfunction Component() {\n  const $ = _c(1);\n  const buttonLabel = _temp;\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = (\n      <View>\n        <Button text={buttonLabel()} />\n      </View>\n    );\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\nfunction _temp() {\n  if (!someCondition) {\n    return fbt._(\"Purchase as a gift\", null, { hk: \"1gHj4g\" });\n  } else {\n    if (\n      !iconOnly &&\n      showPrice &&\n      item?.current_gift_offer?.price?.formatted != null\n    ) {\n      return fbt._(\n        \"Gift | {price}\",\n        [fbt._param(\"price\", item?.current_gift_offer?.price?.formatted)],\n        { hk: \"3GTnGE\" },\n      );\n    } else {\n      if (!iconOnly && !showPrice) {\n        return fbt._(\"Gift\", null, { hk: \"3fqfrk\" });\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: React Counter Component Implementation - Compiled Output\nDESCRIPTION: Compiled version of the counter component showing React's compiler runtime optimizations including memoization logic and scope handling for improved performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/merge-consecutive-scopes-deps-subset-of-decls.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useState } from \"react\";\n\nfunction Component() {\n  const $ = _c(2);\n  const [count, setCount] = useState(0);\n  let t0;\n  if ($[0] !== count) {\n    t0 = (\n      <div>\n        <button onClick={() => setCount(count - 1)}>Decrement</button>\n\n        <button onClick={() => setCount(count + 1)}>Increment</button>\n      </div>\n    );\n    $[0] = count;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component using Compiler-Runtime\nDESCRIPTION: This snippet shows the compiled version of the React component, making use of `react/compiler-runtime` for optimization.  The `_c` function seems to be used for memoization of the `Stringify` component's output, preventing unnecessary re-renders. It checks for a sentinel value in a cache and conditionally renders the component based on whether the output is cached.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-attribute-default-to-true.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { Stringify } from \"shared-runtime\";\n\nfunction Component() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = <Stringify truthyAttribute={true} />;\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}]\n};\n\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Compiler Runtime\nDESCRIPTION: Compiler-optimized version using runtime caching to avoid recreating and recalculating array values. Implements conditional logic to reuse cached values when props haven't changed.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/assignment-expression-computed.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  let x;\n  if ($[0] !== props.x) {\n    x = [props.x];\n\n    x[0] = x[0] * 2;\n    x[\"0\"] = x[\"0\"] + 3;\n    $[0] = props.x;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ x: 2 }],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with Mutator (Compiled Code)\nDESCRIPTION: This is the compiled version of the React component, optimized using `react/compiler-runtime`. It memoizes the `poke` and `hide` functions and the rendering of the `Foo` component to avoid unnecessary re-creations and re-renders. It uses a state array `$` to store memoized values.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-member-expr-call.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction component(t0) {\n  const $ = _c(7);\n  const { mutator } = t0;\n  let t1;\n  if ($[0] !== mutator) {\n    t1 = () => {\n      mutator.poke();\n    };\n    $[0] = mutator;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  const poke = t1;\n  let t2;\n  if ($[2] !== mutator.user) {\n    t2 = () => {\n      mutator.user.hide();\n    };\n    $[2] = mutator.user;\n    $[3] = t2;\n  } else {\n    t2 = $[3];\n  }\n  const hide = t2;\n  let t3;\n  if ($[4] !== hide || $[5] !== poke) {\n    t3 = <Foo poke={poke} hide={hide} />;\n    $[4] = hide;\n    $[5] = poke;\n    $[6] = t3;\n  } else {\n    t3 = $[6];\n  }\n  return t3;\n}\n```\n\n----------------------------------------\n\nTITLE: Input Memoization Function with useMemo\nDESCRIPTION: Initial implementation of useFoo function using React's useMemo hook to create a memoized array based on a callback function\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useMemo-invoke-prop.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees\n\nimport {useMemo} from 'react';\n\nfunction useFoo({callback}) {\n  return useMemo(() => new Array(callback()), [callback]);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [\n    {\n      callback: () => {\n        'use no forget';\n        return [1, 2, 3];\n      },\n    },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring a Same-Origin `iframe`\nDESCRIPTION: This JavaScript snippet demonstrates configuring React DevTools with a same-origin iframe. It initializes both the backend and frontend, ensuring the backend is initialized before React loads in the iframe. The frontend returns a React component that can be rendered in the parent window, and the backend is activated after the frontend is initialized.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools-inline/README.md#2025-04-21_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport {\n  activate as activateBackend,\n  initialize as initializeBackend\n} from 'react-devtools-inline/backend';\nimport { initialize as initializeFrontend } from 'react-devtools-inline/frontend';\n\n// The React app you want to inspect with DevTools is running within this iframe:\nconst iframe = document.getElementById('target');\nconst { contentWindow } = iframe;\n\n// Installs the global hook into the iframe.\n// This must be called before React is loaded into that frame.\ninitializeBackend(contentWindow);\n\n// Initialize DevTools UI to listen to the hook we just installed.\n// This returns a React component we can render anywhere in the parent window.\n// This also must be called before React is loaded into the iframe\nconst DevTools = initializeFrontend(contentWindow);\n\n// React application can be injected into <iframe> at any time now...\n// Note that this would need to be done via <script> tag injection,\n// as setting the src of the <iframe> would load a new page (without the injected backend).\n\n// <DevTools /> interface can be rendered in the parent window at any time now...\n// Be sure to use ReactDOMClient.createRoot() to render this component.\n\n// Let the backend know the frontend is ready and listening.\nactivateBackend(contentWindow);\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: A React component that creates an object from props, deletes a property, and returns the modified object. Includes a fixture entrypoint configuration for testing.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/delete-property.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const x = {a: props.a, b: props.b};\n  delete x.b;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Compiler Runtime\nDESCRIPTION: An optimized version of the React component using React's compiler runtime for efficient memoization and object caching\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-if-else-multiple-return.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(4);\n  let t0;\n  bb0: {\n    if (props.cond) {\n      let t1;\n      if ($[0] !== props.a) {\n        t1 = makeObject(props.a);\n        $[0] = props.a;\n        $[1] = t1;\n      } else {\n        t1 = $[1];\n      }\n      t0 = t1;\n      break bb0;\n    }\n    let t1;\n    if ($[2] !== props.b) {\n      t1 = makeObject(props.b);\n      $[2] = props.b;\n      $[3] = t1;\n    } else {\n      t1 = $[3];\n    }\n    t0 = t1;\n  }\n  const x = t0;\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: React Component Using Custom Hook - JavaScript\nDESCRIPTION: This snippet features a React functional component that utilizes the custom useState hook. The component initiates the state with 'hello' and updates the state to 'goodbye' when the div is clicked. The key functionalities include rendering the current state and handling user interaction through an onClick event.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/globals-dont-resolve-local-useState.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component() {\n  const [state, setState] = useState('hello');\n\n  return <div onClick={() => setState('goodbye')}>{state}</div>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Function with Memoization\nDESCRIPTION: This JavaScript code represents a compiled version of the `get2` function, potentially generated by a React compiler. It uses `react/compiler-runtime` to memoize the result. The code checks if a memoized value exists; if not, it executes the original logic, stores the result, and then returns the result. Subsequent calls will retrieve the memoized value.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-repro-variable-used-in-assignment.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction get2() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const callbk = () => {\n      const copy = x;\n      return copy;\n    };\n\n    const x = 2;\n    t0 = callbk();\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: get2,\n  params: [],\n};\n\n```\n\n----------------------------------------\n\nTITLE: React useCallback Compiled Code\nDESCRIPTION: This snippet shows the transformed code of the 'Foo' component, supposedly compiled for optimization. It uses a '_c' function (likely from \"react/compiler-runtime\") to manage memoization. The 'x' variable and the useCallback's memoized function are stored in an array '$', and the code conditionally recomputes them based on prop changes to preserve memoization guarantees.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useCallback-captures-reassigned-context.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @validatePreserveExistingMemoizationGuarantees\n\nimport { useCallback } from \"react\";\nimport { makeArray } from \"shared-runtime\";\n\n// This case is fine, as all reassignments happen before the useCallback\nfunction Foo(props) {\n  const $ = _c(4);\n  let x;\n  if ($[0] !== props) {\n    x = [];\n    x.push(props);\n    x = makeArray();\n    $[0] = props;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  let t0;\n  if ($[2] !== x) {\n    t0 = () => [x];\n    $[2] = x;\n    $[3] = t0;\n  } else {\n    t0 = $[3];\n  }\n  x;\n  const cb = t0;\n  return cb;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{}]\n};\n```\n\n----------------------------------------\n\nTITLE: Input Component with Fragments and Item Mapping\nDESCRIPTION: React component that conditionally renders Stringify items within a fragment, handling zero-length item scenarios\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-attribute-with-jsx-fragment-value.flow.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component({items}) {\n  return items.length > 0 ? (\n    <Foo\n      value={\n        <>\n          {items.map(item => (\n            <Stringify key={item.id} item={item} />\n          ))}\n        </>\n      }></Foo>\n  ) : null;\n}\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Memoization\nDESCRIPTION: This snippet shows an optimized version of the React component with memoization. It uses a cache to store computed values and avoids unnecessary re-computations. The code includes checks for a special Symbol to determine if cached values should be used.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/regexp-literal.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(4);\n  let t0;\n  let value;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const pattern = /foo/g;\n    value = makeValue();\n\n    t0 = pattern.test(value);\n    $[0] = t0;\n    $[1] = value;\n  } else {\n    t0 = $[0];\n    value = $[1];\n  }\n  if (t0) {\n    let t1;\n    if ($[2] === Symbol.for(\"react.memo_cache_sentinel\")) {\n      t1 = <div>{value}</div>;\n      $[2] = t1;\n    } else {\n      t1 = $[2];\n    }\n    return t1;\n  }\n  let t1;\n  if ($[3] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = <div>Default</div>;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  return t1;\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled React Version with Memoization\nDESCRIPTION: Compiled version of the function using React's compiler runtime with memoization logic. Uses Symbol.for() to implement caching mechanism for the returned object.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-non-identifier-object-keys.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Foo() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = { \"a.b\": 1, \"a\\b\": 2, \"a/b\": 3, \"a+b\": 4, \"a b\": 5 };\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Enhanced React Component with Compiler Runtime\nDESCRIPTION: This snippet imports specific runtime compiler utilities to optimize component performance and manage memoization. The 'Component' function manipulates component state utilizing 'shallowCopy' and 'throwErrorWithMessage' while enhancing performance with compiler-specific symbols and caching mechanisms. It validates and updates state against props, optimizing execution through conditional caching. The component prepares for React memoization using a compiler runtime and exports 'FIXTURE_ENTRYPOINT' with params for testing scenarions.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/try-catch-mutate-outer-value.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enablePropagateDepsInHIR\nconst { shallowCopy, throwErrorWithMessage } = require(\"shared-runtime\");\n\nfunction Component(props) {\n  const $ = _c(5);\n  let x;\n  if ($[0] !== props) {\n    x = [];\n    try {\n      let t0;\n      if ($[2] === Symbol.for(\"react.memo_cache_sentinel\")) {\n        t0 = throwErrorWithMessage(\"oops\");\n        $[2] = t0;\n      } else {\n        t0 = $[2];\n      }\n      x.push(t0);\n    } catch {\n      let t0;\n      if ($[3] !== props.a) {\n        t0 = shallowCopy({ a: props.a });\n        $[3] = props.a;\n        $[4] = t0;\n      } else {\n        t0 = $[4];\n      }\n      x.push(t0);\n    }\n    $[0] = props;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ a: 1 }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Hook in JavaScript\nDESCRIPTION: This snippet defines a custom hook \"useHook\" which initializes a function \"x\" that conditionally mutates an object based on input parameters. The mutation assumes no alterations if function \"x\" is not invoked during render. Dependencies include potential functions that may modify state and are called within the hook.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-conditional-capture-mutate.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nfunction useHook(a, b) {\n  let z = {a};\n  let y = b;\n  let x = function () {\n    if (y) {\n      // we don\\'t know for sure this mutates, so we should assume\n      // that there is no mutation so long as `x` isn\\'t called\n      // during render\n      maybeMutate(z);\n    }\n  };\n  return x;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Optimized Component with Caching - React - JavaScript\nDESCRIPTION: This snippet enhances the previous component by introducing caching to optimize performance. It checks if the input arrays have changed and only recalculates the output if they have. This is done through a use of an internal cache array. It also uses 'makeArray' to adapt the input into the desired output structure.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/call-spread.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { makeArray } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(3);\n  let t0;\n  if ($[0] !== props.a || $[1] !== props.b) {\n    t0 = makeArray(...props.a, null, ...props.b);\n    $[0] = props.a;\n    $[1] = props.b;\n    $[2] = t0;\n  } else {\n    t0 = $[2];\n  }\n  const x = t0;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ a: [1, 2], b: [2, 3, 4] }],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimizing React Component with Memoization and Compiler Runtime\nDESCRIPTION: This snippet shows an optimized version of the Component using React's compiler runtime for memoization. It caches rendered content based on props to avoid unnecessary re-renders, improving performance for repeated renders with the same props.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-loop-with-value-block-initializer.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nconst TOTAL = 10;\nfunction Component(props) {\n  const $ = _c(3);\n  let t0;\n  if ($[0] !== props.items || $[1] !== props.start) {\n    const items = [];\n    for (let i = props.start ?? 0; i < props.items.length; i++) {\n      const item = props.items[i];\n      items.push(<div key={item.id}>{item.value}</div>);\n    }\n\n    t0 = <div>{items}</div>;\n    $[0] = props.items;\n    $[1] = props.start;\n    $[2] = t0;\n  } else {\n    t0 = $[2];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\n    {\n      start: null,\n      items: [\n        { id: 0, value: \"zero\" },\n        { id: 1, value: \"one\" },\n      ],\n    },\n  ],\n\n  sequentialRenders: [\n    {\n      start: 1,\n      items: [\n        { id: 0, value: \"zero\" },\n        { id: 1, value: \"one\" },\n      ],\n    },\n    {\n      start: 2,\n      items: [\n        { id: 0, value: \"zero\" },\n        { id: 1, value: \"one\" },\n      ],\n    },\n    {\n      start: 0,\n      items: [\n        { id: 0, value: \"zero\" },\n        { id: 1, value: \"one\" },\n        { id: 2, value: \"two\" },\n      ],\n    },\n    {\n      start: 1,\n      items: [\n        { id: 0, value: \"zero\" },\n        { id: 1, value: \"one\" },\n        { id: 2, value: \"two\" },\n      ],\n    },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Using Fragments in React Component (JavaScript)\nDESCRIPTION: This JavaScript code snippet illustrates a React component employing the `useFragment` hook from 'shared-runtime' to fetch user data. It maps through the user's post timeline and generates a list of <Post> components. Input is 'props.user', and the component returns the rendered posts wrapped in a fragment. This version lacks caching or memoization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/readonly-object-method-calls.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useFragment} from 'shared-runtime';\n\nfunction Component(props) {\n  const user = useFragment(\n    graphql`\n      fragment Component_user on User {\n        name\n      }\n    `,\n    props.user\n  );\n  const posts = user.timeline.posts.edges.nodes.map(node => (\n    <Post post={node} />\n  ));\n  posts.push({});\n  const count = posts.length;\n  foo(count);\n  return <>{posts}</>;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic React Component\nDESCRIPTION: This snippet demonstrates the creation of a basic functional component named 'ComponentName' that returns a simple JSX element. It does not use any advanced React features like memoization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-function-expression-component.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @compilationMode(infer)\n\nconst Component = function ComponentName(props) {\n  return <Foo />;\n};\n\n```\n\n----------------------------------------\n\nTITLE: Implementing useFoo React Hook with Conditional Logic\nDESCRIPTION: A React hook that conditionally processes input data based on provided conditions. It checks for the existence of nested properties and returns either null or an array containing the processed input.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-poisoned/reduce-if-nonexhaustive-poisoned-deps.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {identity} from 'shared-runtime';\n\nfunction useFoo({input, cond, hasAB}) {\n  const x = [];\n  if (cond) {\n    if (!hasAB) {\n      return null;\n    }\n    x.push(identity(input.a.b));\n  } else {\n    x.push(identity(input.a.b));\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{input: {b: 1}, cond: true, hasAB: false}],\n  sequentialRenders: [\n    {input: {a: {b: 1}}, cond: true, hasAB: true},\n    {input: null, cond: true, hasAB: false},\n    // preserve nullthrows\n    {input: {a: {b: undefined}}, cond: true, hasAB: true},\n    {input: {a: undefined}, cond: true, hasAB: true},\n    {input: {a: {b: undefined}}, cond: true, hasAB: true},\n    {input: undefined, cond: true, hasAB: true},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with Initial Fire and Effect Implementation\nDESCRIPTION: Initial implementation of a React component using fire events and useEffect with memoization and prop interactions\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/bailout-retry/bailout-validate-preserve-memo.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees @enableFire @panicThreshold(none)\nimport {fire} from 'react';\nimport {sum} from 'shared-runtime';\n\nfunction Component({prop1, bar}) {\n  const foo = () => {\n    console.log(prop1);\n  };\n  useEffect(() => {\n    fire(foo(prop1));\n    fire(foo());\n    fire(bar());\n  });\n\n  return useMemo(() => sum(bar), []);\n}\n```\n\n----------------------------------------\n\nTITLE: Identifying React Component Error - JavaScript\nDESCRIPTION: This snippet displays an error message generated by the React linter indicating that the component 'Foo' is attempting to reassign 'someGlobal', which is considered a side effect. The error highlights the need to maintain purity in React components and suggests using hooks like useState instead of direct variable manipulation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.assign-global-in-component-tag-function.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n  1 | function Component() {\n  2 |   const Foo = () => {\n> 3 |     someGlobal = true;\n    |     ^^^^^^^^^^ InvalidReact: Unexpected reassignment of a variable which was defined outside of the component. Components and hooks should be pure and side-effect free, but variable reassignment is a form of side-effect. If this variable is used in rendering, use useState instead. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#side-effects-must-run-outside-of-render) (3:3)\n  4 |   };\n  5 |   return <Foo />;\n  6 | }\n\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: Simple React component that processes array operations on props. It creates an array from props, pushes a value, and accesses an element using the at() method.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-property-call.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const a = [props.a, props.b, 'hello'];\n  const x = a.push(42);\n  const y = a.at(props.c);\n\n  return {a, x, y};\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{a: 1, b: 2, c: 0}],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Component and Exporting Fixture Entrypoint in JavaScript\nDESCRIPTION: This snippet demonstrates how to define a simple component in JavaScript and export it as a fixture entry point. The component processes an input parameter and performs an operation via a nested function. It is designed to be reusable for different input configurations as specified by the fixture entry point.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/function-declaration-simple.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component(a) {\n  let t = {a};\n  function x(p) {\n    p.foo();\n  }\n  x(t);\n  return t;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Function 'bar' in JavaScript\nDESCRIPTION: This snippet defines a simple function named 'bar' that takes an argument 'a', initializes an array and an object, and immediately invokes a function to assign a value to 'y'. The function returns 'y', which is expected to be the value of the first element of the array created from the input parameter.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-alias-computed-load-iife.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction bar(a) {\n  let x = [a];\n  let y = {};\n  (function () {\n    y = x[0];\n  })();\n\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: bar,\n  params: ['TodoAdd'],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Compiler Runtime\nDESCRIPTION: This JavaScript code represents the optimized version of the React component using React's compiler runtime. It uses the `_c` function to memoize the conditional prop value and the resulting component instance, preventing unnecessary re-renders when the conditional value hasn't changed. The `_c` function manages a cache (`$`) to store and reuse values, improving performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-spread.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(5);\n\n  const t0 = props.cond ? props.foo : props.bar;\n  let t1;\n  if ($[0] !== t0) {\n    t1 = { bar: t0 };\n    $[0] = t0;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  let t2;\n  if ($[2] !== props || $[3] !== t1) {\n    t2 = <Component {...props} {...t1} />;\n    $[2] = props;\n    $[3] = t1;\n    $[4] = t2;\n  } else {\n    t2 = $[4];\n  }\n  return t2;\n}\n\n```\n\n----------------------------------------\n\nTITLE: React Hook Definition: useFoo\nDESCRIPTION: Defines a React hook named `useFoo` that takes an `onClose` function as a prop. It initializes a button using `StaticText1` and a `Stringify` component, configuring its primary and secondary actions. The secondary action's onPress handler relies on a `dispatcher` which is initialized using `useHook` after the button's initialization. The hook returns the button.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisted-declaration-with-scope.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {StaticText1, Stringify, identity, useHook} from 'shared-runtime';\n\n/**\n * `button` and `dispatcher` must end up in the same memo block. It would be\n * invalid for `button` to take a dependency on `dispatcher` as dispatcher\n * is created later.\n */\nfunction useFoo({onClose}) {\n  const button = StaticText1 ?? (\n    <Stringify\n      primary={{\n        label: identity('label'),\n        onPress: onClose,\n      }}\n      secondary={{\n        onPress: () => {\n          dispatcher.go('route2');\n        },\n      }}\n    />\n  );\n\n  const dispatcher = useHook();\n\n  return button;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{onClose: identity()}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Optimized Implementation of useFoo with React Compiler Runtime\nDESCRIPTION: This snippet shows an optimized version of the useFoo function, using React's compiler runtime for improved performance. It implements the same functionality as the original but with more efficient memoization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useMemo-inner-decl.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @validatePreserveExistingMemoizationGuarantees\nimport { useMemo } from \"react\";\nimport { identity } from \"shared-runtime\";\n\nfunction useFoo(data) {\n  const $ = _c(4);\n  let t0;\n  let t1;\n  if ($[0] !== data.a) {\n    t1 = identity(data.a);\n    $[0] = data.a;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  const temp = t1;\n  let t2;\n  if ($[2] !== temp) {\n    t2 = { temp };\n    $[2] = temp;\n    $[3] = t2;\n  } else {\n    t2 = $[3];\n  }\n  t0 = t2;\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ a: 2 }],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component Compilation with Memoization\nDESCRIPTION: This snippet shows the compiled code for a React component (TestComponent) that uses a compiler runtime function (`_c`) for memoization. It checks if the input prop `x` has changed and only re-renders the `<Button>` component if necessary, storing the result in a cache.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/apps/playground/__tests__/e2e/__snapshots__/page.spec.ts/use-memo-output.txt#2025-04-21_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction TestComponent(t0) {\n  \"usememo\";\n  const $ = _c(2);\n  const { x } = t0;\n  let t1;\n  if ($[0] !== x) {\n    t1 = <Button>{x}</Button>;\n    $[0] = x;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a React Component with State Mutation - JavaScript\nDESCRIPTION: This snippet defines a React functional component named 'Component' which attempts to manage its internal state using an array. It pushes a value from props into this array and renders it within a div. However, it demonstrates an error since modifying the value after it has been declared in JSX is not allowed. The component aims to show the misuse of state management in React.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-array-push-frozen.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nfunction Component(props) {\n  const x = [];\n  <div>{x}</div>;\n  x.push(props.value);\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing React Hook with Conditional State Update\nDESCRIPTION: A React functional component demonstrating useMemo hook with parameter destructuring. The function checks width condition and potentially updates styles based on input parameters.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/maybe-invalid-useMemo-no-memoblock-sideeffect.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction useFoo({minWidth, styles, setStyles}) {\n  useMemo(() => {\n    if (styles.width > minWidth) {\n      setStyles(styles);\n    }\n  }, [styles, minWidth, setStyles]);\n}\n```\n\nLANGUAGE: javascript\nCODE:\n```\nfunction useFoo(t0) {\n  const { minWidth, styles, setStyles } = t0;\n  let t1;\n  if (styles.width > minWidth) {\n    setStyles(styles);\n  }\n  t1 = undefined;\n}\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Caching\nDESCRIPTION: Optimized version of the component using React compiler runtime for caching. Implements memoization to prevent unnecessary recreations of arrays and objects based on prop changes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-properties.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(7);\n  let t0;\n  if ($[0] !== props.a || $[1] !== props.b) {\n    t0 = [props.a, props.b, \"hello\"];\n    $[0] = props.a;\n    $[1] = props.b;\n    $[2] = t0;\n  } else {\n    t0 = $[2];\n  }\n  const a = t0;\n  const x = a.length;\n  const y = a.push;\n  let t1;\n  if ($[3] !== a || $[4] !== x || $[5] !== y) {\n    t1 = { a, x, y, z: a.concat };\n    $[3] = a;\n    $[4] = x;\n    $[5] = y;\n    $[6] = t1;\n  } else {\n    t1 = $[6];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ a: [1, 2], b: 2 }],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Runtime Optimization\nDESCRIPTION: Compiler-transformed version of the React component with memoization and runtime tracking of component state and renders\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-from-maybemutates-arg0.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { mutateAndReturn, Stringify, useIdentity } from \"shared-runtime\";\n\nfunction Component(t0) {\n  const $ = _c(7);\n  const { value } = t0;\n  const arr = [{ value: \"foo\" }, { value: \"bar\" }, { value }];\n  useIdentity();\n  const derived = Array.from(arr).map(mutateAndReturn);\n  let t1;\n  if ($[0] !== derived) {\n    t1 = derived.at(0);\n    $[0] = derived;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  let t2;\n  if ($[2] !== derived) {\n    t2 = derived.at(-1);\n    $[2] = derived;\n    $[3] = t2;\n  } else {\n    t2 = $[3];\n  }\n  let t3;\n  if ($[4] !== t1 || $[5] !== t2) {\n    t3 = (\n      <Stringify>\n        {t1}\n        {t2}\n      </Stringify>\n    );\n    $[4] = t1;\n    $[5] = t2;\n    $[6] = t3;\n  } else {\n    t3 = $[6];\n  }\n  return t3;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with Memo Block Optimization\nDESCRIPTION: This snippet shows the original implementation of the 'MyApp' React component. It demonstrates the use of hooks, custom functions, and a potential issue with non-reactive variables in memo blocks. The component takes a 'count' prop and returns an array 'thing'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-invalid-pruned-scope-leaks-value.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport invariant from 'invariant';\nimport {makeObject_Primitives, mutate, sum, useIdentity} from 'shared-runtime';\n\n/**\n * Here, `z`'s original memo block is removed due to the inner hook call.\n * However, we also infer that `z` is non-reactive, so by default we would create\n * the memo block for `thing = [y, z]` as only depending on `y`.\n *\n * This could then mean that `thing[1]` and `z` may not refer to the same value,\n * since z recreates every time but `thing` doesn't correspondingly invalidate.\n *\n * The fix is to consider pruned memo block outputs as reactive, since they will\n * recreate on every render. This means `thing` depends on both y and z.\n */\nfunction MyApp({count}) {\n  const z = makeObject_Primitives();\n  const x = useIdentity(2);\n  const y = sum(x, count);\n  mutate(z);\n  const thing = [y, z];\n  if (thing[1] !== z) {\n    invariant(false, 'oh no!');\n  }\n  return thing;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: MyApp,\n  params: [{count: 2}],\n  sequentialRenders: [{count: 2}, {count: 2}, {count: 3}],\n};\n```\n\n----------------------------------------\n\nTITLE: Rendering Button List in React (Input Version)\nDESCRIPTION: This React component takes a list of buttons as props, separates the primary button, and renders the secondary buttons with alternating left/right styles. It uses the StaticText1 and Stringify components from 'shared-runtime'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-undefined-expression-of-jsxexpressioncontainer.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {StaticText1, Stringify, Text} from 'shared-runtime';\n\nfunction Component(props) {\n  const {buttons} = props;\n  const [primaryButton, ...nonPrimaryButtons] = buttons;\n\n  const renderedNonPrimaryButtons = nonPrimaryButtons.map((buttonProps, i) => (\n    <Stringify\n      {...buttonProps}\n      key={`button-${i}`}\n      style={\n        i % 2 === 0 ? styles.leftSecondaryButton : styles.rightSecondaryButton\n      }\n    />\n  ));\n\n  return <StaticText1>{renderedNonPrimaryButtons}</StaticText1>;\n}\n\nconst styles = {\n  leftSecondaryButton: {left: true},\n  rightSecondaryButton: {right: true},\n};\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\n    {\n      buttons: [\n        {},\n        {type: 'submit', children: ['Submit!']},\n        {type: 'button', children: ['Reset']},\n      ],\n    },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Optimization\nDESCRIPTION: Compiler-optimized version of the component that includes memoization logic to prevent unnecessary array creation. Uses React compiler runtime utilities to cache computed values and resulting arrays.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-with-assignment-as-update.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  let x = props.init;\n  for (let i = 0; i < 100; i = i + 1) {\n    x = x + i;\n  }\n  let t0;\n  if ($[0] !== x) {\n    t0 = [x];\n    $[0] = x;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ init: 0 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Invalid Conditional Hook Usage in React Component\nDESCRIPTION: Example of incorrect hook usage where the hook call is made conditionally using optional chaining. This violates React's Rules of Hooks which require hooks to be called in a consistent order and unconditionally.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-hook-optional-property.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component() {\n  const {result} = Module?.useConditionalHook() ?? {};\n  return result;\n}\n```\n\nLANGUAGE: text\nCODE:\n```\n  1 | function Component() {\n> 2 |   const {result} = Module?.useConditionalHook() ?? {};\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^ InvalidReact: Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning) (2:2)\n  3 |   return result;\n  4 | }\n  5 |\n```\n\n----------------------------------------\n\nTITLE: Downloading React DevTools Dependencies from CI\nDESCRIPTION: These commands download the latest experimental build of React DevTools dependencies from CI. They should be run from the scripts/release/ directory.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools-inline/README.md#2025-04-21_snippet_11\n\nLANGUAGE: sh\nCODE:\n```\nyarn\n./download-experimental-build.js --commit=main\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: A React component that generates an array of div elements based on a prop value 'b'. The component uses a while loop to create 10 div elements when a global condition is true.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-missing-dependency-if-within-while.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst someGlobal = true;\nexport default function Component(props) {\n  const {b} = props;\n  const items = [];\n  let i = 0;\n  while (i < 10) {\n    if (someGlobal) {\n      items.push(<div key={i}>{b}</div>);\n      i++;\n    }\n  }\n  return <>{items}</>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{b: 42}],\n  sequentialRenders: [\n    {b: 0},\n    {b: 0},\n    {b: 42},\n    {b: 42},\n    {b: 0},\n    {b: 42},\n    {b: 0},\n    {b: 42},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Using useMemo for Memoization in React JavaScript\nDESCRIPTION: This snippet demonstrates the use of the useMemo hook to optimize component re-renders by memoizing the computed values based on specific dependencies. It defines a function 'useHook' that takes an input and returns an array composed of the input and a nested property, while ensuring dependencies are managed properly. The snippet is designed for use in React and has specific considerations regarding memoization guarantees.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.useMemo-aliased-var.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees\n\n// This is technically a false positive, but source is already breaking\n// `exhaustive-deps` lint rule (and can be considered invalid).\nfunction useHook(x) {\n  const aliasedX = x;\n  const aliasedProp = x.y.z;\n\n  return useMemo(() => [x, x.y.z], [aliasedX, aliasedProp]);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Optimization\nDESCRIPTION: Compiler-optimized version of the component using memo cache sentinel pattern for performance. Implements memoization to prevent unnecessary handler recreation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/concise-arrow-expr.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction component() {\n  const $ = _c(1);\n  const [, setX] = useState(0);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const handler = (v) => setX(v);\n    t0 = <Foo handler={handler} />;\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n```\n\n----------------------------------------\n\nTITLE: Input React Component with useSpecialEffect\nDESCRIPTION: The original React component using useSpecialEffect hooks with two different dependency configurations. The first case expects automatic dependency inference while the second provides explicit dependencies.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/infer-deps-custom-config.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @inferEffectDependencies\nimport {print, useSpecialEffect} from 'shared-runtime';\n\nfunction CustomConfig({propVal}) {\n  // Insertion\n  useSpecialEffect(() => print(propVal), [propVal]);\n  // No insertion\n  useSpecialEffect(() => print(propVal), [propVal], [propVal]);\n}\n\n```\n\n----------------------------------------\n\nTITLE: React Component Definition\nDESCRIPTION: This code defines a React component named `Component` that receives a `statusName` as input. It utilizes helper functions `foo` and `getStyles` to determine text and styling based on the input. The component renders a `div` with a nested `span`, applying CSS classes determined by the styling functions.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/sequential-destructuring-both-mixed-local-and-scope-declaration.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {identity} from 'shared-runtime';\n\nfunction Component(statusName) {\n  // status is local, text is a scope declaration\n  const {status, text} = foo(statusName);\n  // color is local, font is a scope declaration\n  const {color, font} = getStyles(status);\n  // bg is a declaration\n  const bg = identity(color);\n  return (\n    <div className={bg}>\n      <span className={font}>{[text]}</span>\n    </div>\n  );\n}\nfunction foo(name) {\n  return {\n    status: `<status>`,\n    text: `${name}!`,\n  };\n}\n\nfunction getStyles(status) {\n  return {\n    font: 'comic-sans',\n    color: '#657b83',\n  };\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: ['Sathya'],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Implementing a React Component - JavaScript\nDESCRIPTION: This snippet demonstrates the creation of a React component that improperly uses a hook as a regular value. The use of `useFoo` as a prop without invocation leads to an error. No dependencies are explicitly mentioned, but React is assumed. The key parameter is `props`, and the output is a JSX element. The snippet highlights the importance of using hooks correctly in React.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-pass-hook-as-prop.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  return <Child foo={useFoo} />;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing React Counter Component\nDESCRIPTION: This snippet defines a React component with a counter using useState hook. It renders a counter value, a button to increment it, and uses a custom Stringify component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/merge-consecutive-scopes.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useState} from 'react';\nimport {Stringify} from 'shared-runtime';\n\nfunction Component() {\n  let [state, setState] = useState(0);\n  return (\n    <div>\n      <Stringify text=\"Counter\" />\n      <span>{state}</span>\n      <button data-testid=\"button\" onClick={() => setState(state + 1)}>\n        increment\n      </button>\n    </div>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: 42}],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component Definition\nDESCRIPTION: This code defines a simple React component named 'Component' that receives 'props' as input. It creates an array containing the 'count' prop, an object using 'makeObject_Primitives', and renders a div containing the array. The component also logs the created object to the console. The 'FIXTURE_ENTRYPOINT' provides a way to invoke the component with predefined parameters for testing.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/dont-merge-overlapping-scopes-store-const-used-later.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {Stringify, makeObject_Primitives} from 'shared-runtime';\n\nfunction Component(props) {\n  const array = [props.count];\n  const x = makeObject_Primitives();\n  const element = <div>{array}</div>;\n  console.log(x);\n  return <div>{element}</div>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{count: 42}],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Conditional Memoization in React Component\nDESCRIPTION: This snippet defines a React component that uses useMemo to conditionally render based on propA and propB. It demonstrates how to optimize rendering performance by memoizing computed values.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useMemo-conditional-access-own-scope.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees\nimport {useMemo} from 'react';\n\nfunction Component({propA, propB}) {\n  return useMemo(() => {\n    if (propA) {\n      return {\n        value: propB.x.y,\n      };\n    }\n  }, [propA, propB.x.y]);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{propA: 1, propB: {x: {y: []}}}],\n};\n```\n\n----------------------------------------\n\nTITLE: Initializing React Component with Global Variable Mutation\nDESCRIPTION: A React component that attempts to modify a global variable, which is considered an anti-pattern and violates React's component purity principles. This approach can lead to unexpected rendering and state management issues.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.assign-global-in-jsx-spread-attribute.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component() {\n  const foo = () => {\n    someGlobal = true;\n  };\n  return <div {...foo} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a React Component with State Management in JavaScript\nDESCRIPTION: This snippet defines a component function utilizing the React compiler runtime, which helps manage state more effectively. It checks if the input 'a' has changed and either creates a new object or returns an existing one based on changes, thus optimizing performance. The returned object maintains the internal state with nested structures. It exports a fixture entry point similar to the simpler version, facilitating integration into React.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-mutate-nested.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction component(a) {\n  const $ = _c(2);\n  let y;\n  if ($[0] !== a) {\n    y = { b: { a } };\n    const x = function () {\n      y.b.a = 2;\n    };\n\n    x();\n    $[0] = a;\n    $[1] = y;\n  } else {\n    y = $[1];\n  }\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n\n```\n\n----------------------------------------\n\nTITLE: Optimized React Compiler Output for Optional Chaining\nDESCRIPTION: This snippet shows the compiled and optimized version of the 'useFoo' hook. It demonstrates how the React compiler handles optional chaining and implements memoization for improved performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/nested-optional-chains.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { identity } from \"shared-runtime\";\n\n/**\n * identity(...)?.toString() is the outer optional, and prop?.value is the inner\n * one.\n * Note that prop?.\n */\nfunction useFoo(t0) {\n  const $ = _c(15);\n  const { prop1, prop2, prop3, prop4, prop5, prop6 } = t0;\n  let t1;\n  if ($[0] !== prop1?.value) {\n    t1 = identity(prop1?.value)?.toString();\n    $[0] = prop1?.value;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  const x = t1;\n  let t2;\n  if ($[2] !== prop2?.inner.value) {\n    t2 = identity(prop2?.inner.value)?.toString();\n    $[2] = prop2?.inner.value;\n    $[3] = t2;\n  } else {\n    t2 = $[3];\n  }\n  const y = t2;\n  let t3;\n  if ($[4] !== prop3 || $[5] !== prop4?.inner) {\n    t3 = prop3?.fn(prop4?.inner.value).toString();\n    $[4] = prop3;\n    $[5] = prop4?.inner;\n    $[6] = t3;\n  } else {\n    t3 = $[6];\n  }\n  const z = t3;\n  let t4;\n  if ($[7] !== prop5 || $[8] !== prop6?.inner) {\n    t4 = prop5?.fn(prop6?.inner.value)?.toString();\n    $[7] = prop5;\n    $[8] = prop6?.inner;\n    $[9] = t4;\n  } else {\n    t4 = $[9];\n  }\n  const zz = t4;\n  let t5;\n  if ($[10] !== x || $[11] !== y || $[12] !== z || $[13] !== zz) {\n    t5 = [x, y, z, zz];\n    $[10] = x;\n    $[11] = y;\n    $[12] = z;\n    $[13] = zz;\n    $[14] = t5;\n  } else {\n    t5 = $[14];\n  }\n  return t5;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [\n    {\n      prop1: null,\n      prop2: null,\n      prop3: null,\n      prop4: null,\n      prop5: null,\n      prop6: null,\n    },\n  ],\n\n  sequentialRenders: [\n    {\n      prop1: null,\n      prop2: null,\n      prop3: null,\n      prop4: null,\n      prop5: null,\n      prop6: null,\n    },\n    {\n      prop1: { value: 2 },\n      prop2: { inner: { value: 3 } },\n      prop3: { fn: identity },\n      prop4: { inner: { value: 4 } },\n      prop5: { fn: identity },\n      prop6: { inner: { value: 4 } },\n    },\n    {\n      prop1: { value: 2 },\n      prop2: { inner: { value: 3 } },\n      prop3: { fn: identity },\n      prop4: { inner: { value: 4 } },\n      prop5: { fn: identity },\n      prop6: { inner: { value: undefined } },\n    },\n    {\n      prop1: { value: 2 },\n      prop2: { inner: { value: undefined } },\n      prop3: { fn: identity },\n      prop4: { inner: { value: undefined } },\n      prop5: { fn: identity },\n      prop6: { inner: { value: undefined } },\n    },\n    {\n      prop1: { value: 2 },\n      prop2: {},\n      prop3: { fn: identity },\n      prop4: {},\n      prop5: { fn: identity },\n      prop6: { inner: { value: undefined } },\n    },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with Memoized View (Input)\nDESCRIPTION: This snippet defines a React component that renders a list of items using a memoized `View` component. The `View` component uses `React.memo` to prevent unnecessary re-renders when the `items` prop doesn't change. `FIXTURE_ENTRYPOINT` specifies the initial data for the component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/outlining-in-react-memo.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  return <View {...props} />;\n}\n\nconst View = React.memo(({items}) => {\n  return (\n    <ul>\n      {items.map(item => (\n        <li key={item.id}>{item.name}</li>\n      ))}\n    </ul>\n  );\n});\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\n    {\n      items: [\n        {id: 2, name: 'foo'},\n        {id: 3, name: 'bar'},\n      ],\n    },\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Validating React Hooks Usage\nDESCRIPTION: This snippet checks the validity of using React hooks, such as useState and useCallback. It highlights potential pitfalls with inline requires and warns about dangerous patterns. It's designed to recognize expected usages and identify false positives, which may lead to confusion due to naming conventions associated with hooks.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.invalid.invalid-rules-of-hooks-191029ac48c8.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @skip\n// Passed but should have failed\n\n// Invalid because it's dangerous.\n// Normally, this would crash, but not if you use inline requires.\n// This *must* be invalid.\n// It's expected to have some false positives, but arguably\n// they are confusing anyway due to the use*() convention\n// already being associated with Hooks.\nuseState();\nif (foo) {\n  const foo = React.useCallback(() => {});\n}\nuseCustomHook();\n\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Fire and Memoization - JavaScript\nDESCRIPTION: This snippet defines a more optimized version of a React component that uses memoization to prevent unnecessary reassignments of functions and additional calls to fire. It tracks previous values and conditions before executing effects.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/shared-hook-calls.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c, useFire } from \"react/compiler-runtime\"; // @enableFire\nimport { fire } from \"react\";\n\nfunction Component(t0) {\n  const $ = _c(9);\n  const { bar, baz } = t0;\n  let t1;\n  if ($[0] !== bar) {\n    t1 = () => {\n      console.log(bar);\n    };\n    $[0] = bar;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  const foo = t1;\n  const t2 = useFire(foo);\n  const t3 = useFire(baz);\n  let t4;\n  if ($[2] !== bar || $[3] !== t2 || $[4] !== t3) {\n    t4 = () => {\n      t2(bar);\n      t3(bar);\n    };\n    $[2] = bar;\n    $[3] = t2;\n    $[4] = t3;\n    $[5] = t4;\n  } else {\n    t4 = $[5];\n  }\n  useEffect(t4);\n  let t5;\n  if ($[6] !== bar || $[7] !== t2) {\n    t5 = () => {\n      t2(bar);\n    };\n    $[6] = bar;\n    $[7] = t2;\n    $[8] = t5;\n  } else {\n    t5 = $[8];\n  }\n  useEffect(t5);\n  return null;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: Transformed version of the component with added memoization using Symbol.for checks. Includes compiler runtime imports and caching mechanism for object and JSX elements.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/numeric-literal-as-object-property-key.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Test() {\n  const $ = _c(2);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = { 21: \"dimaMachina\" };\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const obj = t0;\n\n  const { 21: myVar } = obj;\n  let t1;\n  if ($[1] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = (\n      <div>\n        {obj[21]}\n        {myVar}\n      </div>\n    );\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Test,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Components with Forget Directive\nDESCRIPTION: React components Bar, NoForget, and Foo implementing the 'use forget' directive for optimization. Includes an export for fixture testing.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/gating-test-export-function-and-default.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @gating @compilationMode(annotation)\nexport default function Bar(props) {\n  'use forget';\n  return <div>{props.bar}</div>;\n}\n\nfunction NoForget(props) {\n  return <Bar>{props.noForget}</Bar>;\n}\n\nfunction Foo(props) {\n  'use forget';\n  if (props.bar < 0) {\n    return props.children;\n  }\n  return (\n    <Foo bar={props.bar - 1}>\n      <NoForget />\n    </Foo>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: eval('Bar'),\n  params: [{bar: 2}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a Memoized React Component - JavaScript\nDESCRIPTION: This snippet defines a more complex React component named 'Component' that uses a memoization cache via React's compiler runtime. It checks if the first cached value is a sentinel and assigns a new object if so; otherwise, it directly retrieves the cached value. The snippet returns a memoized array. The input parameters include component props, and the output is a memoized array containing the component state.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/globals-Number.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = {};\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const x = t0;\n  const y = Number(x);\n  let t1;\n  if ($[1] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = [x, y];\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiled Memoization Function with React Compiler Runtime\nDESCRIPTION: Optimized version of useFoo function using React's compiler runtime to manage memoization with explicit cache and dependency tracking\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useMemo-invoke-prop.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @validatePreserveExistingMemoizationGuarantees\n\nimport { useMemo } from \"react\";\n\nfunction useFoo(t0) {\n  const $ = _c(2);\n  const { callback } = t0;\n  let t1;\n  let t2;\n  if ($[0] !== callback) {\n    t2 = new Array(callback());\n    $[0] = callback;\n    $[1] = t2;\n  } else {\n    t2 = $[1];\n  }\n  t1 = t2;\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [\n    {\n      callback: () => {\n        \"use no forget\";\n        return [1, 2, 3];\n      },\n    },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with FBT Optimization\nDESCRIPTION: This snippet shows the compiled and optimized version of the React component using FBT. It includes performance optimizations such as caching and conditional rendering based on prop changes. The compiled code demonstrates how FBT translates the internationalization markup into efficient JavaScript.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbs-params.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { fbs } from \"fbt\";\n\nfunction Component(props) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== props.name) {\n    t0 = (\n      <div\n        title={fbs._(\n          \"Hello {user name}\",\n          [fbs._param(\"user name\", props.name)],\n          { hk: \"2zEDKF\" },\n        )}\n      >\n        Hover me\n      </div>\n    );\n    $[0] = props.name;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ name: \"Sathya\" }],\n};\n```\n\n----------------------------------------\n\nTITLE: Error Output for Generator in useMemo\nDESCRIPTION: This error message indicates that the use of a YieldExpression within the useMemo hook is not currently supported. It points to the specific line where the yield statement is used.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.useMemo-callback-generator.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n  4 |   // add support for generators in the future.\n  5 |   let x = useMemo(function* () {\n> 6 |     yield a;\n    |     ^^^^^^^ Todo: (BuildHIR::lowerExpression) Handle YieldExpression expressions (6:6)\n  7 |   }, []);\n  8 |   return x;\n  9 | }\n```\n\n----------------------------------------\n\nTITLE: Compiled Router Component with React Runtime\nDESCRIPTION: Compiled version of the Router component using React compiler runtime with caching mechanism for optimization. Includes the same test fixture setup but with proper string escaping.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-of-immutable-collection.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Router(t0) {\n  const $ = _c(3);\n  const { title, mapping } = t0;\n  let array;\n  if ($[0] !== mapping || $[1] !== title) {\n    array = [];\n    for (const [, entry] of mapping) {\n      array.push([title, entry]);\n    }\n    $[0] = mapping;\n    $[1] = title;\n    $[2] = array;\n  } else {\n    array = $[2];\n  }\n  return array;\n}\n\nconst routes = new Map([\n  [\"about\", \"/about\"],\n  [\"contact\", \"/contact\"],\n]);\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Router,\n  params: [],\n  sequentialRenders: [\n    {\n      title: \"Foo\",\n      mapping: routes,\n    },\n    {\n      title: \"Bar\",\n      mapping: routes,\n    },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component with FBT Internationalization\nDESCRIPTION: A React component using the FBT internationalization library to display localized messages with dynamic parameters. The component renders a greeting with the user's name and available actions.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-params.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport fbt from 'fbt';\n\nfunction Component(props) {\n  return (\n    <div>\n      <fbt desc={'Dialog to show to user'}>\n        Hello <fbt:param name=\"user name\">{props.name}</fbt:param>\n      </fbt>\n      <fbt desc={'Available actions|response'}>\n        <fbt:param name=\"actions|response\">{props.actions}</fbt:param>\n      </fbt>\n    </div>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Code with Memoization and Caching\nDESCRIPTION: This snippet shows the compiled version of the previous code, including React compiler optimizations. It introduces memoization using Symbol.for(\"react.memo_cache_sentinel\") and caches the result of the testFunction.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/mutable-lifetime-loops.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction mutate(x, y) {\n  \"use no forget\";\n  if (x != null) {\n    x.value = (x.value ?? 0) + 1;\n  }\n  if (y != null) {\n    y.value = (y.value ?? 0) + 1;\n  }\n}\nfunction cond(x) {\n  \"use no forget\";\n  return x.value > 5;\n}\n\nfunction testFunction(props) {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    let a = {};\n    let b = {};\n    let c = {};\n    let d = {};\n    while (true) {\n      const z = a;\n      a = b;\n      b = c;\n      c = d;\n      d = z;\n      mutate(a, b);\n      if (cond(a)) {\n        break;\n      }\n    }\n    if (a) {\n    }\n    if (b) {\n    }\n    if (c) {\n    }\n    if (d) {\n    }\n\n    mutate(d, null);\n    t0 = { a, b, c, d };\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: testFunction,\n  params: [{}],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with Memoized View (Code with compiler)\nDESCRIPTION: This code snippet demonstrates how the React compiler runtime optimizes a React component using internal caching mechanisms. The `_c` function is part of the compiler runtime and helps to cache intermediate results to avoid redundant computations.  The `View` component is memoized to prevent unnecessary re-renders by checking if the `items` prop has changed.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/outlining-in-react-memo.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== props) {\n    t0 = <View {...props} />;\n    $[0] = props;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\nconst View = React.memo((t0) => {\n  const $ = _c(4);\n  const { items } = t0;\n  let t1;\n  if ($[0] !== items) {\n    t1 = items.map(_temp);\n    $[0] = items;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  let t2;\n  if ($[2] !== t1) {\n    t2 = <ul>{t1}</ul>;\n    $[2] = t1;\n    $[3] = t2;\n  } else {\n    t2 = $[3];\n  }\n  return t2;\n});\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\n    {\n      items: [\n        { id: 2, name: \"foo\" },\n        { id: 3, name: \"bar\" },\n      ],\n    },\n  ],\n};\nfunction _temp(item) {\n  return <li key={item.id}>{item.name}</li>;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Initializing React Component with useMemo and Switch\nDESCRIPTION: A React functional component that uses useMemo to memoize a computed value based on different prop switch cases, returning a value conditionally\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-switch-return.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const x = useMemo(() => {\n    let y;\n    switch (props.switch) {\n      case 'foo': {\n        return 'foo';\n      }\n      case 'bar': {\n        y = 'bar';\n        break;\n      }\n      default: {\n        y = props.y;\n      }\n    }\n    return y;\n  });\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a React Component Functionality - JavaScript\nDESCRIPTION: This snippet defines a React functional component named 'Component' that processes props. It creates an object using 'makeObject' and uses a ternary operator to determine which prop to utilize based on the object's property 'a'. It is important to note that the first snippet contains an unused variable declaration for a cleaner implementation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unused-ternary-assigned-to-variable.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  // unused!\n  const obj = makeObject();\n  const _ = obj.a ? props.b : props.c;\n  return null;\n}\n\n```\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const obj = makeObject();\n  obj.a ? props.b : props.c;\n  return null;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Mutating Data with Conditions in JavaScript\nDESCRIPTION: This snippet defines a function called useFoo, which uses conditionals to determine how to manipulate an array before calling a mutate function. It requires the \"shared-runtime\" module, and the expected input includes an object with properties \"bar\", \"foo\", and \"cond\". The output is an array that has been mutated based on the provided conditions.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/ssa-renaming-with-mutation.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\n// @enablePropagateDepsInHIR\\nimport {mutate} from 'shared-runtime';\\n\\nfunction useFoo(props) {\\n  let x = [];\\n  x.push(props.bar);\\n  if (props.cond) {\\n    x = {};\\n    x = [];\\n    x.push(props.foo);\\n  }\\n  mutate(x);\\n  return x;\\n}\\n\\nexport const FIXTURE_ENTRYPOINT = {\\n  fn: useFoo,\\n  params: [{bar: 'bar', foo: 'foo', cond: true}],\\n  sequentialRenders: [\\n    {bar: 'bar', foo: 'foo', cond: true},\\n    {bar: 'bar', foo: 'foo', cond: true},\\n    {bar: 'bar', foo: 'foo', cond: false},\\n  ],\\n};\\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with compiler-runtime\nDESCRIPTION: This is the compiled version of the React component using `react/compiler-runtime`. It optimizes the component by using a mutable object to store intermediate values and track prop changes for memoization. The compiled code uses `_c` from `react/compiler-runtime` and labels for branching.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-multiple-if-else.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useMemo } from \"react\";\n\nfunction Component(props) {\n  const $ = _c(6);\n  let t0;\n  bb0: {\n    let y;\n    if (\n      $[0] !== props.a ||\n      $[1] !== props.b ||\n      $[2] !== props.cond ||\n      $[3] !== props.cond2\n    ) {\n      y = [];\n      if (props.cond) {\n        y.push(props.a);\n      }\n      if (props.cond2) {\n        t0 = y;\n        break bb0;\n      }\n\n      y.push(props.b);\n      $[0] = props.a;\n      $[1] = props.b;\n      $[2] = props.cond;\n      $[3] = props.cond2;\n      $[4] = y;\n      $[5] = t0;\n    } else {\n      y = $[4];\n      t0 = $[5];\n    }\n    t0 = y;\n  }\n  const x = t0;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ a: 1, b: 2, cond2: false }],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Compiler Runtime\nDESCRIPTION: The compiler-optimized version of the component that implements memoization using React's compiler runtime to avoid unnecessary object creation and property deletion operations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/delete-property.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(3);\n  let x;\n  if ($[0] !== props.a || $[1] !== props.b) {\n    x = { a: props.a, b: props.b };\n    delete x.b;\n    $[0] = props.a;\n    $[1] = props.b;\n    $[2] = x;\n  } else {\n    x = $[2];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Input: React Conditional Array Population Function\nDESCRIPTION: A function that conditionally populates an array based on input object properties, with early return logic for null objects\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-cond-deps-return-in-scope.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction useFoo({obj, objIsNull}) {\n  const x = [];\n  if (objIsNull) {\n    return;\n  } else {\n    x.push(obj.a);\n  }\n  x.push(obj.b);\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: A React component using various hooks (useState, useEffect, useContext) with a custom context implementation. The component manages state, performs side effects, and uses context values through hooks.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/flag-enable-emit-hook-guards.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableEmitHookGuards\nimport {createContext, useContext, useEffect, useState} from 'react';\nimport {\n  CONST_STRING0,\n  ObjectWithHooks,\n  getNumber,\n  identity,\n  print,\n} from 'shared-runtime';\n\nconst MyContext = createContext('my context value');\nfunction Component({value}) {\n  print(identity(CONST_STRING0));\n  const [state, setState] = useState(getNumber());\n  print(value, state);\n  useEffect(() => {\n    if (state === 4) {\n      setState(5);\n    }\n  }, [state]);\n  print(identity(value + state));\n  return ObjectWithHooks.useIdentity(useContext(MyContext));\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  args: [{value: 0}],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Hook Implementation\nDESCRIPTION: Defines a custom React hook that conditionally returns either an object with a getValue method or a number 42. Includes fixture setup for testing.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-literal-method-derived-in-ternary-consequent.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {identity, createHookWrapper} from 'shared-runtime';\n\nfunction useHook({isCond, value}) {\n  return isCond\n    ? identity({\n        getValue() {\n          return value;\n        },\n      })\n    : 42;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: createHookWrapper(useHook),\n  params: [{isCond: true, value: 0}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Component Logic and JSX Rendering with React - JavaScript\nDESCRIPTION: This snippet defines a functional React component that uses a state management approach to handle the rendering of either a primary or an alternate component based on the props received. It employs an inner MaybeMutable class to manage potential state changes. The JSX return statement reflects nested components with dynamic tags, influenced by the component's props.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-tag-evaluation-order-non-global.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {StaticText1, StaticText2} from 'shared-runtime';\n\nfunction MaybeMutable() {\n  return {};\n}\nfunction maybeMutate(x) {}\n\nfunction Component(props) {\n  const maybeMutable = new MaybeMutable();\n  let Tag = props.component;\n  // NOTE: the order of evaluation in the lowering is incorrect:\n  // the jsx element's tag observes `Tag` after reassignment, but should observe\n  // it before the reassignment.\n\n  // Currently, Forget preserves jsx whitespace in the source text.\n  // prettier-ignore\n  return (\n    <Tag>{((Tag = props.alternateComponent), maybeMutate(maybeMutable))}<Tag /></Tag>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{component: StaticText1, alternateComponent: StaticText2}],\n  isComponent: true,\n};\n```\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { StaticText1, StaticText2 } from \"shared-runtime\";\n\nfunction MaybeMutable() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = {};\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nfunction maybeMutate(x) {}\n\nfunction Component(props) {\n  const $ = _c(11);\n  let T0;\n  let Tag;\n  let t0;\n  if ($[0] !== props.alternateComponent || $[1] !== props.component) {\n    const maybeMutable = new MaybeMutable();\n    Tag = props.component;\n\n    T0 = Tag;\n    t0 = ((Tag = props.alternateComponent), maybeMutate(maybeMutable));\n    $[0] = props.alternateComponent;\n    $[1] = props.component;\n    $[2] = T0;\n    $[3] = Tag;\n    $[4] = t0;\n  } else {\n    T0 = $[2];\n    Tag = $[3];\n    t0 = $[4];\n  }\n  let t1;\n  if ($[5] !== Tag) {\n    t1 = <Tag />;\n    $[5] = Tag;\n    $[6] = t1;\n  } else {\n    t1 = $[6];\n  }\n  let t2;\n  if ($[7] !== T0 || $[8] !== t0 || $[9] !== t1) {\n    t2 = (\n      <T0>\n        {t0}\n        {t1}\n      </T0>\n    );\n    $[7] = T0;\n    $[8] = t0;\n    $[9] = t1;\n    $[10] = t2;\n  } else {\n    t2 = $[10];\n  }\n  return t2;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ component: StaticText1, alternateComponent: StaticText2 }],\n  isComponent: true,\n};\n```\n\n----------------------------------------\n\nTITLE: React Component Input with arrayPush\nDESCRIPTION: Defines a React component, `useFoo`, which accepts an object with properties `a` and `b` as input. It creates an object with property `a` and then pushes the value of `b` onto the keys of this object using `arrayPush` from `shared-runtime`. Finally, it exports a `FIXTURE_ENTRYPOINT` which provides the component function and its params.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/shapes-object-key.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {arrayPush} from 'shared-runtime';\n\nfunction useFoo({a, b}) {\n  const obj = {a};\n  arrayPush(Object.keys(obj), b);\n  return obj;\n}\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{a: 2, b: 3}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic React Component Logic with Loop\nDESCRIPTION: This snippet defines a basic React component that initializes a variable `x` based on the iteration count controlled by the `props.test` value. The component returns a reactive array containing `x`. The logic inside the loop decides the value of `x` based on the index `i`, capped at 10. The `props.test` value influences the loop execution, making `x` effectively reactive.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-do-while-test.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let x;\n  let i = 0;\n  do {\n    if (i > 10) {\n      x = 10;\n    } else {\n      x = 1;\n    }\n    i++;\n  } while (i < props.test);\n  // The values assigned to `x` are non-reactive, but the value of `x`\n  // depends on the \"control\" variable `i`, whose value is affected by\n  // `props.test` which is reactive.\n  // Therefore x should be treated as reactive too.\n  return [x];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  sequentialRenders: [\n    {test: 12},\n    {test: 12},\n    {test: 1},\n    {test: 1},\n    {test: 12},\n    {test: 1},\n    {test: 12},\n    {test: 1},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Validating React Component Memoization with useCallback in JavaScript\nDESCRIPTION: This snippet defines a React component called Foo that uses the useCallback hook to handle context variable dependencies. It includes logic to manage context variables and ensure memoization. Dependencies include react and shared-runtime.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useCallback-captures-reassigned-context-property.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useCallback} from 'react';\nimport {Stringify} from 'shared-runtime';\n\n/**\n * TODO: we're currently bailing out because `contextVar` is a context variable\n * and not recorded into the PropagateScopeDeps LoadLocal / PropertyLoad\n * sidemap. Previously, we were able to avoid this as `BuildHIR` hoisted\n * `LoadContext` and `PropertyLoad` instructions into the outer function, which\n * we took as eligible dependencies.\n *\n * One solution is to simply record `LoadContext` identifiers into the\n * temporaries sidemap when the instruction occurs *after* the context\n * variable's mutable range.\n */\nfunction Foo(props) {\n  let contextVar;\n  if (props.cond) {\n    contextVar = {val: 2};\n  } else {\n    contextVar = {};\n  }\n\n  const cb = useCallback(() => [contextVar.val], [contextVar.val]);\n\n  return <Stringify cb={cb} shouldInvokeFns={true} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{cond: true}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Using React Hooks for Local State Management in JavaScript\nDESCRIPTION: This snippet defines a React component using the useEffect and useIdentity hooks to manage local variables. The component attempts to reassign a local variable within hooks, leading to potential inconsistencies if React Compiler optimizations are enabled. Key dependencies include 'useEffect' and 'useIdentity' from 'shared-runtime'. The function expects a callback for identity updates and logs inconsistencies or throws errors based on the React Compiler's state.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-reassign-local-variable-in-hook-argument.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useEffect} from 'react';\nimport {useIdentity} from 'shared-runtime';\n\nfunction Component() {\n  let local;\n\n  const reassignLocal = newValue => {\n    local = newValue;\n  };\n\n  const callback = newValue => {\n    reassignLocal('hello');\n\n    if (local === newValue) {\n      // Without React Compiler, `reassignLocal` is freshly created\n      // on each render, capturing a binding to the latest `local`,\n      // such that invoking reassignLocal will reassign the same\n      // binding that we are observing in the if condition, and\n      // we reach this branch\n      console.log('`local` was updated!');\n    } else {\n      // With React Compiler enabled, `reassignLocal` is only created\n      // once, capturing a binding to `local` in that render pass.\n      // Therefore, calling `reassignLocal` will reassign the wrong\n      // version of `local`, and not update the binding we are checking\n      // in the if condition.\n      //\n      // To protect against this, we disallow reassigning locals from\n      // functions that escape\n      throw new Error('`local` not updated!');\n    }\n  };\n\n  useIdentity(() => {\n    callback();\n  });\n\n  return 'ok';\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Assignment Warning in React\nDESCRIPTION: This section highlights an error in the React component regarding variable reassignment after rendering. It indicates that reassigning the callback variable can lead to inconsistent behavior and advises using React state instead.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.function-expression-references-variable-its-assigned-to.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n  1 | function Component() {\n  2 |   let callback = () => {\n> 3 |     callback = null;\n    |     ^^^^^^^^ InvalidReact: Reassigning a variable after render has completed can cause inconsistent behavior on subsequent renders. Consider using state instead. Variable `callback` cannot be reassigned after render (3:3)\n  4 |   };\n  5 |   return <div onClick={callback} />;\n  6 | }\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Component in React with Global Dependencies\nDESCRIPTION: This snippet defines a React component that utilizes global utilities to create and stringify an array. The function parameter takes an object containing a number, which is used to initialize the array. The component utilizes 'Stringify' from shared-runtime to display the result of pushing the number into the array. It does not memoize 'Stringify' as it's a read from a global context.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/todo-global-load-cached.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {Stringify} from 'shared-runtime';\nimport {makeArray} from 'shared-runtime';\n\n/**\n * Here, we don't need to memoize Stringify as it is a read off of a global.\n * TODO: in PropagateScopeDeps (hir), we should produce a sidemap of global rvals\n * and avoid adding them to `temporariesUsedOutsideDefiningScope`.\n */\nfunction Component({num}: {num: number}) {\n  const arr = makeArray(num);\n  return <Stringify value={arr.push(num)}></Stringify>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{num: 2}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining Component Logic in React: Javascript\nDESCRIPTION: This snippet defines a basic React component function, which performs operations using input properties to compute a result. It relies on helper functions like 'foo' and 'bar', and utilizes array operations to derive its return value. Key operations include duplicating an array and accessing array elements by index.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-at-closure.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const x = foo(props.x);\n  const fn = function () {\n    const arr = [...bar(props)];\n    return arr.at(x);\n  };\n  const fnResult = fn();\n  return fnResult;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Original React Function with Conditional Rendering\nDESCRIPTION: A JavaScript function that conditionally creates an array and renders a div based on input parameters. Demonstrates basic React component logic with conditional rendering and array manipulation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-scopes.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction f(a, b) {\n  let x = []; // <- x starts being mutable here.\n  if (a.length === 1) {\n    if (b) {\n      x.push(b); // <- x stops being mutable here.\n    }\n  }\n\n  return <div>{x}</div>;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom React Hook with Conditional Logic\nDESCRIPTION: This snippet defines a custom React hook 'useTest' that uses conditional logic and another hook 'useHook'. It demonstrates the use of identity function and primitive object creation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-allocating-ternary-test-instruction-scope.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {identity, makeObject_Primitives} from 'shared-runtime';\n\nfunction useHook() {}\n\nfunction useTest({cond}) {\n  const val = makeObject_Primitives();\n\n  useHook();\n  /**\n   * We don't technically need a reactive scope for this ternary as\n   * it cannot produce newly allocated values.\n   * While identity(...) may allocate, we can teach the compiler that\n   * its result is only used as as a test condition\n   */\n  const result = identity(cond) ? val : null;\n  return result;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useTest,\n  params: [{cond: true}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Memoized Component in React - JavaScript\nDESCRIPTION: This snippet implements a memoized version of a React component that tracks whether the cache should be updated based on a sentinel value. If the cache is invalid, it initializes an array, processes it through a temporary function to update items, and returns the processed arrays. The component uses the 'react/compiler-runtime' import for memoization and expects props as input, outputting arrays based on internal logic.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-map-mutable-array-mutating-lambda-noAlias.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const x = [];\n    const y = x.map(_temp);\n    t0 = [x, y];\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\nfunction _temp(item) {\n  item.updated = true;\n  return item;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with useEffect\nDESCRIPTION: This snippet defines a React component 'Foo' using the useEffect hook to update a ref. It also exports a FIXTURE_ENTRYPOINT object for testing purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ref-parameter-mutate-in-effect.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useEffect} from 'react';\n\nfunction Foo(props, ref) {\n  useEffect(() => {\n    ref.current = 2;\n  }, []);\n  return <div>{props.bar}</div>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{bar: 'foo'}, {ref: {current: 1}}],\n  isComponent: true,\n};\n```\n\n----------------------------------------\n\nTITLE: React Hook Error Message\nDESCRIPTION: This error message highlights the problem of referencing a React hook as a normal value. The error indicates that hooks must be called directly and not passed around as regular values. The message also provides a link to the React documentation for more information.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.propertyload-hook.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n  1 | function Component() {\n> 2 |   const x = Foo.useFoo;\n    |             ^^^^^^^^^^ InvalidReact: Hooks may not be referenced as normal values, they must be called. See https://react.dev/reference/rules/react-calls-components-and-hooks#never-pass-around-hooks-as-regular-values (2:2)\n\nInvalidReact: Hooks may not be referenced as normal values, they must be called. See https://react.dev/reference/rules/react-calls-components-and-hooks#never-pass-around-hooks-as-regular-values (3:3)\n  3 |   return x();\n  4 | }\n  5 |\n\n```\n\n----------------------------------------\n\nTITLE: Defining useFoo Function with Optional Chaining - JavaScript\nDESCRIPTION: This snippet defines the 'useFoo' function which takes an object with property 'a', checks for nested properties using optional chaining, and returns an array of results. The function handles potential null or undefined values gracefully by utilizing the optional chaining operator.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-sequential-optional-chain-nonnull.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction useFoo({a}) {\n  let x = [];\n  x.push(a?.b.c?.d.e);\n  x.push(a.b?.c.d?.e);\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Error Message related to fire and useEffect\nDESCRIPTION: This error message indicates an issue with the dependency array used in conjunction with the `fire` function within a `useEffect` hook. Specifically, it arises when you attempt to use the spread operator (`...`) with `fire` and effect dependencies, signaling that an array literal must be used.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/error.invalid-rewrite-deps-spread.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n  13 |       fire(foo(props));\n  14 |     },\n> 15 |     ...deps\n     |        ^^^^ Invariant: Cannot compile `fire`. You must use an array literal for an effect dependency array when that effect uses `fire()` (15:15)\n  16 |   );\n  17 |\n  18 |   return null;\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: Compiled version of the component with added memoization logic. Uses array-based caching to prevent unnecessary recalculations of makeArray and at() operations when props haven't changed.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-annotations/type-annotation-as-array_.flow.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { identity, makeArray } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(4);\n  let t0;\n  if ($[0] !== props.id) {\n    t0 = makeArray(props.id);\n    $[0] = props.id;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const x = (t0: Array<number>);\n  let t1;\n  if ($[2] !== x) {\n    t1 = x.at(0);\n    $[2] = x;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  const y = t1;\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ id: 42 }],\n};\n```\n\n----------------------------------------\n\nTITLE: React Memo Implementation with Compiler Runtime\nDESCRIPTION: Implements React memo components with compiler runtime optimizations and feature flag conditional rendering. Includes caching mechanism using Symbol.for() checks.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/reassigned-fnexpr-variable.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { isForgetEnabled_Fixtures } from \"ReactForgetFeatureFlag\"; // @gating\nimport * as React from \"react\";\n\n/**\n * Test that the correct `Foo` is printed\n */\nlet Foo = isForgetEnabled_Fixtures()\n  ? () => {\n      const $ = _c(1);\n      let t0;\n      if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n        t0 = <div>hello world 1!</div>;\n        $[0] = t0;\n      } else {\n        t0 = $[0];\n      }\n      return t0;\n    }\n  : () => <div>hello world 1!</div>;\nconst MemoOne = React.memo(Foo);\nFoo = isForgetEnabled_Fixtures()\n  ? () => {\n      const $ = _c(1);\n      let t0;\n      if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n        t0 = <div>hello world 2!</div>;\n        $[0] = t0;\n      } else {\n        t0 = $[0];\n      }\n      return t0;\n    }\n  : () => <div>hello world 2!</div>;\nconst MemoTwo = React.memo(Foo);\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: () => {\n    \"use no memo\";\n    return (\n      <>\n        <MemoOne />\n        <MemoTwo />\n      </>\n    );\n  },\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing useFoo Hook with Variable Reassignment\nDESCRIPTION: A hook function that attempts to modify a closure variable directly, which can lead to unexpected rendering behavior in React. The code demonstrates an anti-pattern that React lints warn against.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-reassign-local-in-hook-return-value.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction useFoo() {\n  let x = 0;\n  return value => {\n    x = value;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: Simple React component that performs calculations using imported utility functions. Takes props with 'a' and 'b' values and returns an array of computed results.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/memoization-comments.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableMemoizationComments\nimport {addOne, getNumber, identity} from 'shared-runtime';\n\nfunction Component(props) {\n  const x = identity(props.a);\n  const y = addOne(x);\n  const z = identity(props.b);\n  return [x, y, z];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{a: 1, b: 10}],\n};\n```\n\n----------------------------------------\n\nTITLE: Using React.unstable_AsyncMode in JavaScript\nDESCRIPTION: Example of using the new React.unstable_AsyncMode API, which replaced React.unstable_AsyncComponent.\nSOURCE: https://github.com/facebook/react/blob/main/CHANGELOG.md#2025-04-21_snippet_19\n\nLANGUAGE: JavaScript\nCODE:\n```\n<React.unstable_AsyncMode>\n  <MyAsyncComponent />\n</React.unstable_AsyncMode>\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Array Operations and Memoization\nDESCRIPTION: This snippet shows a React component that uses the useFragment hook to fetch data, performs various array operations like flatMap and filter, and uses useMemo for optimization. It also includes Flow type checking annotations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-missing-memoization-lack-of-phi-types.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @flow @validatePreserveExistingMemoizationGuarantees\nimport {useMemo} from 'react';\nimport {useFragment} from 'shared-runtime';\n\nfunction Component() {\n  const data = useFragment();\n  const nodes = data.nodes ?? [];\n  const flatMap = nodes.flatMap(node => node.items);\n  const filtered = flatMap.filter(item => item != null);\n  const map = useMemo(() => filtered.map(), [filtered]);\n  const index = filtered.findIndex(x => x === null);\n\n  return (\n    <div>\n      {map}\n      {index}\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Conditional Returns\nDESCRIPTION: This snippet defines a React component 'Foo' that uses the useRef hook and returns different structures based on input conditions. It also exports a FIXTURE_ENTRYPOINT object for testing purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/return-ref-callback-structure.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @flow @validateRefAccessDuringRender @validatePreserveExistingMemoizationGuarantees\n\nimport {useRef} from 'react';\n\ncomponent Foo(cond: boolean, cond2: boolean) {\n  const ref = useRef();\n\n  const s = () => {\n    return ref.current;\n  };\n\n  if (cond) return [s];\n  else if (cond2) return {s};\n  else return {s: [s]};\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{cond: false, cond2: false}],\n};\n```\n\n----------------------------------------\n\nTITLE: Original Function Implementation in JavaScript\nDESCRIPTION: A JavaScript function that creates an array and an object, establishes a reference, mutates the object, and returns it.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-property-mutate.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo() {\n  const x = [];\n  const y = {};\n  y.x = x;\n  mutate(y);\n  return y;\n}\n```\n\n----------------------------------------\n\nTITLE: Original Function Implementation\nDESCRIPTION: The original function that creates and returns an object with conditional properties based on someVal condition. It demonstrates basic object property assignment and conditional logic.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/obj-literal-mutated-after-if-else.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(a, b, c, d) {\n  let x = {};\n  if (someVal) {\n    x = {b};\n  } else {\n    x = {c};\n  }\n\n  x.f = 1;\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: Compiled version of the component that includes React's internal memoization logic using compiler-runtime. Implements caching mechanism to avoid recreating the return array if inputs haven't changed.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rest-param-with-array-pattern.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(foo, ...t0) {\n  const $ = _c(3);\n  const [bar] = t0;\n  let t1;\n  if ($[0] !== bar || $[1] !== foo) {\n    t1 = [foo, bar];\n    $[0] = bar;\n    $[1] = foo;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\"foo\", [\"bar\", \"baz\"]],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining React Hook useFoo with Aliasing and Mutation\nDESCRIPTION: This code defines a React hook named `useFoo` that accepts an object with properties `a` and `b`. Inside the hook, an array `arr` and an object `obj` are created. The array is assigned to a property of the object using `setPropertyByKey`. An alias `obj_alias` is created for `obj`. A callback function `cb` is defined which accesses the length of the array through the alias. The code then pushes elements into the array inside a loop. Finally, it returns a `Stringify` component with the callback and a boolean prop.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/bug-aliased-capture-mutate.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @flow @enableTransitivelyFreezeFunctionExpressions:false\nimport {setPropertyByKey, Stringify} from 'shared-runtime';\n\n/**\n * Variation of bug in `bug-aliased-capture-aliased-mutate`\n * Found differences in evaluator results\n * Non-forget (expected):\n *   (kind: ok)\n *   <div>{\"cb\":{\"kind\":\"Function\",\"result\":2},\"shouldInvokeFns\":true}</div>\n *   <div>{\"cb\":{\"kind\":\"Function\",\"result\":3},\"shouldInvokeFns\":true}</div>\n * Forget:\n *   (kind: ok)\n *   <div>{\"cb\":{\"kind\":\"Function\",\"result\":2},\"shouldInvokeFns\":true}</div>\n *   <div>{\"cb\":{\"kind\":\"Function\",\"result\":2},\"shouldInvokeFns\":true}</div>\n */\n\nfunction useFoo({a}: {a: number, b: number}) {\n  const arr = [];\n  const obj = {value: a};\n\n  setPropertyByKey(obj, 'arr', arr);\n  const obj_alias = obj;\n  const cb = () => obj_alias.arr.length;\n  for (let i = 0; i < a; i++) {\n    arr.push(i);\n  }\n  return <Stringify cb={cb} shouldInvokeFns={true} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{a: 2}],\n  sequentialRenders: [{a: 2}, {a: 3}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Mutable State\nDESCRIPTION: This snippet defines a React component that uses mutable state and a closure. It imports a 'mutate' function and exports a FIXTURE_ENTRYPOINT object for testing purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-reference-changes-type.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {mutate} from 'shared-runtime';\nfunction Component({a}) {\n  let x = {a};\n  let y = 1;\n  (function () {\n    y = x;\n  })();\n  mutate(y);\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{a: 2}],\n  sequentialRenders: [{a: 2}, {a: 2}, {a: 3}],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component Implementation with useState\nDESCRIPTION: Original React component implementation showing variable declarations, state management with useState hook, and array return pattern. Demonstrates different variable declaration and reassignment patterns using const, let, and class.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/module-scoped-bindings.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport React from 'react';\nimport {useState} from 'react';\n\nconst CONST = true;\n\nlet NON_REASSIGNED_LET = true;\n\nlet REASSIGNED_LET = false;\nREASSIGNED_LET = true;\n\nfunction reassignedFunction() {}\nreassignedFunction = true;\n\nfunction nonReassignedFunction() {}\n\nclass ReassignedClass {}\nReassignedClass = true;\n\nclass NonReassignedClass {}\n\nfunction Component() {\n  const [state] = useState(null);\n  return [\n    React,\n    state,\n    CONST,\n    NON_REASSIGNED_LET,\n    REASSIGNED_LET,\n    reassignedFunction,\n    nonReassignedFunction,\n    ReassignedClass,\n    NonReassignedClass,\n  ];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimizing React Component with Memoization in JavaScript\nDESCRIPTION: This snippet shows an optimized version of the Component using React's compiler runtime. It implements memoization to cache results and improve performance for repeated renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/do-while-continue.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component() {\n  const $ = _c(1);\n  let ret;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const x = [0, 1, 2, 3];\n    ret = [];\n    do {\n      const item = x.pop();\n      if (item === 0) {\n        continue;\n      }\n\n      ret.push(item / 2);\n    } while (x.length);\n    $[0] = ret;\n  } else {\n    ret = $[0];\n  }\n  return ret;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Input: React Hook with Mutation Effects\nDESCRIPTION: Defines a React hook 'useFoo' that demonstrates mutation behavior and potential tearing effects. The code shows how mutations can affect memoized values after their memo blocks.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/mutation-within-capture-and-mutablerange.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {mutate} from 'shared-runtime';\n\n/**\n * This test fixture is similar to mutation-within-jsx. The only difference\n * is that there is no `freeze` effect here, which means that `z` may be\n * mutated after its memo block through mutating `y`.\n *\n * While this is technically correct (as `z` is a nested memo block), it\n * is an edge case as we believe that values are not mutated after their\n * memo blocks (which may lead to 'tearing', i.e. mutating one render's\n * values in a subsequent render.\n */\nfunction useFoo({a, b}) {\n  // x and y's scopes start here\n  const x = {a};\n  const y = [b];\n  mutate(x);\n  // z captures the result of `mutate(y)`, which may be aliased to `y`.\n  const z = [mutate(y)];\n  // the following line may also mutate z\n  mutate(y);\n  // and end here\n  return z;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{a: 2, b: 3}],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with useRef Hook and Test Fixture\nDESCRIPTION: This snippet defines a React component 'C' that uses the useRef hook to create a mutable reference. It initializes the reference to 1 if it's null. The code also exports a FIXTURE_ENTRYPOINT object for testing purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-ref-initialization.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useRef } from \"react\";\n\nfunction C() {\n  const r = useRef(null);\n  if (r.current == null) {\n    r.current = 1;\n  }\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: C,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Feature Flag Logic\nDESCRIPTION: Transformed version of the React component with compiled forget functionality. Includes conditional rendering based on feature flag and caching mechanism for optimized rendering.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/conflicting-gating-fn.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { isForgetEnabled_Fixtures as _isForgetEnabled_Fixtures } from \"ReactForgetFeatureFlag\"; // @gating\n\nexport const isForgetEnabled_Fixtures = () => {\n  \"use no forget\";\n  return false;\n};\n\nexport const Bar = _isForgetEnabled_Fixtures()\n  ? function Bar(props) {\n      \"use forget\";\n      const $ = _c(2);\n      let t0;\n      if ($[0] !== props.bar) {\n        t0 = <div>{props.bar}</div>;\n        $[0] = props.bar;\n        $[1] = t0;\n      } else {\n        t0 = $[1];\n      }\n      return t0;\n    }\n  : function Bar(props) {\n      \"use forget\";\n      return <div>{props.bar}</div>;\n    };\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: eval(\"Bar\"),\n  params: [{ bar: 2 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Hook and Callback\nDESCRIPTION: This snippet defines a React component that uses a custom hook to get an entity ID and creates a callback function for logging. It then renders a child component with the callback as a prop.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/function-expression-maybe-mutates-hook-return-value.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const id = useSelectedEntitytId();\n  // this example should infer `id` as mutable, and then infer `onLoad` as mutable,\n  // and be rejected because onLoad cannot be passed as a frozen value in the JSX.\n  // however, we likely have to allow this example to work, because hook return\n  // values are generally immutable in practice and are also widely referenced in\n  // callbacks.\n  const onLoad = () => {\n    log(id);\n  };\n  return <Foo onLoad={onLoad} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Original React Hook with useCallback\nDESCRIPTION: This snippet defines a React hook `useFoo` that uses `useCallback` to memoize a function. The memoized function calculates the sum of the elements in the `val` array.  The `FIXTURE_ENTRYPOINT` exports the hook for testing or usage.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useCallback-infer-read-dep.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees\nimport {useCallback} from 'react';\nimport {sum} from 'shared-runtime';\n\nfunction useFoo() {\n  const val = [1, 2, 3];\n\n  return useCallback(() => {\n    return sum(...val);\n  }, [val]);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom Hook with Object-Wrapped Callbacks in React\nDESCRIPTION: Defines a custom hook 'useMakeCallback' that returns an object containing callback functions that access array elements. The hook takes an object parameter with an 'arr' property and returns functions to access values from the array elements.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/return-object-of-functions.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n/**\n * Assume that only directly returned functions or JSX attributes are invoked.\n * Conservatively estimate that functions wrapped in objects or other containers\n * might never be called (and therefore their property loads are not hoistable).\n */\nfunction useMakeCallback({arr}) {\n  return {\n    getElement0: () => arr[0].value,\n    getElement1: () => arr[1].value,\n  };\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useMakeCallback,\n  params: [{arr: [1, 2]}],\n  sequentialRenders: [{arr: [1, 2]}, {arr: []}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: Optimized version of the component with memoized function dependencies and cached values. Uses compiler runtime utilities to manage state and prevent unnecessary recalculations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/functionexprconditional-access.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enableTreatFunctionDepsAsConditional\nfunction Component(props) {\n  const $ = _c(5);\n  let t0;\n  if ($[0] !== props.bar) {\n    t0 = function getLength() {\n      return props.bar.length;\n    };\n    $[0] = props.bar;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const getLength = t0;\n  let t1;\n  if ($[2] !== getLength || $[3] !== props.bar) {\n    t1 = props.bar && getLength();\n    $[2] = getLength;\n    $[3] = props.bar;\n    $[4] = t1;\n  } else {\n    t1 = $[4];\n  }\n  return t1;\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component 'Foo' with Memoization\nDESCRIPTION: This snippet shows the compiled version of the 'Foo' component, incorporating memoization using React's compiler runtime. It uses a Symbol to check if the memoized value needs to be recalculated.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/memoize-value-block-value-logical.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Foo(props) {\n  const $ = _c(1);\n  let x;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    true && ((x = []), null);\n    $[0] = x;\n  } else {\n    x = $[0];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing useFoo Hook in React (Input Version)\nDESCRIPTION: Original implementation of useFoo hook that creates and manipulates an array based on props. The function creates arrays, pushes values based on a condition property, and uses a shared utility function arrayPush.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-renaming-unconditional-ternary-with-mutation.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {arrayPush} from 'shared-runtime';\nfunction useFoo(props) {\n  let x = [];\n  x.push(props.bar);\n  props.cond\n    ? ((x = {}), (x = []), x.push(props.foo))\n    : ((x = []), (x = []), x.push(props.bar));\n  arrayPush(x, 4);\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{cond: false, foo: 2, bar: 55}],\n  sequentialRenders: [\n    {cond: false, foo: 2, bar: 55},\n    {cond: false, foo: 3, bar: 55},\n    {cond: true, foo: 3, bar: 55},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component Rendering with Conditional Logic\nDESCRIPTION: This code snippet uses a React component function with internal caching logic for rendering. It imports from 'react/compiler-runtime' and checks conditions to manage and optimize repeated renders. It uses the 'useRef' hook and evaluates conditions to reuse previous renders, minimizing unnecessary updates.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ref-current-not-added-to-dep-2.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @validateRefAccessDuringRender:false\nfunction Foo(t0) {\n  const $ = _c(4);\n  const { a } = t0;\n  const ref = useRef();\n  let t1;\n  if ($[0] !== a) {\n    t1 = { a, val: ref.current };\n    $[0] = a;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  const x = t1;\n  let t2;\n  if ($[2] !== x) {\n    t2 = <VideoList videos={x} />;\n    $[2] = x;\n    $[3] = t2;\n  } else {\n    t2 = $[3];\n  }\n  return t2;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Invalid Hook Usage in React Component\nDESCRIPTION: Example showing incorrect pattern of assigning a Hook to a variable and calling it, which violates React's rules of Hooks requiring consistent function references across renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-dynamic-hook-via-hooklike-local.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component() {\n  const someFunction = useContext(FooContext);\n  const useOhItsNamedLikeAHookNow = someFunction;\n  useOhItsNamedLikeAHookNow();\n}\n\n```\n\nLANGUAGE: text\nCODE:\n```\n  2 |   const someFunction = useContext(FooContext);\n  3 |   const useOhItsNamedLikeAHookNow = someFunction;\n> 4 |   useOhItsNamedLikeAHookNow();\n    |   ^^^^^^^^^^^^^^^^^^^^^^^^^ InvalidReact: Hooks must be the same function on every render, but this value may change over time to a different function. See https://react.dev/reference/rules/react-calls-components-and-hooks#dont-dynamically-use-hooks (4:4)\n  5 | }\n  6 |\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Change Detection Instrumentation\nDESCRIPTION: The compiled version of the component with React Compiler's change detection instrumentation added. It imports necessary runtime functions and adds structural comparison checks to detect and debug changes in the component's state.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/change-detect-reassign.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { $structuralCheck } from \"react-compiler-runtime\";\nimport { c as _c } from \"react/compiler-runtime\"; // @enableChangeDetectionForDebugging\nfunction Component(props) {\n  const $ = _c(2);\n  let x = null;\n  if (props.cond) {\n    {\n      x = [];\n      x.push(props.value);\n      let condition = $[0] !== props.value;\n      if (!condition) {\n        let old$x = $[1];\n        $structuralCheck(old$x, x, \"x\", \"Component\", \"cached\", \"(3:6)\");\n      }\n      $[0] = props.value;\n      $[1] = x;\n      if (condition) {\n        x = [];\n        x.push(props.value);\n        $structuralCheck($[1], x, \"x\", \"Component\", \"recomputed\", \"(3:6)\");\n        x = $[1];\n      }\n    }\n  }\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Optimizing React Component with Memoization\nDESCRIPTION: This snippet shows an optimized version of the React component using memoization and compiler-specific features. It uses a Symbol-based cache sentinel to determine whether to recompute the component's output or use a cached version.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-of-mutate.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { makeObject_Primitives, mutateAndReturn, toJSON } from \"shared-runtime\";\n\nfunction Component(_props) {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const collection = [makeObject_Primitives()];\n    const results = [];\n    for (const item of collection) {\n      results.push(\n        <div key={toJSON(item)}>{toJSON(mutateAndReturn(item))}</div>,\n      );\n    }\n\n    t0 = <div>{results}</div>;\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  isComponent: true,\n};\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with FBT for Internationalization in JavaScript\nDESCRIPTION: This snippet defines a React component 'Foo' that uses the FBT library to create an internationalized message. It takes two names as props and renders a message stating that these two people accepted the user's pull request.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-preserve-whitespace-two-subtrees.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport fbt from 'fbt';\n\nfunction Foo({name1, name2}) {\n  return (\n    <fbt desc=\"Text that is displayed when two people accepts the user's pull request.\">\n      <fbt:param name=\"user1\">\n        <span key={name1}>\n          <b>{name1}</b>\n        </span>\n      </fbt:param>\n      and\n      <fbt:param name=\"user2\">\n        <span key={name2}>\n          <b>{name2}</b>\n        </span>\n      </fbt:param>\n      accepted your PR!\n    </fbt>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{name1: 'Mike', name2: 'Jan'}],\n};\n```\n\n----------------------------------------\n\nTITLE: Example React Component Fixture with FIXTURE_ENTRYPOINT\nDESCRIPTION: Example of a React component fixture with the required FIXTURE_ENTRYPOINT export. This demonstrates how to set up a component for testing with Sprout.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/snap/src/sprout/README.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// test.js\nfunction MyComponent(props) {\n  return <div>{props.a + props.b}</div>;\n}\nexport const FIXTURE_ENTRYPOINT = {\n  fn: MyComponent,\n  params: [{a: \"hello \", b: \"world\"}],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized Functional Component with React Compiler - JavaScript\nDESCRIPTION: This snippet optimizes the previous component using React's experimental compiler runtime for efficient rendering. It handles state-like behavior through a cached approach to minimize unnecessary re-renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/non-null-assertion.expect.md#2025-04-21_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\ninterface ComponentProps {\n  name?: string;\n}\n\nfunction Component(props) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== props.name) {\n    t0 = props.name.toUpperCase();\n    $[0] = props.name;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ name: \"Alice\" }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Component Definition with JSX Outlining\nDESCRIPTION: This code defines a React component named `Component` which takes an array `arr` as a prop. It maps over this array twice, creating a nested structure of `Bar` and `Baz` components wrapped in JSX. The `@enableJsxOutlining` directive likely enables specific JSX outlining features in the environment.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-outlining-child-stored-in-id.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableJsxOutlining\nfunction Component({arr}) {\n  const x = useX();\n  return arr.map(i => {\n    <>\n      {arr.map((i, id) => {\n        let child = (\n          <Bar x={x}>\n            <Baz i={i}></Baz>\n          </Bar>\n        );\n\n        let jsx = <div>{child}</div>;\n        return jsx;\n      })}\n    </>;\n  });\n}\n\nfunction Bar({x, children}) {\n  return (\n    <>\n      {x}\n      {children}\n    </>\n  );\n}\n\nfunction Baz({i}) {\n  return <>{i}</>;\n}\n\nfunction useX() {\n  return 'x';\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{arr: ['foo', 'bar']}],\n};\n```\n\n----------------------------------------\n\nTITLE: Invalid React Hook Usage in Labeled Block\nDESCRIPTION: Demonstrates an invalid pattern where a React Hook is called within a labeled block statement that can be broken out of conditionally. This violates React's Rules of Hooks requiring hooks to be called in a consistent order and unconditionally.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-rules-of-hooks-49d341e5d68f.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Expected to fail\n\n// Invalid because it's dangerous and might not warn otherwise.\n// This *must* be invalid.\nfunction useLabeledBlock() {\n  label: {\n    if (a) break label;\n    useHook();\n  }\n}\n```\n\nLANGUAGE: text\nCODE:\n```\n   6 |   label: {\n   7 |     if (a) break label;\n>  8 |     useHook();\n     |     ^^^^^^^ InvalidReact: Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning) (8:8)\n   9 |   }\n  10 | }\n  11 |\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with useMemo for Memoization Testing\nDESCRIPTION: Original React component that uses useState and useMemo hooks to create and memoize an array. It includes multiple variable assignments and uses ValidateMemoization to verify the memoization is working correctly.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/existing-variables-with-c-name.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useMemo, useState} from 'react';\nimport {ValidateMemoization} from 'shared-runtime';\n\nfunction Component(props) {\n  const [state] = useState(0);\n  // Test for conflicts with `c` import\n  const c = state;\n  const _c = c;\n  const __c = _c;\n  const c1 = __c;\n  const $c = c1;\n  const array = useMemo(() => [$c], [state]);\n  return <ValidateMemoization inputs={[state]} output={array} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n  sequentialRenders: [{}, {}, {}],\n};\n```\n\n----------------------------------------\n\nTITLE: React Compiler Transformed Component with Memoization\nDESCRIPTION: The React Compiler version of the component with added memoization using the _c runtime function. It caches the returned function and only recreates it when props change, improving performance by avoiding unnecessary function recreation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reassigned-phi-in-returned-function-expression.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== props) {\n    t0 = () => {\n      let str;\n      if (arguments.length) {\n        str = arguments[0];\n      } else {\n        str = props.str;\n      }\n\n      global.log(str);\n    };\n    $[0] = props;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Conditional List Manipulation with React (JavaScript)\nDESCRIPTION: The Foo function takes a default list and a condition, generates a custom list using the makeArray function, and sorts it if the condition is true. It uses useHook from the shared-runtime, showcasing React paradigms for state or effect management. The function combines both sorting logic and conditional rendering based on the input parameters.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/value-block-mutates-outer-value.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {makeArray, useHook} from 'shared-runtime';\n\n/**\n * Here, the cond ? [...] : defaultList value block produces two\n * new values (each with its own scope):\n *   $0 = [\"text\"]\n *   $1 = { text: $0 }\n * The same value block also mutates customList, so it must be\n * merged with the scope producing customList\n */\nfunction Foo({defaultList, cond}) {\n  const comparator = (a, b) => a - b;\n  useHook();\n  const customList = makeArray(1, 5, 2);\n  useHook();\n  const result = cond\n    ? [...customList.sort(comparator), {text: ['text']}]\n    : defaultList;\n\n  return result;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{defaultList: [2, 4], cond: true}],\n};\n\n```\n\nLANGUAGE: javascript\nCODE:\n```\nimport { makeArray, useHook } from \"shared-runtime\";\n\n/**\n * Here, the cond ? [...] : defaultList value block produces two\n * new values (each with its own scope):\n *   $0 = [\"text\"]\n *   $1 = { text: $0 }\n * The same value block also mutates customList, so it must be\n * merged with the scope producing customList\n */\nfunction Foo(t0) {\n  const { defaultList, cond } = t0;\n  const comparator = _temp;\n  useHook();\n  const customList = makeArray(1, 5, 2);\n  useHook();\n  const result = cond\n    ? [...customList.sort(comparator), { text: [\"text\"] }]\n    : defaultList;\n  return result;\n}\nfunction _temp(a, b) {\n  return a - b;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{ defaultList: [2, 4], cond: true }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Optimized React Custom Ref and Callback Implementation\nDESCRIPTION: This snippet shows the compiled and optimized version of the custom ref and callback implementation. It includes compiler-specific optimizations and memoization techniques.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ref-like-name-in-useCallback.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enableTreatRefLikeIdentifiersAsRefs @validatePreserveExistingMemoizationGuarantees\nimport { useRef, useCallback } from \"react\";\n\nfunction useCustomRef() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = { click: _temp };\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return useRef(t0);\n}\nfunction _temp() {}\n\nfunction Foo() {\n  const $ = _c(2);\n  const customRef = useCustomRef();\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = () => {\n      customRef.current?.click();\n    };\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const onClick = t0;\n  let t1;\n  if ($[1] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = <button onClick={onClick} />;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [],\n  isComponent: true,\n};\n```\n\n----------------------------------------\n\nTITLE: Transforming React Component with Compiler Runtime Enhancements\nDESCRIPTION: This snippet provides a transformed version of the given component using 'react/compiler-runtime'. It incorporates a cache mechanism to optimize rendering by comparing previous and current states, and selectively mutates the component state using the 'mutate' function if changes are detected. This version is also set up for using fixture entry points for testing purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-alias-receiver-mutate.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { mutate } from \"shared-runtime\";\n\nfunction Component(t0) {\n  const $ = _c(2);\n  const { a } = t0;\n  let y;\n  if ($[0] !== a) {\n    const x = { a };\n    y = {};\n    const f0 = function () {\n      const a_0 = y;\n      a_0.x = x;\n    };\n\n    f0();\n    mutate(y);\n    $[0] = a;\n    $[1] = y;\n  } else {\n    y = $[1];\n  }\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ a: 2 }],\n  sequentialRenders: [{ a: 2 }, { a: 2 }, { a: 3 }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining React Components with 'use forget' Directive\nDESCRIPTION: This snippet defines three React components: Bar, NoForget, and Foo. The Bar and Foo components use the 'use forget' directive for optimization. It also exports a FIXTURE_ENTRYPOINT object for testing purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/gating-test.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @gating @compilationMode(annotation)\nfunction Bar(props) {\n  'use forget';\n  return <div>{props.bar}</div>;\n}\n\nfunction NoForget(props) {\n  return <Bar>{props.noForget}</Bar>;\n}\n\nfunction Foo(props) {\n  'use forget';\n  return <Foo>{props.bar}</Foo>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: eval('Bar'),\n  params: [{bar: 2}],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: Basic React component implementation that performs shallow copy operations with error handling. Uses shared runtime utilities and returns an array or null based on operation success.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-with-return.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst {shallowCopy, throwInput} = require('shared-runtime');\n\nfunction Component(props) {\n  let x = [];\n  try {\n    const y = shallowCopy({});\n    if (y == null) {\n      return;\n    }\n    x.push(throwInput(y));\n  } catch {\n    return null;\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Original JavaScript function foo\nDESCRIPTION: This code defines the original `foo` function.  It takes a boolean `a` as input. It creates an object `x`, and based on the value of `a`, it adds either a property `y` or `z` to `x`. Finally, it calls `mutate(x)` and returns `x`. The `mutate` function is assumed to be defined elsewhere and modifies the object `x` in place.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-property-alias-mutate-if.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(a) {\n  const x = {};\n  if (a) {\n    let y = {};\n    x.y = y;\n  } else {\n    let z = {};\n    x.z = z;\n  }\n  mutate(x);\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Memoization\nDESCRIPTION: This snippet shows the compiler-optimized version of the React component. It implements memoization using a caching mechanism to avoid unnecessary re-computations and preserves the original component's behavior.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/memberexpr-join-optional-chain.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enablePropagateDepsInHIR\n// To preserve the nullthrows behavior and reactive deps of this code,\n// Forget needs to add `props.a.b` or a subpath as a dependency.\n//\n// (1) Since the reactive block producing x unconditionally read props.a.<...>,\n//     reading `props.a.b` outside of the block would still preserve nullthrows\n//     semantics of source code\n// (2) Technically, props.a, props.a.b, and props.a.b.c are all reactive deps.\n//     However, `props.a?.b` is only dependent on whether `props.a` is nullish,\n//     not its actual value. Since we already preserve nullthrows on `props.a`,\n//     we technically do not need to add `props.a` as a dependency.\n\nfunction Component(props) {\n  const $ = _c(2);\n  let x;\n  if ($[0] !== props.a.b) {\n    x = [];\n    x.push(props.a?.b);\n    x.push(props.a.b.c);\n    $[0] = props.a.b;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ a: { b: { c: 1 } } }],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Feature Flags\nDESCRIPTION: Compiled version of the React components with forget feature flag implementation, including memoization and conditional rendering logic.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/multi-arrow-expr-gating-test.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { isForgetEnabled_Fixtures } from \"ReactForgetFeatureFlag\"; // @gating\nimport { Stringify } from \"shared-runtime\";\n\nconst ErrorView = isForgetEnabled_Fixtures()\n  ? (error, _retry) => {\n      const $ = _c(2);\n      let t0;\n      if ($[0] !== error) {\n        t0 = <Stringify error={error} />;\n        $[0] = error;\n        $[1] = t0;\n      } else {\n        t0 = $[1];\n      }\n      return t0;\n    }\n  : (error, _retry) => <Stringify error={error}></Stringify>;\n\nconst Renderer = isForgetEnabled_Fixtures()\n  ? (props) => {\n      const $ = _c(1);\n      let t0;\n      if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n        t0 = (\n          <div>\n            <span />\n            <ErrorView />\n          </div>\n        );\n        $[0] = t0;\n      } else {\n        t0 = $[0];\n      }\n      return t0;\n    }\n  : (props) => (\n      <div>\n        <span></span>\n        <ErrorView></ErrorView>\n      </div>\n    );\nexport default Renderer;\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: eval(\"Renderer\"),\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Enhanced Custom useState Hook with Memoization - JavaScript\nDESCRIPTION: This snippet enhances the custom useState hook by integrating a memoization strategy to prevent unnecessary re-renders. It utilizes a runtime function to track state changes and optimize updates, improving performance in functional components. The hook behaves similarly to React's useState but with additional optimizations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/globals-dont-resolve-local-useState.expect.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useState as _useState, useCallback, useEffect } from \"react\";\nimport { ValidateMemoization } from \"shared-runtime\";\n\nfunction useState(value) {\n  const $ = _c(2);\n  const [state, setState] = _useState(value);\n  let t0;\n  if ($[0] !== state) {\n    t0 = [state, setState];\n    $[0] = state;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n```\n\n----------------------------------------\n\nTITLE: Original Worklet Function Implementation\nDESCRIPTION: Defines a React hook 'useFoo' that returns a worklet-annotated function. The function is marked with a 'worklet' directive and returns a constant value.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/arrow-function-one-line-directive.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction useFoo() {\n  const update = () => {\n    'worklet';\n    return 1;\n  };\n  return update;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component with Feature Flag Styling\nDESCRIPTION: A React component that conditionally applies styles based on a feature flag. Uses stylex for styling and includes flow type checking. The component demonstrates conditional class name assignment using feature flags.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/nonreactive-noescaping-dependency-can-inline-into-consuming-scope.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @flow\nfunction Component() {\n  return (\n    <div\n      className={stylex(\n        // this value is a) in its own scope, b) non-reactive, and c) non-escaping\n        // its scope gets pruned bc it's non-escaping, but this doesn't mean we need to\n        // create a temporary for it\n        flags.feature('feature-name') ? styles.featureNameStyle : null\n      )}></div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Conditional Reassignment in React Component (Input Version)\nDESCRIPTION: A React component that conditionally reassigns a variable based on boolean props using a helper function called conditionalInvoke. The component includes a fixture entrypoint for testing sequential renders with different prop combinations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/context-variable-reassigned-two-lambdas.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {conditionalInvoke} from 'shared-runtime';\n\nfunction Component({doReassign1, doReassign2}) {\n  let x = {};\n  const reassign1 = () => {\n    x = 2;\n  };\n  const reassign2 = () => {\n    x = 3;\n  };\n  conditionalInvoke(doReassign1, reassign1);\n  conditionalInvoke(doReassign2, reassign2);\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{doReassign1: true, doReassign2: true}],\n  sequentialRenders: [\n    {doReassign1: true, doReassign2: true},\n    {doReassign1: true, doReassign2: false},\n    {doReassign1: false, doReassign2: false},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: Basic React component that conditionally creates an object with a session ID using getNumber() function. The component takes props with a condition flag and returns the created object.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/merge-consecutive-nested-scopes.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst {getNumber} = require('shared-runtime');\n\nfunction Component(props) {\n  let x;\n  // Two scopes: one for `getNumber()`, one for the object literal.\n  // Neither has dependencies so they should merge\n  if (props.cond) {\n    x = {session_id: getNumber()};\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{cond: true}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React useMemo Output\nDESCRIPTION: Compiled version of the useMemo implementation showing how React internally handles memoization. It includes the compiler runtime and implements a caching mechanism using Symbol.for.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useMemo-infer-scope-global.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @validatePreserveExistingMemoizationGuarantees\n\nimport { useMemo } from \"react\";\nimport { CONST_STRING0 } from \"shared-runtime\";\n\n// It's correct to infer a useMemo block has no reactive dependencies\nfunction useFoo() {\n  const $ = _c(1);\n  let t0;\n  let t1;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = [CONST_STRING0];\n    $[0] = t1;\n  } else {\n    t1 = $[0];\n  }\n  t0 = t1;\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component Definition\nDESCRIPTION: Defines a React component named 'Component' that accepts a 'name' prop. It uses `<SharedRuntime.Stringify>` to render a string including the name. The `FIXTURE_ENTRYPOINT` exports the component and a set of params used when evaluating the component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-lowercase-memberexpr.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as SharedRuntime from 'shared-runtime';\nfunction Component({name}) {\n  return <SharedRuntime.Stringify>hello world {name}</SharedRuntime.Stringify>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{name: 'sathya'}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Compiler Runtime Memoized Function\nDESCRIPTION: Enhanced function implementation using React compiler runtime for memoization, with conditional rendering and state caching\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-alias-computed-load-4-iife.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction bar(a) {\n  const $ = _c(2);\n  let y;\n  if ($[0] !== a) {\n    const x = [a];\n    y = {};\n\n    y = x[0].a[1];\n    $[0] = a;\n    $[1] = y;\n  } else {\n    y = $[1];\n  }\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: bar,\n  params: [{ a: [\"val1\", \"val2\"] }],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Initializing React Component with GraphQL Fragment\nDESCRIPTION: Uses useFragment hook to extract user name from a GraphQL fragment, retrieving data from props and returning the user's name\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/tagged-template-in-hook.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useFragment} from 'shared-runtime';\n\nfunction Component(props) {\n  const user = useFragment(\n    graphql`\n      fragment F on User {\n        name\n      }\n    `,\n    props.user\n  );\n  return user.name;\n}\n```\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useFragment } from \"shared-runtime\";\n\nfunction Component(props) {\n  const user = useFragment(\n    graphql`\n      fragment F on User {\n        name\n      }\n    `,\n    props.user,\n  );\n  return user.name;\n}\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: A React component that creates an object with a computed property name based on props.foo. Includes an export of FIXTURE_ENTRYPOINT for component configuration.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-expression-string-literal-key.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const x = {['foo']: props.foo};\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Component with GraphQL Fragment - JavaScript\nDESCRIPTION: This snippet defines a React functional component that uses the GraphQL useFragment hook to fetch user data based on a defined fragment. It expects 'props' containing a 'user' object and returns the user's name. The snippet demonstrates the integration of GraphQL fragments in React components.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hook-inside-logical-expression.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const user =\n    useFragment(\n      graphql`\n        fragment F on T {\n          id\n        }\n      `,\n      props.user\n    ) ?? {};\n  return user.name;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Optimized Function Implementation in JavaScript\nDESCRIPTION: Optimized version of 'foo' function that eliminates redundant assignments. The function only assigns parameter 'c' to variable 'x' before returning it, improving efficiency.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-reassign.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(a, b, c) {\n  let x;\n\n  x = c;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Hoisting Example in Javascript\nDESCRIPTION: This code snippet demonstrates a hoisting scenario in JavaScript. It defines a function `hoisting` that creates an object `x` with a method `foo` that calls another function `bar`.  The function `bar` is defined later, showcasing hoisting. The return value of `x.foo()` is returned.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-object-method.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction hoisting() {\n  const x = {\n    foo() {\n      return bar();\n    },\n  };\n  const bar = () => {\n    return 1;\n  };\n\n  return x.foo(); // OK: bar's value is only accessed outside of its TDZ\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: hoisting,\n  params: [],\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Component Definition\nDESCRIPTION: This snippet defines a React component that conditionally renders a `<Bar>` element based on the `isMenuShown` variable. It uses a ternary operator to choose between `props.b` and `props.c` based on the value of `props.a`. The component returns the rendered element or null.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/temporary-at-start-of-value-block.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component(props) {\n  // NOTE: the temporary for the leading space was previously dropped\n  const x = isMenuShown ? <Bar> {props.a ? props.b : props.c}</Bar> : null;\n  return x;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Optimized Component Function in React using Compiler Runtime in JavaScript\nDESCRIPTION: Optimizes the Component function using React compiler runtime for efficient re-renders. It updates state variables based on input props changes, employing caching mechanism $ to minimize unnecessary updates. Dependencies include React and the compiler runtime (_c).\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-no-mutate.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(t0) {\n  const $ = _c(5);\n  const { a, b } = t0;\n  let z;\n  if ($[0] !== a || $[1] !== b) {\n    z = { a };\n    let t1;\n    if ($[3] !== b) {\n      t1 = { b };\n      $[3] = b;\n      $[4] = t1;\n    } else {\n      t1 = $[4];\n    }\n    const y = t1;\n    const x = function () {\n      z.a = 2;\n      return Math.max(y.b, 0);\n    };\n\n    x();\n    $[0] = a;\n    $[1] = b;\n    $[2] = z;\n  } else {\n    z = $[2];\n  }\n  return z;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ a: 2, b: 3 }],\n  sequentialRenders: [\n    { a: 2, b: 3 },\n    { a: 2, b: 3 },\n    { a: 4, b: 3 },\n    { a: 4, b: 5 },\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Compiler-Transformed Component with Memoization\nDESCRIPTION: The compiler-transformed version of the same component, now with memoization logic added. It uses a cache sentinel symbol to check if the computation needs to be performed or if a cached value can be used instead.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/conflicting-dollar-sign-variable.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { identity } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $0 = _c(1);\n  let t0;\n  if ($0[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const $ = identity(\"jQuery\");\n    t0 = identity([$]);\n    $0[0] = t0;\n  } else {\n    t0 = $0[0];\n  }\n  const t0$0 = t0;\n  return t0$0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Component Functionality in JavaScript\nDESCRIPTION: This snippet defines a React component named 'Component' that processes props to generate output. It checks if a property 'p0' is true, modifies an array based on the value of 'p1', and returns a JSX structure wrapped in the Stringify component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-leave-case.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {Stringify} from 'shared-runtime';\n\nfunction Component(props) {\n  let x = [];\n  let y;\n  if (props.p0) {\n    x.push(props.p1);\n    y = x;\n  }\n  return (\n    <Stringify>\n      {x}\n      {y}\n    </Stringify>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{p0: false, p1: 2}],\n  sequentialRenders: [\n    {p0: false, p1: 2},\n    {p0: false, p1: 2},\n    {p0: true, p1: 2},\n    {p0: true, p1: 3},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Compiler Runtime\nDESCRIPTION: Advanced implementation using React compiler runtime for performance optimization, with explicit memoization and state tracking\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/babel-existing-react-runtime-import.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as React from \"react\";\nimport { someImport, c as _c } from \"react/compiler-runtime\";\nimport { calculateExpensiveNumber } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(4);\n  const [x] = React.useState(0);\n  let t0;\n  let t1;\n  if ($[0] !== x) {\n    t1 = calculateExpensiveNumber(x);\n    $[0] = x;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  t0 = t1;\n  const expensiveNumber = t0;\n  let t2;\n  if ($[2] !== expensiveNumber) {\n    t2 = (\n      <div>\n        {expensiveNumber}\n        {`${someImport}`}\n      </div>\n    );\n    $[2] = expensiveNumber;\n    $[3] = t2;\n  } else {\n    t2 = $[3];\n  }\n  return t2;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining React Component Input\nDESCRIPTION: This snippet defines a simple React component function with a nested function that gets overwritten. It also exports a FIXTURE_ENTRYPOINT object for testing purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/function-declaration-reassign.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component() {\n  function x(a) {\n    a.foo();\n  }\n  x = {};\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Optimizing React Component with Memoization: Javascript\nDESCRIPTION: The snippet illustrates how to optimize a React component function by implementing memoization through React's compiler runtime. It effectively reduces re-computation by caching computations based on input changes. Dependencies include 'react/compiler-runtime' for memoization support, and it requires consistent property inputs for accuracy.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-at-closure.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(7);\n  let t0;\n  if ($[0] !== props.x) {\n    t0 = foo(props.x);\n    $[0] = props.x;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const x = t0;\n  let t1;\n  if ($[2] !== props || $[3] !== x) {\n    t1 = function () {\n      const arr = [...bar(props)];\n      return arr.at(x);\n    };\n    $[2] = props;\n    $[3] = x;\n    $[4] = t1;\n  } else {\n    t1 = $[4];\n  }\n  const fn = t1;\n  let t2;\n  if ($[5] !== fn) {\n    t2 = fn();\n    $[5] = fn;\n    $[6] = t2;\n  } else {\n    t2 = $[6];\n  }\n  const fnResult = t2;\n  return fnResult;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Memoizing a React Component with useMemo\nDESCRIPTION: This code defines a React component that uses `useMemo` to memoize a value based on dependencies `propA.a` and `propB.x.y`.  The memoized value is an object with a `value` property, which is assigned the value of `propB.x.y`.  The `identity` and `mutate` functions are assumed to be imported from `shared-runtime` and might affect the memoization behavior.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.useMemo-infer-less-specific-conditional-value-block.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees\nimport {useMemo} from 'react';\nimport {identity, mutate} from 'shared-runtime';\n\nfunction Component({propA, propB}) {\n  return useMemo(() => {\n    const x = {};\n    if (identity(null) ?? propA.a) {\n      mutate(x);\n      return {\n        value: propB.x.y,\n      };\n    }\n  }, [propA.a, propB.x.y]);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating a custom hook with useCallback in React\nDESCRIPTION: This snippet demonstrates the use of the 'useCallback' hook from React to create a custom hook named 'useFoo'. It memoizes a function that returns an array containing a constant string. This provides performance optimizations by preventing unnecessary re-renders when the component using this hook re-renders, as long as 'CONST_STRING0' remains unchanged.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useCallback-infer-scope-global.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees\n\nimport {useCallback} from 'react';\nimport {CONST_STRING0} from 'shared-runtime';\n\n// It's correct to infer a useCallback block has no reactive dependencies\nfunction useFoo() {\n  return useCallback(() => [CONST_STRING0], [CONST_STRING0]);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Mutating React Component Props in JavaScript\nDESCRIPTION: This JavaScript snippet demonstrates an attempt to directly mutate React component props within a function called during the component's lifecycle. The `mutateProps` function tries to assign a boolean value to a property of the `props` object. React considers this an anti-pattern and throws an error because props should be treated as immutable within a component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-props-mutation-in-effect-indirect.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const mutateProps = () => {\n    props.value = true;\n  };\n  const indirectMutateProps = () => {\n    mutateProps();\n  };\n  useEffect(() => indirectMutateProps(), []);\n}\n```\n\n----------------------------------------\n\nTITLE: Wrapping inner tree with Context Providers\nDESCRIPTION: This snippet illustrates where to find the code responsible for wrapping the inner React tree with the appropriate Context Providers. It directs attention to the `src/legacy/createLegacyRoot.js` file and the `Bridge` component, which receives the aggregated Context object and uses it to provide the Context values to the inner tree. It also suggests that more Providers can be added there if necessary.\nSOURCE: https://github.com/facebook/react/blob/main/fixtures/nesting/README.md#2025-04-21_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\n/*\n* `src/legacy/createLegacyRoot.js`: Look for the `Bridge` component which receives that object and wraps its children with the appropriate Context Providers. **You can wrap them with more Providers there** if your app requires them.\n*/\n```\n\n----------------------------------------\n\nTITLE: Function Export with Entry Point in JavaScript\nDESCRIPTION: This snippet shows a simplified version of a function definition and export in JavaScript. The function Foo returns a numeric literal (0) and is then used as the function part of the FIXTURE_ENTRYPOINT constant, which is exported with empty parameters. No dependencies are required, and the function does not take any parameters, returning a static value instead.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ignore-inner-interface-types.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Foo() {\n  return 0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Components with useMemo - JavaScript\nDESCRIPTION: Illustrates optimized React components using a compiler runtime alias `_c` to minimize recomputation. It uses a caching technique where computations and outputs are cached, reducing the need to recalculate when dependencies do not change. Requires `react/compiler-runtime`, `useState`, and `useMemo` dependencies. It functions similarly to the uncompiled version but is optimized for better performance through direct memory cache access.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/babel-existing-react-import.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useState, useMemo } from \"react\";\n\nfunction Component(props) {\n  const $ = _c(4);\n  const [x] = useState(0);\n  let t0;\n  let t1;\n  if ($[0] !== x) {\n    t1 = calculateExpensiveNumber(x);\n    $[0] = x;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  t0 = t1;\n  const expensiveNumber = t0;\n  let t2;\n  if ($[2] !== expensiveNumber) {\n    t2 = <div>{expensiveNumber}</div>;\n    $[2] = expensiveNumber;\n    $[3] = t2;\n  } else {\n    t2 = $[3];\n  }\n  return t2;\n}\n\nfunction Component2(props) {\n  const $ = _c(4);\n  const [x] = useState(0);\n  let t0;\n  let t1;\n  if ($[0] !== x) {\n    t1 = calculateExpensiveNumber(x);\n    $[0] = x;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  t0 = t1;\n  const expensiveNumber = t0;\n  let t2;\n  if ($[2] !== expensiveNumber) {\n    t2 = <div>{expensiveNumber}</div>;\n    $[2] = expensiveNumber;\n    $[3] = t2;\n  } else {\n    t2 = $[3];\n  }\n  return t2;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Functional Component Foo with Identity Functions - JavaScript\nDESCRIPTION: This snippet defines a functional React component named 'Foo' that takes props 'a' and 'cond', evaluates conditions, and uses the identity function to manipulate data before rendering. It also prepares its output for further evaluation using a Stringify component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/infer-function-uncond-access-hoists-other-dep.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enablePropagateDepsInHIR\n\nimport {identity, makeArray, Stringify, useIdentity} from 'shared-runtime';\n\nfunction Foo({a, cond}) {\n  // Assume fn will be uncond evaluated, so we can safely evaluate {a.<any>,\n  // a.b.<any}\n  const fn = () => [a, a.b.c];\n  useIdentity(null);\n  const x = makeArray();\n  if (cond) {\n    x.push(identity(a.b.c));\n  }\n  return <Stringify fn={fn} x={x} shouldInvokeFns={true} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{a: null, cond: true}],\n  sequentialRenders: [\n    {a: null, cond: true},\n    {a: {b: {c: 4}}, cond: true},\n    {a: {b: {c: 4}}, cond: true},\n  ],\n};\n\n\n```\n\n----------------------------------------\n\nTITLE: Original React Component with Destructuring Parameters\nDESCRIPTION: Basic React component that takes a regular parameter 'foo' and uses array destructuring for the rest parameter 'bar'. Returns an array containing both parameters.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rest-param-with-array-pattern.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(foo, ...[bar]) {\n  return [foo, bar];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: ['foo', ['bar', 'baz']],\n};\n```\n\n----------------------------------------\n\nTITLE: Using Action State with Memoization in React Component (Extended Version)\nDESCRIPTION: This snippet illustrates an enhanced version of the initial component where memoization is introduced using the '_c' function from 'react/compiler-runtime'. It manages the memoization of the component rendering by caching the output. Similar to the first snippet, it uses the 'useActionState' hook for handling actions. The use case remains the same, but with optimizations for re-rendering. Dependencies include the React library and the compiler runtime. It takes props for action handlers and returns the rendered component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useActionState-dispatch-considered-as-non-reactive.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useActionState } from \"react\";\n\nfunction Component() {\n  const $ = _c(1);\n  const [, dispatchAction] = useActionState();\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const onSubmitAction = () => {\n      dispatchAction();\n    };\n\n    t0 = <Foo onSubmitAction={onSubmitAction} />;\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nfunction Foo() {}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n};\n\n```\n\n----------------------------------------\n\nTITLE: React useRef Access Error Message\nDESCRIPTION: The error message produced when attempting to access a ref's current property during component rendering. It points to line 9 where f(r.current) is called, explaining that ref values may not be accessed during render and providing a link to the React documentation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.ref-initialization-post-access-2.expect.md#2025-04-22_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n   7 |     r.current = 1;\n   8 |   }\n>  9 |   f(r.current);\n     |     ^^^^^^^^^ InvalidReact: Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef) (9:9)\n  10 | }\n  11 |\n  12 | export const FIXTURE_ENTRYPOINT = {\n```\n\n----------------------------------------\n\nTITLE: Error Handling for Invalid React State Mutation in JavaScript\nDESCRIPTION: This snippet contains an error message generated by the React framework when attempting to delete a property from an object that is being used in JSX. The error highlights the issue with updating values in JSX and provides guidance for resolving it by suggesting mutations should be done before the JSX is rendered.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-delete-property-of-frozen-value.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n  3 |   // freeze\n  4 |   <div>{x}</div>;\n> 5 |   delete x.y;\n    |          ^ InvalidReact: Updating a value used previously in JSX is not allowed. Consider moving the mutation before the JSX (5:5)\n  6 |   return x;\n  7 | }\n  8 |\n\n```\n\n----------------------------------------\n\nTITLE: Optimized Reactive Ref with Compiler Runtime - JavaScript\nDESCRIPTION: This snippet shows an optimized version of the previous reactive reference management using a compiler runtime (_c). It demonstrates conditional rendering and memoization techniques, ensuring that components re-render only when certain dependencies change. Dependencies include the react/compiler-runtime and shared-runtime packages. The Parent function has been enhanced for performance using the _c function, where reference states are cached for optimization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-ref-param.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useRef, forwardRef } from \"react\";\nimport { Stringify } from \"shared-runtime\";\n\n/**\n * Fixture showing that Ref types may be reactive.\n * We should always take a dependency on ref values (the outer box) as\n * they may be reactive. Pruning should be done in\n * `pruneNonReactiveDependencies`\n */\n\nfunction Parent(t0) {\n  const $ = _c(2);\n  const { cond } = t0;\n  const ref1 = useRef(1);\n  const ref2 = useRef(2);\n  const ref = cond ? ref1 : ref2;\n  let t1;\n  if ($[0] !== ref) {\n    t1 = <Child ref={ref} />;\n    $[0] = ref;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n\nfunction ChildImpl(_props, ref) {\n  const $ = _c(4);\n  let t0;\n  if ($[0] !== ref) {\n    t0 = () => ref.current;\n    $[0] = ref;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const cb = t0;\n  let t1;\n  if ($[2] !== cb) {\n    t1 = <Stringify cb={cb} shouldInvokeFns={true} />;\n    $[2] = cb;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  return t1;\n}\n\nconst Child = forwardRef(ChildImpl);\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Parent,\n  params: [{ cond: true }],\n  sequentialRenders: [{ cond: true }, { cond: false }],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: Compiler-transformed version of the React component with explicit memoization cache handling using Symbol.for('react.memo_cache_sentinel'). Shows how the compiler implements memoization guarantees.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useCallback-call-second-function-which-captures-maybe-mutable-value-preserve-memoization.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enablePreserveExistingMemoizationGuarantees\nimport { useCallback } from \"react\";\nimport {\n  identity,\n  logValue,\n  makeObject_Primitives,\n  useHook,\n} from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(4);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = makeObject_Primitives();\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const object = t0;\n\n  useHook();\n  let t1;\n  if ($[1] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = () => {\n      logValue(object);\n    };\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  const log = t1;\n  let t2;\n  if ($[2] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t2 = () => {\n      log();\n    };\n    $[2] = t2;\n  } else {\n    t2 = $[2];\n  }\n  const onClick = t2;\n\n  identity(object);\n  let t3;\n  if ($[3] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t3 = <div onClick={onClick} />;\n    $[3] = t3;\n  } else {\n    t3 = $[3];\n  }\n  return t3;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: React Hook Conditional Call Error\nDESCRIPTION: This error message indicates that React hooks are being called conditionally.  React's rules of hooks state that hooks must be called in the same order on every render of a component.  Calling a hook inside an `if` statement violates this rule and can lead to unexpected behavior and errors.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-conditional-call-aliased-react-hook.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n  4 |   let s;\n  5 |   if (props.cond) {\n> 6 |     [s] = state();\n    |           ^^^^^ InvalidReact: Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning) (6:6)\n  7 |   }     \n  8 |   return s;\n  9 | }\n\n```\n\n----------------------------------------\n\nTITLE: Initializing React Component with Name Rendering\nDESCRIPTION: Defines a React functional component that renders its own name within a div element. Supports conditional compilation based on feature flags.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/gating-access-function-name-in-component.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @gating\nfunction Component() {\n  const name = Component.name;\n  return <div>{name}</div>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n};\n```\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { isForgetEnabled_Fixtures } from \"ReactForgetFeatureFlag\"; // @gating\nconst Component = isForgetEnabled_Fixtures()\n  ? function Component() {\n      const $ = _c(1);\n      const name = Component.name;\n      let t0;\n      if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n        t0 = <div>{name}</div>;\n        $[0] = t0;\n      } else {\n        t0 = $[0];\n      }\n      return t0;\n    }\n  : function Component() {\n      const name = Component.name;\n      return <div>{name}</div>;\n    };\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Using Hook with Mutation - JavaScript\nDESCRIPTION: This snippet defines a custom hook `useHook` which returns an object with a method to get a mutated value. It uses the `mutateAndReturn` function to modify the incoming value. The primary purpose is to optimize value retrieval based on whether the value has changed.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-method-shorthand-derived-value.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {createHookWrapper, mutateAndReturn} from 'shared-runtime';\nfunction useHook({value}) {\n  const x = mutateAndReturn({value});\n  const obj = {\n    getValue() {\n      return x;\n    },\n  };\n  return obj;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: createHookWrapper(useHook),\n  params: [{value: 0}],\n};\n```\n\n----------------------------------------\n\nTITLE: React Error Handling for Invalid Ref Access - JavaScript\nDESCRIPTION: This snippet displays an error message indicating that ref values (the `current` property) cannot be accessed during render cycles in React. This serves as a warning for developers regarding appropriate use of refs.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.ref-initialization-other.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n\"   6 |   const r2 = useRef(null);\\n   7 |   if (r.current == null) {\\n>  8 |     r2.current = 1;\\n     |     ^^^^^^^^^^ InvalidReact: Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef) (8:8)\\n   9 |   }\\n  10 | }\\n  11 |\\n\"\n```\n\n----------------------------------------\n\nTITLE: React Hook Implementation with External Function\nDESCRIPTION: This snippet defines a React hook, `useMyHook`, which returns a reference to an external function `_temp`. The `_temp` function modifies the value of the variable `b` to 2 when called. The module also exports a `FIXTURE_ENTRYPOINT` to facilitate testing the hook.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reassign-global-return.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nlet b = 1;\n\nexport default function useMyHook() {\n  const fn = _temp;\n  return fn;\n}\nfunction _temp() {\n  b = 2;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useMyHook,\n  params: [],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Function - JavaScript\nDESCRIPTION: The first snippet defines a simple function 'bar' that takes an argument, creates an array and an object, and returns a value contained in the array. It doesn't use any external libraries or dependencies.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-alias-computed-load-2.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction bar(a) {\n  let x = [a];\n  let y = {};\n  const f0 = function () {\n    y = x[0][1];\n  };\n  f0();\n\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: bar,\n  params: [['val1', 'val2']],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: React Error for Invalid ref.current Access\nDESCRIPTION: The error message shown when React detects an invalid access to ref.current during component rendering. This error points to the specific line where the violation occurs and provides a link to the React documentation about proper ref usage.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.validate-mutate-ref-arg-in-render.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n  1 | // @validateRefAccessDuringRender:true\n  2 | function Foo(props, ref) {\n> 3 |   console.log(ref.current);\n    |               ^^^^^^^^^^^ InvalidReact: Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef) (3:3)\n  4 |   return <div>{props.bar}</div>;\n  5 | }\n  6 |\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component after Compilation\nDESCRIPTION: This snippet shows the optimized version of the Component after being processed by React's compiler. It includes memoization and conditional rendering optimizations to improve performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/function-param-assignment-pattern.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(t0, t1) {\n  const $ = _c(5);\n  const x = t0 === undefined ? \"default\" : t0;\n  let t2;\n  if ($[0] !== t1) {\n    t2 = t1 === undefined ? [{}] : t1;\n    $[0] = t1;\n    $[1] = t2;\n  } else {\n    t2 = $[1];\n  }\n  const y = t2;\n  let t3;\n  if ($[2] !== x || $[3] !== y) {\n    t3 = [x, y];\n    $[2] = x;\n    $[3] = y;\n    $[4] = t3;\n  } else {\n    t3 = $[4];\n  }\n  return t3;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Transpiled React Function with Data Attribute Handling\nDESCRIPTION: This snippet shows the transpiled version of the 'foo' function, where the object destructuring is converted to a more compatible format. It also includes the 'FIXTURE_ENTRYPOINT' constant, which is used for testing or fixture setup.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructure-param-string-literal-key-invalid-identifier.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(t0) {\n  const { \"data-foo-bar\": dataTestID } = t0;\n  return dataTestID;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [{ \"data-foo-bar\": {} }],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Compiler Runtime\nDESCRIPTION: The compiler-optimized version of the component using React's compiler runtime for memoization. It includes caching mechanism to prevent unnecessary recreations of functions and objects.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/mutate-captured-arg-separately.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction component(a) {\n  const $ = _c(2);\n  let y;\n  if ($[0] !== a) {\n    y = function () {\n      m(x);\n    };\n\n    let x;\n    x = { a };\n    m(x);\n    $[0] = a;\n    $[1] = y;\n  } else {\n    y = $[1];\n  }\n  return y;\n}\n\nfunction m(x) {}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: [{ name: \"Jason\" }],\n};\n```\n\n----------------------------------------\n\nTITLE: Utilize Caching in useFoo Function with React.memo_cache_sentinel in JavaScript\nDESCRIPTION: An optimized version of useFoo leveraging caching with react.memo_cache_sentinel and managing state across renders. It implements cache validation for input parameter changes, utilizes shared constants for caching, and returns array manipulations. Dependencies include the 'shared-runtime' for arrayPush and 'react/compiler-runtime' for caching helper _c.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-unpoisoned/return-before-scope-starts.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { arrayPush } from \"shared-runtime\";\n\nfunction useFoo(t0) {\n  const $ = _c(3);\n  const { input, cond } = t0;\n  if (cond) {\n    let t1;\n    if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n      t1 = { result: \"early return\" };\n      $[0] = t1;\n    } else {\n      t1 = $[0];\n    }\n    return t1;\n  }\n  let x;\n  if ($[1] !== input.a.b) {\n    x = [];\n    arrayPush(x, input.a.b);\n    $[1] = input.a.b;\n    $[2] = x;\n  } else {\n    x = $[2];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ input: { a: { b: 2 } }, cond: false }],\n  sequentialRenders: [\n    { input: null, cond: true },\n    { input: { a: { b: 2 } }, cond: false },\n    { input: null, cond: true },\n    // preserve nullthrows\n    { input: {}, cond: false },\n    { input: { a: { b: null } }, cond: false },\n    { input: { a: null }, cond: false },\n    { input: { a: { b: 3 } }, cond: false },\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Optimized Router Component with React Compiler Runtime\nDESCRIPTION: This is an optimized version of the Router component using React's compiler runtime. It includes memoization to prevent unnecessary re-renders when the inputs haven't changed. The code also defines the routes and FIXTURE_ENTRYPOINT for testing.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-of-iterator-of-immutable-collection.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Router(t0) {\n  const $ = _c(3);\n  const { title, mapping } = t0;\n  let array;\n  if ($[0] !== mapping || $[1] !== title) {\n    array = [];\n    for (const entry of mapping.values()) {\n      array.push([title, entry]);\n    }\n    $[0] = mapping;\n    $[1] = title;\n    $[2] = array;\n  } else {\n    array = $[2];\n  }\n  return array;\n}\n\nconst routes = new Map([\n  [\"about\", \"/about\"],\n  [\"contact\", \"/contact\"],\n]);\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Router,\n  params: [],\n  sequentialRenders: [\n    {\n      title: \"Foo\",\n      mapping: routes,\n    },\n    {\n      title: \"Bar\",\n      mapping: routes,\n    },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Transformed React Component\nDESCRIPTION: This snippet represents the transformed version of the React component, optimized by the React compiler. It introduces memoization using the `_c` function from `react/compiler-runtime` to store and reuse intermediate values. This reduces redundant computations during rendering by checking if input values have changed since the last render.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/sequential-destructuring-both-mixed-local-and-scope-declaration.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { identity } from \"shared-runtime\";\n\nfunction Component(statusName) {\n  const $ = _c(12);\n  let font;\n  let t0;\n  let text;\n  if ($[0] !== statusName) {\n    const { status, text: t1 } = foo(statusName);\n    text = t1;\n\n    const { color, font: t2 } = getStyles(status);\n    font = t2;\n\n    t0 = identity(color);\n    $[0] = statusName;\n    $[1] = font;\n    $[2] = t0;\n    $[3] = text;\n  } else {\n    font = $[1];\n    t0 = $[2];\n    text = $[3];\n  }\n  const bg = t0;\n  let t1;\n  if ($[4] !== text) {\n    t1 = [text];\n    $[4] = text;\n    $[5] = t1;\n  } else {\n    t1 = $[5];\n  }\n  let t2;\n  if ($[6] !== font || $[7] !== t1) {\n    t2 = <span className={font}>{t1}</span>;\n    $[6] = font;\n    $[7] = t1;\n    $[8] = t2;\n  } else {\n    t2 = $[8];\n  }\n  let t3;\n  if ($[9] !== bg || $[10] !== t2) {\n    t3 = <div className={bg}>{t2}</div>;\n    $[9] = bg;\n    $[10] = t2;\n    $[11] = t3;\n  } else {\n    t3 = $[11];\n  }\n  return t3;\n}\n\nfunction foo(name) {\n  const $ = _c(2);\n\n  const t0 = `${name}!`;\n  let t1;\n  if ($[0] !== t0) {\n    t1 = { status: `<status>`, text: t0 };\n    $[0] = t0;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n\nfunction getStyles(status) {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = { font: \"comic-sans\", color: \"#657b83\" };\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\"Sathya\"],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Original React Component with useState Hook\nDESCRIPTION: A simple React component that uses the useState hook to initialize a state variable with null and returns it in an array. The input component shows the code before compilation optimization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-functions-component-with-hook-call.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @compilationMode(infer)\nfunction Component(props) {\n  const [state, _] = useState(null);\n  return [state];\n}\n```\n\n----------------------------------------\n\nTITLE: Input: Allocating Primitive Expression as Dependency in React Component\nDESCRIPTION: Original React component function that uses an allocating expression (bar(props).b) that produces a primitive value. This is a candidate for memoization by the React compiler to improve performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allocating-primitive-as-dep.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// bar(props.b) is an allocating expression that produces a primitive, which means\n// that Forget should memoize it.\n// Correctness:\n//   - y depends on either bar(props.b) or bar(props.b) + 1\nfunction AllocatingPrimitiveAsDep(props) {\n  let y = foo(bar(props).b + 1);\n  return y;\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization Implementation\nDESCRIPTION: Compiled version of the component showing how React implements memoization using a compiler runtime. The code includes caching logic to prevent unnecessary recomputation of values and function references.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-map-noAlias-escaping-function.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(4);\n  const f = _temp;\n  let t0;\n  if ($[0] !== props.items) {\n    t0 = [...props.items].map(f);\n    $[0] = props.items;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const x = t0;\n  let t1;\n  if ($[2] !== x) {\n    t1 = [x, f];\n    $[2] = x;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  return t1;\n}\nfunction _temp(item) {\n  return item;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ items: [{ id: 1 }] }],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with FBT Translation - Input Version\nDESCRIPTION: Original source code showing a React component that uses FBT for text translation. The component accepts a name prop and renders a greeting message using FBT's parameter interpolation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-param-with-quotes.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport fbt from 'fbt';\n\nfunction Component(props) {\n  const element = (\n    <fbt desc={'Dialog to show to user'}>\n      Hello <fbt:param name='\"user\" name'>{props.name}</fbt:param>\n    </fbt>\n  );\n  return element.toString();\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{name: 'Jason'}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Component with useMemo in React - JavaScript\nDESCRIPTION: This snippet defines a functional React component 'Component' that uses the 'useMemo' hook to memoize a value based on the 'props.cond' condition. It checks the condition and returns the memoized value.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-nested-ifs.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const x = useMemo(() => {\n    if (props.cond) {\n      if (props.cond) {\n      }\n    }\n  }, [props.cond]);\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: React Hook Input Implementation\nDESCRIPTION: Initial hook implementation showing the input structure with imports and hook definition. The hook takes an object with a value property and returns one of two constant strings based on identity check.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-literal-method-call-in-ternary-test.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {\n  createHookWrapper,\n  identity,\n  CONST_STRING0,\n  CONST_STRING1,\n} from 'shared-runtime';\n\nfunction useHook({value}) {\n  return {\n    getValue() {\n      return identity(value);\n    },\n  }.getValue()\n    ? CONST_STRING0\n    : CONST_STRING1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: createHookWrapper(useHook),\n  params: [{value: 0}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining React Component 'Foo' with Conditional Assignment\nDESCRIPTION: This snippet defines a React functional component 'Foo' that conditionally assigns an empty array to variable 'x'. It also exports a FIXTURE_ENTRYPOINT object for testing purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/memoize-value-block-value-logical.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Foo(props) {\n  let x;\n  true && ((x = []), null);\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Hook Implementation\nDESCRIPTION: Defines a custom React hook 'useTest' that creates an array using function evaluation and side effects. Uses the makeArray utility and demonstrates sequence evaluation order.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/codegen-inline-iife-reassign.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {makeArray, print} from 'shared-runtime';\n\nfunction useTest() {\n  let w = {};\n  return makeArray(\n    (w = 42),\n    w,\n    (function foo() {\n      w = 999;\n      return 2;\n    })(),\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useTest,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled Component with React Compiler Optimizations\nDESCRIPTION: The React Compiler transformed version of the component with memoization for rendering optimizations. It uses the _c function to create and maintain a local state array that tracks changes to props and avoids unnecessary re-renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-call-complex-param-value.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport fbt from \"fbt\";\nimport { identity } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(4);\n  let t0;\n  if ($[0] !== props.name) {\n    t0 = fbt._(\n      \"Hello, {(key) name}!\",\n      [fbt._param(\"(key) name\", identity(props.name))],\n      { hk: \"2sOsn5\" },\n    );\n    $[0] = props.name;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const text = t0;\n  let t1;\n  if ($[2] !== text) {\n    t1 = <div>{text}</div>;\n    $[2] = text;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  return t1;\n}\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: Simple React component that filters out null values from an items array passed through props. Includes test fixture with sample input data.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/noAlias-filter-on-array-prop.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const filtered = props.items.filter(item => item != null);\n  return filtered;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\n    {\n      items: [{a: true}, null, true, false, null, 'string', 3.14, null, [null]],\n    },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Complex Component Initialization with React Runtime Checks\nDESCRIPTION: This snippet introduces a more complex version of the React component utilizing runtime checks and caching. It integrates the useState hook and special '$structuralCheck' functions for verifying structural integrity during rerenders. This approach helps optimize performance by checking changes only when necessary, and it accounts for the component's internal caching behavior along with handling memoization using Symbol.for and other React runtime utilities.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useState-pruned-dependency-change-detect.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { $structuralCheck } from \"react-compiler-runtime\";\nimport { c as _c } from \"react/compiler-runtime\"; // @enableChangeDetectionForDebugging\nimport { useState } from \"react\";\n\nfunction Component(props) {\n  const $ = _c(3);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = f(props.x);\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const [x] = useState(t0);\n  let t1;\n  {\n    t1 = <div>{x}</div>;\n    let condition = $[1] !== x;\n    if (!condition) {\n      let old$t1 = $[2];\n      $structuralCheck(old$t1, t1, \"t1\", \"Component\", \"cached\", \"(6:6)\");\n    }\n    $[1] = x;\n    $[2] = t1;\n    if (condition) {\n      t1 = <div>{x}</div>;\n      $structuralCheck($[2], t1, \"t1\", \"Component\", \"recomputed\", \"(6:6)\");\n      t1 = $[2];\n    }\n  }\n  return t1;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Compiled: React Compiler-Optimized Code with Dependency Tracking\nDESCRIPTION: Compiled version of the function that includes React compiler's optimizations. It adds dependency tracking using the compiler runtime, storing values in a cache array to prevent unnecessary recalculations and renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/promote-uncond.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // When a conditional dependency `props.a.b.c` has no unconditional dependency\n// in its subpath or superpath, we should find the nearest unconditional access\n\nimport { identity } from \"shared-runtime\";\n\n// and promote it to an unconditional dependency.\nfunction usePromoteUnconditionalAccessToDependency(props, other) {\n  const $ = _c(4);\n  let x;\n  if ($[0] !== other || $[1] !== props.a.a.a || $[2] !== props.a.b) {\n    x = {};\n    x.a = props.a.a.a;\n    if (identity(other)) {\n      x.c = props.a.b.c;\n    }\n    $[0] = other;\n    $[1] = props.a.a.a;\n    $[2] = props.a.b;\n    $[3] = x;\n  } else {\n    x = $[3];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: usePromoteUnconditionalAccessToDependency,\n  params: [{ a: { a: { a: 3 } } }, false],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with direct assignment\nDESCRIPTION: This React component takes props as input and directly assigns a value `x` based on the conditional `props.a && props.b`.  It returns the computed value.  A fixture entrypoint is defined to specify the component and its parameters, facilitating testing or demonstration.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-logical.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let t0;\n  t0 = props.a && props.b;\n  const x = t0;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n\n```\n\n----------------------------------------\n\nTITLE: Optimizing Rendering with State Management in React\nDESCRIPTION: This code snippet enhances the previous `Foo` component by implementing state management for optimizing renders using React's compiler runtime. It utilizes a custom state array to track previous values of `a` and `x`, ensuring that the component re-renders only when necessary, which improves performance. The method checks if the new props or calculated values differ from the previous ones, facilitating targeted updates to the video list component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ref-current-aliased-not-added-to-dep-2.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @validateRefAccessDuringRender:false\nfunction Foo(t0) {\n  const $ = _c(4);\n  const { a } = t0;\n  const ref = useRef();\n  const val = ref.current;\n  let t1;\n  if ($[0] !== a) {\n    t1 = { a, val };\n    $[0] = a;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  const x = t1;\n  let t2;\n  if ($[2] !== x) {\n    t2 = <VideoList videos={x} />;\n    $[2] = x;\n    $[3] = t2;\n  } else {\n    t2 = $[3];\n  }\n  return t2;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Memoization\nDESCRIPTION: This snippet shows an optimized version of the component using React's compiler-runtime. It implements memoization to cache object references and improve performance. The optimization is achieved through the use of Symbol.for('react.memo_cache_sentinel') for cache checking.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-test-field-store.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction component() {\n  const $ = _c(1);\n  let x;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    x = {};\n    const q = {};\n    x.t = q;\n    $[0] = x;\n  } else {\n    x = $[0];\n  }\n  const z = x.t;\n  return z;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: React Invalid Hook Call Error\nDESCRIPTION: This error message indicates that a hook is being called conditionally, violating the Rules of Hooks in React. The error specifically points to line 6 where `local.useFoo()` is being called inside an `if` statement. This error prevents React from correctly managing hook state and effects.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-conditionally-methodcall-hooklike-property-of-local.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n  4 |   const local = makeObject_Primitives();\n  5 |   if (props.cond) {\n> 6 |     local.useFoo();\n    |     ^^^^^^^^^^^^ InvalidReact: Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning) (6:6)\n  7 |   }\n  8 | }\n  9 |\n\n```\n\n----------------------------------------\n\nTITLE: React Hook Invocation Error Demonstration\nDESCRIPTION: Shows an error message from React indicating that hooks cannot be passed around as regular values and must be called directly\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.hook-property-load-local-hook.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nInvalidReact: Hooks may not be referenced as normal values, they must be called. See https://react.dev/reference/rules/react-calls-components-and-hooks#never-pass-around-hooks-as-regular-values\n```\n\n----------------------------------------\n\nTITLE: Using Conditional Type Inference in React\nDESCRIPTION: This snippet defines a function 'useFoo' that utilizes type inference to handle different input conditions by modifying an object based on the 'cond' parameter. It manages type propagation through unexpected behavior in TypeScript and Flow. Import dependencies include 'mutate' for changing internal state and 'arrayPush' for handling non-primitive scenarios. Key parameters include 'cond' (a boolean for condition checking) and 'value' (a number to be manipulated based on the type of 'x.value'). It is crucial to note that the inference may behave inconsistently across different type systems.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/bug-type-inference-control-flow.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {arrayPush, CONST_NUMBER0, mutate} from 'shared-runtime';\n\n/**\n * Repro for bug in our type inference system. We currently propagate inferred\n * types through control flow / potential type guards. Note that this is\n * inconsistent with both Flow and Typescript.\n * https://flow.org/try/#1N4Igxg9gdgZglgcxALlAIwIZoKYBsD6uEEAztvhgE6UYCe+JADpdhgCYowa5kA0I2KAFcAtiRQAXSkOz9sADwxgJ+NPTbYuQ3BMnTZA+Y2yU4IwRO4A6SFBIrGVDGM7c+h46fNRLuKxJIGWh8MeT0ZfhYlCStpHzNsFBAMIQkIEQwJODAQfiEyfBE4eWw2fDgofDBMsAALfAA3KjgsXGxxZC4eAw0G-GhcWn9aY3wWZldu-g1mbGqJUoBaCRHEzrcDEgBrbAk62kXhXFxJ923d-cPRHEpTgyEoMDaqZdW7vKgoOfaSKgOKpqmDA+d4gB5fMA-P6LCCMLLQbiLOoYCqgh6-GDYRYIXYLSgkRZkCR4jpddwPfJLZjpOBkO4AX34kA0SRWxgABAAxYjsgC87OAAB0oOzReythU2Mh2YKQNyILLeMKxeymrgZNLhCIbsL6QBuYVs7DsgBCVD5AuVYolUClMpAZsoiqtorVGvZWpuSqg9OFMAeyjg0HZdTmW3lAAp5NKAPJoABWcwkAEppWZGLg4O12fJ2bSuTyhSKxSwJEJKCKAOQ2tiVvMi3MAMkbOasNb5vP5svlsoNPuFfoD8JFGQqUel8vZAB9TVReCHoHa0MRnlBUwWIJbi6K4DB2RHbGxk1uVSrd-uAIShsDh4hR5PHoun5-siS1SgQADuHuw34AotQECUBGsqysmfYvuyvrbqepblg2EFitBKpwRWOZ9vSuQgA0JgkEGUBJBk9gmCA9JAA\n * https://www.typescriptlang.org/play/?#code/C4TwDgpgBAYg9nKBeKBvAUFLUDWBLAOwBMAuKAInjnIBpNsA3AQwBsBXCMgtgWwCMIAJ3QBfANzpQkKACEmg5GnpZ8xMuTmDayqM3aco3fkLoj0AMzYEAxsDxwCUawAsI1nFQAUADzJw+AFZuwACUZEwAzhFCwBFQ3lB4cVRK2InmUJ4AhJ4A5KpEuYmOCQBkpfEAdAXISCiUCOQhIalp2MDOgnAA7oYQvQCigl2CnuRWEN6QthBETTpmZhZWtvaOPEyEPmQpAD6y8jRODqRQfAgsEEwEYbAIrVh4GZ7WJy0Ybdgubh4IPiEST5YQQQYBsQQlQHYMxpEFgiHxCQiIA\n */\nfunction useFoo({cond, value}: {cond: boolean; value: number}) {\n  const x = {value: cond ? CONST_NUMBER0 : []};\n  mutate(x);\n\n  const xValue = x.value;\n  let result;\n  if (typeof xValue === 'number') {\n    result = xValue + 1; //               (1) here we infer xValue is a primitive\n  } else {\n    result = arrayPush(xValue, value); // (2) and propagate it to all other xValue references\n  }\n\n  return result;\n}\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{cond: true}],\n  sequentialRenders: [\n    {cond: false, value: 2},\n    {cond: false, value: 3},\n  ],\n};\n```\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { arrayPush, CONST_NUMBER0, mutate } from \"shared-runtime\";\n\n/**\n * Repro for bug in our type inference system. We currently propagate inferred\n * types through control flow / potential type guards. Note that this is\n * inconsistent with both Flow and Typescript.\n * https://flow.org/try/#1N4Igxg9gdgZglgcxALlAIwIZoKYBsD6uEEAztvhgE6UYCe+JADpdhgCYowa5kA0I2KAFcAtiRQAXSkOz9sADwxgJ+NPTbYuQ3BMnTZA+Y2yU4IwRO4A6SFBIrGVDGM7c+h46fNRLuKxJIGWh8MeT0ZfhYlCStpHzNsFBAMIQkIEQwJODAQfiEyfBE4eWw2fDgofDBMsAALfAA3KjgsXGxxZC4eAw0G-GhcWn9aY3wWZldu-g1mbGqJUoBaCRHEzrcDEgBrbAk62kXhXFxJ923d-cPRHEpTgyEoMDaqZdW7vKgoOfaSKgOKpqmDA+d4gB5fMA-P6LCCMLLQbiLOoYCqgh6-GDYRYIXYLSgkRZkCR4jpddwPfJLZjpOBkO4AX34kA0SRWxgABAAxYjsgC87OAAB0oOzReythU2Mh2YKQNyILLeMKxeymrgZNLhCIbsL6QBuYVs7DsgBCVD5AuVYolUClMpAZsoiqtorVGvZWpuSqg9OFMAeyjg0HZdTmW3lAAp5NKAPJoABWcwkAEppWZGLg4O12fJ2bSuTyhSKxSwJEJKCKAOQ2tiVvMi3MAMkbOasNb5vP5svlsoNPuFfoD8JFGQqUel8vZAB9TVReCHoHa0MRnlBUwWIJbi6K4DB2RHbGxk1uVSrd-uAIShsDh4hR5PHoun5-siS1SgQADuHuw34AotQECUBGsqysmfYvuyvrbqepblg2EFitBKpwRWOZ9vSuQgA0JgkEGUBJBk9gmCA9JAA\n * https://www.typescriptlang.org/play/?#code/C4TwDgpgBAYg9nKBeKBvAUFLUDWBLAOwBMAuKAInjnIBpNsA3AQwBsBXCMgtgWwCMIAJ3QBfANzpQkKACEmg5GnpZ8xMuTmDayqM3aco3fkLoj0AMzYEAxsDxwCUawAsI1nFQAUADzJw+AFZuwACUZEwAzhFCwBFQ3lB4cVRK2InmUJ4AhJ4A5KpEuYmOCQBkpfEAdAXISCiUCOQhIalp2MDOgnAA7oYQvQCigl2CnuRWEN6QthBETTpmZhZWtvaOPEyEPmQpAD6y8jRODqRQfAgsEEwEYbAIrVh4GZ7WJy0Ybdgubh4IPiEST5YQQQYBsQQlQHYMxpEFgiHxCQiIA\n */\nfunction useFoo(t0) {\n  const $ = _c(5);\n  const { cond, value } = t0;\n  let x;\n  if ($[0] !== cond) {\n    x = { value: cond ? CONST_NUMBER0 : [] };\n    mutate(x);\n    $[0] = cond;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n\n  const xValue = x.value;\n  let result;\n  if (typeof xValue === \"number\") {\n    result = xValue + 1;\n  } else {\n    let t1;\n    if ($[2] !== value || $[3] !== xValue) {\n      t1 = arrayPush(xValue, value);\n      $[2] = value;\n      $[3] = xValue;\n      $[4] = t1;\n    } else {\n      t1 = $[4];\n    }\n    result = t1;\n  }\n  return result;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ cond: true }],\n  sequentialRenders: [\n    { cond: false, value: 2 },\n    { cond: false, value: 3 },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Counter Component Implementation\nDESCRIPTION: Basic React component implementation of a counter with useState hook. Renders a counter display with an increment button and uses the Stringify component for the header text.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/merge-consecutive-scopes-reordering.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableInstructionReordering\nimport {useState} from 'react';\nimport {Stringify} from 'shared-runtime';\n\nfunction Component() {\n  let [state, setState] = useState(0);\n  return (\n    <div>\n      <Stringify text=\"Counter\" />\n      <span>{state}</span>\n      <button data-testid=\"button\" onClick={() => setState(state + 1)}>\n        increment\n      </button>\n    </div>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: 42}],\n};\n```\n\n----------------------------------------\n\nTITLE: Creating an FBT Component with Parameter Substitution in React\nDESCRIPTION: This snippet shows a React component using the FBT library to create an internationalized greeting with a dynamic parameter. The component takes a name prop and inserts it into the greeting text, then converts the result to a string.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-param-with-unicode.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport fbt from 'fbt';\n\nfunction Component(props) {\n  const element = (\n    <fbt desc={'Dialog to show to user'}>\n      Hello <fbt:param name=\"user name \">{props.name}</fbt:param>\n    </fbt>\n  );\n  return element.toString();\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{name: 'Jason'}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Original React Component in JavaScript\nDESCRIPTION: This snippet defines a React component named 'Component' that returns the result of calling a method 'foo' on an object. The 'foo' method returns an empty array or undefined if an error occurs.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-within-object-method.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const object = {\n    foo() {\n      try {\n        return [];\n      } catch (e) {\n        return;\n      }\n    },\n  };\n  return object.foo();\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Memoized React Hook with Aliased References\nDESCRIPTION: A React hook function demonstrating complex dependency tracking with aliased variables and nested property access. The hook uses useCallback to memoize a function with references that may cause memoization preservation challenges.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.useCallback-aliased-var.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction useHook(x) {\n  const aliasedX = x;\n  const aliasedProp = x.y.z;\n\n  return useCallback(() => [aliasedX, x.y.z], [x, aliasedProp]);\n}\n```\n\n----------------------------------------\n\nTITLE: Input React Components with Flow Types\nDESCRIPTION: Original React components with Flow type annotations, showing a Foo component that renders a Bar component with a number prop.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/component-declaration-basic.flow.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @flow @compilationMode(infer)\nexport default component Foo(bar: number) {\n  return <Bar bar={bar} />;\n}\n\ncomponent Bar(bar: number) {\n  return <div>{bar}</div>;\n}\n\nfunction shouldNotCompile() {}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{bar: 42}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a Component with Reactive Logic in React\nDESCRIPTION: This snippet defines a React component that introduces a reactive mechanism using a custom runtime import. The component modifies its state based on the `props` it receives and optimizes performance by only re-rendering when necessary. It uses an internal array `$` to manage state and track changes. Inputs include the `props` object with a `cond` property. The expected output is an array containing the updated value of `x` based on the evaluation of `cond` in a loop.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-reactive-after-fixpoint.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  let x = 0;\n\n  let value = null;\n  for (let i = 0; i < 10; i++) {\n    switch (value) {\n      case true: {\n        x = 1;\n        break;\n      }\n      case false: {\n        x = 2;\n        break;\n      }\n    }\n\n    value = props.cond;\n  }\n  let t0;\n  if ($[0] !== x) {\n    t0 = [x];\n    $[0] = x;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  sequentialRenders: [\n    { cond: true },\n    { cond: true },\n    { cond: false },\n    { cond: false },\n    { cond: true },\n    { cond: false },\n    { cond: true },\n    { cond: false },\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Component Definition with Props and Mapping\nDESCRIPTION: Defines a React component named `Component2` that accepts a `props` object with an `items` array. It uses the `map` function to iterate through the `items` array and renders each item as a list item (`<li>`) within an unordered list (`<ul>`).  The `key` prop is set to `item.id` for efficient React rendering.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/outlining-in-func-expr.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst Component2 = props => {\n  return (\n    <ul>\n      {props.items.map(item => (\n        <li key={item.id}>{item.name}</li>\n      ))}\n    </ul>\n  );}\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Hook in React JavaScript\nDESCRIPTION: This code snippet defines a custom hook named 'useHook' in a React application. It imports constants and a 'Stringify' component, uses a conditional to modify a number, and outputs a JSX component. A fixture entry point is defined for test purposes. Dependencies include React, 'shared-runtime', and 'compiler-runtime'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-reassigned-let-declaration.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {CONST_NUMBER0, CONST_NUMBER1, Stringify} from 'shared-runtime';\n\nfunction useHook({cond}) {\n  'use memo';\n  const getX = () => x;\n\n  let x = CONST_NUMBER0;\n  if (cond) {\n    x += CONST_NUMBER1;\n  }\n  return <Stringify getX={getX} shouldInvokeFns={true} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useHook,\n  params: [{cond: true}],\n  sequentialRenders: [{cond: true}, {cond: true}, {cond: false}],\n};\n\n```\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { CONST_NUMBER0, CONST_NUMBER1, Stringify } from \"shared-runtime\";\n\nfunction useHook(t0) {\n  \"use memo\";\n  const $ = _c(2);\n  const { cond } = t0;\n  let t1;\n  if ($[0] !== cond) {\n    const getX = () => x;\n\n    let x;\n    x = CONST_NUMBER0;\n    if (cond) {\n      x = x + CONST_NUMBER1;\n      x;\n    }\n\n    t1 = <Stringify getX={getX} shouldInvokeFns={true} />;\n    $[0] = cond;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useHook,\n  params: [{ cond: true }],\n  sequentialRenders: [{ cond: true }, { cond: true }, { cond: false }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining React Components with Recursive Functions (Input)\nDESCRIPTION: Original React component definitions with recursive callback functions that count down from 10 to 0. Component1 stores the result in a variable before returning, while Component directly returns the result of the recursive function call.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/recursive-function-expression.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component1() {\n  const x = callback(10);\n  function callback(x) {\n    if (x == 0) {\n      return null;\n    }\n    return callback(x - 1);\n  }\n  return x;\n}\n\nfunction Component() {\n  function callback(x) {\n    if (x == 0) {\n      return null;\n    }\n    return callback(x - 1);\n  }\n  return callback(10);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with React Compiler Runtime\nDESCRIPTION: This is the compiled version of the React component, utilizing React's compiler runtime for optimization. The code uses `_c` to create a cache and memoize the onChange handler, the useEffect callback, and the rendered JSX element. It avoids redundant computations by storing values in the cache, improving performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ref-in-effect.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(3);\n  const ref = useRef(null);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = (e) => {\n      const newValue = e.target.value ?? ref.current;\n      ref.current = newValue;\n    };\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const onChange = t0;\n  let t1;\n  if ($[1] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = () => {\n      console.log(ref.current);\n    };\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  useEffect(t1);\n  let t2;\n  if ($[2] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t2 = <Foo onChange={onChange} />;\n    $[2] = t2;\n  } else {\n    t2 = $[2];\n  }\n  return t2;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Invalid React Hook Implementation Example\nDESCRIPTION: Shows an incorrect pattern of calling a hook through a player object's method. This violates React's rules of hooks which require hooks to be called at the top level and be the same function on every render.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-hook-from-property-of-other-hook.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction useFoo({data}) {\n  const player = useVideoPlayer();\n  const foo = player.useMedia();\n  return foo;\n}\n```\n\nLANGUAGE: plaintext\nCODE:\n```\n  1 | function useFoo({data}) {\n  2 |   const player = useVideoPlayer();\n> 3 |   const foo = player.useMedia();\n    |               ^^^^^^^^^^^^^^^ InvalidReact: Hooks must be the same function on every render, but this value may change over time to a different function. See https://react.dev/reference/rules/react-calls-components-and-hooks#dont-dynamically-use-hooks (3:3)\n  4 |   return foo;\n  5 | }\n  6 |\n\n```\n\n----------------------------------------\n\nTITLE: React Component with Side-Effect\nDESCRIPTION: This snippet defines a React component `MyApp` that reassigns the value of a variable `b` defined outside the component's scope.  This is flagged as an error because React components should be pure functions without side effects.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.reassign-global-fn-arg.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nlet b = 1;\n\nexport default function MyApp() {\n  const fn = () => {\n    b = 2;\n  };\n  return foo(fn);\n}\n\nfunction foo(fn) {}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: MyApp,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Exporting React Components in JavaScript\nDESCRIPTION: This snippet defines and exports a React component named 'Component' which utilizes a child component called 'Child'. The 'Component' is also set as a property in a 'FIXTURE_ENTRYPOINT' object, allowing it to be executed with parameters. The child component displays the text passed as a property.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/quoted-strings-in-jsx-attribute.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nexport function Component() {\n  return <Child text='Some \\\"text\\\"' />;\n}\n\nfunction Child(props) {\n  return props.text;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Optimizing React Component with Compiler Runtime - JavaScript\nDESCRIPTION: This snippet showcases a more optimized version of the React components using a custom compiler runtime to enhance performance. It manages state and memoization through an internal array, significantly improving the efficiency of rendering by reducing unnecessary recalculations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/babel-existing-react-kitchensink-import.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport * as React from \"react\";\nimport { useState, useMemo } from \"react\";\n\nfunction Component(props) {\n  const $ = _c(4);\n  const [x] = useState(0);\n  let t0;\n  let t1;\n  if ($[0] !== x) {\n    t1 = calculateExpensiveNumber(x);\n    $[0] = x;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  t0 = t1;\n  const expensiveNumber = t0;\n  let t2;\n  if ($[2] !== expensiveNumber) {\n    t2 = <div>{expensiveNumber}</div>;\n    $[2] = expensiveNumber;\n    $[3] = t2;\n  } else {\n    t2 = $[3];\n  }\n  return t2;\n}\n\nfunction Component2(props) {\n  const $ = _c(4);\n  const [x] = useState(0);\n  let t0;\n  let t1;\n  if ($[0] !== x) {\n    t1 = calculateExpensiveNumber(x);\n    $[0] = x;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  t0 = t1;\n  const expensiveNumber = t0;\n  let t2;\n  if ($[2] !== expensiveNumber) {\n    t2 = <div>{expensiveNumber}</div>;\n    $[2] = expensiveNumber;\n    $[3] = t2;\n  } else {\n    t2 = $[3];\n  }\n  return t2;\n}\n```\n\n----------------------------------------\n\nTITLE: Optimized React Context Access with Compiler Runtime\nDESCRIPTION: This code snippet shows the transformed React component App after optimization using the React compiler runtime. The _c function from react/compiler-runtime is used to memoize the values of foo and bar. The component checks if the values have changed before re-rendering the Bar component, thus preventing unnecessary updates.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/todo.lower-context-access-mixed-array-obj.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @lowerContextAccess\nfunction App() {\n  const $ = _c(3);\n  const context = useContext(MyContext);\n  const [foo] = context;\n  const { bar } = context;\n  let t0;\n  if ($[0] !== bar || $[1] !== foo) {\n    t0 = <Bar foo={foo} bar={bar} />;\n    $[0] = bar;\n    $[1] = foo;\n    $[2] = t0;\n  } else {\n    t0 = $[2];\n  }\n  return t0;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Preserving Memoization with useCallback and useRef in React\nDESCRIPTION: Demonstrates the creation of a React hook function 'useFoo' using useCallback and useRef to ensure the preservation of existing memoization guarantees. The snippet includes the definition of the FIXTURE_ENTRYPOINT, which exports the 'useFoo' function with no additional parameters. React and its hooks are required for this implementation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/preserve-use-memo-ref-missing-ok.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees\nimport {useCallback, useRef} from 'react';\n\nfunction useFoo() {\n  const ref = useRef<undefined | (() => undefined)>();\n\n  return useCallback(() => {\n    if (ref != null) {\n      ref.current();\n    }\n  }, []);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Testing React useMemo Cache Behavior with Module Variables\nDESCRIPTION: A test component that demonstrates how useMemo caches values across renders when module-level variables change. This shows potential issues when module state changes between renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fast-refresh-dont-refresh-const-changes-prod.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @compilationMode(infer)\nimport {useEffect, useMemo, useState} from 'react';\nimport {ValidateMemoization} from 'shared-runtime';\n\nlet pretendConst = 0;\n\nfunction unsafeResetConst() {\n  pretendConst = 0;\n}\n\nfunction unsafeUpdateConst() {\n  pretendConst += 1;\n}\n\nfunction Component() {\n  useState(() => {\n    // unsafe: reset the constant when first rendering the instance\n    unsafeResetConst();\n  });\n  // UNSAFE! changing a module variable that is read by a component is normally\n  // unsafe, but in this case we're simulating a fast refresh between each render\n  unsafeUpdateConst();\n\n  // In production mode (no @enableResetCacheOnSourceFileChanges) memo caches are not\n  // reset unless the deps change\n  const value = useMemo(() => [{pretendConst}], []);\n\n  return <ValidateMemoization inputs={[]} output={value} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n  sequentialRenders: [{}, {}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Array Props\nDESCRIPTION: This snippet defines a React component that creates arrays from props and returns a logical expression. It also exports a fixture entrypoint for testing or demonstration purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/escape-analysis-logical.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const a = [props.a];\n  const b = [props.b];\n  const c = [props.c];\n  // We don't do constant folding for non-primitive values (yet) so we consider\n  // that any of a, b, or c could return here\n  return (a && b) || c;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Memoization (JavaScript)\nDESCRIPTION: This snippet defines a React component 'useFoo' that uses memoization to optimize rendering. It utilizes a custom compiler runtime for dependency tracking and caching. The component renders a 'Stringify' element with memoized props.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/infer-object-method-uncond-access.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enablePropagateDepsInHIR\n\nimport { identity, Stringify } from \"shared-runtime\";\n\nfunction useFoo(t0) {\n  const $ = _c(4);\n  const { a } = t0;\n  let t1;\n  if ($[0] !== a) {\n    t1 = {\n      fn() {\n        return identity(a.b.c);\n      },\n    };\n    $[0] = a;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  const x = t1;\n  let t2;\n  if ($[2] !== x) {\n    t2 = <Stringify x={x} shouldInvokeFns={true} />;\n    $[2] = x;\n    $[3] = t2;\n  } else {\n    t2 = $[3];\n  }\n  return t2;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ a: null }],\n  sequentialRenders: [{ a: null }, { a: { b: { c: 4 } } }],\n};\n```\n\n----------------------------------------\n\nTITLE: Exporting React Component Fixture in JavaScript\nDESCRIPTION: This snippet defines a simple React component and exports it as a fixture entry point. It includes the component function and parameters necessary for its initialization. The expected input is a function that acts as a React component, and it exports an object containing the component function and its parameters as an array.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.handle-unexpected-exception-pipeline.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @throwUnknownException__testonly:true\n\nfunction Component() {}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with FBT Optimization\nDESCRIPTION: Compiled and optimized version of the component with React compiler runtime integrations. Includes caching logic for memoization of FBT translations and Stringify wrapper components.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-template-string-same-scope.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport fbt from \"fbt\";\nimport { Stringify } from \"shared-runtime\";\n\nexport function Component(props) {\n  const $ = _c(4);\n  let count = 0;\n  if (props.items) {\n    count = props.items.length;\n  }\n  let t0;\n  if ($[0] !== count) {\n    t0 = fbt._(\"for {count} experiences\", [fbt._param(\"count\", count)], {\n      hk: \"nmYpm\",\n    });\n    $[0] = count;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  let t1;\n  if ($[2] !== t0) {\n    t1 = <Stringify>{t0}</Stringify>;\n    $[2] = t0;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ items: [1, 2, 3] }],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Unoptimized React Component with Dynamic Item Rendering\nDESCRIPTION: This snippet defines a React component that renders a list of items based on props. It includes a constant TOTAL and exports a FIXTURE_ENTRYPOINT for testing different render scenarios.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-loop-with-value-block-initializer.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst TOTAL = 10;\nfunction Component(props) {\n  const items = [];\n  for (let i = props.start ?? 0; i < props.items.length; i++) {\n    const item = props.items[i];\n    items.push(<div key={item.id}>{item.value}</div>);\n  }\n  return <div>{items}</div>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\n    {\n      start: null,\n      items: [\n        {id: 0, value: 'zero'},\n        {id: 1, value: 'one'},\n      ],\n    },\n  ],\n  sequentialRenders: [\n    {\n      start: 1,\n      items: [\n        {id: 0, value: 'zero'},\n        {id: 1, value: 'one'},\n      ],\n    },\n    {\n      start: 2,\n      items: [\n        {id: 0, value: 'zero'},\n        {id: 1, value: 'one'},\n      ],\n    },\n    {\n      start: 0,\n      items: [\n        {id: 0, value: 'zero'},\n        {id: 1, value: 'one'},\n        {id: 2, value: 'two'},\n      ],\n    },\n    {\n      start: 1,\n      items: [\n        {id: 0, value: 'zero'},\n        {id: 1, value: 'one'},\n        {id: 2, value: 'two'},\n      ],\n    },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Code with Memoization for Effect Dependencies\nDESCRIPTION: The compiled output of the React component, showing how the compiler handles memoization and dependency tracking. It uses a cache mechanism to store the object and effect callback, and explicitly includes the object in the dependency array.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/nonreactive-dep.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @inferEffectDependencies\nimport { useEffect } from \"react\";\nimport { makeObject_Primitives, print } from \"shared-runtime\";\n\n/**\n * Note that `obj` is currently added to the effect dependency array, even\n * though it's non-reactive due to memoization.\n *\n * This is a TODO in effect dependency inference. Note that we cannot simply\n * filter out non-reactive effect dependencies, as some non-reactive (by data\n * flow) values become reactive due to scope pruning. See the\n * `infer-effect-deps/pruned-nonreactive-obj` fixture for why this matters.\n *\n * Realizing that this `useEffect` should have an empty dependency array\n * requires effect dependency inference to be structured similarly to memo\n * dependency inference.\n * Pass 1: add all potential dependencies regardless of dataflow reactivity\n * Pass 2: (todo) prune non-reactive dependencies\n *\n * Note that instruction reordering should significantly reduce scope pruning\n */\nfunction NonReactiveDepInEffect() {\n  const $ = _c(2);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = makeObject_Primitives();\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const obj = t0;\n  let t1;\n  if ($[1] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = () => print(obj);\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  useEffect(t1, [obj]);\n}\n```\n\n----------------------------------------\n\nTITLE: Compiler-Optimized React Hook Implementation\nDESCRIPTION: The compiler-optimized version of the hook with memoization using an array cache ($). Includes checks to prevent unnecessary recreations of arrays and map entries.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/global-types/map-constructor.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { makeArray } from \"shared-runtime\";\n\nfunction useHook(t0) {\n  const $ = _c(7);\n  const { el1, el2 } = t0;\n  let s;\n  if ($[0] !== el1 || $[1] !== el2) {\n    s = new Map();\n    let t1;\n    if ($[3] !== el1) {\n      t1 = makeArray(el1);\n      $[3] = el1;\n      $[4] = t1;\n    } else {\n      t1 = $[4];\n    }\n    s.set(el1, t1);\n    let t2;\n    if ($[5] !== el2) {\n      t2 = makeArray(el2);\n      $[5] = el2;\n      $[6] = t2;\n    } else {\n      t2 = $[6];\n    }\n    s.set(el2, t2);\n    $[0] = el1;\n    $[1] = el2;\n    $[2] = s;\n  } else {\n    s = $[2];\n  }\n  return s.size;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useHook,\n  params: [{ el1: 1, el2: \"foo\" }],\n  sequentialRenders: [\n    { el1: 1, el2: \"foo\" },\n    { el1: 2, el2: \"foo\" },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component Definition (Original)\nDESCRIPTION: This snippet defines a functional React component named `Component` that accepts `props`. Inside the component, an array `x` is initialized, a value from `props` is pushed into it, and another variable `y` is assigned to `x`. Later, `x` is reassigned to a new empty array and a JSX element using `Component` is created. Finally, another value from `props` is pushed into `y` and the component returns a JSX element using `Component`.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reassignment.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let x = [];\n  x.push(props.p0);\n  let y = x;\n\n  x = [];\n  let _ = <Component x={x} />;\n\n  y.push(props.p1);\n\n  return <Component x={x} y={y} />;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom React Hook in JavaScript\nDESCRIPTION: This code snippet demonstrates the creation of a custom React hook. The `createHook` function returns a `useHook` function which in turn calls other hooks (`useHook1` and `useHook2`). This illustrates a valid pattern in React where hooks can invoke other hooks.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-2bec02ac982b.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// @compilationMode(infer)\n// Valid because hooks can call hooks.\nfunction createHook() {\n  return function useHook() {\n    useHook1();\n    useHook2();\n  };\n}\n\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Memoization\nDESCRIPTION: This snippet shows the optimized version of the component using React's compiler-runtime. It implements memoization to cache the component's state, potentially improving performance by avoiding unnecessary re-computations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/declare-reassign-variable-in-closure.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(p) {\n  const $ = _c(1);\n  let x;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const foo = () => {\n      x = {};\n    };\n\n    foo();\n    $[0] = x;\n  } else {\n    x = $[0];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Unused Variable\nDESCRIPTION: This snippet defines a React functional component named 'Component' that returns the 'value' prop. It also includes an unused variable '_'. The component is then exported as part of a FIXTURE_ENTRYPOINT object.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/dce-unused-const.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const _ = 42;\n  return props.value;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: 42}],\n};\n```\n\n----------------------------------------\n\nTITLE: Using Hooks within a React Component in JavaScript\nDESCRIPTION: Demonstrates the implementation of a React component with an incorrect usage of hooks, where a hook is invoked based on a condition inside the component, leading to a runtime error. The correct pattern requires hooks to be called unconditionally to maintain consistent ordering across renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-condtionally-call-hooklike-property-of-local.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {makeObject_Primitives} from 'shared-runtime';\n\nfunction Component(props) {\n  const local = makeObject_Primitives();\n  if (props.cond) {\n    const foo = local.useFoo;\n    foo();\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Component Definition\nDESCRIPTION: This snippet defines a simple React component that takes a parameter 'a', creates an object 'z' with 'a' as a property, and then adds a property 'b' to 'z' within nested immediately invoked function expressions (IIFEs). Finally, it returns the object 'z'. This demonstrates a basic component structure with side effects within the function body.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capture_mutate-across-fns-iife.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component(a) {\n  let z = {a};\n  (function () {\n    (function () {\n      z.b = 1;\n    })();\n  })();\n  return z;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: [2],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Hook with Memoization Logic\nDESCRIPTION: Shows the compiled version of the custom hook with explicit memoization checks and caching implementation. Uses React compiler runtime to manage memoized values and implement dependency comparison logic.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useMemo-infer-more-specific.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @validatePreserveExistingMemoizationGuarantees\n\nimport { useMemo } from \"react\";\n\n// More specific memoization always results in fewer memo block\n// executions.\n// Precisely:\n//  x_new != x_prev does NOT imply x.y.z_new != x.y.z_prev\n//  x.y.z_new != x.y.z_prev does imply x_new != x_prev\nfunction useHook(x) {\n  const $ = _c(2);\n  let t0;\n  let t1;\n  if ($[0] !== x.y.z) {\n    t1 = [x.y.z];\n    $[0] = x.y.z;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  t0 = t1;\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useHook,\n  params: [{ y: { z: 2 } }],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component without useCallback Implementation\nDESCRIPTION: Alternative implementation of the same component without using useCallback for memoization. Creates mutable objects and returns a non-memoized callback function.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useCallback-maybe-modify-free-variable-dont-preserve-memoization-guarantee.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// @enablePreserveExistingMemoizationGuarantees:false\nimport { useCallback } from \"react\";\nimport {\n  identity,\n  makeObject_Primitives,\n  mutate,\n  useHook,\n} from \"shared-runtime\";\n\nfunction Component(props) {\n  const free = makeObject_Primitives();\n  const free2 = makeObject_Primitives();\n  const part = free2.part;\n  useHook();\n  const callback = () => {\n    const x = makeObject_Primitives();\n    x.value = props.value;\n    mutate(x, free, part);\n  };\n\n  mutate(free, part);\n  return callback;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ value: 42 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Click Event Handlers with Stringify Component - JavaScript\nDESCRIPTION: This snippet defines two click event handler functions ('onClick' and 'onClick2') within a 'hoisting' function, which returns a 'Stringify' component with the handlers passed as props. It demonstrates the use of local variables and object property access. Dependencies include 'shared-runtime' for the Stringify component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-computed-member-expression.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {Stringify} from 'shared-runtime';\n\nfunction hoisting() {\n  function onClick() {\n    return bar['baz'];\n  }\n  function onClick2() {\n    return bar[baz];\n  }\n  const baz = 'baz';\n  const bar = {baz: 1};\n\n  return (\n    <Stringify onClick={onClick} onClick2={onClick2} shouldInvokeFns={true} />\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: hoisting,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Publishing Current Contents of Build to NPM in Shell\nDESCRIPTION: This script publishes the contents of the build directory to NPM. It updates the specified tags to match without verifying the contents beforehand. It can be run with a `--dry` flag to simulate the NPM publish step without executing it. The output includes instructions for tagging the commit and updating the CHANGELOG.\nSOURCE: https://github.com/facebook/react/blob/main/scripts/release/README.md#2025-04-21_snippet_12\n\nLANGUAGE: sh\nCODE:\n```\nscripts/release/publish.js --tags latest next\n```\n\n----------------------------------------\n\nTITLE: React Compiler Transformed Component with Memoization\nDESCRIPTION: Compiler-generated version of useFoo with explicit memoization and state tracking using _c runtime helper, handling nested function and component rendering\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/infer-nested-function-uncond-access-local-var.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction useFoo(t0) {\n  const $ = _c(6);\n  const { a } = t0;\n  let local;\n  if ($[0] !== a) {\n    local = shallowCopy(a);\n    mutate(local);\n    $[0] = a;\n    $[1] = local;\n  } else {\n    local = $[1];\n  }\n  // ... rest of transformed implementation\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: This snippet shows the compiled version of the React component, utilizing React's compiler runtime (likely prepack or similar). It memoizes the rendered element based on the `props.version` to avoid unnecessary re-renders. The component leverages the `_c` function from `react/compiler-runtime` for memoization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-namespaced-name.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== props.version) {\n    t0 = <xml:http protocol:version={props.version} />;\n    $[0] = props.version;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Memoization\nDESCRIPTION: Compiler-optimized version of the component that includes memoization checks and caching using React's compiler runtime. Implements efficient prop comparison and object caching.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-push-effect.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // arrayInstance.push should have the following effects:\\n//  - read on all args (rest parameter)\\n//  - mutate on receiver\\nfunction Component(props) {\\n  const $ = _c(8);\\n  let t0;\\n  if ($[0] !== props.x) {\\n    t0 = foo(props.x);\\n    $[0] = props.x;\\n    $[1] = t0;\\n  } else {\\n    t0 = $[1];\\n  }\\n  const x = t0;\\n  let t1;\\n  if ($[2] !== props.y) {\\n    t1 = { y: props.y };\\n    $[2] = props.y;\\n    $[3] = t1;\\n  } else {\\n    t1 = $[3];\\n  }\\n  const y = t1;\\n  let arr;\\n  if ($[4] !== x || $[5] !== y) {\\n    arr = [];\\n    let t2;\\n    if ($[7] === Symbol.for(\"react.memo_cache_sentinel\")) {\\n      t2 = {};\\n      $[7] = t2;\\n    } else {\\n      t2 = $[7];\\n    }\\n    arr.push(t2);\\n    arr.push(x, y);\\n    $[4] = x;\\n    $[5] = y;\\n    $[6] = arr;\\n  } else {\\n    arr = $[6];\\n  }\\n  return arr;\\n}\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Memoization\nDESCRIPTION: This snippet shows an optimized version of the React component using memoization techniques. It uses the '_c' function from 'react/compiler-runtime' to create a cache and optimize re-renders based on prop changes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/functionexpr-conditional-access-2.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enableTreatFunctionDepsAsConditional\nimport { Stringify } from \"shared-runtime\";\n\nfunction Component(t0) {\n  const $ = _c(7);\n  const { props } = t0;\n  let t1;\n  if ($[0] !== props) {\n    t1 = () => props.a.b;\n    $[0] = props;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  const f = t1;\n  let t2;\n  if ($[2] !== f || $[3] !== props) {\n    t2 = props == null ? _temp : f;\n    $[2] = f;\n    $[3] = props;\n    $[4] = t2;\n  } else {\n    t2 = $[4];\n  }\n  let t3;\n  if ($[5] !== t2) {\n    t3 = <Stringify f={t2} />;\n    $[5] = t2;\n    $[6] = t3;\n  } else {\n    t3 = $[6];\n  }\n  return t3;\n}\nfunction _temp() {}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ props: null }],\n};\n```\n\n----------------------------------------\n\nTITLE: Enhanced Custom Hook with React Compiler Runtime in JavaScript\nDESCRIPTION: This snippet is an enhanced version of the previous hook, adding state checks and utilizing the React compiler runtime for more efficient state management. It encapsulates value mutation and retrieval, checking if the current value has changed before reassigning the internal state.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-method-shorthand-mutated-after.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { createHookWrapper, mutate, mutateAndReturn } from \"shared-runtime\";\nfunction useHook(t0) {\n  const $ = _c(2);\n  const { value } = t0;\n  let obj;\n  if ($[0] !== value) {\n    const x = mutateAndReturn({ value });\n    obj = {\n      getValue() {\n        return x;\n      },\n    };\n\n    mutate(obj);\n    $[0] = value;\n    $[1] = obj;\n  } else {\n    obj = $[1];\n  }\n  return obj;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: createHookWrapper(useHook),\n  params: [{ value: 0 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining React Functional Component - Advanced Version with React Compiler Runtime\nDESCRIPTION: This JavaScript snippet enhances the previous component by integrating the React/compiler-runtime. It introduces memoization logic to avoid recalculating the object unless its reference changes. It maintains the same export structure for testing with a sample 'foo' implementation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisted-function-declaration.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction component(a) {\n  const $ = _c(2);\n  let t;\n  if ($[0] !== a) {\n    t = { a };\n    x(t);\n    function x(p) {\n      p.a.foo();\n    }\n    $[0] = a;\n    $[1] = t;\n  } else {\n    t = $[1];\n  }\n  return t;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: [\n    {\n      foo: () => {\n        console.log(42);\n      },\n    },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Mutating Component with Shared-Runtime in JavaScript\nDESCRIPTION: The snippet demonstrates a function named 'component' which utilizes the 'mutate' method from 'shared-runtime'. It initializes an object 'x' and a function scope variable 'y', modifies 'y' within an IIFE by attaching 'x', and then mutates 'y'. The exported 'FIXTURE_ENTRYPOINT' object aids in testing by specifying input parameters. No external dependencies apart from the 'shared-runtime' library are required. The function expects a single string parameter and returns a mutated object.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-alias-receiver-mutate-iife.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst {mutate} = require('shared-runtime');\n\nfunction component(a) {\n  let x = {a};\n  let y = {};\n  (function () {\n    let a = y;\n    a.x = x;\n  })();\n  mutate(y);\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: ['foo'],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Using useState in React Component - JavaScript\nDESCRIPTION: This snippet defines a React functional component utilizing the useState hook to manage internal state and render a div element containing that state value. It imports useState from React and defines auxiliary functions to handle data transformations. It establishes a clear entry point for testing the component with predefined parameters.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useState-and-other-hook-unpruned-dependency.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useState} from 'react'; // @enableChangeDetectionForDebugging\n\nfunction useOther(x) {\n  return x;\n}\n\nfunction Component(props) {\n  const w = f(props.x);\n  const z = useOther(w);\n  const [x, _] = useState(z);\n  return <div>{x}</div>;\n}\n\nfunction f(x) {\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{x: 42}],\n  isComponent: true,\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Memoized React Component - JavaScript\nDESCRIPTION: This snippet represents a more optimized version of the React component that utilizes a memoization technique for performance. It changes the behavior based on previous props and conditions to avoid unnecessary object creation if the props havent changed. The memoization relies on symbols and maintains a cache-like behavior to store previous results. This snippet also requires React as a dependency. It returns an array with similar structure and conditions as the first snippet.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/phi-type-inference-property-store.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @debug @enablePropagateDepsInHIR\nfunction Component(props) {\n  const $ = _c(4);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = {};\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const x = t0;\n  let t1;\n  if ($[1] !== props.a || $[2] !== props.cond) {\n    let y;\n    if (props.cond) {\n      y = {};\n    } else {\n      y = { a: props.a };\n    }\n\n    y.x = x;\n\n    t1 = [x, y];\n    $[1] = props.a;\n    $[2] = props.cond;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ cond: false, a: \"a!\" }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Running React DevTools Scheduling Profiler Fixture with Shell Commands\nDESCRIPTION: Shell commands for downloading the latest experimental React build and running the scheduling profiler fixture. This needs to be executed from the root directory of the React project.\nSOURCE: https://github.com/facebook/react/blob/main/fixtures/devtools/scheduling-profiler/README.md#2025-04-21_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n# In the root directory\n# Download the latest *experimental* React build\nscripts/release/download-experimental-build.js\n\n# Run this fixtures\nfixtures/devtools/scheduling-profiler/run.js\n```\n\n----------------------------------------\n\nTITLE: Efficient Dependency Management in React Component - JavaScript\nDESCRIPTION: The code refines a React component by applying optimizations like caching dependencies and utilizing the 'useFire' hook. It demonstrates dependency tracking to prevent unnecessary re-renders. Dependencies such as 'props.bar' are monitored, and effects are fired accordingly, offering a more efficient lifecycle management.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/fire-and-autodeps.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c, useFire } from \"react/compiler-runtime\"; // @enableFire @inferEffectDependencies\nimport { fire, useEffect } from \"react\";\n\nfunction Component(props) {\n  const $ = _c(5);\n  let t0;\n  if ($[0] !== props.bar) {\n    t0 = (arg) => {\n      console.log(arg, props.bar);\n    };\n    $[0] = props.bar;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const foo = t0;\n  const t1 = useFire(foo);\n  let t2;\n  if ($[2] !== props || $[3] !== t1) {\n    t2 = () => {\n      t1(props);\n    };\n    $[2] = props;\n    $[3] = t1;\n    $[4] = t2;\n  } else {\n    t2 = $[4];\n  }\n  useEffect(t2, [props]);\n  return null;\n}\n\n```\n\n----------------------------------------\n\nTITLE: React Component with useMemo\nDESCRIPTION: This React component utilizes `useMemo` to memoize the `handlers` object based on the `props.value`. It also includes a switch statement that logs the `handlers.value` to the console if `props.test` is true. The component returns the memoized `handlers` object. This is intended to be the original, uncompiled source.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/block-scoping-switch-variable-scoping.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useMemo} from 'react';\n\nfunction Component(props) {\n  const outerHandlers = useMemo(() => {\n    let handlers = {value: props.value};\n    switch (props.test) {\n      case true: {\n        console.log(handlers.value);\n        break;\n      }\n      default: {\n      }\n    }\n    return handlers;\n  });\n  return outerHandlers;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{test: true, value: 'hello'}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Original React Component\nDESCRIPTION: This snippet shows the original React component definition. It takes props as input, creates a MaybeMutable object, retrieves a value from props, and returns an array containing the prop value and the result of calling maybeMutate with the MaybeMutable object.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/temporary-property-load-accessed-outside-scope.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const maybeMutable = new MaybeMutable();\n  let x = props.value;\n  return [x, maybeMutate(maybeMutable)];\n}\n```\n\n----------------------------------------\n\nTITLE: Input React Components with 'use forget' Directive\nDESCRIPTION: Original React component code before compilation, showing Bar and Foo components with 'use forget' directives. Both components import from 'shared-runtime' and use the 'use forget' directive to optimize rendering.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/conflict-codegen-instrument-forget.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableEmitInstrumentForget @compilationMode(annotation)\n\nimport {identity} from 'shared-runtime';\n\nfunction Bar(props) {\n  'use forget';\n  const shouldInstrument = identity(null);\n  const _shouldInstrument = identity(null);\n  const _x2 = () => {\n    const _shouldInstrument2 = 'hello world';\n    return identity({_shouldInstrument2});\n  };\n  return (\n    <div style={shouldInstrument} other={_shouldInstrument}>\n      {props.bar}\n    </div>\n  );\n}\n\nfunction Foo(props) {\n  'use forget';\n  return <Foo>{props.bar}</Foo>;\n}\n```\n\n----------------------------------------\n\nTITLE: Enhanced React Component with React Compiler Runtime\nDESCRIPTION: This snippet showcases an optimized version of the Component function with enhanced reactivity management using the react/compiler-runtime module. It introduces a caching mechanism through a memoized sentinel for improved performance. The state manipulation logic remains similar to the initial implementation, with reliance on the props for initial state settings. The caching mechanism checks for a sentinel value, allowing encapsulated reactivity in returning state outputs. Dependencies include import of react/compiler-runtime. It inputs props, outputs an array of values, and requires usage within a compatible React environment.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-from-interleaved-reactivity-for-in.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(1);\n\n  const a = [];\n  const b = [];\n  b.push(props.cond);\n  a.push({ a: false });\n\n  const c = [a];\n\n  let x;\n  for (const i in c[0][0]) {\n    x = 1;\n  }\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = [x];\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ cond: true }],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: Basic React component implementation showing useCallback pattern for event handling and object memoization. Uses custom hooks and utilities for demonstration purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useCallback-call-second-function-which-captures-maybe-mutable-value-preserve-memoization.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enablePreserveExistingMemoizationGuarantees\nimport {useCallback} from 'react';\nimport {\n  identity,\n  logValue,\n  makeObject_Primitives,\n  useHook,\n} from 'shared-runtime';\n\nfunction Component(props) {\n  const object = makeObject_Primitives();\n\n  useHook();\n\n  const log = () => {\n    logValue(object);\n  };\n\n  const onClick = useCallback(() => {\n    log();\n  }, [log]);\n\n  identity(object);\n\n  return <div onClick={onClick} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Components with Memoization\nDESCRIPTION: Compiled version of the React components with added memoization logic. Shows how the forget directive is transformed into conditional rendering with value caching using the compiler runtime.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/gating-test-export-function.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { isForgetEnabled_Fixtures } from \"ReactForgetFeatureFlag\"; // @gating @compilationMode(annotation)\nexport const Bar = isForgetEnabled_Fixtures()\n  ? function Bar(props) {\n      \"use forget\";\n      const $ = _c(2);\n      let t0;\n      if ($[0] !== props.bar) {\n        t0 = <div>{props.bar}</div>;\n        $[0] = props.bar;\n        $[1] = t0;\n      } else {\n        t0 = $[1];\n      }\n      return t0;\n    }\n  : function Bar(props) {\n      \"use forget\";\n      return <div>{props.bar}</div>;\n    };\n\nexport function NoForget(props) {\n  return <Bar>{props.noForget}</Bar>;\n}\n\nexport const Foo = isForgetEnabled_Fixtures()\n  ? function Foo(props) {\n      \"use forget\";\n      const $ = _c(2);\n      let t0;\n      if ($[0] !== props.bar) {\n        t0 = <Foo>{props.bar}</Foo>;\n        $[0] = props.bar;\n        $[1] = t0;\n      } else {\n        t0 = $[1];\n      }\n      return t0;\n    }\n  : function Foo(props) {\n      \"use forget\";\n      return <Foo>{props.bar}</Foo>;\n    };\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: eval(\"Bar\"),\n  params: [{ bar: 2 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: The compiled version of the React component with explicit memoization cache handling. Uses Symbol.for('react.memo_cache_sentinel') for cache validation and implements manual dependency checking.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useCallback-maybe-modify-free-variable-preserve-memoization-guarantee.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enablePreserveExistingMemoizationGuarantees\nimport { useCallback } from \"react\";\nimport {\n  identity,\n  makeObject_Primitives,\n  mutate,\n  useHook,\n} from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(4);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = makeObject_Primitives();\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const free = t0;\n  let t1;\n  if ($[1] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = makeObject_Primitives();\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  const free2 = t1;\n  const part = free2.part;\n  useHook();\n  let t2;\n  if ($[2] !== props.value) {\n    t2 = () => {\n      const x = makeObject_Primitives();\n      x.value = props.value;\n      mutate(x, free, part);\n    };\n    $[2] = props.value;\n    $[3] = t2;\n  } else {\n    t2 = $[3];\n  }\n  const callback = t2;\n\n  mutate(free, part);\n  return callback;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ value: 42 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization Optimizations in JavaScript\nDESCRIPTION: The compiled version of the React component with memoization optimizations applied. It uses React compiler runtime to cache values between renders and conditionally rebuilds arrays only when dependent props change.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/phi-type-inference-array-push-consecutive-phis.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { makeArray } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(6);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = {};\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const x = t0;\n  let t1;\n  if (\n    $[1] !== props.cond ||\n    $[2] !== props.cond2 ||\n    $[3] !== props.value ||\n    $[4] !== props.value2\n  ) {\n    let y;\n    if (props.cond) {\n      if (props.cond2) {\n        y = [props.value];\n      } else {\n        y = [props.value2];\n      }\n    } else {\n      y = [];\n    }\n\n    y.push(x);\n\n    t1 = [x, y];\n    $[1] = props.cond;\n    $[2] = props.cond2;\n    $[3] = props.value;\n    $[4] = props.value2;\n    $[5] = t1;\n  } else {\n    t1 = $[5];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ cond: true, cond2: true, value: 42 }],\n  sequentialRenders: [\n    { cond: true, cond2: true, value: 3.14 },\n    { cond: true, cond2: true, value: 42 },\n    { cond: true, cond2: true, value: 3.14 },\n    { cond: true, cond2: false, value2: 3.14 },\n    { cond: true, cond2: false, value2: 42 },\n    { cond: true, cond2: false, value2: 3.14 },\n    { cond: false },\n    { cond: false },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiler-Optimized React Component Implementation\nDESCRIPTION: An optimized version of the React component using React compiler runtime with memoization and cached computations\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useEffect-nested-lambdas.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enableTransitivelyFreezeFunctionExpressions:false\n\nfunction Component(props) {\n  const $ = _c(7);\n  const item = useMutable(props.itemId);\n  const dispatch = useDispatch();\n  useFreeze(dispatch);\n  let t0;\n  if ($[0] !== dispatch) {\n    t0 = () => {\n      dispatch(createExitAction());\n    };\n    $[0] = dispatch;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const exit = t0;\n  let t1;\n  let t2;\n  if ($[2] !== exit || $[3] !== item) {\n    t1 = () => {\n      const cleanup = GlobalEventEmitter.addListener(\"onInput\", () => {\n        if (item.value) {\n          exit();\n        }\n      });\n      return () => cleanup.remove();\n    };\n    t2 = [exit, item];\n    $[2] = exit;\n    $[3] = item;\n    $[4] = t1;\n    $[5] = t2;\n  } else {\n    t1 = $[4];\n    t2 = $[5];\n  }\n  useEffect(t1, t2);\n\n  maybeMutate(item);\n  let t3;\n  if ($[6] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t3 = <div />;\n    $[6] = t3;\n  } else {\n    t3 = $[6];\n  }\n  return t3;\n}\n```\n\n----------------------------------------\n\nTITLE: Advanced Transition Management in React JavaScript\nDESCRIPTION: This JavaScript snippet uses React's compiler-runtime for memoization and uses the hooks useCallback and useTransition to manage state transitions. The function useFoo returns a memoized function, ensuring transitions are correctly handled by using internal caches to optimize repeated renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/preserve-use-memo-transition.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @validatePreserveExistingMemoizationGuarantees\nimport { useCallback, useTransition } from \"react\";\n\nfunction useFoo() {\n  const $ = _c(1);\n  const [, start] = useTransition();\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = () => {\n      start();\n    };\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Compiler Runtime\nDESCRIPTION: This snippet demonstrates the optimized version of the component using React's compiler-runtime. It implements memoization and efficient updates based on prop changes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-join.expect.md#2025-04-22_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(7);\n  let t0;\n  let t1;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = {};\n    t1 = [];\n    $[0] = t0;\n    $[1] = t1;\n  } else {\n    t0 = $[0];\n    t1 = $[1];\n  }\n  let t2;\n  if ($[2] !== props.value) {\n    t2 = [t0, t1, props.value];\n    $[2] = props.value;\n    $[3] = t2;\n  } else {\n    t2 = $[3];\n  }\n  const x = t2;\n  const y = x.join(_temp);\n  foo(y);\n  let t3;\n  if ($[4] !== x || $[5] !== y) {\n    t3 = [x, y];\n    $[4] = x;\n    $[5] = y;\n    $[6] = t3;\n  } else {\n    t3 = $[6];\n  }\n  return t3;\n}\nfunction _temp() {\n  return \"this closure gets stringified, not called\";\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled React Counter Component\nDESCRIPTION: The compiled version of the counter component showing how React transforms the code with memoization, compiler runtime imports, and optimization techniques. Includes implementation of memo cache sentinel and state management.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/arrow-expr-directive.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component() {\n  \"use strict\";\n  const $ = _c(3);\n\n  const [count, setCount] = React.useState(0);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = () => {\n      \"worklet\";\n\n      setCount(_temp);\n    };\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const update = t0;\n  let t1;\n  if ($[1] !== count) {\n    t1 = <button onClick={update}>{count}</button>;\n    $[1] = count;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  return t1;\n}\nfunction _temp(count_0) {\n  return count_0 + 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component\nDESCRIPTION: This snippet shows the compiled version of the React component, optimized using `react/compiler-runtime`. It uses a caching mechanism (`_c`) to avoid re-rendering the component if the `name` prop hasn't changed.  It utilizes `SharedRuntime.Stringify` to format the output.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-lowercase-localvar-memberexpr.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport * as SharedRuntime from \"shared-runtime\";\nfunction Component(t0) {\n  const $ = _c(2);\n  const { name } = t0;\n  let t1;\n  if ($[0] !== name) {\n    t1 = <SharedRuntime.Stringify>hello world {name}</SharedRuntime.Stringify>;\n    $[0] = name;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ name: \"sathya\" }],\n};\n```\n\n----------------------------------------\n\nTITLE: React Compiler Memoization Error\nDESCRIPTION: This is the error message generated by the React Compiler.  It explains why the compiler skipped optimizing a component.  The error `CannotPreserveMemoization` explains that the inferred dependencies did not match the manually specified dependencies.  The message pinpoints the line where useCallback is used and the dependencies array.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.useCallback-property-call-dep.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n  3 |\n  4 | function Component({propA}) {\n> 5 |   return useCallback(() => {\n    |                      ^^^^^^^\n> 6 |     return propA.x();\n    | ^^^^^^^^^^^^^^^^^^^^^\n> 7 |   }, [propA.x]);\n    | ^^^^ CannotPreserveMemoization: React Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. The inferred dependencies did not match the manually specified dependencies, which could cause the value to change more or less frequently than expected (5:7)\n  8 | }\n  9 |\n\n```\n\n----------------------------------------\n\nTITLE: Using React useState Hook for State Management in JavaScript\nDESCRIPTION: This snippet illustrates the use of the useState hook from React to manage local component state. The initial state is set to an object containing a nested structure. However, it demonstrates an incorrect approach by directly mutating the state, which leads to a warning about proper usage. It is important to utilize the setter function to make updates to the state instead of mutating it directly.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.modify-state-2.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useState} from 'react';\n\nfunction Foo() {\n  const [state, setState] = useState({foo: {bar: 3}});\n  const foo = state.foo;\n  foo.bar = 1;\n  return state;\n}\n\n```\n\nLANGUAGE: javascript\nCODE:\n```\n  4 |   const [state, setState] = useState({foo: {bar: 3}});\n  5 |   const foo = state.foo;\n> 6 |   foo.bar = 1;\n    |   ^^^ InvalidReact: Mutating a value returned from 'useState()', which should not be mutated. Use the setter function to update instead (6:6)\n  7 |   return state;\n  8 | }\n  9 |\n```\n\n----------------------------------------\n\nTITLE: Input: Function Component with Closure Variable Modification\nDESCRIPTION: Demonstrates a React functional component that modifies an external variable through a nested function, using useFoo higher-order function\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reassign-global-hook-arg.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nlet b = 1;\n\nexport default function MyApp() {\n  const fn = () => {\n    b = 2;\n  };\n  return useFoo(fn);\n}\n\nfunction useFoo(fn) {}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: MyApp,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Simplified React Component with Constant Return\nDESCRIPTION: Simplified version of the React component that directly returns a constant value of 42. This implementation removes the error handling and demonstrates the same functional outcome as the more complex version.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-try-immediately-throws-after-constant-propagation.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let x;\n  return 42;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ default: 42 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Utilizing Hooks in React with TypeScript\nDESCRIPTION: The `useFoo` function is a custom React hook that accepts a props object with a value potentially containing properties `x` and `y` as strings or `null`. It creates an array using the `createArray` function and attempts to join the values with a comma delimiter. The `createArray` function is a utility to aggregate the given arguments into an array. There is a known issue related to handling optional properties in TypeScript, indicated by the error snippet. No specific external libraries are required other than TypeScript and React.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/error.todo-optional-call-chain-in-optional.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enablePropagateDepsInHIR\nfunction useFoo(props: {value: {x: string; y: string} | null}) {\n  const value = props.value;\n  return createArray(value?.x, value?.y)?.join(', ');\n}\n\nfunction createArray<T>(...args: Array<T>): Array<T> {\n  return args;\n}\n\nexport const FIXTURE_ENTRYPONT = {\n  fn: useFoo,\n  props: [{value: null}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Component Definition and Export (Code)\nDESCRIPTION: Defines a functional React component named `Component` that renders a div containing the text \"Hello world\". This version seems to utilize an internal React feature, possibly related to memoization, indicated by the `_c` import and the use of `Symbol.for(\"react.memo_cache_sentinel\")`. The `FIXTURE_ENTRYPOINT` exports the component with metadata.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/target-flag-meta-internal.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react\"; // @target=\"donotuse_meta_internal\"\n\nfunction Component() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = <div>Hello world</div>;\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  isComponent: true,\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: Compiled version of the React component with added memoization logic using React's compiler runtime. Includes symbol-based cache sentinel checks and block-scoped error handling.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-with-return.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nconst { shallowCopy, throwInput } = require(\"shared-runtime\");\n\nfunction Component(props) {\n  const $ = _c(2);\n  let t0;\n  let x;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = Symbol.for(\"react.early_return_sentinel\");\n    bb0: {\n      x = [];\n      try {\n        const y = shallowCopy({});\n        if (y == null) {\n          t0 = undefined;\n          break bb0;\n        }\n\n        x.push(throwInput(y));\n      } catch {\n        t0 = null;\n        break bb0;\n      }\n    }\n    $[0] = t0;\n    $[1] = x;\n  } else {\n    t0 = $[0];\n    x = $[1];\n  }\n  if (t0 !== Symbol.for(\"react.early_return_sentinel\")) {\n    return t0;\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Components with Memoization\nDESCRIPTION: Compiled version of the components with added memoization logic using the compiler runtime. Includes feature flag checks and cache management for optimized rendering.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/gating-test-export-function-and-default.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { isForgetEnabled_Fixtures } from \"ReactForgetFeatureFlag\"; // @gating @compilationMode(annotation)\nconst Bar = isForgetEnabled_Fixtures()\n  ? function Bar(props) {\n      \"use forget\";\n      const $ = _c(2);\n      let t0;\n      if ($[0] !== props.bar) {\n        t0 = <div>{props.bar}</div>;\n        $[0] = props.bar;\n        $[1] = t0;\n      } else {\n        t0 = $[1];\n      }\n      return t0;\n    }\n  : function Bar(props) {\n      \"use forget\";\n      return <div>{props.bar}</div>;\n    };\nexport default Bar;\n\nfunction NoForget(props) {\n  return <Bar>{props.noForget}</Bar>;\n}\nconst Foo = isForgetEnabled_Fixtures()\n  ? function Foo(props) {\n      \"use forget\";\n      const $ = _c(3);\n      if (props.bar < 0) {\n        return props.children;\n      }\n\n      const t0 = props.bar - 1;\n      let t1;\n      if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n        t1 = <NoForget />;\n        $[0] = t1;\n      } else {\n        t1 = $[0];\n      }\n      let t2;\n      if ($[1] !== t0) {\n        t2 = <Foo bar={t0}>{t1}</Foo>;\n        $[1] = t0;\n        $[2] = t2;\n      } else {\n        t2 = $[2];\n      }\n      return t2;\n    }\n  : function Foo(props) {\n      \"use forget\";\n      if (props.bar < 0) {\n        return props.children;\n      }\n      return (\n        <Foo bar={props.bar - 1}>\n          <NoForget />\n        </Foo>\n      );\n    };\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: eval(\"Bar\"),\n  params: [{ bar: 2 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled useEffect and useState React Component - JavaScript\nDESCRIPTION: This snippet is a compiled version of a React component using useState and useEffect. It includes memoization techniques and checks symbol values to conditionally assign an effect handler. The function _temp defines the update logic for the state.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/invalid-setState-in-useEffect.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @logger @validateNoSetStateInPassiveEffects\nimport { useEffect, useState } from \"react\";\n\nfunction Component() {\n  const $ = _c(1);\n  const [state, setState] = useState(0);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = () => {\n      setState(_temp);\n    };\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  useEffect(t0);\n  return state;\n}\nfunction _temp(s) {\n  return s + 1;\n}\n\n```\n\n----------------------------------------\n\nTITLE: React forwardRef with Hooks\nDESCRIPTION: This code snippet demonstrates the usage of React's `forwardRef` with hooks. It shows that hooks can be used within the anonymous function provided as an argument to `forwardRef`. The `FancyButton` component forwards its ref to the underlying button element and uses a hook named `useHook`.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-e66a744cffbe.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Valid because hooks can be used in anonymous function arguments to\n// forwardRef.\nconst FancyButton = forwardRef(function (props, ref) {\n  useHook();\n  return <button {...props} ref={ref} />;\n});\n\n```\n\n----------------------------------------\n\nTITLE: Defining a React Component with Hooks in JavaScript\nDESCRIPTION: This snippet defines a simple React functional component that uses a custom hook and the identity function from shared-runtime. The component conditionally modifies a state variable based on props and returns an array containing that state variable. The useHook() call is placed specifically to prevent memoization of the variable x.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/prune-scopes-whose-deps-may-invalidate-array.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useHook, identity} from 'shared-runtime';\n\nfunction Component(props) {\n  let x = 42;\n  if (props.cond) {\n    x = [];\n  }\n  useHook(); // intersperse a hook call to prevent memoization of x\n  identity(x);\n\n  const y = [x];\n\n  return [y];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: 'sathya'}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Optimization\nDESCRIPTION: Compiled version of the component that includes React runtime optimization. Implements caching mechanism using an array to store previous values and avoid unnecessary object creation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unary-expr.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction component(a) {\n  const $ = _c(8);\n  const t = { t: a };\n  const z = +t.t;\n  const q = -t.t;\n  const p = void t.t;\n  const n = delete t.t;\n  const m = !t.t;\n  const e = ~t.t;\n  const f = typeof t.t;\n  let t0;\n  if (\n    $[0] !== e ||\n    $[1] !== f ||\n    $[2] !== m ||\n    $[3] !== n ||\n    $[4] !== p ||\n    $[5] !== q ||\n    $[6] !== z\n  ) {\n    t0 = { z, p, q, n, m, e, f };\n    $[0] = e;\n    $[1] = f;\n    $[2] = m;\n    $[3] = n;\n    $[4] = p;\n    $[5] = q;\n    $[6] = z;\n    $[7] = t0;\n  } else {\n    t0 = $[7];\n  }\n  return t0;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Functional Component in React\nDESCRIPTION: This snippet defines a functional component named 'foo' that takes 'props' as an argument. It initializes variables, processes input props, and returns a structured JSX output containing a header and content. The component maintains internal state using local variables and handles changes in props efficiently using array manipulations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/same-variable-as-dep-and-redeclare.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// note: comments are for the ideal scopes, not what is currently\n// emitted\nfunction foo(props) {\n  // scope 0: deps=[props.a] decl=[x] reassign=none\n  let x = [];\n  x.push(props.a);\n\n  // scope 1: deps=[x] decl=[header] reassign=none\n  const header = <div>{x}</div>;\n\n  // scope 2:\n  // deps=[x, props.b, props.c]\n  // decl=none\n  // reassign=[x]\n  const y = [x]; // y depends on the earlier x\n  x = []; // x reassigned\n  y.push(props.b); // interleaved mutation of x/y\n  x.push(props.c); // interleaved mutation\n\n  // scope 3 ...\n  const content = (\n    <div>\n      {x}\n      {y}\n    </div>\n  );\n\n  // scope 4 ...\n  return (\n    <>\n      {header}\n      {content}\n    </>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Managing Local Variable Reassignment in React Component JavaScript\nDESCRIPTION: This JavaScript snippet demonstrates how to manage the reassignment of a local variable within a React component. It utilizes a function 'mk_reassignlocal' to encapsulate logic for resetting the variable and handling potential state management issues. The useEffect hook is employed to execute the onMount function, which checks the variable reassignment. This implementation must consider React's rendering lifecycle to avoid unexpected behavior. No external dependencies are required, but understanding React's lifecycle is crucial.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-nested-function-reassign-local-variable-in-effect.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport {useEffect} from 'react';\nfunction Component() {\n  let local;\n  const mk_reassignlocal = () => {\n    // Create the reassignment function inside another function, then return it\n    const reassignLocal = newValue => {\n      local = newValue;\n    };\n    return reassignLocal;\n  };\n  const reassignLocal = mk_reassignlocal();\n  const onMount = newValue => {\n    reassignLocal('hello');\n    if (local === newValue) {\n      // Without React Compiler, `reassignLocal` is freshly created\n      // on each render, capturing a binding to the latest `local`,\n      // such that invoking reassignLocal will reassign the same\n      // binding that we are observing in the if condition, and\n      // we reach this branch\n      console.log('`local` was updated!');\n    } else {\n      // With React Compiler enabled, `reassignLocal` is only created\n      // once, capturing a binding to `local` in that render pass.\n      // Therefore, calling `reassignLocal` will reassign the wrong\n      // version of `local`, and not update the binding we are checking\n      // in the if condition.\n      //\n      // To protect against this, we disallow reassigning locals from\n      // functions that escape\n      throw new Error('`local` not updated!');\n    }\n  };\n  useEffect(() => {\n    onMount();\n  }, [onMount]);\n  return 'ok';\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing useMakeCallback Hook with useMemo in React\nDESCRIPTION: A custom React hook that creates a callback function which updates state based on object value. It uses useMemo to cache the callback and only recreate it when obj.value or shouldSynchronizeState changes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/assume-invoked/use-memo-returned.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useState, useMemo} from 'react';\nimport {useIdentity} from 'shared-runtime';\n\n/**\n * Assume that conditionally called functions can be invoked and that their\n * property loads are hoistable to the function declaration site.\n */\nfunction useMakeCallback({\n  obj,\n  shouldSynchronizeState,\n}: {\n  obj: {value: number};\n  shouldSynchronizeState: boolean;\n}) {\n  const [state, setState] = useState(0);\n  const cb = useMemo(() => {\n    return () => {\n      if (obj.value !== 0) setState(obj.value);\n    };\n  }, [obj.value, shouldSynchronizeState]);\n  useIdentity(null);\n  return cb;\n}\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useMakeCallback,\n  params: [{obj: {value: 1}}],\n  sequentialRenders: [{obj: {value: 1}}, {obj: {value: 2}}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a React Component with Conditional Hook Usage - JavaScript\nDESCRIPTION: This snippet defines a functional component named Component that conditionally calls the useFoo hook from the Foo module based on the value of props. If the condition is true, it retrieves a value using the hook; otherwise, the value remains null. The snippet is intended to illustrate correct and incorrect usage patterns of hooks in React.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.conditional-hooks-as-method-call.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let x = null;\n  if (props.cond) {\n    x = Foo.useFoo();\n  }\n  return x;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing a Basic React Component with ESLint Ignore\nDESCRIPTION: This JavaScript code snippet defines a simple React component named 'lowercasecomponent'. The component disables specific React ESLint rules using comments, which can lead to suboptimal performance and unexpected behavior. It returns a JSX element containing an empty array variable. The component does not follow ideal React practices as indicated by the warning messages.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-sketchy-code-use-forget.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n/* eslint-disable react-hooks/rules-of-hooks */\nfunction lowercasecomponent() {\n  'use forget';\n  const x = [];\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  return <div>{x}</div>;\n}\n/* eslint-enable react-hooks/rules-of-hooks */\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Array Processing Component in JavaScript\nDESCRIPTION: This snippet defines a React component that processes an array, removing zeros and halving other values. It demonstrates usage of array methods and a do-while loop.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/do-while-continue.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component() {\n  const x = [0, 1, 2, 3];\n  const ret = [];\n  do {\n    const item = x.pop();\n    if (item === 0) {\n      continue;\n    }\n    ret.push(item / 2);\n  } while (x.length);\n\n  return ret;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Rendering HTML from a Server Component\nDESCRIPTION: This JavaScript snippet demonstrates the usage of the experimental_renderToHTML function to render an EmailTemplate component to HTML, which is then sent as an email. The function must be awaited as it is asynchronous.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-markup/README.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { experimental_renderToHTML as renderToHTML } from 'react-markup';\nimport EmailTemplate from './my-email-template-component.js'\n\nasync function action(email, name) {\n  \"use server\";\n  // ... in your server, e.g. a Server Action...\n  const htmlString = await renderToHTML(<EmailTemplate name={name} />);\n  // ... send e-mail using some e-mail provider\n  await sendEmail({ to: email, contentType: 'text/html', body: htmlString });\n}\n```\n\n----------------------------------------\n\nTITLE: FBT Component Input Source\nDESCRIPTION: Original React component using FBT for text translation. Demonstrates basic FBT syntax with parameter interpolation using fbt:param.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-preserve-whitespace.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport fbt from 'fbt';\n\nconst _ = fbt;\nfunction Component({value}: {value: string}) {\n  return (\n    <fbt desc=\"descdesc\">\n      Before text\n      <fbt:param name=\"paramName\">{value}</fbt:param>\n    </fbt>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: 'hello world'}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memo Cache\nDESCRIPTION: Compiled version of the component that implements memo caching using Symbol.for() check. Includes compiler runtime imports and cache sentinel validation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-of-break.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = [];\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const x = t0;\n  for (const item of [1, 2]) {\n    break;\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: This snippet shows the compiled version of the Component function. It includes memoization logic using Symbol.for(\"react.memo_cache_sentinel\") and imports a compiler runtime function. The FIXTURE_ENTRYPOINT object remains unchanged.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/multi-directive.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component() {\n  \"use foo\";\n  \"use bar\";\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = <div>\"foo\"</div>;\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  isComponent: true,\n};\n```\n\n----------------------------------------\n\nTITLE: React Component Definition with State Loop\nDESCRIPTION: This code defines a React component that increments variables x and y within a do-while loop based on the props.limit value. The value of 'y' is assigned to 'z' in each iteration, and the component returns an array containing the final value of 'z'. The component is designed to be used with React's sequential rendering mechanism.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-do-while-indirect.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  do {\n    x += 1;\n    y += 1;\n    z = y;\n  } while (x < props.limit);\n  return [z];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  sequentialRenders: [\n    {limit: 10},\n    {limit: 10},\n    {limit: 1},\n    {limit: 1},\n    {limit: 10},\n    {limit: 1},\n    {limit: 10},\n    {limit: 1},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Using useRef in React Functional Component - JavaScript\nDESCRIPTION: This snippet demonstrates the usage of the `useRef` hook to create two ref objects within a React functional component. The first ref is checked for being null, and if true, the second ref's `current` property is set to 1. It highlights the misuse of accessing ref values during render, which is restricted in React.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.ref-initialization-other.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n\"//@flow\\nimport {useRef} from 'react';\\n\\ncomponent C() {\\n  const r = useRef(null);\\n  const r2 = useRef(null);\\n  if (r.current == null) {\\n    r2.current = 1;\\n  }\\n}\\n\\nexport const FIXTURE_ENTRYPOINT = {\\n  fn: C,\\n  params: [{}],\\n};\\n\"\n```\n\n----------------------------------------\n\nTITLE: Compiled Output with Inferred Dependencies\nDESCRIPTION: The compiled version of the component with automatically inferred dependencies for the useEffect hook. The compiler creates a cache array and tracks changes to objects and their properties to properly determine when effects should re-run.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/reactive-memberexpr-merge.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @inferEffectDependencies\nimport { useEffect } from \"react\";\nimport { print } from \"shared-runtime\";\n\nfunction ReactiveMemberExprMerge(t0) {\n  const $ = _c(4);\n  const { propVal } = t0;\n  let t1;\n  if ($[0] !== propVal) {\n    t1 = { a: { b: propVal } };\n    $[0] = propVal;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  const obj = t1;\n  let t2;\n  if ($[2] !== obj.a) {\n    t2 = () => print(obj.a, obj.a.b);\n    $[2] = obj.a;\n    $[3] = t2;\n  } else {\n    t2 = $[3];\n  }\n  useEffect(t2, [obj.a]);\n}\n```\n\n----------------------------------------\n\nTITLE: Optimizing React Component Compilation in JavaScript\nDESCRIPTION: This snippet demonstrates an optimized version of the React component using a React compilation technique. It leverages a memoization strategy to cache and reuse the component structure, thus reducing render overhead. The '@compilationMode(infer)' directive aids the compiler in optimizing component compilation. Inputs and outputs are similar to the basic definition, with the added complexity of utilizing memoization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-functions-component-with-jsx.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @compilationMode(infer)\nfunction Component(props) {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = <div />;\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\n```\n\n----------------------------------------\n\nTITLE: React Component with XML Attribute\nDESCRIPTION: This snippet defines a React component that renders an XML element with a dynamic attribute. The `protocol:version` attribute of the `xml:http` element is set to the value of the `version` prop passed to the component.  It also exports a fixture entry point for testing or demonstration.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-namespaced-name.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  return <xml:http protocol:version={props.version} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n\n```\n\n----------------------------------------\n\nTITLE: Implementing React Components with Conditional Rendering\nDESCRIPTION: This snippet defines two React components, ComponentA and ComponentB, which conditionally render child elements based on props. It also includes utility functions Foo and mayMutate.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/conditional-on-mutable.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction ComponentA(props) {\n  const a = [];\n  const b = [];\n  if (b) {\n    a.push(props.p0);\n  }\n  if (props.p1) {\n    b.push(props.p2);\n  }\n  return <Foo a={a} b={b} />;\n}\n\nfunction ComponentB(props) {\n  const a = [];\n  const b = [];\n  if (mayMutate(b)) {\n    a.push(props.p0);\n  }\n  if (props.p1) {\n    b.push(props.p2);\n  }\n  return <Foo a={a} b={b} />;\n}\n\nfunction Foo() {}\nfunction mayMutate() {}\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization (JavaScript)\nDESCRIPTION: This snippet shows the compiled version of the React component, incorporating memoization and compiler optimizations. It uses Symbol.for('react.memo_cache_sentinel') for caching and demonstrates how React's compiler transforms the original code.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/frozen-after-alias.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = [];\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const a = t0;\n  const b = a;\n  useFreeze(a);\n  foo(b);\n  return b;\n}\n\nfunction useFreeze() {}\nfunction foo(x) {}\n```\n\n----------------------------------------\n\nTITLE: Compiled Output of Conditional Subpath Optimization in React\nDESCRIPTION: Compiled version of the function showing how the React Compiler has transformed it to include memoization. The compiler has optimized the dependency tracking to just track 'props.a' rather than both 'props.a' and 'props.a.b'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/subpath-order1.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // When a conditional dependency `props.a` is a subpath of an unconditional\n// dependency `props.a.b`, we can access `props.a` while preserving program\n// semantics (with respect to nullthrows).\n// deps: {`props.a`, `props.a.b`} can further reduce to just `props.a`\n\nimport { identity } from \"shared-runtime\";\n\n// ordering of accesses should not matter\nfunction useConditionalSubpath1(props, cond) {\n  const $ = _c(3);\n  let x;\n  if ($[0] !== cond || $[1] !== props.a) {\n    x = {};\n    x.b = props.a.b;\n    if (identity(cond)) {\n      x.a = props.a;\n    }\n    $[0] = cond;\n    $[1] = props.a;\n    $[2] = x;\n  } else {\n    x = $[2];\n  }\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component Implementation\nDESCRIPTION: Compiled version with optimization logic including both optimized and unoptimized paths. Uses compiler runtime utilities and feature flags to conditionally apply optimizations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/gating-use-before-decl.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { isForgetEnabled_Fixtures } from \"ReactForgetFeatureFlag\"; // @gating\nimport { memo } from \"react\";\nimport { Stringify } from \"shared-runtime\";\n\nexport default memo(Foo);\nconst isForgetEnabled_Fixtures_result = isForgetEnabled_Fixtures();\nfunction Foo_optimized(t0) {\n  \"use memo\";\n  const $ = _c(3);\n  const { prop1, prop2 } = t0;\n  let t1;\n  if ($[0] !== prop1 || $[1] !== prop2) {\n    t1 = <Stringify prop1={prop1} prop2={prop2} />;\n    $[0] = prop1;\n    $[1] = prop2;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  return t1;\n}\nfunction Foo_unoptimized({ prop1, prop2 }) {\n  \"use memo\";\n  return <Stringify prop1={prop1} prop2={prop2} />;\n}\nfunction Foo(arg0) {\n  if (isForgetEnabled_Fixtures_result) return Foo_optimized(arg0);\n  else return Foo_unoptimized(arg0);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: eval(\"Foo\"),\n  params: [{ prop1: 1, prop2: 2 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Optimization\nDESCRIPTION: Optimized version after React compiler processing, introducing memoization using Symbol.for() and compiler runtime utilities. Shows how React transforms the code to improve performance through caching.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-test-field-load-binary-op.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction component() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = { u: makeSomePrimitive(), v: makeSomePrimitive() };\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const x = t0;\n  const u = x.u;\n  const v = x.v;\n  if (u > v) {\n  }\n\n  const z = x.v;\n  return z;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a React Component with Stringify in JavaScript\nDESCRIPTION: This code snippet defines a simple React component using the 'Stringify' component from 'shared-runtime'. It accepts an object with properties 'a' and 'b', then renders the property 'a' using 'Stringify'. The component is part of a fixture that tests its rendering behavior with sequential inputs.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-runs-inference.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {Stringify} from 'shared-runtime';\nfunction Component({a, b}) {\n  let z = {a};\n  let p = () => <Stringify>{z}</Stringify>;\n  return p();\n}\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{a: 1}],\n  sequentialRenders: [{a: 1}, {a: 1}, {a: 2}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled useFoo React Component with Memoization\nDESCRIPTION: This code presents the compiled version of the `useFoo` React component. It imports `_c` from `react/compiler-runtime` for memoization and conditionally executes the component's logic based on prop changes. The compiled version uses an array `$` to store previous prop values and the result of the component, optimizing for re-renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-renaming-with-mutation.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { mutate } from \"shared-runtime\";\n\nfunction useFoo(props) {\n  const $ = _c(4);\n  let x;\n  if ($[0] !== props.bar || $[1] !== props.cond || $[2] !== props.foo) {\n    x = [];\n    x.push(props.bar);\n    if (props.cond) {\n      x = [];\n      x.push(props.foo);\n    }\n\n    mutate(x);\n    $[0] = props.bar;\n    $[1] = props.cond;\n    $[2] = props.foo;\n    $[3] = x;\n  } else {\n    x = $[3];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ bar: \"bar\", foo: \"foo\", cond: true }],\n  sequentialRenders: [\n    { bar: \"bar\", foo: \"foo\", cond: true },\n    { bar: \"bar\", foo: \"foo\", cond: true },\n    { bar: \"bar\", foo: \"foo\", cond: false },\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: Compiled version of the React component with memoization implementation using Symbol.for('react.memo_cache_sentinel') for cache detection and optimization of renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/log-pruned-memoization.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @logger\nimport { createContext, use, useState } from \"react\";\nimport {\n  Stringify,\n  identity,\n  makeObject_Primitives,\n  useHook,\n} from \"shared-runtime\";\n\nfunction Component() {\n  const $ = _c(6);\n  const w = use(Context);\n\n  const x = makeObject_Primitives();\n  const x2 = makeObject_Primitives();\n  useState(null);\n  identity(x);\n  identity(x2);\n\n  const y = useHook();\n  let z;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    z = [];\n    for (let i = 0; i < 10; i++) {\n      const obj = makeObject_Primitives();\n      z.push(obj);\n    }\n    $[0] = z;\n  } else {\n    z = $[0];\n  }\n  let t0;\n  if ($[1] !== w || $[2] !== x || $[3] !== x2 || $[4] !== y) {\n    t0 = <Stringify items={[w, x, x2, y, z]} />;\n    $[1] = w;\n    $[2] = x;\n    $[3] = x2;\n    $[4] = y;\n    $[5] = t0;\n  } else {\n    t0 = $[5];\n  }\n  return t0;\n}\n\nconst Context = createContext();\n\nfunction Wrapper() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = (\n      <Context value={42}>\n        <Component />\n      </Context>\n    );\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Wrapper,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Conditional Component Logic using Labeled Code Blocks in React JavaScript\nDESCRIPTION: This snippet demonstrates an alternative approach to conditional logic in a React component, using labeled code blocks to determine which prop to return based on a condition. This approach relies solely on native JavaScript without any React-specific hooks. The result is determined by the `props.cond` condition, returning `props.a` or `props.b` accordingly.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-inverted-if.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nfunction Component(props) {\n  let t0;\n  bb0: {\n    bb1: {\n      if (props.cond) {\n        break bb1;\n      }\n\n      t0 = props.a;\n      break bb0;\n    }\n\n    t0 = props.b;\n  }\n  const x = t0;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Switch Case for Value Assignment in React Component\nDESCRIPTION: This snippet implements a React functional component that uses a switch case statement to determine the appropriate value to return based on a prop key. It illustrates an alternate approach without using hooks, relying on traditional variable assignment in a control structure to achieve similar functionality.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-switch-no-fallthrough.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let t0;\n  bb0: switch (props.key) {\n    case \"key\": {\n      t0 = props.value;\n      break bb0;\n    }\n    default: {\n      t0 = props.defaultValue;\n    }\n  }\n  const x = t0;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n\n```\n\n----------------------------------------\n\nTITLE: Transformed Implementation of useRelayData Hook\nDESCRIPTION: Transformed version of the useRelayData hook with destructured parameters. This version includes the same functionality but with modified parameter handling and formatting.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/relay-transitive-mixeddata.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useFragment } from \"shared-runtime\";\n\n/**\n * React compiler should infer that the returned value is a primitive and avoid\n * memoizing it.\n */\nfunction useRelayData(t0) {\n  \"use memo\";\n  const { query, idx } = t0;\n\n  const data = useFragment(\"\", query);\n  return data.a[idx].toString();\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useRelayData,\n  params: [{ query: \"\", idx: 0 }],\n  sequentialRenders: [\n    { query: \"\", idx: 0 },\n    { query: \"\", idx: 0 },\n    { query: \"\", idx: 1 },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component with Conditionals (Input)\nDESCRIPTION: This code snippet shows the original React component before constant propagation.  It defines a series of variables (a, b, c, d, e) assigned values based on conditional checks. The component returns the final value of 'e', which is determined by the initial value of 'a'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/sequentially-constant-progagatable-if-test-conditions.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component() {\n  let a = 1;\n\n  let b;\n  if (a === 1) {\n    b = true;\n  } else {\n    b = false;\n  }\n\n  let c;\n  if (b) {\n    c = 'hello';\n  } else {\n    c = null;\n  }\n\n  let d;\n  if (c === 'hello') {\n    d = 42.0;\n  } else {\n    d = 42.001;\n  }\n\n  let e;\n  if (d === 42.0) {\n    e = 'ok';\n  } else {\n    e = 'nope';\n  }\n\n  // should constant-propagate to \"ok\"\n  return e;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  isComponent: false,\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Hook Error Message\nDESCRIPTION: Error message showing the invalid reassignment of a variable outside component scope. The error explains that components and hooks must be pure and side-effect free, suggesting useState as the proper solution.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.update-global-should-bailout.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n  1 | let renderCount = 0;\n  2 | function useFoo() {\n> 3 |   renderCount += 1;\n    |   ^^^^^^^^^^^^^^^^ InvalidReact: Unexpected reassignment of a variable which was defined outside of the component. Components and hooks should be pure and side-effect free, but variable reassignment is a form of side-effect. If this variable is used in rendering, use useState instead. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#side-effects-must-run-outside-of-render) (3:3)\n  4 |   return renderCount;\n  5 | }\n  6 |\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: Basic React component implementation using context and event handling. Demonstrates usage of useContext hook with a memoized onClick handler that mutates context data.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useContext-maybe-mutate-context-in-callback.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as React from 'react';\nimport {useContext} from 'react';\nimport {mutate} from 'shared-runtime';\n\nconst FooContext = React.createContext({current: null});\n\nfunction Component(props) {\n  const Foo = useContext(FooContext);\n  // This callback can be memoized because we aren't 100% positive that\n  // `mutate()` actually mutates, so we optimistically assume it doesn't\n  // Its range doesn't get entagled w the useContext call so we're able\n  // to create a reactive scope and memoize it.\n  const onClick = () => {\n    mutate(Foo.current);\n  };\n  return <div onClick={onClick}>{props.children}</div>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{children: <div>Hello</div>}],\n};\n```\n\n----------------------------------------\n\nTITLE: Initializing React Component with useMemo\nDESCRIPTION: A React functional component using useMemo to memoize a mutation operation with empty dependency array\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-return-empty.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component(a) {\n  let x = useMemo(() => {\n    mutate(a);\n  }, []);\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: Simple React component demonstrating object property access and destructuring with numeric keys. Returns a div containing repeated string values.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/numeric-literal-as-object-property-key.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Test() {\n  const obj = {\n    21: 'dimaMachina',\n  };\n  // Destructuring assignment\n  const {21: myVar} = obj;\n  return (\n    <div>\n      {obj[21]}\n      {myVar}\n    </div>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Test,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component Definition with Stringify and Conditional Rendering\nDESCRIPTION: This code defines a React component `Foo` that takes `a` and `shouldReadA` as props. It uses the `Stringify` component to render the result of a method call, which conditionally accesses the nested property `a.b.c` based on the value of `shouldReadA`. The component is exported as part of `FIXTURE_ENTRYPOINT`, which also defines parameters and sequential renders for testing.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/infer-objectmethod-cond-access.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enablePropagateDepsInHIR\nimport {Stringify} from 'shared-runtime';\n\nfunction Foo({a, shouldReadA}) {\n  return (\n    <Stringify\n      objectMethod={{\n        method() {\n          if (shouldReadA) return a.b.c;\n          return null;\n        },\n      }}\n      shouldInvokeFns={true}\n    />\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{a: null, shouldReadA: true}],\n  sequentialRenders: [\n    {a: null, shouldReadA: true},\n    {a: null, shouldReadA: false},\n    {a: {b: {c: 4}}, shouldReadA: true},\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Hoisting with shared-runtime in JavaScript\nDESCRIPTION: This snippet imports a `print` function from the `shared-runtime` module to demonstrate JavaScript variable hoisting. The `hoisting` function takes a boolean parameter `cond` and prints different values for `x` based on this condition. Initial dependencies include the `shared-runtime` library for logging purposes. The function prints `1` if `cond` is true and `2` otherwise. It highlights the concept of variable hoisting in JavaScript where a later declared variable can overshadow the previous one within its scope.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-nested-block-statements.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {print} from 'shared-runtime';\n\nfunction hoisting(cond) {\n  if (cond) {\n    const x = 1;\n    print(x);\n  }\n\n  const x = 2;\n  print(x);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: hoisting,\n  params: [false],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a Reactive Component - React JavaScript\nDESCRIPTION: This snippet defines a functional component that uses a global constant to determine the value of a local variable based on props. It illustrates how the variable's value depends on reactive props, making it essential to treat it as reactive. The component returns an array containing the computed value based on the switch statement. Dependencies include React for creating components.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-switch-condition.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst GLOBAL = 42;\n\nfunction Component({value}) {\n  let x;\n  switch (GLOBAL) {\n    case value: {\n      x = 1;\n      break;\n    }\n    default: {\n      x = 2;\n    }\n  }\n  // The values assigned to `x` are non-reactive, but the value of `x`\n  // depends on the \"control\" value `props.value` which is reactive.\n  // Therefore x should be treated as reactive too.\n  return [x];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  sequentialRenders: [\n    {value: GLOBAL},\n    {value: GLOBAL},\n    {value: null},\n    {value: null},\n    {value: GLOBAL},\n    {value: null},\n    {value: GLOBAL},\n    {value: null},\n  ],\n};\n```\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nconst GLOBAL = 42;\n\nfunction Component(t0) {\n  const $ = _c(2);\n  const { value } = t0;\n  let x;\n  bb0: switch (GLOBAL) {\n    case value: {\n      x = 1;\n      break bb0;\n    }\n    default: {\n      x = 2;\n    }\n  }\n  let t1;\n  if ($[0] !== x) {\n    t1 = [x];\n    $[0] = x;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  sequentialRenders: [\n    { value: GLOBAL },\n    { value: GLOBAL },\n    { value: null },\n    { value: null },\n    { value: GLOBAL },\n    { value: null },\n    { value: GLOBAL },\n    { value: null },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Runtime Optimizations\nDESCRIPTION: Compiled version of the React component using compiler runtime optimizations. Includes caching mechanism using the _c compiler runtime function to optimize repeated operations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-cast-expression.flow.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\ntype Foo = { bar: string };\nfunction Component(props) {\n  const $ = _c(2);\n  let y;\n  if ($[0] !== props.bar) {\n    const x = { bar: props.bar };\n    y = (x: Foo);\n    y.bar = \"hello\";\n    $[0] = props.bar;\n    $[1] = y;\n  } else {\n    y = $[1];\n  }\n  const z = (y: Foo);\n  return z;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with RegExp Pattern Matching (Original)\nDESCRIPTION: This snippet shows a React component that uses a regular expression to test a value and conditionally render content. It demonstrates the use of RegExp objects and conditional rendering in React.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/regexp-literal.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const pattern = /foo/g;\n  const value = makeValue();\n  // We treat RegExp instances as mutable objects (bc they are)\n  // so by default we assume this could be mutating `value`:\n  if (pattern.test(value)) {\n    return <div>{value}</div>;\n  }\n  return <div>Default</div>;\n}\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: A React component function that conditionally returns different values based on props. It has a potential performance issue with a non-memoized array being returned.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/partial-early-return-within-reactive-scope.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let x = [];\n  let y = null;\n  if (props.cond) {\n    x.push(props.a);\n    // oops no memo!\n    return x;\n  } else {\n    y = foo();\n    if (props.b) {\n      return;\n    }\n  }\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{cond: true, a: 42}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiler-Optimized React Component\nDESCRIPTION: The compiler-transformed version of the component using React's memo cache sentinel for optimization. It implements caching logic to avoid recreating and mutating the array on every render.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/do-while-early-unconditional-break.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(1);\n  let x;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    x = [1, 2, 3];\n\n    mutate(x);\n    $[0] = x;\n  } else {\n    x = $[0];\n  }\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Hooks and Rendering Logic\nDESCRIPTION: This snippet defines a React component using hooks and includes rendering logic. It demonstrates the use of useEffect, state management, and JSX rendering with dynamic content.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-dont-memoize-array-with-mutable-map-after-hook.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useEffect, useState} from 'react';\nimport {mutate} from 'shared-runtime';\n\nfunction Component(props) {\n  const x = [{...props.value}];\n  useEffect(() => {}, []);\n  const onClick = () => {\n    console.log(x.length);\n  };\n  let y;\n  return (\n    <div onClick={onClick}>\n      {x.map(item => {\n        item.flag = true;\n        return <span key={item.id}>{item.text}</span>;\n      })}\n      {mutate(y)}\n    </div>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: {id: 0, text: 'Hello', flag: false}}],\n  isComponent: true,\n};\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Increment Operations (Input)\nDESCRIPTION: This code defines a React component that receives props 'a', 'b', and 'c'. It then uses both pre-increment and post-increment operators on these props. The component returns an array containing the modified props and the results of the increment operations. The FIXTURE_ENTRYPOINT object provides the component, test parameters, and specifies that it is not a React Component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/update-expression-on-function-parameter-1.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component({a: a, b: [b], c: {c}}) {\n  let d = a++;\n  let e = ++a;\n  let f = b--;\n  let g = --b;\n  let h = c++;\n  let i = --c;\n  return [a, b, c, d, e, f, g, h, i];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{a: 2, b: [3], c: {c: 4}}],\n  isComponent: false,\n};\n\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: Shows the initial implementation of a React component with nested functions and closure accessing a constant value. Contains a while loop with conditional logic and returns a function that accesses the closed-over variable.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rewrite-phis-in-lambda-capture-context.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component() {\n  const x = 4;\n\n  const get4 = () => {\n    while (bar()) {\n      if (baz) {\n        bar();\n      }\n    }\n    return () => x;\n  };\n\n  return get4;\n}\n```\n\n----------------------------------------\n\nTITLE: Calculating Sum from Queue - JavaScript\nDESCRIPTION: This snippet defines a Component function that calculates the sum of numbers in an array using a while loop to pop values off the queue. It returns the total sum of the numbers. It's an example of basic programming logic in a React functional component context.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/while-with-assignment-in-test.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component() {\n  const queue = [1, 2, 3];\n  let value = 0;\n  let sum = 0;\n  while ((value = queue.pop()) != null) {\n    sum += value;\n  }\n  return sum;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: This JavaScript code represents the compiled version of the React component `hoisting`. It utilizes `react/compiler-runtime` for memoization and optimization.  The compiled component checks for a memoized value and either reuses it or creates a new `Stringify` element with the `onClick` function as a prop.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-member-expression.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { Stringify } from \"shared-runtime\";\n\nfunction hoisting() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const onClick = function onClick(x) {\n      return x + bar.baz;\n    };\n\n    const bar = { baz: 1 };\n\n    t0 = <Stringify onClick={onClick} />;\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: hoisting,\n  params: [],\n  isComponent: false,\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining Original React Component in JavaScript\nDESCRIPTION: This snippet shows the original React component function before compilation. It declares variables, performs comparisons, and returns a value.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-test-return-type-inference.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component() {\n  let x = foo();\n  let y = foo();\n  if (x > y) {\n    let z = {};\n  }\n\n  let z = foo();\n  return z;\n}\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: Basic React component implementation that demonstrates error handling with try/catch blocks and array manipulation. The component attempts to push an error message to an array, catches any errors, and falls back to pushing a shallow copy of an empty object.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-within-mutable-range.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst {throwErrorWithMessage, shallowCopy} = require('shared-runtime');\n\nfunction Component(props) {\n  const x = [];\n  try {\n    x.push(throwErrorWithMessage('oops'));\n  } catch {\n    x.push(shallowCopy({}));\n  }\n  x.push(props.value); // extend the mutable range to include the try/catch\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: ESLint Error for Mutating React Props\nDESCRIPTION: This is the ESLint error message generated when attempting to mutate React component props. The error highlights the line of code where the mutation occurs and suggests using a local variable instead. The error message informs the developer that directly modifying props is invalid and provides guidance on alternative approaches, such as using local component state.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-props-mutation-in-effect-indirect.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n  1 | function Component(props) {\n  2 |   const mutateProps = () => {\n> 3 |     props.value = true;\n    |     ^^^^^ InvalidReact: Mutating component props or hook arguments is not allowed. Consider using a local variable instead. Found mutation of `props` (3:3)\n  4 |   };\n  5 |   const indirectMutateProps = () => {\n  6 |     mutateProps();\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple React Component in JavaScript\nDESCRIPTION: This snippet defines a basic React component that returns a <div> element with the text 'Hello world'. It is structured to serve as a fixture entry point for testing or documentation APIs. The component does not take any parameters and does not depend on external libraries other than React itself.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/target-flag.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @target=\"18\"\n\nfunction Component() {\n  return <div>Hello world</div>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  isComponent: true,\n};\n\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with Error Handling in JavaScript\nDESCRIPTION: This code defines a React component that attempts to push a prop value into an array and throw it, then catches any errors and modifies them. It also exports a fixture for testing.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-try-value-modified-in-catch.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst {throwInput} = require('shared-runtime');\n\nfunction Component(props) {\n  try {\n    const y = [];\n    y.push(props.y);\n    throwInput(y);\n  } catch (e) {\n    e.push(props.e);\n    return e;\n  }\n  return null;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{y: 'foo', e: 'bar'}],\n};\n```\n\n----------------------------------------\n\nTITLE: Accessing Ref Current in Render Error Message - Javascript\nDESCRIPTION: This snippet captures the error generated when trying to access the `current` property of a ref during rendering in React. The error message explicitly explains the violation of React's rules regarding refs, making it a useful reference for understanding this common issue.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-access-ref-during-render.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n  2 | function Component(props) {\n  3 |   const ref = useRef(null);\n> 4 |   const value = ref.current;\n    |                 ^^^^^^^^^^^ InvalidReact: Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef) (4:4)\n  5 |   return value;\n  6 | }\n  7 |\n```\n\n----------------------------------------\n\nTITLE: Optimized Conditional Render Component in React\nDESCRIPTION: This snippet enhances the previous component with optimizations using a 'compiler-runtime' to manage render states. It conditionally renders static text and employs memoization to reduce rendering overhead. It also exports the component with defined parameters for consistency in testing and usage across the application.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-ternary-local-variable.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { RenderPropAsChild, StaticText1, StaticText2 } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(2);\n  const Foo = props.showText1 ? StaticText1 : StaticText2;\n  let t0;\n  if ($[0] !== Foo) {\n    t0 = <RenderPropAsChild items={[() => <Foo key=\"0\" />]} />;\n    $[0] = Foo;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ showText1: false }],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a React Component Using useState and useMemo - JavaScript\nDESCRIPTION: This snippet defines a React functional component that uses the useState hook to manage component state and the useMemo hook to create a memoized array from the state value. The component serializes an object to JSON and renders both the doubled array and the JSON string.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hooks-with-prefix.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @hookPattern:\".*\\b(use[^$]+)$\"\n\nimport * as React from 'react';\nimport {makeArray, useHook} from 'shared-runtime';\n\nconst React$useState = React.useState;\nconst React$useMemo = React.useMemo;\nconst Internal$Reassigned$useHook = useHook;\n\nfunction Component() {\n  const [state, setState] = React$useState(0);\n  const object = Internal$Reassigned$useHook();\n  const json = JSON.stringify(object);\n  const doubledArray = React$useMemo(() => {\n    return makeArray(state);\n  }, [state]);\n  return (\n    <div>\n      {doubledArray.join('')}\n      {json}\n    </div>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Component Definition with Array Destructuring\nDESCRIPTION: Defines a React functional component `t` that takes props as input and destructures it to extract a value using array destructuring. It then returns the extracted value. This component is intended for use in a testing or fixture environment.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/holey-array-pattern-dce-2.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction t(props) {\n  let [foo, bar, ,] = props;\n  return foo;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: t,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Component Definition with Conditional Logic\nDESCRIPTION: This snippet defines a React component named `Component` that conditionally returns an array based on the `props.cond` value. If `props.cond` is true, it returns an array containing `props.a`. Otherwise, it uses `makeArray` to create an array from `props.b`. The `FIXTURE_ENTRYPOINT` object defines the component and sequential render examples with different props.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/early-return-within-reactive-scope.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enablePropagateDepsInHIR\nimport {makeArray} from 'shared-runtime';\n\nfunction Component(props) {\n  let x = [];\n  if (props.cond) {\n    x.push(props.a);\n    // oops no memo!\n    return x;\n  } else {\n    return makeArray(props.b);\n  }\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  sequentialRenders: [\n    // pattern 1\n    {cond: true, a: 42},\n    {cond: true, a: 42},\n    // pattern 2\n    {cond: false, b: 3.14},\n    {cond: false, b: 3.14},\n    // pattern 1\n    {cond: true, a: 42},\n    // pattern 2\n    {cond: false, b: 3.14},\n    // pattern 1\n    {cond: true, a: 42},\n    // pattern 2\n    {cond: false, b: 3.14},\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Creating and Returning React Component with Validation - JavaScript\nDESCRIPTION: This snippet illustrates creating and returning a React component within a function using annotations for logging and validation. It serves as an example of a typical but incorrect pattern of creating components within the render method. There are no explicit dependencies declared in this snippet, but it implies React as a dependency. The function takes `props` as parameters and returns a React component instance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/static-components/invalid-dynamically-construct-component-in-render.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @logger @validateStaticComponents\nfunction Example(props) {\n  const Component = createComponent();\n  return <Component />;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining Conditional Function and Exporting Fixture in JavaScript\nDESCRIPTION: This snippet defines a function 'foo' that returns null if the first parameter is null, otherwise returns the second parameter. It also exports a constant FIXTURE_ENTRYPOINT object that references the 'foo' function and specifies parameters for a 'TodoAdd' component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/return-conditional.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(a, b) {\n  if (a == null) {\n    return null;\n  } else {\n    return b;\n  }\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Reproducing React Context Variable Inference Bug - Input Version\nDESCRIPTION: The input code demonstrates a bug where 'x' was incorrectly inferred as a context variable. It shows a component that initializes 'x', creates an object, updates 'x', and returns its value, which should be 4 after optimization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/constant-prop-across-objectmethod-def.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {identity} from 'shared-runtime';\n\n// repro for context identifier scoping bug, in which x was\n// inferred as a context variable.\n\nfunction Component() {\n  let x = 2;\n  const obj = {\n    method() {},\n  };\n  x = 4;\n  identity(obj);\n  // constant propagation should return 4 here\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Optimization Code\nDESCRIPTION: The React compiler-optimized version of the code that implements caching using an array to store condition and object references. It reduces object allocations by reusing previously created objects when the condition hasn't changed.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/alias-while.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction foo(cond) {\n  const $ = _c(2);\n  let a;\n  if ($[0] !== cond) {\n    a = {};\n    let b = {};\n    let c = {};\n    while (cond) {\n      const z = a;\n      a = b;\n      b = c;\n      c = z;\n      mutate(a, b);\n    }\n    $[0] = cond;\n    $[1] = a;\n  } else {\n    a = $[1];\n  }\n  return a;\n}\n\nfunction mutate(x, y) {}\n```\n\n----------------------------------------\n\nTITLE: Input React Component with Flow Types\nDESCRIPTION: Original React component code with Flow type annotations. Defines a Foo type with a bar string property and demonstrates type casting and property assignment.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-cast-expression.flow.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @flow\ntype Foo = {bar: string};\nfunction Component(props) {\n  const x = {bar: props.bar};\n  const y = (x: Foo);\n  y.bar = 'hello';\n  const z = (y: Foo);\n  return z;\n}\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Component Logic in React - JavaScript\nDESCRIPTION: Defines a React component `Component` that uses properties to manipulate its state. It initializes an object and an array, pushes the input prop to the array, and updates a boolean `z` based on the input. It returns the component's state, with `FIXTURE_ENTRYPOINT` defined for sequential renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactivity-via-aliased-mutation-through-property-load.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const x = {};\n  const y = [];\n  x.y = y;\n  x.y.push(props.input);\n\n  let z = 0;\n  if (x.y[0]) {\n    z = 1;\n  }\n\n  return [z];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  sequentialRenders: [\n    {input: true},\n    {input: true},\n    {input: false},\n    {input: false},\n    {input: true},\n    {input: false},\n    {input: true},\n    {input: false},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining and Exporting React Component as Fixture Entrypoint (Input)\nDESCRIPTION: This snippet defines a simple component function that returns a value and exports it as a fixture entrypoint. The component initializes two variables but only returns one of them.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-test-primitive.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component() {\n  let x = 1;\n  let y = 2;\n\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Creating an Optimized Custom Hook in React\nDESCRIPTION: Implements an optimized version of the 'useFoo' hook that utilizes reference tracking to minimize re-renders and improve performance. It makes use of a compiler runtime and maintains state through a cached array. This version is more efficient but requires the 'react/compiler-runtime' package.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-method-shorthand-hook-dep.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { createHookWrapper } from \"shared-runtime\";\nimport { useState } from \"react\";\nfunction useFoo() {\n  const $ = _c(2);\n  const [state] = useState(false);\n  let t0;\n  if ($[0] !== state) {\n    t0 = {\n      func() {\n        return state;\n      },\n    };\n    $[0] = state;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: createHookWrapper(useFoo),\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized Conditional Component Creation with React.memo\nDESCRIPTION: This snippet defines a React functional component that conditionally creates components using memoization to optimize rendering. It employs a custom cache to avoid re-creating components unnecessarily.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/static-components/invalid-conditionally-assigned-dynamically-constructed-component-in-render.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @logger @validateStaticComponents\nfunction Example(props) {\n  const $ = _c(3);\n  let Component;\n  if (props.cond) {\n    let t0;\n    if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n      t0 = createComponent();\n      $[0] = t0;\n    } else {\n      t0 = $[0];\n    }\n    Component = t0;\n  } else {\n    Component = DefaultComponent;\n  }\n  let t0;\n  if ($[1] !== Component) {\n    t0 = <Component />;\n    $[1] = Component;\n    $[2] = t0;\n  } else {\n    t0 = $[2];\n  }\n  return t0;\n}\n\n```\n\n----------------------------------------\n\nTITLE: React Component with useCallback and useRef\nDESCRIPTION: This code defines a React component `Foo` that utilizes `useCallback` and `useRef` hooks to create a memoized `onClick` handler that interacts with a ref.  The `useCustomRef` hook is used to create a ref object.  The error indicates that React Compiler couldn't preserve the memoization guarantees due to dependency mismatch.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.ref-like-name-not-Ref.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees\nimport {useCallback, useRef} from 'react';\n\nfunction useCustomRef() {\n  return useRef({click: () => {}});\n}\n\nfunction Foo() {\n  const Ref = useCustomRef();\n\n  const onClick = useCallback(() => {\n    Ref.current?.click();\n  }, []);\n\n  return <button onClick={onClick} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [],\n  isComponent: true,\n};\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Memoization in a React Functional Component - JavaScript\nDESCRIPTION: This snippet implements a functional component Foo that makes use of the React library and memoization techniques for performance optimization. By leveraging internal caching, it optimizes rendering by preventing unnecessary updates based on unchanged props. The code indicates a dependency on React's library functionalities.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-fragment.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Foo(props) {\n  const $ = _c(3);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = (\n      <div>\n        <>Text</>\n      </div>\n    );\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  let t1;\n  if ($[1] !== props.greeting) {\n    t1 = (\n      <>\n        Hello {props.greeting} {t0}\n      </>\n    );\n    $[1] = props.greeting;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Reactive Component in React (JavaScript)\nDESCRIPTION: This snippet defines a React functional component, implementing non-reactive state variables that depend on a reactive prop. The component computes the value of `x` based on a loop relative to the `props.init` value, returning it in an array. The snippet also discusses the reactive nature of `x` due to its dependence on the `props.init` control variable.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-for-init.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let x;\n  for (let i = props.init; i < 10; i++) {\n    if (i === 0) {\n      x = 0;\n      break;\n    } else {\n      x = 1;\n      break;\n    }\n  }\n  // The values assigned to `x` are non-reactive, but the value of `x`\n  // depends on the \"control\" variable `i`, whose initial value `props.init` is reactive.\n  // Therefore x should be treated as reactive too.\n  return [x];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  sequentialRenders: [\n    {init: 0},\n    {init: 0},\n    {init: 10},\n    {init: 10},\n    {init: 0},\n    {init: 10},\n    {init: 0},\n    {init: 10},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Logging Props with Fire Hook in React\nDESCRIPTION: This snippet defines a React functional component that logs its props to the console using a fire hook. It renders nothing and executes the logging effect when props are received.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/hook-guard.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableFire @enableEmitHookGuards\nimport {fire} from 'react';\n\nfunction Component(props) {\n  const foo = props => {\n    console.log(props);\n  };\n  useEffect(() => {\n    fire(foo(props));\n  });\n\n  return null;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Compiled Component with Memoization\nDESCRIPTION: This code represents the compiled output of the `Component` defined previously, utilizing the `react/compiler-runtime`. It incorporates memoization techniques to optimize rendering performance by caching previous prop values and rendered results. The `_c` function from `react/compiler-runtime` is used for memoization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/switch-with-only-default.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { Stringify } from \"shared-runtime\";\n\nfunction Component(t0) {\n  const $ = _c(5);\n  let kind;\n  let props;\n  if ($[0] !== t0) {\n    ({ kind, ...props } = t0);\n    $[0] = t0;\n    $[1] = kind;\n    $[2] = props;\n  } else {\n    kind = $[1];\n    props = $[2];\n  }\n  switch (kind) {\n    default: {\n      let t1;\n      if ($[3] !== props) {\n        t1 = <Stringify {...props} />;\n        $[3] = props;\n        $[4] = t1;\n      } else {\n        t1 = $[4];\n      }\n      return t1;\n    }\n  }\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ kind: \"foo\", a: 1, b: true, c: \"sathya\" }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Compiler-Transformed Component with Memoization\nDESCRIPTION: The compiler-transformed version of the component with added memoization. The React compiler has added a cache array ($) and conditionals to prevent unnecessary recalculations when inputs haven't changed, optimizing the component's performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-nested-member-expr-in-nested-func.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction component(a) {\n  const $ = _c(4);\n  let t0;\n  if ($[0] !== a) {\n    t0 = { a: { a } };\n    $[0] = a;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const z = t0;\n  let t1;\n  if ($[2] !== z.a.a) {\n    t1 = function () {\n      (function () {\n        console.log(z.a.a);\n      })();\n    };\n    $[2] = z.a.a;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  const x = t1;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Flow Types\nDESCRIPTION: A React component function that uses compiler runtime optimization (_c) and Flow type checking. The function memoizes rendering of a div element based on the numeric baz property value.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/apps/playground/__tests__/e2e/__snapshots__/page.spec.ts/parse-flow-output.txt#2025-04-21_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction useFoo(propVal) {\n  const $ = _c(2);\n  const t0 = (propVal.baz: number);\n  let t1;\n  if ($[0] !== t0) {\n    t1 = <div>{t0}</div>;\n    $[0] = t0;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n```\n\n----------------------------------------\n\nTITLE: React Compiler Optimized Output with Memoization\nDESCRIPTION: The React compiler's transformed output that adds memoization for performance optimization. It imports the compiler runtime and uses a memoization technique to avoid recalculating values when the input props haven't changed.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/computed-call-spread.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(4);\n  let t0;\n  if ($[0] !== props.a || $[1] !== props.b || $[2] !== props.method) {\n    t0 = foo[props.method](...props.a, null, ...props.b);\n    $[0] = props.a;\n    $[1] = props.b;\n    $[2] = props.method;\n    $[3] = t0;\n  } else {\n    t0 = $[3];\n  }\n  const x = t0;\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: React Component with Object Property Iteration\nDESCRIPTION: A React component that spreads props.value into a new object, iterates through its properties, and attempts to mutate the last property name. Includes a test fixture with sample input values.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-in-statement-type-inference.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst {identity, mutate} = require('shared-runtime');\n\nfunction Component(props) {\n  let x;\n  const object = {...props.value};\n  for (const y in object) {\n    x = y;\n  }\n  mutate(x); // can't modify, x is known primitive!\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: {a: 'a', b: 'B', c: 'C!'}}],\n};\n```\n\nLANGUAGE: javascript\nCODE:\n```\nconst { identity, mutate } = require(\"shared-runtime\");\n\nfunction Component(props) {\n  let x;\n  const object = { ...props.value };\n  for (const y in object) {\n    x = y;\n  }\n\n  mutate(x);\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ value: { a: \"a\", b: \"B\", c: \"C!\" } }],\n};\n```\n\n----------------------------------------\n\nTITLE: Using Conditional Dependencies in React - Initializing\nDESCRIPTION: This snippet defines the function 'useCondDepInNestedIfElse' which manages dependencies conditionally based on the input state. It checks if certain properties are accessed in given condition paths and sets up the reactive state accordingly. It imports necessary functions from 'shared-runtime' to determine conditional logic control. Key parameters include 'props', which holds the property values, and 'cond', a boolean that dictates which code path to take.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/cfg-nested-ifelse-missing.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// props.a.b should NOT be added as a unconditional dependency to the reactive\n// scope that produces x if it is not accessed in every path\n\nimport {identity, getNull} from 'shared-runtime';\n\nfunction useCondDepInNestedIfElse(props, cond) {\n  const x = {};\n  if (identity(cond)) {\n    if (getNull()) {\n      x.a = props.a.b;\n    }\n  } else {\n    x.d = props.a.b;\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useCondDepInNestedIfElse,\n  params: [{a: {b: 2}}, true],\n};\n```\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // props.a.b should NOT be added as a unconditional dependency to the reactive\n// scope that produces x if it is not accessed in every path\n\nimport { identity, getNull } from \"shared-runtime\";\n\nfunction useCondDepInNestedIfElse(props, cond) {\n  const $ = _c(3);\n  let x;\n  if ($[0] !== cond || $[1] !== props) {\n    x = {};\n    if (identity(cond)) {\n      if (getNull()) {\n        x.a = props.a.b;\n      }\n    } else {\n      x.d = props.a.b;\n    }\n    $[0] = cond;\n    $[1] = props;\n    $[2] = x;\n  } else {\n    x = $[2];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useCondDepInNestedIfElse,\n  params: [{ a: { b: 2 } }, true],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a React function with conditional break and property access in JavaScript\nDESCRIPTION: This JavaScript code defines a function `useFoo` that takes an `input` object and a `cond` boolean as parameters. It conditionally pushes a value `input.a.b` into an array `x`. A label and break statement are used for the conditional logic. It returns the array x.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-unpoisoned/jump-target-within-scope-label.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction useFoo({input, cond}) {\n  const x = [];\n  label: {\n    if (cond) {\n      break label;\n    }\n  }\n  x.push(input.a.b); // unconditional\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Input React Component with Error Handling\nDESCRIPTION: Basic React component implementation that attempts to throw an error and falls back to creating a shallow copy of props. Uses shared runtime utilities for error throwing and shallow copying.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-mutate-outer-value.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst {shallowCopy, throwErrorWithMessage} = require('shared-runtime');\n\nfunction Component(props) {\n  const x = [];\n  try {\n    x.push(throwErrorWithMessage('oops'));\n  } catch {\n    x.push(shallowCopy({a: props.a}));\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{a: 1}],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with React Compiler Runtime Transformation\nDESCRIPTION: This code represents the transformed React component after being processed by the React compiler runtime. The `_c` function is used to manage reactivity. The compiler runtime introduces a state variable `$` to track the value of `b` and update the component when `b` changes. The compiler also uses temporary variable `t0` for storing and returning the result based on changes of the reactive values.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactivity-via-readonly-alias-of-mutable-value.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  const x = [];\n  const y = x;\n\n  const z = [y];\n\n  y.push(props.input);\n\n  const a = [z];\n\n  let b = 0;\n  if (a[0][0][0] === 42) {\n    b = 1;\n  }\n  let t0;\n  if ($[0] !== b) {\n    t0 = [b];\n    $[0] = b;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  sequentialRenders: [\n    { input: 42 },\n    { input: 42 },\n    { input: \"sathya\" },\n    { input: \"sathya\" },\n    { input: 42 },\n    { input: \"sathya\" },\n    { input: 42 },\n    { input: \"sathya\" },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with Optional Chaining (Input)\nDESCRIPTION: This snippet defines a simple React component named `Component` that accepts `props` as input. It returns the result of calling the function `foo` with the `props` object, using optional chaining to handle cases where `foo` might be null or undefined. This original, uncompiled, definition of the Component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-call-simple.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  return foo?.(props);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Custom React Ref Hook Implementation\nDESCRIPTION: Creates a custom useRef hook that initializes a ref with a default click method, demonstrating React Compiler's memoization approach\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ref-like-name-in-effect.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction useCustomRef() {\n  return useRef({click: () => {}});\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled React Hook with Memoization\nDESCRIPTION: The compiled version of the useFoo hook that implements React's memoization pattern. Uses Symbol.for to implement cache sentinel and maintains state across renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/align-scopes-reactive-scope-overlaps-if.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction useFoo(t0) {\n  const $ = _c(3);\n  const { cond } = t0;\n  let t1;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = {};\n    $[0] = t1;\n  } else {\n    t1 = $[0];\n  }\n  let items = t1;\n  bb0: if ($[1] !== cond) {\n    if (cond) {\n      items = [];\n    } else {\n      break bb0;\n    }\n\n    items.push(2);\n    $[1] = cond;\n    $[2] = items;\n  } else {\n    items = $[2];\n  }\n  return items;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ cond: true }],\n  sequentialRenders: [\n    { cond: true },\n    { cond: true },\n    { cond: false },\n    { cond: false },\n    { cond: true },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing a React Test Fixture with Conditional Logic\nDESCRIPTION: A JavaScript function 'foo' with conditional logic that modifies a variable based on a condition, followed by a FIXTURE_ENTRYPOINT export that exposes the function for testing purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-simple-phi.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo() {\n  let y = 2;\n\n  if (y > 1) {\n    y = 1;\n  } else {\n    y = 2;\n  }\n\n  let x = y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with No Memo Directive\nDESCRIPTION: Implements a React component that takes props and renders a div element. The component uses a 'use no memo' directive and creates an array from props.foo. Includes a fixture entrypoint configuration for testing purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/use-no-memo-simple.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  'use no memo';\n  let x = [props.foo];\n  return <div x={x}>\"foo\"</div>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{foo: 1}],\n  isComponent: true,\n};\n```\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  \"use no memo\";\n  let x = [props.foo];\n  return <div x={x}>\"foo\"</div>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ foo: 1 }],\n  isComponent: true,\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled getItem Function Definition\nDESCRIPTION: The getItem function returns an object containing the srcName and uid.  This function is used to store and retrieve the properties.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/import-as-local.expect.md#2025-04-21_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nfunction _temp(srcName, uid) {\n  return { srcName, uid };\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Ref Hook with React\nDESCRIPTION: This snippet defines a custom hook 'useCustomRef' that creates and returns a ref using the useRef hook in React. The hook is useful for encapsulating ref usage within functional components, providing simpler access to DOM elements or components without needing to deal with React's ref forwarding.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/helper-nonreactive.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @inferEffectDependencies\nimport {useEffect, useRef} from 'react';\nfunction useCustomRef() {\n  const ref = useRef();\n  return ref;\n}\nfunction NonReactiveWrapper() {\n  const ref = useCustomRef();\n  useEffect(() => {\n    print(ref);\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Transformed: React Compiler Optimized Component\nDESCRIPTION: Compiler-transformed version of the component using runtime memoization and conditional re-computation\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/bug-functiondecl-hoisting.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Foo(t0) {\n  const $ = _c(6);\n  const { value } = t0;\n  let bar;\n  let result;\n  if ($[0] !== value) {\n    result = bar();\n    bar = function bar() {\n      return { value };\n    };\n    $[0] = value;\n    $[1] = bar;\n    $[2] = result;\n  } else {\n    bar = $[1];\n    result = $[2];\n  }\n  let t1;\n  if ($[3] !== bar || $[4] !== result) {\n    t1 = <Stringify result={result} fn={bar} shouldInvokeFns={true} />;\n    $[3] = bar;\n    $[4] = result;\n    $[5] = t1;\n  } else {\n    t1 = $[5];\n  }\n  return t1;\n}\n```\n\n----------------------------------------\n\nTITLE: React Component Input Definition\nDESCRIPTION: Original component definition with an arrow function as default parameter that returns an array of mixed values.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/default-param-with-reorderable-callback.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(x = () => [-1, true, 42.0, 'hello']) {\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Transforming React Component without Destructuring in JavaScript\nDESCRIPTION: This snippet shows the same React component rewritten without using array destructuring. It manually checks for undefined values and assigns the default. The fixture remains the same for testing consistency.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-default-at-array-hole.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const [t0] = props.value;\n  const x = t0 === undefined ? 42 : t0;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ value: [, /* hole! */ 3.14] }],\n};\n```\n\n----------------------------------------\n\nTITLE: Exporting React Component as FIXTURE_ENTRYPOINT\nDESCRIPTION: This code exports the 'Foo' component as part of an object assigned to 'FIXTURE_ENTRYPOINT'. This object configures the component for use in a fixture or testing setup. It includes the component function itself, the component's parameters, and the component's name.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unused-object-element.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Hook for Keyboard Commands in React\nDESCRIPTION: This snippet implements the 'useKeyCommand' custom hook which uses React's 'useRef' to track the current position. The hook defines two handlers for moving left and right based on keyboard commands, updating the reference to manage the current state without causing renders. It returns those handlers for use in components.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.capture-ref-for-mutation.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useRef} from 'react';\nimport {addOne} from 'shared-runtime';\n\nfunction useKeyCommand() {\n  const currentPosition = useRef(0);\n  const handleKey = direction => () => {\n    const position = currentPosition.current;\n    const nextPosition = direction === 'left' ? addOne(position) : position;\n    currentPosition.current = nextPosition;\n  };\n  const moveLeft = {\n    handler: handleKey('left')(),\n  };\n  const moveRight = {\n    handler: handleKey('right')(),\n  };\n  return [moveLeft, moveRight];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useKeyCommand,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Custom Function in useEffect\nDESCRIPTION: This snippet extends the previous example by moving the logic inside the useEffect to a separate function. The function _temp is invoked within useEffect to assign a value to a property of the object x. This organization allows for better separation of logic and could facilitate easier testing or modification of the effect's behavior. As before, it requires React to be present.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useEffect-method-call.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nlet x = {};\nfunction Component() {\n  React.useEffect(_temp);\n}\nfunction _temp() {\n  x.foo = 1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Invalid React State Update During Render\nDESCRIPTION: Example of incorrect useState implementation where setState is called unconditionally during component render. This pattern violates React's principles and causes infinite rendering loops since each state update triggers a new render.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.unconditional-set-state-lambda.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validateNoSetStateInRender\nfunction Component(props) {\n  const [x, setX] = useState(0);\n\n  const foo = () => {\n    setX(1);\n  };\n  foo();\n\n  return [x];\n}\n```\n\nLANGUAGE: plaintext\nCODE:\n```\n   6 |     setX(1);\n   7 |   };\n>  8 |   foo();\n     |   ^^^ InvalidReact: This is an unconditional set state during render, which will trigger an infinite loop. (https://react.dev/reference/react/useState) (8:8)\n   9 |\n  10 |   return [x];\n  11 | }\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Caching Optimizations (JavaScript)\nDESCRIPTION: This snippet shows the compiled version of the React component with added caching optimizations. It includes memoization of derived values and conditional rendering based on changed inputs.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/global-types/repro-array-map-capture-mutate-bug.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { mutateAndReturn, Stringify, useIdentity } from \"shared-runtime\";\n\n/**\n * Copy of repro-array-map-capture-mutate-bug, showing that the same issue applies to any\n * function call which captures its callee when applying an operand.\n */\nfunction Component(t0) {\n  const $ = _c(7);\n  const { value } = t0;\n  const arr = [{ value: \"foo\" }, { value: \"bar\" }, { value }];\n  useIdentity(null);\n  const derived = arr.map(mutateAndReturn);\n  let t1;\n  if ($[0] !== derived) {\n    t1 = derived.at(0);\n    $[0] = derived;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  let t2;\n  if ($[2] !== derived) {\n    t2 = derived.at(-1);\n    $[2] = derived;\n    $[3] = t2;\n  } else {\n    t2 = $[3];\n  }\n  let t3;\n  if ($[4] !== t1 || $[5] !== t2) {\n    t3 = (\n      <Stringify>\n        {t1}\n        {t2}\n      </Stringify>\n    );\n    $[4] = t1;\n    $[5] = t2;\n    $[6] = t3;\n  } else {\n    t3 = $[6];\n  }\n  return t3;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ value: 5 }],\n  sequentialRenders: [{ value: 5 }, { value: 6 }, { value: 6 }],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component Definition\nDESCRIPTION: This snippet defines a simple React component using JSX syntax. It takes `props` as input and returns a `div` element.  The `@compilationMode(infer)` directive suggests that the code should be compiled with type inference enabled.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-function-assignment.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @compilationMode(infer)\nconst Component = props => {\n  return <div />;\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Compiler Runtime\nDESCRIPTION: Compiler-optimized version of the component that implements caching and memoization using React's compiler runtime. Uses array-based caching to store and compare previous values of props and computed results.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructure-object-declaration-to-context-var.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { identity } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(4);\n  let x;\n  if ($[0] !== props) {\n    const { x: t0 } = props;\n    x = t0;\n    const foo = () => {\n      x = identity(props.x);\n    };\n\n    foo();\n    $[0] = props;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  let t0;\n  if ($[2] !== x) {\n    t0 = { x };\n    $[2] = x;\n    $[3] = t0;\n  } else {\n    t0 = $[3];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ x: 42 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a JavaScript Function\nDESCRIPTION: This code defines a simple JavaScript function named `foo` that takes an object `a` as input, extracts the value of `a.b`, creates an array containing this value, and returns the array. It showcases basic object property access and array creation in JavaScript.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/simple-scope.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(a) {\n  const x = [a.b];\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with Conditional Logic in JavaScript\nDESCRIPTION: This snippet defines a React component function that performs conditional logic based on props. It uses logical operators to determine values for variables 'a' and 'b', which are then used in the return statement.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/logical-expression.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component(props) {\n  let a = props.a || (props.b && props.c && props.d);\n  let b = (props.a && props.b && props.c) || props.d;\n  return a ? b : props.c;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Component with Optimized Context Variable Handling in JavaScript\nDESCRIPTION: This snippet presents an alternative implementation of the Component function that optimizes for context variable management and state mutation. It captures inputs using a closure defined by the compiler runtime and manages shared state effectively. The function returns an object composed of the bar value and modified x property. This implementation showcases subtle differences in capturing context variables compared to the previous snippet. Dependencies include 'react/compiler-runtime' and 'shared-runtime'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/bug-capturing-func-maybealias-captured-mutate.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { makeArray, mutate } from \"shared-runtime\";\n\n/**\n * Bug repro:\n * Found differences in evaluator results\n *   Non-forget (expected):\n *   (kind: ok)\n *   {\"bar\":4,\"x\":{\"foo\":3,\"wat0\":\"joe\"}}\n *   {\"bar\":5,\"x\":{\"foo\":3,\"wat0\":\"joe\"}}\n *   Forget:\n *   (kind: ok)\n *   {\"bar\":4,\"x\":{\"foo\":3,\"wat0\":\"joe\"}}\n *   {\"bar\":5,\"x\":{\"foo\":3,\"wat0\":\"joe\",\"wat1\":\"joe\"}}\n *\n * Fork of `capturing-func-alias-captured-mutate`, but instead of directly\n * aliasing `y` via `[y]`, we make an opaque call.\n *\n * Note that the bug here is that we don't infer that `a = makeArray(y)`\n * potentially captures a context variable into a local variable. As a result,\n * we don't understand that `a[0].x = b` captures `x` into `y` -- instead, we're\n * currently inferring that this lambda captures `y` (for a potential later\n * mutation) and simply reads `x`.\n *\n * Concretely `InferReferenceEffects.hasContextRefOperand` is incorrectly not\n * used when we analyze CallExpressions.\n */\nfunction Component(t0) {\n  const $ = _c(5);\n  const { foo, bar } = t0;\n  let t1;\n  if ($[0] !== foo) {\n    t1 = { foo };\n    $[0] = foo;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  const x = t1;\n  let y;\n  if ($[2] !== bar || $[3] !== x) {\n    y = { bar };\n    const f0 = function () {\n      const a = makeArray(y);\n      const b = x;\n\n      a[0].x = b;\n    };\n\n    f0();\n    mutate(y.x);\n    $[2] = bar;\n    $[3] = x;\n    $[4] = y;\n  } else {\n    y = $[4];\n  }\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ foo: 3, bar: 4 }],\n  sequentialRenders: [\n    { foo: 3, bar: 4 },\n    { foo: 3, bar: 5 },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: Basic React component that creates an array from props, performs multiplication and addition operations on array elements. Shows unoptimized array manipulation logic.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/assignment-expression-computed.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const x = [props.x];\n  const index = 0;\n  x[index] *= 2;\n  x['0'] += 3;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{x: 2}],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with React Compiler Runtime\nDESCRIPTION: This code represents the compiled version of the React component, utilizing React's compiler runtime. It uses the `_c` function to memoize values and optimize rendering. The component checks if the props have changed and updates the internal state accordingly before rendering.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-on-context-variable.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { identity } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(4);\n  let x;\n  if ($[0] !== props) {\n    const f = () => {\n      if (props.cond) {\n        x = 1;\n      } else {\n        x = 2;\n      }\n    };\n\n    const f2 = identity(f);\n    f2();\n    $[0] = props;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  let t0;\n  if ($[2] !== x) {\n    t0 = [x];\n    $[2] = x;\n    $[3] = t0;\n  } else {\n    t0 = $[3];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  sequentialRenders: [\n    { cond: true },\n    { cond: true },\n    { cond: false },\n    { cond: false },\n    { cond: true },\n    { cond: false },\n    { cond: true },\n    { cond: false },\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Original React Component with Optional Chaining\nDESCRIPTION: A React component that maps over post comments using optional chaining. Uses @enablePropagateDepsInHIR directive for compilation optimization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reactive-dependencies-non-optional-properties-inside-optional-chain.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enablePropagateDepsInHIR\nfunction Component(props) {\n  return props.post.feedback.comments?.edges?.map(render);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Hook and Component in React - JavaScript\nDESCRIPTION: This snippet defines a custom hook using the useRef hook from React to create a reference with a click method, and a functional component Foo that utilizes this custom hook. The component defines an onClick handler using useCallback to invoke the click method of the ref when a button is clicked. No external dependencies other than React are needed, and it assumes the component is rendered using React in a browser environment.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ref-like-name-in-useCallback-2.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableTreatRefLikeIdentifiersAsRefs @validatePreserveExistingMemoizationGuarantees\\nimport {useRef, useCallback} from 'react';\\n\\nfunction useCustomRef() {\\n  return useRef({click: () => {}});\\n}\\n\\nfunction Foo() {\\n  const ref = useCustomRef();\\n\\n  const onClick = useCallback(() => {\\n    ref.current?.click();\\n  }, []);\\n\\n  return <button onClick={onClick} />;\\n}\\n\\nexport const FIXTURE_ENTRYPOINT = {\\n  fn: Foo,\\n  params: [],\\n  isComponent: true,\\n};\n```\n\n----------------------------------------\n\nTITLE: Using Labeled Break Statements in JavaScript Function\nDESCRIPTION: This code snippet demonstrates a function that uses a labeled break statement to exit from nested loops. The function takes three parameters and contains a labeled if-statement with nested while and if blocks, using 'break label' to exit the outer block when condition c is true.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/complex-while.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(a, b, c) {\n  label: if (a) {\n    while (b) {\n      if (c) {\n        break label;\n      }\n    }\n  }\n  return c;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Original Function Implementation in JavaScript\nDESCRIPTION: Initial implementation of a function that manipulates an array based on props conditions, without explicit memoization\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-renaming.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(props) {\n  let x = [];\n  x.push(props.bar);\n  if (props.cond) {\n    x = {};\n    x = [];\n    x.push(props.foo);\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with Mutation\nDESCRIPTION: This snippet defines a React component that takes a prop 'a', creates an object 'x' with 'a', and then mutates an object 'y' within a function 'f0'. The 'mutate' function is called on 'y', and finally, 'y' is returned. The component is exported as FIXTURE_ENTRYPOINT for testing and demonstration purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-alias-mutate.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {mutate} from 'shared-runtime';\nfunction Component({a}) {\n  let x = {a};\n  let y = {};\n  const f0 = function () {\n    y.x = x;\n  };\n  f0();\n  mutate(y);\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{a: 2}],\n  sequentialRenders: [{a: 2}, {a: 2}, {a: 3}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Memoizing Component with Conditional Array Manipulation\nDESCRIPTION: Demonstrates a React component using useMemo with conditional array population and optional chaining, which triggers memoization preservation warning\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.hoist-optional-member-expression-with-conditional.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees @enableOptionalDependencies\nimport {ValidateMemoization} from 'shared-runtime';\nfunction Component(props) {\n  const data = useMemo(() => {\n    const x = [];\n    x.push(props?.items);\n    if (props.cond) {\n      x.push(props.items);\n    }\n    return x;\n  }, [props?.items, props.cond]);\n  return (\n    <ValidateMemoization inputs={[props?.items, props.cond]} output={data} />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Optimized Component Rendering with Compiler Runtime in React\nDESCRIPTION: This second snippet offers a low-level representation of a React component that manually optimizes rendering using a compiler runtime (`_c`). Instead of relying on useMemo directly, it implements a series of checks and state updates to conditionally render output. This demonstrates advanced techniques in React for handling props and memoization, providing another layer of optimization specific to the lifecycle of the component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/props-method-dependency.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @compilationMode(infer)\nimport { useMemo } from \"react\";\nimport { ValidateMemoization } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(7);\n  let t0;\n  let t1;\n  if ($[0] !== props.x) {\n    t1 = props.x();\n    $[0] = props.x;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  t0 = t1;\n  const x = t0;\n  let t2;\n  if ($[2] !== props.x) {\n    t2 = [props.x];\n    $[2] = props.x;\n    $[3] = t2;\n  } else {\n    t2 = $[3];\n  }\n  let t3;\n  if ($[4] !== t2 || $[5] !== x) {\n    t3 = <ValidateMemoization inputs={t2} output={x} />;\n    $[4] = t2;\n    $[5] = x;\n    $[6] = t3;\n  } else {\n    t3 = $[6];\n  }\n  return t3;\n}\n\nconst f = () => [\"React\"];\nconst g = () => [\"Compiler\"];\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ x: () => [\"React\"] }],\n  sequentialRenders: [{ x: f }, { x: g }, { x: g }, { x: f }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Fixture Entrypoint Configuration\nDESCRIPTION: Test configuration for the useFoo function, defining input parameters and sequential render scenarios\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-cond-deps-return-in-scope.expect.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ obj: null, objIsNull: true }],\n  sequentialRenders: [\n    { obj: null, objIsNull: true },\n    { obj: { a: 2 }, objIsNull: false },\n  ]\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Original React Component Function in JavaScript\nDESCRIPTION: This snippet defines a function 'foo' that manipulates arrays based on input parameters. It also exports a FIXTURE_ENTRYPOINT object for component testing.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/dependencies.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(x, y, z) {\n  const items = [z];\n  items.push(x);\n\n  const items2 = [];\n  if (x) {\n    items2.push(y);\n  }\n\n  if (y) {\n    items.push(x);\n  }\n\n  return items2;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with State Tracking\nDESCRIPTION: Enhances the initial React component with an optimization mechanism using a caching system to only recompute the component structure when necessary, exploiting the runtime caching provided by React. This optimization is driven by changes in the props.p0 value, demonstrating state tracking and rendering efficiency.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/property-assignment.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== props.p0) {\n    const x = {};\n    const y = [];\n    x.y = y;\n    const child = <Component data={y} />;\n    x.y.push(props.p0);\n    t0 = <Component data={x}>{child}</Component>;\n    $[0] = props.p0;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with Array Destructuring in JavaScript\nDESCRIPTION: This snippet defines a React component that uses array destructuring with a default value. It also exports a fixture for testing purposes with a sparse array input.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-default-at-array-hole.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  // destructure slot index has a hole in the input, should return default\n  const [x = 42] = props.value;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: [, /* hole! */ 3.14]}],\n};\n```\n\n----------------------------------------\n\nTITLE: React Compiler Error Logs for Dynamic Component Creation\nDESCRIPTION: Compiler error logs showing why the dynamic component creation pattern is invalid. The logs indicate that components created during render will reset their state each time they're created and should be declared outside the render function.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/static-components/invalid-dynamically-constructed-component-new.expect.md#2025-04-21_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\"kind\":\"CompileError\",\"detail\":{\"options\":{\"reason\":\"Components created during render will reset their state each time they are created. Declare components outside of render. \",\"description\":null,\"severity\":\"InvalidReact\",\"suggestions\":null,\"loc\":{\"start\":{\"line\":4,\"column\":10,\"index\":117},\"end\":{\"line\":4,\"column\":19,\"index\":126},\"filename\":\"invalid-dynamically-constructed-component-new.ts\"}}}},\"fnLoc\":null}\n{\"kind\":\"CompileError\",\"detail\":{\"options\":{\"reason\":\"The component may be created during render\",\"description\":null,\"severity\":\"InvalidReact\",\"suggestions\":null,\"loc\":{\"start\":{\"line\":3,\"column\":20,\"index\":83},\"end\":{\"line\":3,\"column\":42,\"index\":105},\"filename\":\"invalid-dynamically-constructed-component-new.ts\"}}}},\"fnLoc\":null}\n{\"kind\":\"CompileSuccess\",\"fnLoc\":{\"start\":{\"line\":2,\"column\":0,\"index\":37},\"end\":{\"line\":5,\"column\":1,\"index\":132},\"filename\":\"invalid-dynamically-constructed-component-new.ts\"}},\"fnName\":\"Example\",\"memoSlots\":1,\"memoBlocks\":1,\"memoValues\":1,\"prunedMemoBlocks\":0,\"prunedMemoValues\":0}\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Getter Property in Object Literal\nDESCRIPTION: A React component that creates an object with a getter property accessing the component's props. The getter returns the 'value' prop passed to the component, which is then rendered inside a div element.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-object-expression-get-syntax.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component({value}) {\n  const object = {\n    get value() {\n      return value;\n    },\n  };\n  return <div>{object.value}</div>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [{value: 0}],\n  sequentialRenders: [{value: 1}, {value: 2}],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom React Hook 'useFoo' in JavaScript\nDESCRIPTION: This snippet defines a custom React hook 'useFoo' that manipulates an object based on input conditions. It uses utility functions from 'shared-runtime' and includes error handling. The hook is exported with test fixtures for different render scenarios.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-in-nested-scope.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {mutate, setProperty, throwErrorWithMessageIf} from 'shared-runtime';\n\nfunction useFoo({value, cond}) {\n  let y = [value];\n  let x = {cond};\n\n  try {\n    mutate(x);\n    throwErrorWithMessageIf(x.cond, 'error');\n  } catch {\n    setProperty(x, 'henderson');\n    return x;\n  }\n  setProperty(x, 'nevada');\n  y.push(x);\n\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{value: 4, cond: true}],\n  sequentialRenders: [\n    {value: 4, cond: true},\n    {value: 5, cond: true},\n    {value: 5, cond: false},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Exporting Fixture Entry Point for Testing - JavaScript\nDESCRIPTION: This snippet exports a constant 'FIXTURE_ENTRYPOINT' which contains the 'useFoo' function, initialization parameters, and a series of sequential renders to emulate different scenarios for testing the function's robustness against diverse input structures.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-sequential-optional-chain-nonnull.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{a: null}],\n  sequentialRenders: [\n    {a: null},\n    {a: null},\n    {a: {}},\n    {a: {b: {c: {d: {e: 42}}}}},\n    {a: {b: {c: {d: {e: 43}}}}},\n    {a: {b: {c: {d: {e: undefined}}}}},\n    {a: {b: undefined}},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized Memoization in React with useIdentity\nDESCRIPTION: This snippet provides an optimized version of the Foo component by caching state transitions using a compiler runtime. Through memoization techniques, the component enhances performance by reusing previously computed values. It requires react/compiler-runtime and takes an object with val1 as a parameter. It returns a JSX element, ensuring minimized component re-renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hook-call-freezes-captured-memberexpr.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useIdentity, Stringify, identity } from \"shared-runtime\";\n\nfunction Foo(t0) {\n  const $ = _c(9);\n  const { val1 } = t0;\n  let t1;\n  if ($[0] !== val1) {\n    t1 = { inner: val1 };\n    $[0] = val1;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  const x = t1;\n  let t2;\n  if ($[2] !== x.inner) {\n    t2 = () => x.inner;\n    $[2] = x.inner;\n    $[3] = t2;\n  } else {\n    t2 = $[3];\n  }\n  const cb = useIdentity(t2);\n  let t3;\n  if ($[4] !== x) {\n    t3 = identity(x);\n    $[4] = x;\n    $[5] = t3;\n  } else {\n    t3 = $[5];\n  }\n  const copy = t3;\n  let t4;\n  if ($[6] !== cb || $[7] !== copy) {\n    t4 = <Stringify copy={copy} cb={cb} shouldInvokeFns={true} />;\n    $[6] = cb;\n    $[7] = copy;\n    $[8] = t4;\n  } else {\n    t4 = $[8];\n  }\n  return t4;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{ val1: 1 }],\n  sequentialRenders: [{ val1: 1 }, { val1: 1 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation with useMemo\nDESCRIPTION: A React component that uses useMemo to optimize rendering. The component closes over an external global variable and updates it on click events. The implementation demonstrates a potential issue with memoization as the onClick handler references a prop but is not in the dependency array.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-modify-global-in-callback-jsx.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useMemo} from 'react';\n\nconst someGlobal = {value: 0};\n\nfunction Component({value}) {\n  const onClick = () => {\n    someGlobal.value = value;\n  };\n  return useMemo(() => {\n    return <div onClick={onClick}>{someGlobal.value}</div>;\n  }, []);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: 0}],\n  sequentialRenders: [\n    {value: 1},\n    {value: 1},\n    {value: 42},\n    {value: 42},\n    {value: 0},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: React Compiler Transformed Version with Memoization\nDESCRIPTION: The compiled version of the useFoo hook that implements memoization to avoid recalculation when inputs haven't changed. It uses the React compiler runtime functions to store and retrieve previous values.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-poisoned/break-in-scope.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction useFoo(t0) {\n  const $ = _c(3);\n  const { obj, objIsNull } = t0;\n  let x;\n  if ($[0] !== obj || $[1] !== objIsNull) {\n    x = [];\n    bb0: {\n      if (objIsNull) {\n        break bb0;\n      }\n\n      x.push(obj.a);\n    }\n    $[0] = obj;\n    $[1] = objIsNull;\n    $[2] = x;\n  } else {\n    x = $[2];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ obj: null, objIsNull: true }],\n  sequentialRenders: [\n    { obj: null, objIsNull: true },\n    { obj: { a: 2 }, objIsNull: false },\n    // check we preserve nullthrows\n    { obj: { a: undefined }, objIsNull: false },\n    { obj: undefined, objIsNull: false },\n    { obj: { a: undefined }, objIsNull: false },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing useMemo with Array Dependencies in React\nDESCRIPTION: A React hook implementation that demonstrates an issue with useMemo and mutable array dependencies. The function creates an array, pushes props to it, and then tries to memoize it, which causes a React Compiler error because the memoization cannot be preserved.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.false-positive-useMemo-dropped-infer-always-invalidating.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees\n\nimport {useMemo} from 'react';\nimport {useHook} from 'shared-runtime';\n\n// useMemo values may not be memoized in Forget output if we\n// infer that their deps always invalidate.\n// This is technically a false positive as the useMemo in source\n// was effectively a no-op\nfunction useFoo(props) {\n  const x = [];\n  useHook();\n  x.push(props);\n\n  return useMemo(() => [x], [x]);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Foo Component with Callbacks - JavaScript\nDESCRIPTION: This snippet defines a React functional component Foo that accepts two arrays and a boolean prop. It uses the useCallback hook to create memoized functions getVal1 and getVal2, which determine the computed values based on the input arrays and the boolean flag. The component returns a Stringify element which displays the results of these functions.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useCallback-reordering-deplist-controlflow.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useCallback} from 'react';\nimport {Stringify} from 'shared-runtime';\n\nfunction Foo({arr1, arr2, foo}) {\n  const x = [arr1];\n\n  let y = [];\n\n  const getVal1 = useCallback(() => {\n    return {x: 2};\n  }, []);\n\n  const getVal2 = useCallback(() => {\n    return [y];\n  }, [foo ? (y = x.concat(arr2)) : y]);\n\n  return <Stringify val1={getVal1} val2={getVal2} shouldInvokeFns={true} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{arr1: [1, 2], arr2: [3, 4], foo: true}],\n  sequentialRenders: [\n    {arr1: [1, 2], arr2: [3, 4], foo: true},\n    {arr1: [1, 2], arr2: [3, 4], foo: false},\n  ],\n};\n```\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useCallback } from \"react\";\nimport { Stringify } from \"shared-runtime\";\n\nfunction Foo(t0) {\n  const $ = _c(8);\n  const { arr1, arr2, foo } = t0;\n  let getVal1;\n  let t1;\n  if ($[0] !== arr1 || $[1] !== arr2 || $[2] !== foo) {\n    const x = [arr1];\n\n    let y;\n    y = [];\n\n    getVal1 = _temp;\n\n    t1 = () => [y];\n    foo ? (y = x.concat(arr2)) : y;\n    $[0] = arr1;\n    $[1] = arr2;\n    $[2] = foo;\n    $[3] = getVal1;\n    $[4] = t1;\n  } else {\n    getVal1 = $[3];\n    t1 = $[4];\n  }\n  const getVal2 = t1;\n  let t2;\n  if ($[5] !== getVal1 || $[6] !== getVal2) {\n    t2 = <Stringify val1={getVal1} val2={getVal2} shouldInvokeFns={true} />;\n    $[5] = getVal1;\n    $[6] = getVal2;\n    $[7] = t2;\n  } else {\n    t2 = $[7];\n  }\n  return t2;\n}\nfunction _temp() {\n  return { x: 2 };\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{ arr1: [1, 2], arr2: [3, 4], foo: true }],\n  sequentialRenders: [\n    { arr1: [1, 2], arr2: [3, 4], foo: true },\n    { arr1: [1, 2], arr2: [3, 4], foo: false },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimizing Component Rendering in React with Memoization\nDESCRIPTION: This code snippet depicts an optimized implementation of a React component using memoization techniques to enhance rendering efficiency. It utilizes internal caching through an array '$' to track and minimize re-computation when component props change. This pattern is a common React optimization strategy for components handling dynamic input values. The snippet depends on the 'react/compiler-runtime', indicating an integration for additional React compiler optimizations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-access-assignment.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(t0) {\n  const $ = _c(6);\n  const { a, b, c } = t0;\n  let t1;\n  if ($[0] !== a || $[1] !== b || $[2] !== c) {\n    const x = [a];\n    let t2;\n    if ($[4] !== b) {\n      t2 = [null, b];\n      $[4] = b;\n      $[5] = t2;\n    } else {\n      t2 = $[5];\n    }\n    const y = t2;\n    const z = [[], [], [c]];\n    x[0] = y[1];\n    z[0][0] = x[0];\n    t1 = [x, z];\n    $[0] = a;\n    $[1] = b;\n    $[2] = c;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ a: 1, b: 20, c: 300 }],\n  sequentialRenders: [\n    { a: 2, b: 20, c: 300 },\n    { a: 3, b: 20, c: 300 },\n    { a: 3, b: 21, c: 300 },\n    { a: 3, b: 22, c: 300 },\n    { a: 3, b: 22, c: 301 },\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Compiler Optimized Output with Memoization\nDESCRIPTION: The compiler-transformed version of the same component with memoization added. It uses React's compiler runtime to cache computations and avoid unnecessary re-renders by tracking parameter changes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/overlapping-scopes-shadowing-within-block.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction foo(a, b, c) {\n  const $ = _c(9);\n  let x;\n  if ($[0] !== a || $[1] !== b || $[2] !== c) {\n    x = [];\n    if (a) {\n      let y;\n      if ($[4] !== b || $[5] !== c) {\n        y = [];\n        if (b) {\n          y.push(c);\n        }\n        $[4] = b;\n        $[5] = c;\n        $[6] = y;\n      } else {\n        y = $[6];\n      }\n      let t0;\n      if ($[7] !== y) {\n        t0 = <div>{y}</div>;\n        $[7] = y;\n        $[8] = t0;\n      } else {\n        t0 = $[8];\n      }\n      x.push(t0);\n    }\n    $[0] = a;\n    $[1] = b;\n    $[2] = c;\n    $[3] = x;\n  } else {\n    x = $[3];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled and Memoized Array Manipulation Function in JavaScript\nDESCRIPTION: This is the compiled version of the useFoo function, optimized by the React compiler. It implements memoization to avoid unnecessary recalculations and preserves the order of evaluation. The function uses a closure array for caching previous results.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/evaluation-order-mutate-call-after-dependency-load.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; /**\n * Test that we preserve order of evaluation on the following case scope@0\n * ```js\n * // simplified HIR\n * scope@0\n *    ...\n *    $0 = arr.length\n *    $1 = arr.push(...)\n *\n * scope@1 <-- here we should depend on $0 (the value of the property load before the\n *             mutable call)\n *   [$0, $1]\n * ```\n */\nfunction useFoo(source) {\n  const $ = _c(6);\n  let t0;\n  let t1;\n  if ($[0] !== source) {\n    const arr = [1, 2, 3, ...source];\n    t0 = arr.length;\n    t1 = arr.push(0);\n    $[0] = source;\n    $[1] = t0;\n    $[2] = t1;\n  } else {\n    t0 = $[1];\n    t1 = $[2];\n  }\n  let t2;\n  if ($[3] !== t0 || $[4] !== t1) {\n    t2 = [t0, t1];\n    $[3] = t0;\n    $[4] = t1;\n    $[5] = t2;\n  } else {\n    t2 = $[5];\n  }\n  return t2;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [[5, 6]],\n};\n```\n\n----------------------------------------\n\nTITLE: Initializing React Component with Let Variables\nDESCRIPTION: This snippet shows a React component function using 'let' for variable declarations. It creates nested arrays, uses a custom hook, and returns the outer array.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/nested-scopes-hook-call.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component(props) {\n  let x = [];\n  let y = [];\n  y.push(useHook(props.foo));\n  x.push(y);\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Optimized State Mutation - JavaScript\nDESCRIPTION: In this snippet, the component function includes an optimization mechanism that checks if the input parameter has changed. It only constructs and mutates the state object if the parameter differs from the previous invocation, utilizing the `mutate` function appropriately.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-alias-computed-mutate-iife.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nconst { mutate } = require(\"shared-runtime\");\n\nfunction component(a) {\n  const $ = _c(2);\n  let y;\n  if ($[0] !== a) {\n    const x = { a };\n    y = {};\n\n    y.x = x;\n\n    mutate(y);\n    $[0] = a;\n    $[1] = y;\n  } else {\n    y = $[1];\n  }\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: [\"foo\"],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Memoization\nDESCRIPTION: This snippet shows an optimized version of the 'Foo' component using memoization techniques. It includes caching mechanisms to prevent unnecessary re-renders and optimizes the useEffect hook.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ref-parameter-mutate-in-effect.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useEffect } from \"react\";\n\nfunction Foo(props, ref) {\n  const $ = _c(5);\n  let t0;\n  if ($[0] !== ref) {\n    t0 = () => {\n      ref.current = 2;\n    };\n    $[0] = ref;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  let t1;\n  if ($[2] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = [];\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  useEffect(t0, t1);\n  let t2;\n  if ($[3] !== props.bar) {\n    t2 = <div>{props.bar}</div>;\n    $[3] = props.bar;\n    $[4] = t2;\n  } else {\n    t2 = $[4];\n  }\n  return t2;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{ bar: \"foo\" }, { ref: { current: 1 } }],\n  isComponent: true,\n};\n```\n\n----------------------------------------\n\nTITLE: Transformed React Component with Memoization\nDESCRIPTION: Compiler-transformed version of the component with added memoization logic. Uses a cache system to store and retrieve previously computed values, preventing unnecessary recalculations when inputs haven't changed.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-reassign-to-variable-without-mutable-range.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @debug\nfunction Component(a, b) {\n  const $ = _c(11);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = [];\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  let x = t0;\n  let t1;\n  if ($[1] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = [];\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  let y = t1;\n  if ($[2] !== a || $[3] !== b) {\n    const z = foo(a);\n    if (FLAG) {\n      x = bar(z);\n      let t2;\n      if ($[6] !== b) {\n        t2 = baz(b);\n        $[6] = b;\n        $[7] = t2;\n      } else {\n        t2 = $[7];\n      }\n      y = t2;\n    }\n    $[2] = a;\n    $[3] = b;\n    $[4] = x;\n    $[5] = y;\n  } else {\n    x = $[4];\n    y = $[5];\n  }\n  let t2;\n  if ($[8] !== x || $[9] !== y) {\n    t2 = [x, y];\n    $[8] = x;\n    $[9] = y;\n    $[10] = t2;\n  } else {\n    t2 = $[10];\n  }\n  return t2;\n}\n```\n\n----------------------------------------\n\nTITLE: Exporting Fixture Entry Point\nDESCRIPTION: This snippet exports a constant FIXTURE_ENTRYPOINT that holds the reference to the useFoo function, initial parameters, and a series of test cases with various object states to validate its behavior.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-poisoned/return-in-scope.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{obj: null, objIsNull: true}],\n  sequentialRenders: [\n    {obj: null, objIsNull: true},\n    {obj: {a: 2}, objIsNull: false},\n    // check we preserve nullthrows\n    {obj: {a: undefined}, objIsNull: false},\n    {obj: undefined, objIsNull: false},\n    {obj: {a: undefined}, objIsNull: false},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Initialising Component with React's Compiler Runtime in JavaScript\nDESCRIPTION: This JavaScript code snippet uses React's compiler-runtime, showing an advanced pattern for state management in components. It initializes a component with potential React state management utilities, updating or retaining previous states using dependency 'compiler-runtime'. Expected input is parameter 'a', influencing how the object 'x' is manipulated.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capture-indirect-mutate-alias.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction component(a) {\n  const $ = _c(2);\n  let x;\n  if ($[0] !== a) {\n    x = { a };\n    const f0 = function () {\n      const q = x;\n      const f1 = function () {\n        q.b = 1;\n      };\n\n      f1();\n    };\n\n    f0();\n    $[0] = a;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing a Counter Function with Export for React Testing\nDESCRIPTION: Defines a 'foo' function that increments a counter from 1 to 10 using a while loop, then returns the final value. The function is exported via FIXTURE_ENTRYPOINT with metadata indicating it's not a React component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-while.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo() {\n  let x = 1;\n  while (x < 10) {\n    x = x + 1;\n  }\n\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [],\n  isComponent: false,\n};\n```\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo() {\n  let x = 1;\n  while (x < 10) {\n    x = x + 1;\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with Infinite Loop and Export (Modified Version)\nDESCRIPTION: This code defines a React component function with an infinite loop due to a constant loop variable. It also exports a fixture entrypoint object for testing purposes, with slight modifications from the input version.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-empty-update.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let x = 0;\n  for (const i = 0; 0 < props.count; ) {\n    x = x + 0;\n    if (x > 10) {\n      break;\n    }\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: React Regression Test with Conditional Expression and useState\nDESCRIPTION: This snippet demonstrates a regression test in React for a conditional expression. The test includes the useState hook and a conditional ternary operator, ensuring that valid code involving these features is not falsely flagged.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-c5d1f3143c4c.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// Regression test for incorrectly flagged valid code.\nfunction RegressionTest() {\n  cond ? a : b;\n  useState();\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing useFoo React Hook in JavaScript\nDESCRIPTION: This snippet defines the useFoo hook that takes an object with optional string properties and a boolean flag. It conditionally destructures the input and returns a new object with selected properties. The hook demonstrates handling of optional parameters and conditional logic.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructure-in-branch-ssa.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction useFoo(props: {\n  x?: string;\n  y?: string;\n  z?: string;\n  doDestructure: boolean;\n}) {\n  let x = null;\n  let y = null;\n  let z = null;\n  const myList = [];\n  if (props.doDestructure) {\n    ({x, y, z} = props);\n\n    myList.push(z);\n  }\n  return {\n    x,\n    y,\n    myList,\n  };\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{x: 'hello', y: 'world', doDestructure: true}],\n};\n```\n\n----------------------------------------\n\nTITLE: Integrating React Compiler Runtime in Component - JavaScript\nDESCRIPTION: Enhances the basic React component by utilizing React's compiler-runtime to manage component rendering more efficiently. This version tracks state changes using an array `$` and avoids unnecessary re-renders with a mechanism to return previous render results if the state remains unchanged.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactivity-via-aliased-mutation-through-property-load.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  const x = {};\n  const y = [];\n  x.y = y;\n  x.y.push(props.input);\n\n  let z = 0;\n  if (x.y[0]) {\n    z = 1;\n  }\n  let t0;\n  if ($[0] !== z) {\n    t0 = [z];\n    $[0] = z;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  sequentialRenders: [\n    { input: true },\n    { input: true },\n    { input: false },\n    { input: false },\n    { input: true },\n    { input: false },\n    { input: true },\n    { input: false },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized Component State Management in JavaScript\nDESCRIPTION: This JavaScript code snippet defines a more optimized version of a component, using a cache-like mechanism to store previous states and reduce unnecessary recalculations. It uses a compiler runtime to optimize component rendering decisions based on input changes. The function optimizes where possible by using a stored state when repeated inputs occur, reducing computational overhead. This approach is useful for performance-critical React applications where component rendering needs to be highly efficient.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-alias-receiver-computed-mutate-iife.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { mutate } from \"shared-runtime\";\n\nfunction component(a) {\n  const $ = _c(2);\n  let y;\n  if ($[0] !== a) {\n    const x = { a };\n    y = {};\n\n    const a_0 = y;\n    a_0.x = x;\n\n    mutate(y);\n    $[0] = a;\n    $[1] = y;\n  } else {\n    y = $[1];\n  }\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: [\"foo\"],\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Compiler Error: Cannot Preserve Memoization\nDESCRIPTION: The error output from React Compiler showing it has skipped optimizing the component because the existing manual memoization could not be preserved. The compiler detected that inferred dependencies didn't match the manually specified ones in useCallback.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.hoist-useCallback-conditional-access-own-scope.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n   3 |\n   4 | function Component({propA, propB}) {\n>  5 |   return useCallback(() => {\n     |                      ^^^^^^^\n>  6 |     if (propA) {\n     | ^^^^^^^^^^^^^^^^\n>  7 |       return {\n     | ^^^^^^^^^^^^^^^^\n>  8 |         value: propB.x.y,\n     | ^^^^^^^^^^^^^^^^\n>  9 |       };\n     | ^^^^^^^^^^^^^^^^\n> 10 |     }\n     | ^^^^^^^^^^^^^^^^\n> 11 |   }, [propA, propB.x.y]);\n     | ^^^^ CannotPreserveMemoization: React Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. The inferred dependencies did not match the manually specified dependencies, which could cause the value to change more or less frequently than expected (5:11)\n  12 | }\n  13 |\n  14 | export const FIXTURE_ENTRYPOINT = {\n```\n\n----------------------------------------\n\nTITLE: Optimized React Hook with Compiler Runtime\nDESCRIPTION: This snippet is an optimized version of the React hook using a function imported from the React compiler runtime. The hook employs a memoization technique to store previous state conditions. The function gets a 'cond' parameter and conditionally updates a value, returning a JSX component if necessary. It uses the same constants and has similar functionality as the first snippet but follows a different memoization pattern. It expects an object with 'cond' as a parameter and outputs a JSX component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-reassigned-twice-let-declaration.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { CONST_NUMBER0, CONST_NUMBER1, Stringify } from \"shared-runtime\";\n\nfunction useHook(t0) {\n  \"use memo\";\n  const $ = _c(2);\n  const { cond } = t0;\n  let t1;\n  if ($[0] !== cond) {\n    const getX = () => x;\n\n    let x;\n    x = CONST_NUMBER0;\n    if (cond) {\n      x = x + CONST_NUMBER1;\n      x;\n      x = Math.min(x, 100);\n    }\n\n    t1 = <Stringify getX={getX} shouldInvokeFns={true} />;\n    $[0] = cond;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useHook,\n  params: [{ cond: true }],\n  sequentialRenders: [{ cond: true }, { cond: true }, { cond: false }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Compiler Error Message\nDESCRIPTION: The error message displayed by the React compiler when encountering the hoisting issue. It indicates that it expected the identifier 'hasErrors' to be initialized before use, pointing to line 9 where the function is called.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-repro-named-function-with-shadowed-local-same-name.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n   7 |     return hasErrors;\n   8 |   }\n>  9 |   return hasErrors();\n     |          ^^^^^^^^^ Invariant: [hoisting] Expected value for identifier to be initialized. hasErrors_0$14 (9:9)\n  10 | }\n  11 |\n```\n\n----------------------------------------\n\nTITLE: Defining a Component with Non-Reactive State - JavaScript\nDESCRIPTION: This snippet defines a React component named `Component` that determines the value of `x` based on the input props. The logic sets `x` to 10 if the input value is greater than 10, or to 1 otherwise. The component returns an array containing the value of `x`, which is commented to indicate that while `x` is non-reactive, it depends on the reactive control variable `i`.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-forof-collection.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let x;\n  for (const i of props.values) {\n    if (i > 10) {\n      x = 10;\n    } else {\n      x = 1;\n    }\n  }\n  // The values assigned to `x` are non-reactive, but the value of `x`\n  // depends on the \"control\" variable `i`, whose value is derived from\n  // `props.values` which is reactive.\n  // Therefore x should be treated as reactive too.\n  return [x];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  sequentialRenders: [\n    {values: [12]},\n    {values: [12]},\n    {values: [1]},\n    {values: [1]},\n    {values: [12]},\n    {values: [1]},\n    {values: [12]},\n    {values: [1]},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with useFire Hook\nDESCRIPTION: This snippet represents the compiled output of the previous React component, utilizing React's compiler runtime and a 'useFire' hook. It demonstrates how the 'fire' function is transformed into a memoized and conditionally executed side effect, optimizing performance by avoiding unnecessary executions. The code uses temporary variables and conditional checks to manage the side effect execution based on prop and hook changes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/basic.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c, useFire } from \"react/compiler-runtime\"; // @enableFire\nimport { fire } from \"react\";\n\nfunction Component(props) {\n  const $ = _c(3);\n  const foo = _temp;\n  const t0 = useFire(foo);\n  let t1;\n  if ($[0] !== props || $[1] !== t0) {\n    t1 = () => {\n      t0(props);\n    };\n    $[0] = props;\n    $[1] = t0;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  useEffect(t1);\n  return null;\n}\nfunction _temp(props_0) {\n  console.log(props_0);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Unsupported Throw Statement in Try/Catch Block in React Component\nDESCRIPTION: A React component function that attempts to throw an array in a try/catch block and then access the caught exception. This pattern triggers a build-time error in React's compiler that indicates throwing arrays inside try/catch blocks is not supported.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo.try-catch-with-throw.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let x;\n  try {\n    throw [];\n  } catch (e) {\n    x.push(e);\n  }\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple React Functional Component in JavaScript\nDESCRIPTION: This snippet declares a function `foo` that returns an array based on the input parameters. It conditionally adds elements to the array based on whether parameter `a` is truthy. If so, it adds a React `div` containing parameter `b`; otherwise, it adds parameter `c`. The `FIXTURE_ENTRYPOINT` object exports the function `foo`, alongside additional metadata.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-scopes-if.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nfunction foo(a, b, c) {\n  const x = [];\n  if (a) {\n    const y = [];\n    y.push(b);\n    x.push(<div>{y}</div>);\n  } else {\n    x.push(c);\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with Default Array Destructuring in JavaScript\nDESCRIPTION: This snippet defines a React component that uses array destructuring with a default value. It destructures the first element of props.value array, defaulting to 42 if the array is empty or undefined. The component returns this value.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-default-past-end-of-array.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  // destructure past end of empty array, should evaluate to default\n  const [x = 42] = props.value;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: []}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: Compiled version of the React component with explicit memoization checks and render optimizations. Includes compiler-generated code for tracking prop changes and memoizing render output.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/use-operator-conditional.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { ValidateMemoization } from \"shared-runtime\";\nimport { use, useMemo } from \"react\";\n\nconst FooContext = React.createContext(null);\nfunction Component(props) {\n  const $ = _c(5);\n  let t0;\n  if ($[0] !== props.cond) {\n    t0 = <Inner cond={props.cond} />;\n    $[0] = props.cond;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  let t1;\n  if ($[2] !== props.value || $[3] !== t0) {\n    t1 = <FooContext.Provider value={props.value}>{t0}</FooContext.Provider>;\n    $[2] = props.value;\n    $[3] = t0;\n    $[4] = t1;\n  } else {\n    t1 = $[4];\n  }\n  return t1;\n}\n\nfunction Inner(props) {\n  const $ = _c(7);\n  let input;\n  input = null;\n  if (props.cond) {\n    input = use(FooContext);\n  }\n\n  input;\n  let t0;\n  let t1;\n  if ($[0] !== input) {\n    t1 = [input];\n    $[0] = input;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  t0 = t1;\n  const output = t0;\n  let t2;\n  if ($[2] !== input) {\n    t2 = [input];\n    $[2] = input;\n    $[3] = t2;\n  } else {\n    t2 = $[3];\n  }\n  let t3;\n  if ($[4] !== output || $[5] !== t2) {\n    t3 = <ValidateMemoization inputs={t2} output={output} />;\n    $[4] = output;\n    $[5] = t2;\n    $[6] = t3;\n  } else {\n    t3 = $[6];\n  }\n  return t3;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ cond: true, value: 42 }],\n  sequentialRenders: [\n    // change cond true->false\n    { cond: true, value: 42 },\n    { cond: false, value: 42 },\n\n    // change value\n    { cond: false, value: null },\n    { cond: false, value: 42 },\n\n    // change cond false->true\n    { cond: true, value: 42 },\n\n    // change cond true->false, change unobserved value, change cond false->true\n    { cond: false, value: 42 },\n    { cond: false, value: null },\n    { cond: true, value: 42 },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Hook with React Setup - JavaScript\nDESCRIPTION: This snippet shows the implementation of a custom React hook useFoo that manages an object based on null check conditions. Dependencies include the React compiler-runtime for the caching mechanism. The function takes an object with properties obj and objIsNull and pushes values into an array conditionally. It returns the array as its output. Key parameters obj and objIsNull determine behavior. Inputs are objects following the specified structure. Returns an array of managed states. Assumes a React environment for runtime aspect.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-cond-deps-break-in-scope.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction useFoo(t0) {\n  const $ = _c(3);\n  const { obj, objIsNull } = t0;\n  let x;\n  if ($[0] !== obj || $[1] !== objIsNull) {\n    x = [];\n    bb0: {\n      if (objIsNull) {\n        break bb0;\n      } else {\n        x.push(obj.a);\n      }\n\n      x.push(obj.b);\n    }\n    $[0] = obj;\n    $[1] = objIsNull;\n    $[2] = x;\n  } else {\n    x = $[2];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ obj: null, objIsNull: true }],\n  sequentialRenders: [\n    { obj: null, objIsNull: true },\n    { obj: { a: 2 }, objIsNull: false },\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Compiler-Optimized Version with Memoization\nDESCRIPTION: Shows how React's compiler transforms the custom hook to include memoization. It adds dependency tracking to prevent unnecessary recreations of the callback object when inputs haven't changed, using React's compiler-runtime utilities.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/return-object-of-functions.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; /**\n * Assume that only directly returned functions or JSX attributes are invoked.\n * Conservatively estimate that functions wrapped in objects or other containers\n * might never be called (and therefore their property loads are not hoistable).\n */\nfunction useMakeCallback(t0) {\n  const $ = _c(2);\n  const { arr } = t0;\n  let t1;\n  if ($[0] !== arr) {\n    t1 = { getElement0: () => arr[0].value, getElement1: () => arr[1].value };\n    $[0] = arr;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useMakeCallback,\n  params: [{ arr: [1, 2] }],\n  sequentialRenders: [{ arr: [1, 2] }, { arr: [] }],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with State Checking (JavaScript)\nDESCRIPTION: This snippet enhances the `foo` function with state caching using the `react/compiler-runtime` import. It checks previous inputs to optimize re-rendering, making use of a cache array `$` to store previous values and DOM elements, reducing unnecessary updates. The `FIXTURE_ENTRYPOINT` object is also included, providing the function `foo` along with parameters and component metadata.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-scopes-if.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction foo(a, b, c) {\n  const $ = _c(8);\n  let x;\n  if ($[0] !== a || $[1] !== b || $[2] !== c) {\n    x = [];\n    if (a) {\n      let y;\n      if ($[4] !== b) {\n        y = [];\n        y.push(b);\n        $[4] = b;\n        $[5] = y;\n      } else {\n        y = $[5];\n      }\n      let t0;\n      if ($[6] !== y) {\n        t0 = <div>{y}</div>;\n        $[6] = y;\n        $[7] = t0;\n      } else {\n        t0 = $[7];\n      }\n      x.push(t0);\n    } else {\n      x.push(c);\n    }\n    $[0] = a;\n    $[1] = b;\n    $[2] = c;\n    $[3] = x;\n  } else {\n    x = $[3];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Optimizing Hook with Compiler Runtime in React\nDESCRIPTION: This snippet enhances the `useHook` function by adding caching mechanism provided by React's `compiler-runtime`, imported as `_c`. The function logs messages only when the condition changes, utilizing the compiler runtime to store previous states. It requires the `react/compiler-runtime` and `shared-runtime` modules.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/labeled-break-within-label-switch.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { CONST_STRING0 } from \"shared-runtime\";\n\nfunction useHook(cond) {\n  const $ = _c(2);\n  let log;\n  if ($[0] !== cond) {\n    log = [];\n    switch (CONST_STRING0) {\n      case CONST_STRING0: {\n        log.push(`@A`);\n        bb0: {\n          if (cond) {\n            break bb0;\n          }\n\n          log.push(`@B`);\n        }\n\n        log.push(`@C`);\n      }\n    }\n    $[0] = cond;\n    $[1] = log;\n  } else {\n    log = $[1];\n  }\n  return log;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useHook,\n  params: [true],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining React Functional Component - Basic Version\nDESCRIPTION: This JavaScript snippet defines a functional component that takes an argument 'a', creates an object 't' containing 'a', and calls the inner function 'x' that accesses 'foo' method of 'a'. It also exports a constant as a fixture for testing with a sample 'foo' implementation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisted-function-declaration.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component(a) {\n  let t = {a};\n  x(t); // hoisted call\n  function x(p) {\n    p.a.foo();\n  }\n  return t;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: [\n    {\n      foo: () => {\n        console.log(42);\n      },\n    },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: Initial implementation of a React component with forget directive and feature flag setup. Includes a Bar component and feature flag check function.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/conflicting-gating-fn.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @gating\n\nexport const isForgetEnabled_Fixtures = () => {\n  'use no forget';\n  return false;\n};\n\nexport function Bar(props) {\n  'use forget';\n  return <div>{props.bar}</div>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: eval('Bar'),\n  params: [{bar: 2}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Caching\nDESCRIPTION: Compiler-optimized version of the component with added caching logic. Uses an array ($) to store previous values and implements dependency checking to avoid unnecessary recalculations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-property-call.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(11);\n  let a;\n  let t0;\n  if ($[0] !== props.a || $[1] !== props.b) {\n    a = [props.a, props.b, \"hello\"];\n    t0 = a.push(42);\n    $[0] = props.a;\n    $[1] = props.b;\n    $[2] = a;\n    $[3] = t0;\n  } else {\n    a = $[2];\n    t0 = $[3];\n  }\n  const x = t0;\n  let t1;\n  if ($[4] !== a || $[5] !== props.c) {\n    t1 = a.at(props.c);\n    $[4] = a;\n    $[5] = props.c;\n    $[6] = t1;\n  } else {\n    t1 = $[6];\n  }\n  const y = t1;\n  let t2;\n  if ($[7] !== a || $[8] !== x || $[9] !== y) {\n    t2 = { a, x, y };\n    $[7] = a;\n    $[8] = x;\n    $[9] = y;\n    $[10] = t2;\n  } else {\n    t2 = $[10];\n  }\n  return t2;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ a: 1, b: 2, c: 0 }],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with FBT Internationalization\nDESCRIPTION: This snippet defines a React component using the FBT framework for internationalization. It imports the FBT library, creates a component that renders internationalized text with a parameterized value, and exports a fixture for testing.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-single-space-btw-param-and-text.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport fbt from 'fbt';\n\nconst _ = fbt;\nfunction Component({value}: {value: string}) {\n  return (\n    <fbt desc=\"descdesc\">\n      Before text <fbt:param name=\"paramName\">{value}</fbt:param> after text\n    </fbt>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: 'hello world'}],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Error Handling in React Component\nDESCRIPTION: This snippet shows a React component that attempts to push a prop value into an array, throws an input, and catches the error. It demonstrates basic error handling in React components.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-try-value-modified-in-catch-escaping.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst {throwInput} = require('shared-runtime');\n\nfunction Component(props) {\n  let x;\n  try {\n    const y = [];\n    y.push(props.y);\n    throwInput(y);\n  } catch (e) {\n    e.push(props.e);\n    x = e;\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{y: 'foo', e: 'bar'}],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with useIdentity Hook (Duplicate)\nDESCRIPTION: This code defines a React component named `useFoo` which leverages the `useIdentity` hook from the `shared-runtime` library. The component creates a Set, gets its values, and then returns the maximum value from the set. A fixture entry point is also exported for testing purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/call-spread-argument-mutable-iterator.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useIdentity } from \"shared-runtime\";\n\nfunction useFoo() {\n  const it = new Set([1, 2]).values();\n  useIdentity();\n  return Math.max(...it);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{}],\n  sequentialRenders: [{}, {}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Component with Global State - Input Source\nDESCRIPTION: A React component that demonstrates global state management using hooks. It shows how to safely mutate global state within effects and handle state updates. The component uses useState and useEffect hooks to manage and respond to global state changes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-mutate-global-in-effect-fixpoint.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useEffect, useState} from 'react';\n\nlet someGlobal = {value: null};\n\nfunction Component() {\n  const [state, setState] = useState(someGlobal);\n\n  // NOTE: if we initialize to eg null or a local, then it won't be a definitively global\n  // mutation below when we modify `y`. The point of this is example is that if all control\n  // flow paths produce a global, we allow the mutation in an effect\n  let x = someGlobal;\n  while (x == null) {\n    x = someGlobal;\n  }\n\n  // capture into a separate variable that is not a context variable.\n  const y = x;\n  /**\n   * Note that this fixture currently produces a stale effect closure if `y = x\n   * = someGlobal` changes between renders. Under current compiler assumptions,\n   * that would be a rule of react violation.\n   */\n  useEffect(() => {\n    y.value = 'hello';\n  });\n\n  useEffect(() => {\n    setState(someGlobal.value);\n  }, [someGlobal]);\n\n  return <div>{String(state)}</div>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: Original implementation of a React component that creates a context object based on props and performs mutation. Uses dynamic key assignment and the identity function from shared runtime.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-expression-computed-member.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {identity, mutate, mutateAndReturn} from 'shared-runtime';\n\nfunction Component(props) {\n  const key = {a: 'key'};\n  const context = {\n    [key.a]: identity([props.value]),\n  };\n  mutate(key);\n  return context;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: 42}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Compiler Runtime Optimizations\nDESCRIPTION: Transformed version of the React component using React compiler runtime (_c) for advanced memoization and caching strategies\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-mabye-modified-free-variable-preserve-memoization-guarantees.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useMemo } from \"react\";\nimport {\n  identity,\n  makeObject_Primitives,\n  mutate,\n  useHook,\n} from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(4);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = makeObject_Primitives();\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const free = t0;\n  let t1;\n  if ($[1] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = makeObject_Primitives();\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  const free2 = t1;\n  const part = free2.part;\n\n  useHook();\n  let t2;\n  let x;\n  if ($[2] !== props.value) {\n    x = makeObject_Primitives();\n    x.value = props.value;\n    mutate(x, free, part);\n    $[2] = props.value;\n    $[3] = x;\n  } else {\n    x = $[3];\n  }\n  t2 = x;\n  const object = t2;\n\n  identity(free);\n  identity(part);\n  return object;\n}\n```\n\n----------------------------------------\n\nTITLE: Input React Component with FBT\nDESCRIPTION: Source code showing a React component that uses FBT for internationalization. The component takes a name prop and renders a greeting message using FBT's parameter substitution.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-param-with-newline.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport fbt from 'fbt';\n\nfunction Component(props) {\n  const element = (\n    <fbt desc={'Dialog to show to user'}>\n      Hello{' '}\n      <fbt:param\n        name=\"a really long description\n      that got split into multiple lines\">\n        {props.name}\n      </fbt:param>\n    </fbt>\n  );\n  return element.toString();\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{name: 'Jason'}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: The React compiler-transformed version of the component that implements memoization. It uses the compiler runtime to cache results based on prop changes and employs Symbol.for() for cache validation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reassignment-conditional.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(5);\n  let t0;\n  if ($[0] !== props.p0 || $[1] !== props.p1 || $[2] !== props.p2) {\n    let x = [];\n    x.push(props.p0);\n    const y = x;\n    if (props.p1) {\n      let t1;\n      if ($[4] === Symbol.for(\"react.memo_cache_sentinel\")) {\n        t1 = [];\n        $[4] = t1;\n      } else {\n        t1 = $[4];\n      }\n      x = t1;\n    }\n\n    y.push(props.p2);\n\n    t0 = <Component x={x} y={y} />;\n    $[0] = props.p0;\n    $[1] = props.p1;\n    $[2] = props.p2;\n    $[3] = t0;\n  } else {\n    t0 = $[3];\n  }\n  return t0;\n}\n```\n\n----------------------------------------\n\nTITLE: Optimizing Component Logic with Cached Values\nDESCRIPTION: This snippet presents an optimized version of the React component that implements caching for performance improvements. It uses a cached array and checks dependencies using a global variable to avoid unnecessary updates. This code version also leverages a local variable to manage the output JSX efficiently, enhancing re-rendering logic based on prop changes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/todo-global-load-cached.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from 'react/compiler-runtime';\nimport { Stringify } from 'shared-runtime';\nimport { makeArray } from 'shared-runtime';\n\n/**\n * Here, we don't need to memoize Stringify as it is a read off of a global.\n * TODO: in PropagateScopeDeps (hir), we should produce a sidemap of global rvals\n * and avoid adding them to `temporariesUsedOutsideDefiningScope`.\n */\nfunction Component(t0) {\n  const $ = _c(6);\n  const { num } = t0;\n  let T0;\n  let t1;\n  if ($[0] !== num) {\n    const arr = makeArray(num);\n    T0 = Stringify;\n    t1 = arr.push(num);\n    $[0] = num;\n    $[1] = T0;\n    $[2] = t1;\n  } else {\n    T0 = $[1];\n    t1 = $[2];\n  }\n  let t2;\n  if ($[3] !== T0 || $[4] !== t1) {\n    t2 = <T0 value={t1} />;\n    $[3] = T0;\n    $[4] = t1;\n    $[5] = t2;\n  } else {\n    t2 = $[5];\n  }\n  return t2;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ num: 2 }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Optimization in JavaScript\nDESCRIPTION: This is a compiled and optimized version of the React component. It includes memoization for props and uses symbols for early returns. The core functionality remains the same as the original component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-try-value-modified-in-catch.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nconst { throwInput } = require(\"shared-runtime\");\n\nfunction Component(props) {\n  const $ = _c(3);\n  let t0;\n  if ($[0] !== props.e || $[1] !== props.y) {\n    t0 = Symbol.for(\"react.early_return_sentinel\");\n    bb0: {\n      try {\n        const y = [];\n        y.push(props.y);\n        throwInput(y);\n      } catch (t1) {\n        const e = t1;\n        e.push(props.e);\n        t0 = e;\n        break bb0;\n      }\n    }\n    $[0] = props.e;\n    $[1] = props.y;\n    $[2] = t0;\n  } else {\n    t0 = $[2];\n  }\n  if (t0 !== Symbol.for(\"react.early_return_sentinel\")) {\n    return t0;\n  }\n  return null;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ y: \"foo\", e: \"bar\" }],\n};\n```\n\n----------------------------------------\n\nTITLE: Inefficient Function Implementation in JavaScript\nDESCRIPTION: Original implementation of 'foo' function with redundant variable assignments. The function takes three parameters but only returns the last one after multiple reassignments.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-reassign.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(a, b, c) {\n  let x = 0;\n  x = a;\n  x = b;\n  x = c;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component Implementation with Memoization\nDESCRIPTION: This snippet shows an optimized version of the Component function, likely generated by a React compiler. It uses memoization techniques to avoid unnecessary re-renders and computations, storing intermediate results in an array for reuse across renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/optional-member-expression-as-memo-dep.expect.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @validatePreserveExistingMemoizationGuarantees @enableOptionalDependencies @enablePropagateDepsInHIR\nimport { identity, ValidateMemoization } from \"shared-runtime\";\nimport { useMemo } from \"react\";\n\nfunction Component(t0) {\n  const $ = _c(7);\n  const { arg } = t0;\n\n  arg?.items.edges?.nodes;\n  let t1;\n  let t2;\n  if ($[0] !== arg?.items.edges?.nodes) {\n    t2 = arg?.items.edges?.nodes.map(identity);\n    $[0] = arg?.items.edges?.nodes;\n    $[1] = t2;\n  } else {\n    t2 = $[1];\n  }\n  t1 = t2;\n  const data = t1;\n\n  const t3 = arg?.items.edges?.nodes;\n  let t4;\n  if ($[2] !== t3) {\n    t4 = [t3];\n    $[2] = t3;\n    $[3] = t4;\n  } else {\n    t4 = $[3];\n  }\n  let t5;\n  if ($[4] !== data || $[5] !== t4) {\n    t5 = <ValidateMemoization inputs={t4} output={data} />;\n    $[4] = data;\n    $[5] = t4;\n    $[6] = t5;\n  } else {\n    t5 = $[6];\n  }\n  return t5;\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Object Immutability in React Component\nDESCRIPTION: This JavaScript snippet defines a React component that attempts to modify an object after it has been used in JSX, leading to an immutability error. React components should avoid mutating objects that have been rendered in JSX to prevent inconsistencies. This example exemplifies the need to reorder the steps, ensuring mutations occur before being used in JSX.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-property-store-to-frozen-value.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const x = makeObject();\n  // freeze\n  <div>{x}</div>;\n  x.y = true;\n  return x;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Async React Component with Data Population\nDESCRIPTION: This JavaScript code defines an asynchronous React component named `Component` that takes `props` as an argument. It initializes an empty array `x`, populates it with data using `populateData(props.id, x)`, and returns the populated array. This component fetches data on every render.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/await-side-effecting-promise.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nasync function Component(props) {\n  const x = [];\n  await populateData(props.id, x);\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Exceptions in React - JavaScript\nDESCRIPTION: This JavaScript function demonstrates a regression test in a React component, where an error is thrown if a condition is met (e.g., 'page' is null). The useState hook is mentioned, indicating it is part of a React component's logic. This snippet requires React library environment with use of useState hook.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-0e2214abc294.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Valid because exceptions abort rendering\\nfunction RegressionTest() {\\n  if (page == null) {\\n    throw new Error('oh no!');\\n  }\\n  useState();\\n}\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Valid because exceptions abort rendering\\nfunction RegressionTest() {\\n  if (page == null) {\\n    throw new Error(\"oh no!\");\\n  }\\n\\n  useState();\\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Optimized Dependency Tracking\nDESCRIPTION: The transformed version of the component after React compilation. It uses the compiler runtime to track dependencies and only recreates objects and effect callbacks when dependencies change, explicitly adding obj.a.b as a dependency to useEffect.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/reactive-memberexpr.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @inferEffectDependencies\nimport { useEffect } from \"react\";\nimport { print } from \"shared-runtime\";\n\nfunction ReactiveMemberExpr(t0) {\n  const $ = _c(4);\n  const { propVal } = t0;\n  let t1;\n  if ($[0] !== propVal) {\n    t1 = { a: { b: propVal } };\n    $[0] = propVal;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  const obj = t1;\n  let t2;\n  if ($[2] !== obj.a.b) {\n    t2 = () => print(obj.a.b);\n    $[2] = obj.a.b;\n    $[3] = t2;\n  } else {\n    t2 = $[3];\n  }\n  useEffect(t2, [obj.a.b]);\n}\n```\n\n----------------------------------------\n\nTITLE: Using Memoization with useCallback in React (JavaScript)\nDESCRIPTION: This snippet implements a custom hook `useHook` utilizing `useCallback` for memoization. It returns an array consisting of a deeply nested property of the input object. The hook ensures that it only recalculates when the specific property changes, thus optimizing performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useCallback-infer-more-specific.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees\n\nimport {useCallback} from 'react';\n\n// More specific memoization always results in fewer memo block\n// executions.\n// Precisely:\n//  x_new != x_prev does NOT imply x.y.z_new != x.y.z_prev\n//  x.y.z_new != x.y.z_prev does imply x_new != x_prev\nfunction useHook(x) {\n  return useCallback(() => [x.y.z], [x]);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useHook,\n  params: [{y: {z: 2}}],\n};\n```\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @validatePreserveExistingMemoizationGuarantees\n\nimport { useCallback } from \"react\";\n\n// More specific memoization always results in fewer memo block\n// executions.\n// Precisely:\n//  x_new != x_prev does NOT imply x.y.z_new != x.y.z_prev\n//  x.y.z_new != x.y.z_prev does imply x_new != x_prev\nfunction useHook(x) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== x.y.z) {\n    t0 = () => [x.y.z];\n    $[0] = x.y.z;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useHook,\n  params: [{ y: { z: 2 } }],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: The compiled version of the component that includes React's compiler runtime memoization logic to optimize re-renders and state management. Uses an array to cache previous values and implement value comparison.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/update-expression-in-sequence.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(5);\n  let a = props.x;\n  let b;\n  let c;\n  let d;\n  if (props.cond) {\n    d = ((b = a), a++, (c = a), ++a);\n  }\n  let t0;\n  if ($[0] !== a || $[1] !== b || $[2] !== c || $[3] !== d) {\n    t0 = [a, b, c, d];\n    $[0] = a;\n    $[1] = b;\n    $[2] = c;\n    $[3] = d;\n    $[4] = t0;\n  } else {\n    t0 = $[4];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ x: 2, cond: true }],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Optimization\nDESCRIPTION: Compiled version of the component showing both optimized and unoptimized paths, using React.forwardRef and implementing caching logic for optimized rendering based on the Forget feature flag.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/component-syntax-ref-gating.flow.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { isForgetEnabled_Fixtures } from \"ReactForgetFeatureFlag\";\nimport { Stringify } from \"shared-runtime\";\nimport * as React from \"react\";\n\nconst Foo = React.forwardRef(Foo_withRef);\nconst isForgetEnabled_Fixtures_result = isForgetEnabled_Fixtures();\nfunction Foo_withRef_optimized(_$$empty_props_placeholder$$, ref) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== ref) {\n    t0 = <Stringify ref={ref} />;\n    $[0] = ref;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\nfunction Foo_withRef_unoptimized(\n  _$$empty_props_placeholder$$: $ReadOnly<{}>,\n  ref: React.RefSetter<Controls>,\n): React.Node {\n  return <Stringify ref={ref} />;\n}\nfunction Foo_withRef(arg0, arg1) {\n  if (isForgetEnabled_Fixtures_result) return Foo_withRef_optimized(arg0, arg1);\n  else return Foo_withRef_unoptimized(arg0, arg1);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: eval(\"(...args) => React.createElement(Foo, args)\"),\n  params: [{ ref: React.createRef() }],\n};\n```\n\n----------------------------------------\n\nTITLE: Error Handling in Component Function - JavaScript\nDESCRIPTION: This snippet defines a React component function that processes input properties, pushes one of the properties to an array, and uses a shared runtime function 'throwInput' to manage exceptions. It captures errors and outputs an error array when exceptions occur.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/try-catch-try-value-modified-in-catch.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enablePropagateDepsInHIR\nconst {throwInput} = require('shared-runtime');\n\nfunction Component(props) {\n  try {\n    const y = [];\n    y.push(props.y);\n    throwInput(y);\n  } catch (e) {\n    e.push(props.e);\n    return e;\n  }\n  return null;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{y: 'foo', e: 'bar'}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Component with useMemo\nDESCRIPTION: This code defines a React component that utilizes `useMemo` for memoization. It takes `propA` and `propB` as props. Inside `useMemo`, it conditionally returns an object with a `value` property based on the presence of `propA?.a`. If `propA?.a` exists, it also calls `mutate(x)` on an empty object.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.useMemo-infer-less-specific-conditional-access.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees\nimport {useMemo} from 'react';\nimport {mutate} from 'shared-runtime';\n\nfunction Component({propA, propB}) {\n  return useMemo(() => {\n    const x = {};\n    if (propA?.a) {\n      mutate(x);\n      return {\n        value: propB.x.y,\n      };\n    }\n  }, [propA?.a, propB.x.y]);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with FBT Optimization\nDESCRIPTION: The compiled output of the FBT component after React's compiler transformation. It shows how the compiler optimizes rendering by memoizing translations based on prop changes using an internal state array (_c) to avoid unnecessary rerenders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-preserve-jsxtext.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport fbt from \"fbt\";\n\nfunction Foo(props) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== props.value) {\n    t0 = fbt._(\n      { \"0\": \"hello {value},\", \"1\": \"goodbye {value},\" },\n      [\n        fbt._enum(props.value ? \"0\" : \"1\", { \"0\": \"hello\", \"1\": \"goodbye\" }),\n        fbt._param(\n          \"value\",\n\n          props.value,\n        ),\n      ],\n      { hk: \"Ri5kJ\" },\n    );\n    $[0] = props.value;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{ value: 1 }],\n  sequentialRenders: [{ value: 1 }, { value: 0 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component\nDESCRIPTION: This is the compiled version of the `Foo` component, leveraging the `react/compiler-runtime` for optimization. It uses the `_c` function for memoization of intermediate values based on prop changes. It checks if `props.a` has changed and only re-calculates `bar(props.a)` if necessary.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-member-expression.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Foo(props) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== props.a) {\n    t0 = bar(props.a);\n    $[0] = props.a;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const x = t0;\n  const y = x?.b;\n\n  const z = useBar(y);\n  return z;\n}\n```\n\n----------------------------------------\n\nTITLE: React Compiler Error: Cannot Preserve Memoization\nDESCRIPTION: The error message produced by the React Compiler when it detects a mismatch between inferred dependencies and manually specified dependencies in a useMemo call, which could lead to unexpected behavior in component rendering.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.maybe-invalid-useMemo-read-maybeRef.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n  3 |\n  4 | function useHook(maybeRef, shouldRead) {\n> 5 |   return useMemo(() => {\n    |                  ^^^^^^^\n> 6 |     return () => [maybeRef.current];\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 7 |   }, [shouldRead, maybeRef]);\n    | ^^^^ CannotPreserveMemoization: React Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. The inferred dependencies did not match the manually specified dependencies, which could cause the value to change more or less frequently than expected (5:7)\n  8 | }\n  9 |\n\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component using Compiler-Runtime in JavaScript\nDESCRIPTION: This snippet shows an optimized version of the Component using React's compiler-runtime. It implements memoization to avoid unnecessary re-computations and improve performance. The component logic remains the same, but with added caching mechanisms.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-object-pattern-within-rest.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(6);\n  let t0;\n  let y;\n  if ($[0] !== props.value) {\n    [y, ...t0] = props.value;\n    $[0] = props.value;\n    $[1] = t0;\n    $[2] = y;\n  } else {\n    t0 = $[1];\n    y = $[2];\n  }\n  const { z } = t0;\n  let t1;\n  if ($[3] !== y || $[4] !== z) {\n    t1 = [y, z];\n    $[3] = y;\n    $[4] = z;\n    $[5] = t1;\n  } else {\n    t1 = $[5];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ value: [\"y\", { z: \"z!\" }] }],\n};\n```\n\n----------------------------------------\n\nTITLE: React Hook inside Loop (Valid - Simplified)\nDESCRIPTION: This JavaScript snippet demonstrates a simplified version of using `React.useLayoutEffect` inside a `for` loop.  The loop runs a fixed number of times, guaranteeing that the same hook is called during each render.  The `_temp` function is used as a placeholder for the effect.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-93dc5d5e538a.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// Valid because the loop doesn't change the order of hooks calls.\nfunction RegressionTest() {\n  const res = [];\n  for (let i = 0; i !== 10 && true; ++i) {\n    res.push(i);\n  }\n\n  React.useLayoutEffect(_temp);\n}\nfunction _temp() {}\n\n```\n\n----------------------------------------\n\nTITLE: Optimized Property Access in React Component with Compiler Caching\nDESCRIPTION: This enhanced version of the 'useFoo' function uses a React compiler runtime for caching to minimize redundant calculations. It checks for changes in nested properties and updates accordingly, leveraging optional chaining for safety.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/infer-sequential-optional-chain-nonnull.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enablePropagateDepsInHIR\n\nfunction useFoo(t0) {\n  const $ = _c(2);\n  const { a } = t0;\n  let x;\n  if ($[0] !== a.b.c.d.e) {\n    x = [];\n    x.push(a?.b.c?.d.e);\n    x.push(a.b?.c.d?.e);\n    $[0] = a.b.c.d.e;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ a: null }],\n  sequentialRenders: [\n    { a: null },\n    { a: null },\n    { a: {} },\n    { a: { b: { c: { d: { e: 42 } } } } },\n    { a: { b: { c: { d: { e: 43 } } } } },\n    { a: { b: { c: { d: { e: undefined } } } } },\n    { a: { b: undefined } },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Computed Property Key\nDESCRIPTION: A React component that creates an object with a computed property key using mutateAndReturn function. The component takes props, creates an empty object as a key, and then uses mutateAndReturn on that key as a computed property name in a context object.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-object-expression-computed-key-mutate-key-while-constructing-object.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {identity, mutate, mutateAndReturn} from 'shared-runtime';\n\nfunction Component(props) {\n  const key = {};\n  const context = {\n    [mutateAndReturn(key)]: identity([props.value]),\n  };\n  return context;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: 42}],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: A React component that renders a button with a deeplink ID. Takes props containing 'wat' path and 'itemID', with a nested function that creates an unused pathname variable.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-hoisting.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const wat = () => {\n    const pathname = 'wat';\n    pathname;\n  };\n\n  const pathname = props.wat;\n  const deeplinkItemId = pathname ? props.itemID : null;\n\n  return <button onClick={() => wat()}>{deeplinkItemId}</button>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{wat: '/dev/null', itemID: 42}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: Compiled version of the React component with added memoization optimization. Uses Symbol.for to implement caching mechanism for the ref access function.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/return-ref-callback.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\n\nimport { useRef } from \"react\";\n\nfunction Foo() {\n  const $ = _c(1);\n  const ref = useRef();\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = () => ref.current;\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const s = t0;\n  return s;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component Definition\nDESCRIPTION: This code defines a simple React component called `Component` that uses the `useCustomHook` with the string \"hello\".  It returns a `div` element containing the text \"Hello\". This component demonstrates how to use the custom hook within a functional component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/import-as-local.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component() {\n  useCustomHook('hello');\n  return <div>Hello</div>;\n}\n```\n\n----------------------------------------\n\nTITLE: ESLint Immutability Violation in React Component\nDESCRIPTION: This ESLint error indicates an attempt to mutate a variable that React considers immutable. Specifically, it flags the line where `renderIcon.displayName` is being assigned. This is a common issue when trying to set properties on function components in a way that React's reconciliation process might not expect.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.mutate-function-property.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n  1 | export function ViewModeSelector(props) {\n  2 |   const renderIcon = () => <AcceptIcon />;\n> 3 |   renderIcon.displayName = 'AcceptIcon';\n    |   ^^^^^^^^^^ InvalidReact: This mutates a variable that React considers immutable (3:3)\n  4 |\n  5 |   return <Dropdown checkableIndicator={{children: renderIcon}} />;\n  6 | }\n```\n\n----------------------------------------\n\nTITLE: React Component with Update Error\nDESCRIPTION: This React component initializes two arrays, x and y, where y is initially a reference to x. Based on the value of props.p1, x may be re-initialized. After rendering a component using x in JSX, it attempts to push a value into y. Since y might be an alias of the potentially frozen x due to its usage in JSX, this mutation throws an error.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-mutate-after-aliased-freeze.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let x = [];\n  let y = x;\n\n  if (props.p1) {\n    x = [];\n  }\n\n  let _ = <Component x={x} />;\n\n  // y is MaybeFrozen at this point, since it may alias to x\n  // (which is the above line freezes)\n  y.push(props.p2);\n\n  return <Component x={x} y={y} />;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Build Error for Computed Property Name\nDESCRIPTION: Error output showing the build failure when using a computed property name with a function call in an object literal. The error indicates the build system expected an Identifier but found a CallExpression in the object's key.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-object-expression-member-expr-call.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n   5 |   const key = {};\n   6 |   const context = {\n>  7 |     [obj.mutateAndReturn(key)]: identity([props.value]),\n     |      ^^^^^^^^^^^^^^^^^^^^^^^^ Todo: (BuildHIR::lowerExpression) Expected Identifier, got CallExpression key in ObjectExpression (7:7)\n   8 |   };\n   9 |   mutate(key);\n  10 |   return context;\n```\n\n----------------------------------------\n\nTITLE: Defining React Components with Forget Optimization\nDESCRIPTION: This snippet defines two React components (Component and Component2) with conditional implementations based on the Forget feature flag. It uses the isForgetEnabled_Fixtures() function to determine which implementation to use. The optimized version uses the _c function from react/compiler-runtime.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/gating-preserves-function-properties.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { isForgetEnabled_Fixtures } from \"ReactForgetFeatureFlag\"; // @gating\nconst Component = isForgetEnabled_Fixtures()\n  ? function Component() {\n      const $ = _c(1);\n      let t0;\n      if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n        t0 = <></>;\n        $[0] = t0;\n      } else {\n        t0 = $[0];\n      }\n      return t0;\n    }\n  : function Component() {\n      return <></>;\n    };\nexport default Component;\n\nexport const Component2 = isForgetEnabled_Fixtures()\n  ? function Component2() {\n      const $ = _c(1);\n      let t0;\n      if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n        t0 = <></>;\n        $[0] = t0;\n      } else {\n        t0 = $[0];\n      }\n      return t0;\n    }\n  : function Component2() {\n      return <></>;\n    };\n\nComponent.displayName = \"Component ONE\";\nComponent2.displayName = \"Component TWO\";\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  sequentialRenders: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized State Management in React Component with JavaScript\nDESCRIPTION: Optimizes a React component function `Component` using `react/compiler-runtime` and shared runtime. Utilizes caching strategies to reduce redundant computations and manages state mutations efficiently. It adjusts state depending on input object and is structured to efficiently handle repeated renders. Inputs are parameter objects; outputs are state representations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-alias-receiver-computed-mutate.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { mutate } from \"shared-runtime\";\n\nfunction Component(t0) {\n  const $ = _c(2);\n  const { a } = t0;\n  let y;\n  if ($[0] !== a) {\n    const x = { a };\n    y = {};\n    const f0 = function () {\n      const a_0 = y;\n      a_0.x = x;\n    };\n\n    f0();\n    mutate(y);\n    $[0] = a;\n    $[1] = y;\n  } else {\n    y = $[1];\n  }\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ a: 2 }],\n  sequentialRenders: [{ a: 2 }, { a: 2 }, { a: 3 }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic React Component - JavaScript\nDESCRIPTION: This snippet defines a simple React component that returns an array of objects based on the condition provided through props. It initializes two objects and modifies one based on the provided props. The functionality relies on the condition being evaluated to either create a default object or extend an object with properties. It does not have external dependencies other than React itself. Expected output is an array containing two objects, under various conditional scenarios.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/phi-type-inference-property-store.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @debug @enablePropagateDepsInHIR\nfunction Component(props) {\n  const x = {};\n  let y;\n  if (props.cond) {\n    y = {};\n  } else {\n    y = {a: props.a};\n  }\n  // This should be inferred as `<store> y` s.t. `x` can still\n  // be independently memoized. *But* this also must properly\n  // extend the mutable range of the object literals in the\n  // if/else branches\ny.x = x;\n\n  return [x, y];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{cond: false, a: 'a!'}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Error Analysis for Incremented Render Count - JavaScript\nDESCRIPTION: This error message indicates an unsupported update expression for a global variable 'renderCount' within a React function component. The error highlights the code location and suggests that global variable updates must be managed safely, potentially with state management solutions.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.mutate-global-increment-op-invalid-react.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n  2 |\n  3 | function NoHooks() {\n> 4 |   renderCount++;\n    |   ^^^^^^^^^^^^^ Todo: (BuildHIR::lowerExpression) Support UpdateExpression where argument is a global (4:4)\n  5 |   return <div />;\n  6 | }\n  7 |\n\n```\n\n----------------------------------------\n\nTITLE: React Component with Switch Statement\nDESCRIPTION: This React component takes props and uses a switch statement based on `props.p0` to manipulate an array `x`.  It conditionally pushes `props.p2` and `props.p3` into `x`. The component then renders a child component with modified array. It returns another component with `child` as children.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/switch.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let x = [];\n  let y;\n  switch (props.p0) {\n    case true: {\n      x.push(props.p2);\n      x.push(props.p3);\n      y = [];\n    }\n    case false: {\n      y = x;\n      break;\n    }\n  }\n  const child = <Component data={x} />;\n  y.push(props.p4);\n  return <Component data={y}>{child}</Component>;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining React Component Function with Closure\nDESCRIPTION: This snippet defines a React component function 'f' that creates a closure to set a variable 'x' and returns a div element. It also exports a FIXTURE_ENTRYPOINT object for testing purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/lambda-mutated-non-reactive-to-reactive.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction f(a) {\n  let x;\n  (() => {\n    x = {a};\n  })();\n  return <div x={x} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: f,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with useFire Hook\nDESCRIPTION: This snippet shows a React component that utilizes the `useFire` hook and `_c` from `react/compiler-runtime` to optimize the execution of the `foo` function within a `useEffect` hook.  `useFire` memoizes the function, and `_c` is used for conditional updates to reduce unnecessary re-renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/multiple-scope.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c, useFire } from \"react/compiler-runtime\"; // @enableFire\nimport { fire } from \"react\";\n\nfunction Component(props) {\n  const $ = _c(3);\n  const foo = _temp;\n  const t0 = useFire(foo);\n  let t1;\n  if ($[0] !== props || $[1] !== t0) {\n    t1 = () => {\n      t0(props);\n      const nested = function nested() {\n        t0(props);\n      };\n\n      nested();\n    };\n    $[0] = props;\n    $[1] = t0;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  useEffect(t1);\n  return null;\n}\nfunction _temp(props_0) {\n  console.log(props_0);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Modified Component Function in JavaScript\nDESCRIPTION: An alternative JavaScript snippet for the Component function that uses a const declaration to define the local object. It still relies on an external function, mutate, to manipulate the object. The function takes a single parameter, c, and doesn't return any value.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/issue852.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(c) {\n  const x = { c };\n  mutate(x);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Advanced React Component Export with Memoization\nDESCRIPTION: In this JavaScript snippet, a React component is defined using an imported compiler runtime function '_c'. It checks if memoization is necessary, reuses existing values or initializes them, and returns the values. It exports the component configuration for external use, with parameters and component identity included. This setup facilitates advanced rendering logic within React applications.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-arrayexpression.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = [1, 2];\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const x = t0;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Input React Component with useCallback\nDESCRIPTION: Original React component code showing usage of useCallback and useRef hooks. Defines a Foo component that uses ref access in a callback, and a simple A component that renders a div.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useCallback-ref-in-render.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @flow @validateRefAccessDuringRender @validatePreserveExistingMemoizationGuarantees\nimport {useCallback, useRef} from 'react';\n\ncomponent Foo() {\n  const ref = useRef();\n\n  const s = useCallback(() => {\n    return ref.current;\n  });\n\n  return <A r={s} />;\n}\n\ncomponent A(r: mixed) {\n  return <div />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Transformed Hoisting Example using React Compiler\nDESCRIPTION: This code snippet represents the transformed code after being processed by the React compiler. It shows how the compiler optimizes the code, potentially caching values and using temporary variables to improve performance. The code leverages `react/compiler-runtime` to manage the component's lifecycle and state.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-object-method.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction hoisting() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const x = {\n      foo() {\n        return bar();\n      },\n    };\n\n    const bar = _temp;\n\n    t0 = x.foo();\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\nfunction _temp() {\n  return 1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: hoisting,\n  params: [],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Optional Chaining with React Hooks in JavaScript\nDESCRIPTION: This function, 'useFoo', processes an input object with a 'screen' property. It returns a specific string based on whether 'screen.title_text' is non-null, utilizing optional chaining. Key dependencies include the 'identity' function from 'shared-runtime'. Inputs include a 'screen' object that may be null or contain a 'title_text' property. The expected behavior is to return '(not null)' for non-null 'title_text', otherwise it returns an identity function result. The function may throw if 'screen' is null.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/merge-uncond-optional-chain-and-cond.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {identity} from 'shared-runtime';\n\n/**\n * Very contrived text fixture showing that it's technically incorrect to merge\n * a conditional dependency (e.g. dep.path in `cond ? dep.path : ...`) and an\n * unconditionally evaluated optional chain (`dep?.path`).\n *\n *\n * when screen is non-null, useFoo returns { title: null } or \"(not null)\"\n * when screen is null, useFoo throws\n */\nfunction useFoo({screen}: {screen: null | undefined | {title_text: null}}) {\n  return screen?.title_text != null\n    ? '(not null)'\n    : identity({title: screen.title_text});\n}\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{screen: null}],\n  sequentialRenders: [{screen: {title_bar: undefined}}, {screen: null}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Functional Component in React - JavaScript\nDESCRIPTION: This snippet defines a simple functional component named Foo using React. It accepts 'props' and renders a greeting message along with static content. The snippet does not include any external dependencies and focuses purely on React's JSX syntax.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-fragment.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Foo(props) {\n  return (\n    <>\n      Hello {props.greeting}{' '}\n      <div>\n        <>Text</>\n      </div>\n    </>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n\n```\n\n----------------------------------------\n\nTITLE: TypeScript Optional Property Error in React Function\nDESCRIPTION: This snippet captures an error related to the handling of optional properties in TypeScript within the `useFoo` function. It highlights how TypeScript's handling of optional chaining can cause unexpected issues, specifically when using optional properties that may fall through.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/error.todo-optional-call-chain-in-optional.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n  2 | function useFoo(props: {value: {x: string; y: string} | null}) {\n  3 |   const value = props.value;\n> 4 |   return createArray(value?.x, value?.y)?.join(', ');\n    |                      ^^^^^^^^ Todo: Unexpected terminal kind `optional` for optional fallthrough block (4:4)\n  5 | }\n  6 |\n  7 | function createArray<T>(...args: Array<T>): Array<T> {\n\n```\n\n----------------------------------------\n\nTITLE: Compiled Output with React Compiler Optimizations\nDESCRIPTION: The compiled version of the hook function after React Compiler transformation. It implements memoization to maintain reference stability of the returned array, ensuring the same array reference is returned if the state hasn't changed.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-functions-hook-with-hook-call.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @compilationMode(infer)\nfunction useStateValue(props) {\n  const $ = _c(2);\n  const [state] = useState(null);\n  let t0;\n  if ($[0] !== state) {\n    t0 = [state];\n    $[0] = state;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n```\n\n----------------------------------------\n\nTITLE: React Compiler Runtime Component with Memoization\nDESCRIPTION: An optimized version of the React component using compiler runtime for efficient state tracking and re-rendering, with conditional rendering and memoization techniques\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-alias-captured-mutate.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { mutate } from \"shared-runtime\";\n\nfunction Component(t0) {\n  const $ = _c(3);\n  const { foo, bar } = t0;\n  let y;\n  if ($[0] !== bar || $[1] !== foo) {\n    const x = { foo };\n    y = { bar };\n    const f0 = function () {\n      const a = [y];\n      const b = x;\n\n      a[0].x = b;\n    };\n\n    f0();\n    mutate(y.x);\n    $[0] = bar;\n    $[1] = foo;\n    $[2] = y;\n  } else {\n    y = $[2];\n  }\n  return y;\n}\n```\n\n----------------------------------------\n\nTITLE: Using Reactive Dependencies in Conditional Scopes - JavaScript\nDESCRIPTION: This snippet defines a function 'useReactiveDepsInCondScope' that handles reactive dependencies within a conditional scope. It utilizes 'CONST_FALSE' and 'identity' from 'shared-runtime' to manage dependencies based on the conditional status of the scope. This implementation creates a new object 'x' and conditionally assigns a temporary variable 'tmp' using an identity function when the condition is met. It is designed to work with predefined constants and objects from the 'shared-runtime'. The function is exported as a part of the FIXTURE_ENTRYPOINT with its parameters defined.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/cond-scope.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {CONST_FALSE, identity} from 'shared-runtime';\\n\\nfunction useReactiveDepsInCondScope(props) {\\n  let x = {};\\n  if (CONST_FALSE) {\\n    let tmp = identity(props.a.b);\\n    x.a = tmp;\\n  }\\n  return x;\\n}\\n\\nexport const FIXTURE_ENTRYPOINT = {\\n  fn: useReactiveDepsInCondScope,\\n  params: [{}],\\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Hoisting Function in JavaScript\nDESCRIPTION: This snippet defines a simple hoisting function that demonstrates variable scoping and returns a computation based on two local variables 'bar' and 'baz'. It utilizes a nested function structure to compute and return the value of 'foo'. The function is initialized correctly outside of the temporal dead zone (TDZ) and allows the variable 'result' to be returned. Dependencies: None.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-nested-const-declaration.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction hoisting() {\n  const qux = () => {\n    let result;\n    {\n      result = foo();\n    }\n    return result;\n  };\n  const foo = () => {\n    return bar + baz;\n  };\n  const bar = 3;\n  const baz = 2;\n  return qux(); // OK: called outside of TDZ\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: hoisting,\n  params: [],\n  isComponent: false,\n};\n\n```\n\n----------------------------------------\n\nTITLE: Function Initialization with Conditional Logic in JavaScript\nDESCRIPTION: This JavaScript snippet demonstrates basic object initialization inside a function, with different objects configured based on the input condition. The function returns an object containing the initialized sub-object. No external dependencies are required, and the function accepts one parameter that determines which sub-object to initialize.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-property-alias-if.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(a) {\n  const x = {};\n  if (a) {\n    let y = {};\n    x.y = y;\n  } else {\n    let z = {};\n    x.z = z;\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Function with Caching\nDESCRIPTION: Transformed version of the function using React compiler runtime utilities to implement caching mechanism for improved performance. Uses _c utility for managing cached values.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/obj-mutated-after-if-else-with-alias.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction foo(a, b, c, d) {\n  const $ = _c(2);\n  someObj();\n  let x;\n  if ($[0] !== a) {\n    if (a) {\n      const y = someObj();\n      const z = y;\n      x = z;\n    } else {\n      x = someObj();\n    }\n\n    x.f = 1;\n    $[0] = a;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Foo Functionality with Direct Return - JavaScript\nDESCRIPTION: This snippet defines a function 'foo' that directly returns the value 2. It simplifies the function's logic by removing the conditional checks from the previous version. The 'FIXTURE_ENTRYPOINT' constant again exports this streamlined version of the function as part of an object, allowing it to be used externally in other modules.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-return.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo() {\n  return 2;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [],\n  isComponent: false,\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Component in React with JavaScript\nDESCRIPTION: This snippet defines a basic React component that uses a switch statement to assign a value to `x` based on a prop condition. It demonstrates handling reactivity by treating `x` as influenced by a reactive prop. The `FIXTURE_ENTRYPOINT` object outlines test scenarios with sequential renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-switch-case-test.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let x;\n  switch (props.cond) {\n    case true: {\n      x = 1;\n      break;\n    }\n    case false: {\n      x = 2;\n      break;\n    }\n    default: {\n      x = 3;\n    }\n  }\n  // The values assigned to `x` are non-reactive, but the value of `x`\n  // depends on the \"control\" value `props.cond` which is reactive.\n  // Therefore x should be treated as reactive too.\n  return [x];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  sequentialRenders: [\n    {cond: true},\n    {cond: true},\n    {cond: false},\n    {cond: false},\n    {cond: true},\n    {cond: false},\n    {cond: true},\n    {cond: false},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining React Component and Fixture Entrypoint in JavaScript\nDESCRIPTION: This snippet defines a React component function that iterates over props.value without performing any operations, and exports a fixture entrypoint for testing. The component takes props as an argument and returns an undefined variable x. The fixture specifies the component function and test parameters.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-in-statement-empty-body.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let x;\n  for (const y in props.value) {\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ value: { a: \"a\", b: \"B\", c: \"C!\" } }],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimizing React Component with Memoization\nDESCRIPTION: This snippet showcases an optimized version of the React component using memoization techniques. It utilizes React's compiler runtime to cache and reuse computed values, improving performance for subsequent renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-of-capture-item-of-local-collection-mutate-later.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { makeObject_Primitives } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(1);\n  let items;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    let lastItem = {};\n    items = [makeObject_Primitives(), makeObject_Primitives()];\n    for (const x of items) {\n      lastItem = x;\n    }\n    if (lastItem != null) {\n      lastItem.a = lastItem.a + 1;\n    }\n    $[0] = items;\n  } else {\n    items = $[0];\n  }\n  return items;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n  sequentialRenders: [{}, {}],\n};\n```\n\n----------------------------------------\n\nTITLE: Alternative React Component with Labeled Break Blocks\nDESCRIPTION: A React functional component using labeled break blocks and explicit variable assignment to achieve similar conditional logic as the previous implementation\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-switch-return.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let t0;\n  bb0: {\n    let y;\n    bb1: switch (props.switch) {\n      case \"foo\": {\n        t0 = \"foo\";\n        break bb0;\n      }\n      case \"bar\": {\n        y = \"bar\";\n        break bb1;\n      }\n      default: {\n        y = props.y;\n      }\n    }\n\n    t0 = y;\n  }\n  const x = t0;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: A React component that manipulates multiple variables through sequence operations based on a conditional prop. Shows the pre-compiled version of the component logic.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/update-expression-in-sequence.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let a = props.x;\n  let b;\n  let c;\n  let d;\n  if (props.cond) {\n    d = ((b = a), a++, (c = a), ++a);\n  }\n  return [a, b, c, d];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{x: 2, cond: true}],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Calculating Factorial using JavaScript in React\nDESCRIPTION: This snippet demonstrates a React functional component that calculates the factorial of a number using a slightly optimized closure for caching results. It utilizes the React 'c' function from the compiler-runtime for optimization. The input is an object containing a numeric value, with the output being the factorial of that value.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-recursive-call.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Foo(t0) {\n  const $ = _c(2);\n  const { value } = t0;\n  let t1;\n  if ($[0] !== value) {\n    const factorial = (x) => {\n      if (x <= 1) {\n        return 1;\n      } else {\n        return x * factorial(x - 1);\n      }\n    };\n\n    t1 = factorial(value);\n    $[0] = value;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{ value: 3 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: The compiled version of the component with React's memoization logic implemented. Uses a sentinel value to check if cached values should be used or recomputed.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-of-capture-item-of-local-collection-mutate-later-value-initially-null.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { makeObject_Primitives } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(1);\n  let items;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    let lastItem = null;\n    items = [makeObject_Primitives(), makeObject_Primitives()];\n    for (const x of items) {\n      lastItem = x;\n    }\n    if (lastItem != null) {\n      lastItem.a = lastItem.a + 1;\n    }\n    $[0] = items;\n  } else {\n    items = $[0];\n  }\n  return items;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n  sequentialRenders: [{}, {}, {}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with useEffect and State Update\nDESCRIPTION: This is the compiled version of the React component. It uses `react/compiler-runtime` and memoization techniques to optimize performance. It defines the state and associated update logic, encapsulating the increment within a separate function `_temp`. The `useEffect` hook is set up to trigger this incrementing logic.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/invalid-setState-in-useEffect-transitive.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @logger @validateNoSetStateInPassiveEffects\nimport { useEffect, useState } from \"react\";\n\nfunction Component() {\n  const $ = _c(2);\n  const [state, setState] = useState(0);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const f = () => {\n      setState(_temp);\n    };\n\n    t0 = () => {\n      f();\n    };\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const g = t0;\n  let t1;\n  if ($[1] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = () => {\n      g();\n    };\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  useEffect(t1);\n  return state;\n}\nfunction _temp(s) {\n  return s + 1;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining Memoized React Component - JavaScript\nDESCRIPTION: This snippet defines a React functional component that incorporates memoization logic using the React compiler runtime. It checks if the component's states are memoized and returns either a new object or the memoized values, optimizing performance by avoiding unnecessary re-renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/globals-String.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = {};\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const x = t0;\n  const y = String(x);\n  let t1;\n  if ($[1] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = [x, y];\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Cache Optimization\nDESCRIPTION: Compiled version of the React component showing cache implementation details. Includes optimization logic for preventing unnecessary recalculations and managing component state.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useMemo-reordering-depslist-controlflow.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useMemo } from \"react\";\nimport { Stringify } from \"shared-runtime\";\n\nfunction Foo(t0) {\n  const $ = _c(9);\n  const { arr1, arr2, foo } = t0;\n  let t1;\n  let val1;\n  if ($[0] !== arr1 || $[1] !== arr2 || $[2] !== foo) {\n    const x = [arr1];\n\n    let y;\n    y = [];\n    let t2;\n    let t3;\n    if ($[5] === Symbol.for(\"react.memo_cache_sentinel\")) {\n      t3 = { x: 2 };\n      $[5] = t3;\n    } else {\n      t3 = $[5];\n    }\n    t2 = t3;\n    val1 = t2;\n\n    foo ? (y = x.concat(arr2)) : y;\n    t1 = (() => [y])();\n    $[0] = arr1;\n    $[1] = arr2;\n    $[2] = foo;\n    $[3] = t1;\n    $[4] = val1;\n  } else {\n    t1 = $[3];\n    val1 = $[4];\n  }\n  const val2 = t1;\n  let t2;\n  if ($[6] !== val1 || $[7] !== val2) {\n    t2 = <Stringify val1={val1} val2={val2} />;\n    $[6] = val1;\n    $[7] = val2;\n    $[8] = t2;\n  } else {\n    t2 = $[8];\n  }\n  return t2;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{ arr1: [1, 2], arr2: [3, 4], foo: true }],\n  sequentialRenders: [\n    { arr1: [1, 2], arr2: [3, 4], foo: true },\n    { arr1: [1, 2], arr2: [3, 4], foo: false },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Component State Mutation with Shared Runtime in JavaScript\nDESCRIPTION: This snippet demonstrates a React component that manipulates an object state using a shared runtime's mutate function. The component takes props and modifies an internal state object, invoking an external mutation function to perform the update.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-simple-alias.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {mutate} from 'shared-runtime';\n\nfunction Component({a}) {\n  let x = {a};\n  let y = {};\n  const f0 = function () {\n    y = x;\n  };\n  f0();\n  mutate(y);\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{a: 2}],\n  sequentialRenders: [{a: 2}, {a: 2}, {a: 3}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: The original component implementation assigns a value to x, then passes a reassignment expression to the function call of x, creating a side effect during function invocation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-reassign-in-rval.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Forget should call the original x (x = foo()) to compute result\nfunction Component() {\n  let x = foo();\n  let result = x((x = bar()), 5);\n  return [result, x];\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Hook Usage in React Component\nDESCRIPTION: Demonstrates incorrect usage of a React Hook by assigning it to a variable in a conditional expression. This violates the Rules of Hooks by treating a hook as a normal value rather than calling it directly.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-call-phi-possibly-hook.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  // This is a violation of using a hook as a normal value rule:\n  const getUser = props.cond ? useGetUser : emptyFunction;\n\n  // Ideally we would report a \"conditional hook call\" error here.\n  // It's an unconditional call, but the value may or may not be a hook.\n  // TODO: report a conditional hook call error here\n  return getUser();\n}\n```\n\nLANGUAGE: text\nCODE:\n```\n  1 | function Component(props) {\n  2 |   // This is a violation of using a hook as a normal value rule:\n> 3 |   const getUser = props.cond ? useGetUser : emptyFunction;\n    |                                ^^^^^^^^^^ InvalidReact: Hooks may not be referenced as normal values, they must be called. See https://react.dev/reference/rules/react-calls-components-and-hooks#never-pass-around-hooks-as-regular-values (3:3)\n\nInvalidReact: Hooks may not be referenced as normal values, they must be called. See https://react.dev/reference/rules/react-calls-components-and-hooks#never-pass-around-hooks-as-regular-values (3:3)\n\nInvalidReact: Hooks may not be referenced as normal values, they must be called. See https://react.dev/reference/rules/react-calls-components-and-hooks#never-pass-around-hooks-as-regular-values (8:8)\n  4 |\n  5 |   // Ideally we would report a \"conditional hook call\" error here.\n  6 |   // It's an unconditional call, but the value may or may not be a hook.\n```\n\n----------------------------------------\n\nTITLE: Defining a Function with Hoisting in JavaScript\nDESCRIPTION: This snippet defines a function `hoisting` that demonstrates variable hoisting in JavaScript. The function defines a closure `foo` that references `bar` and `baz` before they are declared. This code shows how hoisting works in JS and affects the function's behavior.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-simple-let-declaration.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction hoisting() {\n  let foo = () => {\n    return bar + baz;\n  };\n  let bar = 3;\n  let baz = 2;\n  return foo(); // OK: called outside of TDZ for bar/baz\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: hoisting,\n  params: [],\n  isComponent: false,\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining a React Hook with Conditional Dependencies\nDESCRIPTION: This code defines a React hook `useJoinCondDepsInUncondScopes` that conditionally sets properties of objects `x` and `y` based on the value of `props.a.b`. The purpose is to test how React Forget handles conditional dependencies in inner scopes and whether it propagates them correctly to parent scopes. The hook takes `props` as input, where `props.a.b` is expected to be a value used in the conditional logic and property setting.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/join-uncond-scopes-cond-deps.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// This tests an optimization, NOT a correctness property.\n// When propagating reactive dependencies of an inner scope up to its parent,\n// we prefer to retain granularity.\n//\n// In this test, we check that Forget propagates the inner scope's conditional\n// dependencies (e.g. props.a.b) instead of only its derived minimal\n// unconditional dependencies (e.g. props).\n// ```javascript\n//  scope @0 (deps=[???] decls=[x, y]) {\n//    let y = {};\n//    scope @1 (deps=[props] decls=[x]) {\n//      let x = {};\n//      if (foo) mutate1(x, props.a.b);\n//    }\n//    mutate2(y, props.a.b);\n//  }\n\nimport {CONST_TRUE, setProperty} from 'shared-runtime';\n\nfunction useJoinCondDepsInUncondScopes(props) {\n  let y = {};\n  let x = {};\n  if (CONST_TRUE) {\n    setProperty(x, props.a.b);\n  }\n  setProperty(y, props.a.b);\n  return [x, y];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useJoinCondDepsInUncondScopes,\n  params: [{a: {b: 3}}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Component with Caching Logic in React - JavaScript\nDESCRIPTION: This code snippet illustrates a React component that uses caching for optimizing the rendering logic. It imports a cache management function from 'react/compiler-runtime' to store and check previous values of items' edges and length, determining if updates are necessary. The cached values help avoid redundant computations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/memberexpr-join-optional-chain2.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(5);\n  let x;\n  if ($[0] !== props.items?.edges || $[1] !== props.items?.length) {\n    x = [];\n    x.push(props.items?.length);\n    let t0;\n    if ($[3] !== props.items?.edges) {\n      t0 = props.items?.edges?.map?.(render)?.filter?.(Boolean) ?? [];\n      $[3] = props.items?.edges;\n      $[4] = t0;\n    } else {\n      t0 = $[4];\n    }\n    x.push(t0);\n    $[0] = props.items?.edges;\n    $[1] = props.items?.length;\n    $[2] = x;\n  } else {\n    x = $[2];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ items: { edges: null, length: 0 } }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: Basic React component that processes props.items, creating an array with length and filtered edge mappings. Uses optional chaining for null safety.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/memberexpr-join-optional-chain2.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enablePropagateDepsInHIR\nfunction Component(props) {\n  const x = [];\n  x.push(props.items?.length);\n  x.push(props.items?.edges?.map?.(render)?.filter?.(Boolean) ?? []);\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{items: {edges: null, length: 0}}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Subpath Dependency\nDESCRIPTION: This code defines a React component, `TestOverlappingDescendantTracked`, that accesses a nested property (`props.a.b.c`) and its descendant (`props.a.b.c.x.y`). It then creates an object with references to both these properties as well as `props.a`.  The component illustrates a scenario where careful dependency tracking is required, specifically when overlapping descendants are involved.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/uncond-overlap-descendant.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Test that we correctly track a subpath if the subpath itself is accessed as\n// a dependency\nfunction TestOverlappingDescendantTracked(props) {\n  let x = {};\n  x.b = props.a.b.c;\n  x.c = props.a.b.c.x.y;\n  x.a = props.a;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: TestOverlappingDescendantTracked,\n  params: [{a: {b: {c: {x: {y: 5}}}}}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Loop and Conditional Logic\nDESCRIPTION: This snippet defines a React component that initializes an array, performs a do-while loop with conditional logic, and mutates the array based on a prop condition.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/do-while-conditional-break.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let x = [0, 1, 2, 3];\n  do {\n    if (x === 0) {\n      break;\n    }\n    mutate(x);\n  } while (props.cond);\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Basic React Hook using Shared Runtime\nDESCRIPTION: This snippet defines a simple React hook, 'useFoo', that imports from 'shared-runtime'. It creates a text element using the value '4' and returns it. No additional parameters are utilized, making it a straightforward implementation of a functional component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-local-memberexpr-tag.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as SharedRuntime from 'shared-runtime';\nfunction useFoo() {\n  const MyLocal = SharedRuntime;\n  return <MyLocal.Text value={4} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Using Fire Function with React Component\nDESCRIPTION: This snippet demonstrates a React functional component that imports and uses a method named fire from the react library. Within the component, it declares a function foo to log incoming props and attempts to call fire within a useEffect hook. It highlights an error due to incorrect arguments being passed to fire, which only accepts a single call expression.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/error.invalid-multiple-args.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableFire\nimport {fire} from 'react';\n\nfunction Component({bar, baz}) {\n  const foo = () => {\n    console.log(bar, baz);\n  };\n  useEffect(() => {\n    fire(foo(bar), baz);\n  });\n\n  return null;\n}\n\n```\n\n----------------------------------------\n\nTITLE: React Component with useMemo Hook\nDESCRIPTION: This React component takes props as input and uses the `useMemo` hook to conditionally compute and memoize a value `x` based on the `a` and `b` properties of the props.  It returns the computed value. The component utilizes React's `useMemo` hook for performance optimization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-logical.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const x = useMemo(() => props.a && props.b);\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n\n```\n\n----------------------------------------\n\nTITLE: Ensuring Memoization in useFoo with Symbol Comparison\nDESCRIPTION: Illustrates a React hook function 'useFoo' that employs a Symbol comparison to determine the memoization cache sentinel. It uses the _c function for memoization management, along with useRef and useCallback. The snippet also exports 'useFoo' in FIXTURE_ENTRYPOINT, requiring React for execution.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/preserve-use-memo-ref-missing-ok.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @validatePreserveExistingMemoizationGuarantees\nimport { useCallback, useRef } from \"react\";\n\nfunction useFoo() {\n  const $ = _c(1);\n  const ref = useRef();\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = () => {\n      if (ref != null) {\n        ref.current();\n      }\n    };\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component using Compiler Runtime\nDESCRIPTION: This is the compiled version of the React component using React's compiler runtime. It uses a caching mechanism for memoization and preserves the scoping behavior of the original component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/lambda-reassign-shadowed-primitive.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = {};\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const x = t0;\n\n  let x_0;\n  x_0 = 56;\n  const fn = function () {\n    x_0 = 42;\n  };\n\n  fn();\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component\nDESCRIPTION: This is the transformed React component after compilation. It uses the `_c` function from `react/compiler-runtime` for memoization. The transformed component checks if the props.value has changed and updates the cached values accordingly, optimizing re-renders. The function returns an array containing the cached values.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/temporary-property-load-accessed-outside-scope.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(6);\n  let t0;\n  let t1;\n  if ($[0] !== props.value) {\n    const maybeMutable = new MaybeMutable();\n    const x = props.value;\n    t0 = x;\n    t1 = maybeMutate(maybeMutable);\n    $[0] = props.value;\n    $[1] = t0;\n    $[2] = t1;\n  } else {\n    t0 = $[1];\n    t1 = $[2];\n  }\n  let t2;\n  if ($[3] !== t0 || $[4] !== t1) {\n    t2 = [t0, t1];\n    $[3] = t0;\n    $[4] = t1;\n    $[5] = t2;\n  } else {\n    t2 = $[5];\n  }\n  return t2;\n}\n```\n\n----------------------------------------\n\nTITLE: Initial Input Component with Mutation\nDESCRIPTION: JavaScript component that creates an object with dynamic property assignment and uses the mutate function from shared runtime to modify state\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-alias-computed-mutate.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {mutate} from 'shared-runtime';\nfunction Component({a}) {\n  let x = {a};\n  let y = {};\n  const f0 = function () {\n    y['x'] = x;\n  };\n  f0();\n  mutate(y);\n  return y;\n}\n```\n\n----------------------------------------\n\nTITLE: Optimized JavaScript Function 'foo' with React Compiler\nDESCRIPTION: This snippet shows the optimized 'foo' function, transformed by the React Compiler Runtime. It utilizes the `_c` function for memoization. The function checks if the input parameters have changed since the last execution. If they haven't, it returns the cached result; otherwise, it executes the function logic, caches the result, and returns it. The `FIXTURE_ENTRYPOINT` remains the same, pointing to this optimized `foo`.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inverted-if.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction foo(a, b, c, d) {\n  const $ = _c(5);\n  let y;\n  if ($[0] !== a || $[1] !== b || $[2] !== c || $[3] !== d) {\n    y = [];\n    bb0: if (a) {\n      if (b) {\n        y.push(c);\n        break bb0;\n      }\n\n      y.push(d);\n    }\n    $[0] = a;\n    $[1] = b;\n    $[2] = c;\n    $[3] = d;\n    $[4] = y;\n  } else {\n    y = $[4];\n  }\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Hook Implementation\nDESCRIPTION: A React hook that creates a Map containing arrays from two input elements. Returns the size of the Map. Uses shared runtime utility makeArray.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/global-types/map-constructor.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {makeArray} from 'shared-runtime';\n\nfunction useHook({el1, el2}) {\n  const s = new Map();\n  s.set(el1, makeArray(el1));\n  s.set(el2, makeArray(el2));\n  return s.size;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useHook,\n  params: [{el1: 1, el2: 'foo'}],\n  sequentialRenders: [\n    {el1: 1, el2: 'foo'},\n    {el1: 2, el2: 'foo'},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimizing a React Component using Compiler Runtime in JavaScript\nDESCRIPTION: This snippet showcases an optimized version of the React component that utilizes the compiler runtime for performance enhancements. It checks prop changes to conditionally render the component, thereby minimizing unnecessary re-renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-empty-expression.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nexport function Component(props) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== props.a) {\n    t0 = <div>{props.a}</div>;\n    $[0] = props.a;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ a: \"hello\" }],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with ESLint Rule Disabling (JavaScript)\nDESCRIPTION: This code defines a React component (`lowercasecomponent`) that disables a custom ESLint rule (`my-app/react-rule`) using `eslint-disable` and `eslint-disable-next-line`. The purpose is to demonstrate how disabling such rules can prevent React Compiler from optimizing the component. The component returns a simple `div` containing a variable `x`.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.bailout-on-suppression-of-custom-rule.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @eslintSuppressionRules(my-app/react-rule)\n\n/* eslint-disable my-app/react-rule */\nfunction lowercasecomponent() {\n  'use forget';\n  const x = [];\n  // eslint-disable-next-line my-app/react-rule\n  return <div>{x}</div>;\n}\n/* eslint-enable my-app/react-rule */\n```\n\n----------------------------------------\n\nTITLE: Original React Component with Array Processing\nDESCRIPTION: A React component that creates an array of iterators and arrays, transforms them using Object.fromEntries, and displays specific entries. The component accepts a value prop that gets incorporated into the array data.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/global-types/repro-array-map-known-mutate-shape.expect.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {Stringify, useIdentity} from 'shared-runtime';\n\n/**\n * Also see repro-array-map-known-nonmutate-Boolean, which calls a global\n * function that does *not* mutate its operands.\n */\nfunction Component({value}) {\n  const arr = [\n    new Set([['foo', 2]]).values(),\n    new Set([['bar', 4]]).values(),\n    [['baz', value]],\n  ];\n  useIdentity(null);\n  const derived = arr.map(Object.fromEntries);\n  return (\n    <Stringify>\n      {derived.at(0)}\n      {derived.at(-1)}\n    </Stringify>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: 5}],\n  sequentialRenders: [{value: 5}, {value: 6}, {value: 6}],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with Memoization - Compiled Code\nDESCRIPTION: Compiled version of the React component showing the internal implementation of memoization using compiler runtime helpers. Includes caching logic and optimized rendering.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-provider-log-default-import.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useMemo } from \"react\";\nimport { ValidateMemoization } from \"shared-runtime\";\nimport typedLog from \"shared-runtime\";\n\nexport function Component(t0) {\n  const $ = _c(17);\n  const { a, b } = t0;\n  let t1;\n  let t2;\n  if ($[0] !== a) {\n    t2 = { a };\n    $[0] = a;\n    $[1] = t2;\n  } else {\n    t2 = $[1];\n  }\n  t1 = t2;\n  const item1 = t1;\n  let t3;\n  let t4;\n  if ($[2] !== b) {\n    t4 = { b };\n    $[2] = b;\n    $[3] = t4;\n  } else {\n    t4 = $[3];\n  }\n  t3 = t4;\n  const item2 = t3;\n  typedLog(item1, item2);\n  let t5;\n  if ($[4] !== a) {\n    t5 = [a];\n    $[4] = a;\n    $[5] = t5;\n  } else {\n    t5 = $[5];\n  }\n  let t6;\n  if ($[6] !== item1 || $[7] !== t5) {\n    t6 = <ValidateMemoization inputs={t5} output={item1} />;\n    $[6] = item1;\n    $[7] = t5;\n    $[8] = t6;\n  } else {\n    t6 = $[8];\n  }\n  let t7;\n  if ($[9] !== b) {\n    t7 = [b];\n    $[9] = b;\n    $[10] = t7;\n  } else {\n    t7 = $[10];\n  }\n  let t8;\n  if ($[11] !== item2 || $[12] !== t7) {\n    t8 = <ValidateMemoization inputs={t7} output={item2} />;\n    $[11] = item2;\n    $[12] = t7;\n    $[13] = t8;\n  } else {\n    t8 = $[13];\n  }\n  let t9;\n  if ($[14] !== t6 || $[15] !== t8) {\n    t9 = (\n      <>\n        {t6}\n        {t8}\n      </>\n    );\n    $[14] = t6;\n    $[15] = t8;\n    $[16] = t9;\n  } else {\n    t9 = $[16];\n  }\n  return t9;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Recursive Function with IIFE in JavaScript\nDESCRIPTION: This implementation of 'foo' calculates a sum using recursion. It includes both direct recursion and an immediately invoked function expression (IIFE) that makes another recursive call, potentially causing redundant calculations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/recursive-function.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(x) {\n  if (x <= 0) {\n    return 0;\n  }\n  return x + foo(x - 1) + (() => foo(x - 2))();\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [10],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom React Hook with Nested Function\nDESCRIPTION: Demonstrates implementation of a custom React hook 'useFoo' that modifies props, contains a nested function 'bar', and uses 'useNoAlias'. Includes test fixture setup for entry point testing.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-retain-source-when-bailout.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @panicThreshold(none)\nimport {useNoAlias} from 'shared-runtime';\n\nconst cond = true;\nfunction useFoo(props) {\n  props.x = 10;\n  if (cond) bar();\n  return useNoAlias({});\n\n  function bar() {\n    console.log('bar called');\n    return 5;\n  }\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{}],\n};\n```\n\nLANGUAGE: javascript\nCODE:\n```\n// @panicThreshold(none)\nimport { useNoAlias } from \"shared-runtime\";\n\nconst cond = true;\nfunction useFoo(props) {\n  props.x = 10;\n  if (cond) bar();\n  return useNoAlias({});\n\n  function bar() {\n    console.log(\"bar called\");\n    return 5;\n  }\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Runtime Optimizations\nDESCRIPTION: Compiled output showing the transformed component with compiler runtime optimizations. Includes memoization logic to prevent unnecessary re-renders and compiler-specific runtime imports.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/global-types/set-foreach-mutate.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { mutateAndReturn, Stringify, useIdentity } from \"shared-runtime\";\n\nfunction Component(t0) {\n  const $ = _c(2);\n  const { value } = t0;\n  const arr = [{ value: \"foo\" }, { value: \"bar\" }, { value }];\n  useIdentity();\n  const derived = new Set(arr).forEach(mutateAndReturn);\n  let t1;\n  if ($[0] !== derived) {\n    t1 = <Stringify>{[...derived]}</Stringify>;\n    $[0] = derived;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ value: 5 }],\n  sequentialRenders: [{ value: 5 }, { value: 6 }, { value: 6 }, { value: 7 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Refactored React Component with Separated Effect\nDESCRIPTION: Second code snippet demonstrating a refactored version of the React component where the effect callback is extracted into a separate function, maintaining the same external object mutation behavior\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useEffect-external-mutate.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useEffect } from \"react\";\n\nlet x = { a: 42 };\n\nfunction Component(props) {\n  useEffect(_temp);\n}\nfunction _temp() {\n  x.a = 10;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Demonstrating useMemo Memoization Preservation Issue in React\nDESCRIPTION: This code demonstrates an edge case in React Compiler's memoization preservation. The function 'useFoo' creates an array 'x', modifies it, then uses it in a useMemo dependency array. The compiler flags this as an error because 'x' is considered potentially mutable after the useMemo call, even though its mutable range has ended.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.false-positive-useMemo-overlap-scopes.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees:true\nimport {useMemo} from 'react';\nimport {arrayPush} from 'shared-runtime';\n\n/**\n * Repro showing differences between mutable ranges and scope ranges.\n *\n * For useMemo dependency `x`:\n * - mutable range ends after the `arrayPush(x, b)` instruction\n * - scope range is extended due to MergeOverlappingScopes\n *\n * Since manual memo deps are guaranteed to be named (guaranteeing valid\n * codegen), it's correct to take a dependency on a dep *before* the end\n * of its scope (but after its mutable range ends).\n */\n\nfunction useFoo(a, b) {\n  const x = [];\n  const y = [];\n  arrayPush(x, b);\n  const result = useMemo(() => {\n    return [Math.max(x[1], a)];\n  }, [a, x]);\n  arrayPush(y, 3);\n  return {result, y};\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [1, 2],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component Definition with Conditional Rendering\nDESCRIPTION: This snippet defines a React component that conditionally renders different outputs based on the `props.cond`, `props.a`, and `props.b` values. It uses `x.push` to construct arrays and returns them based on nested `if` conditions. Notably, there's a potential for missed memoization opportunities in this initial, unoptimized version.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/early-return-nested-early-return-within-reactive-scope.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enablePropagateDepsInHIR\nfunction Component(props) {\n  let x = [];\n  if (props.cond) {\n    x.push(props.a);\n    if (props.b) {\n      const y = [props.b];\n      x.push(y);\n      // oops no memo!\n      return x;\n    }\n    // oops no memo!\n    return x;\n  } else {\n    return foo();\n  }\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{cond: true, a: 42, b: 3.14}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Invalid Hook Assignment in React Component\nDESCRIPTION: Example of incorrect hook usage where a hook (useFoo) is assigned to a variable instead of being called directly. This violates React's rules of hooks which require hooks to be called at the top level of components.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-hook-reassigned-in-conditional.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let y;\n  props.cond ? (y = useFoo) : null;\n  return y();\n}\n```\n\nLANGUAGE: plaintext\nCODE:\n```\n  1 | function Component(props) {\n  2 |   let y;\n> 3 |   props.cond ? (y = useFoo) : null;\n    |                     ^^^^^^ InvalidReact: Hooks may not be referenced as normal values, they must be called. See https://react.dev/reference/rules/react-calls-components-and-hooks#never-pass-around-hooks-as-regular-values (3:3)\n\nInvalidReact: Hooks may not be referenced as normal values, they must be called. See https://react.dev/reference/rules/react-calls-components-and-hooks#never-pass-around-hooks-as-regular-values (3:3)\n\nInvalidReact: Hooks may not be referenced as normal values, they must be called. See https://react.dev/reference/rules/react-calls-components-and-hooks#never-pass-around-hooks-as-regular-values (4:4)\n  4 |   return y();\n  5 | }\n  6 |\n\n```\n\n----------------------------------------\n\nTITLE: React Component Using Computed Property Keys\nDESCRIPTION: This code defines a React component that creates an object with a computed property key using mutateAndReturn. The component imports utility functions from 'shared-runtime' and exports a FIXTURE_ENTRYPOINT for testing purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-object-expression-computed-key-modified-during-after-construction.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {identity, mutate, mutateAndReturn} from 'shared-runtime';\n\nfunction Component(props) {\n  const key = {};\n  const context = {\n    [mutateAndReturn(key)]: identity([props.value]),\n  };\n  mutate(key);\n  return context;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: 42}],\n};\n```\n\n----------------------------------------\n\nTITLE: Switch Statement Implementation in JavaScript\nDESCRIPTION: This JavaScript code defines a function 'foo' that uses a switch statement to modify the value of a variable 'x'. The switch statement evaluates the value of 'x' and increments it based on the matching case.  The 'FIXTURE_ENTRYPOINT' exports the 'foo' function.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-switch.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo() {\n  let x = 1;\n\n  switch (x) {\n    case 1: {\n      x = x + 1;\n      break;\n    }\n    case 2: {\n      x = x + 2;\n      break;\n    }\n    default: {\n      x = x + 3;\n    }\n  }\n\n  let y = x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Setting Up Fizz Fixtures with Local React Build\nDESCRIPTION: Command sequence to set up Fizz Fixtures using a local build of React. This requires first building React at the project root, then navigating to the fixtures directory to install dependencies and start the development server.\nSOURCE: https://github.com/facebook/react/blob/main/fixtures/fizz/README.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncd fixtures/fizz\nyarn\nyarn start\n```\n\n----------------------------------------\n\nTITLE: Implementing State Management in React Component - JavaScript\nDESCRIPTION: This snippet enhances the 'Foo' component by integrating state management using a custom Hook '_c' from 'react/compiler-runtime'. It checks for changes in props and re-renders the component accordingly, employing a cached mechanism to optimize performance. Dependencies include 'react/compiler-runtime' and 'shared-runtime'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/repro-invariant.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enablePropagateDepsInHIR\nimport { Stringify } from \"shared-runtime\";\n\nfunction Foo(t0) {\n  const $ = _c(5);\n  const { data } = t0;\n  let t1;\n  if ($[0] !== data.a.d) {\n    t1 = () => data.a.d;\n    $[0] = data.a.d;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  const t2 = data.a?.b.c;\n  let t3;\n  if ($[2] !== t1 || $[3] !== t2) {\n    t3 = <Stringify foo={t1} bar={t2} shouldInvokeFns={true} />;\n    $[2] = t1;\n    $[3] = t2;\n    $[4] = t3;\n  } else {\n    t3 = $[4];\n  }\n  return t3;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{ data: { a: null } }],\n  sequentialRenders: [{ data: { a: { b: { c: 4 } } } }],\n};\n```\n\n----------------------------------------\n\nTITLE: Improved useFoo Hook with Dependency Management - JavaScript\nDESCRIPTION: This snippet improves upon the earlier 'useFoo' implementation by adding state management based on dependencies using an array '$'. The hook checks for changes in the props and either initializes a new state or uses the previous one, improving efficiency. The integration of a conditional state update mechanism ensures that unnecessary updates are minimized, making this version more performant.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/ssa-renaming-ternary-destruction-with-mutation.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enablePropagateDepsInHIR\nimport { mutate } from \"shared-runtime\";\n\nfunction useFoo(props) {\n  const $ = _c(4);\n  let x;\n  if ($[0] !== props.bar || $[1] !== props.cond || $[2] !== props.foo) {\n    x = [];\n    x.push(props.bar);\n    props.cond ? (([x] = [[]]), x.push(props.foo)) : null;\n    mutate(x);\n    $[0] = props.bar;\n    $[1] = props.cond;\n    $[2] = props.foo;\n    $[3] = x;\n  } else {\n    x = $[3];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ cond: false, foo: 2, bar: 55 }],\n  sequentialRenders: [\n    { cond: false, foo: 2, bar: 55 },\n    { cond: false, foo: 3, bar: 55 },\n    { cond: true, foo: 3, bar: 55 },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Enhanced Component with React Compiler Runtime\nDESCRIPTION: This snippet imports a function from the React compiler runtime and defines a component function that incorporates state management by checking input parameters against a stored state array. It either creates a new state object or retrieves an existing one, while still allowing for internal property manipulation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capture-indirect-mutate-alias-iife.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction component(a) {\n  const $ = _c(2);\n  let x;\n  if ($[0] !== a) {\n    x = { a };\n\n    const q = x;\n    (function () {\n      q.b = 1;\n    })();\n    $[0] = a;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: [2],\n};\n```\n\n----------------------------------------\n\nTITLE: Minimal JavaScript Function Test Fixture\nDESCRIPTION: A simplified JavaScript function example that contains an empty foo function and exports it as part of a FIXTURE_ENTRYPOINT object. This pattern appears to be used for testing function behavior in the React codebase.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-if-else.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo() {}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a Function and Exporting an Object in JavaScript\nDESCRIPTION: This snippet defines a function `foo` which adds two elements from a props array and exports an object `FIXTURE_ENTRYPOINT` containing a reference to the function and component parameters. The function uses destructuring to extract values from `props.a`.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unused-array-middle-element.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(props) {\n  const [x, , y] = props.a;\n  return x + y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Hook with Compiler Runtime\nDESCRIPTION: This code defines a React hook, `useFoo`, and uses the `react/compiler-runtime` to optimize re-renders. It uses a compiler runtime cache (`_c`) to store the previous input and output, and only re-calculates if the input `bar` has changed. The `FIXTURE_ENTRYPOINT` exports the hook and example parameters for automated testing.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hook-declaration-basic.flow.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nexport default function useFoo(bar) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== bar) {\n    t0 = [bar];\n    $[0] = bar;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [42],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component Output\nDESCRIPTION: Compiled version of the FBT component showing how the JSX and FBT syntax is transformed into runtime function calls. Includes caching logic for optimized rendering performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-param-with-newline.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport fbt from \"fbt\";\n\nfunction Component(props) {\n  const $ = _c(4);\n  let t0;\n  if ($[0] !== props.name) {\n    t0 = fbt._(\n      \"Hello {a really long description that got split into multiple lines}\",\n      [\n        fbt._param(\n          \"a really long description that got split into multiple lines\",\n\n          props.name,\n        ),\n      ],\n      { hk: \"1euPUp\" },\n    );\n    $[0] = props.name;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const element = t0;\n  let t1;\n  if ($[2] !== element) {\n    t1 = element.toString();\n    $[2] = element;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ name: \"Jason\" }],\n};\n```\n\n----------------------------------------\n\nTITLE: Enhanced React Component with State Management and Multiple Condition Checks - JavaScript\nDESCRIPTION: This snippet expands upon the previous component by implementing conditional checks for caching previous state and avoiding unnecessary re-renders. It showcases an additional implementation detail with a more complex state management strategy and conditions to update state and render output only when necessary.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hooks-with-prefix.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @hookPattern:\".*\\b(use[^$]+)$\"\n\nimport * as React from \"react\";\nimport { makeArray, useHook } from \"shared-runtime\";\n\nconst React$useState = React.useState;\nconst React$useMemo = React.useMemo;\nconst Internal$Reassigned$useHook = useHook;\n\nfunction Component() {\n  const $ = _c(8);\n  const [state] = React$useState(0);\n  const object = Internal$Reassigned$useHook();\n  let t0;\n  if ($[0] !== object) {\n    t0 = JSON.stringify(object);\n    $[0] = object;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const json = t0;\n  let t1;\n  let t2;\n  if ($[2] !== state) {\n    t1 = makeArray(state);\n    const doubledArray = t1;\n\n    t2 = doubledArray.join(\"\");\n    $[2] = state;\n    $[3] = t2;\n    $[4] = t1;\n  } else {\n    t2 = $[3];\n    t1 = $[4];\n  }\n  let t3;\n  if ($[5] !== json || $[6] !== t2) {\n    t3 = (\n      <div>\n        {t2}\n        {json}\n      </div>\n    );\n    $[5] = json;\n    $[6] = t2;\n    $[7] = t3;\n  } else {\n    t3 = $[7];\n  }\n  return t3;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with Loop and Export (Input Version)\nDESCRIPTION: This code defines a React component function with a loop that increments a variable based on props.count. It also exports a fixture entrypoint object for testing purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-empty-update.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let x = 0;\n  for (let i = 0; i < props.count; ) {\n    x += i;\n    if (x > 10) {\n      break;\n    }\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: React Compiler Runtime Memoized Component\nDESCRIPTION: The compiled version of the component using React's compiler runtime for memoization. It uses a cache sentinel to determine whether to create new objects or return previously cached ones for performance optimization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/alias-nested-member-path.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction component() {\n  const $ = _c(1);\n  let x;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const z = [];\n    const y = {};\n    y.z = z;\n    x = {};\n    x.y = y;\n    $[0] = x;\n  } else {\n    x = $[0];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Managing Component States React JavaScript\nDESCRIPTION: The snippet provides a React component implementation that involves calculating and mutating variables, followed by rendering a JSX element. The 'Component' function computes values based on props and conditionally mutates them before returning a 'Foo' component with the updated values. Dependencies include React and any supporting compiler runtime for code optimization. Props a, b, and c are inputs affecting the computation and rendering processes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/independent-across-if.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction compute() {}\nfunction mutate() {}\nfunction foo() {}\nfunction Foo() {}\n\n/**\n * Should produce 3 scopes:\n *\n * a: inputs=props.a & props.c; outputs=a\n *   a = compute(props.a);\n *   if (props.c)\n *     mutate(a)\n * b: inputs=props.b & props.c; outputs=b\n *   b = compute(props.b);\n *   if (props.c)\n *     mutate(b)\n * return: inputs=a, b outputs=return\n *   return = <Foo a={a} b={b} />\n */\nfunction Component(props) {\n  const a = compute(props.a);\n  const b = compute(props.b);\n  if (props.c) {\n    mutate(a);\n    mutate(b);\n  }\n  return <Foo a={a} b={b} />;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Advanced Stringify Component Usage with Conditional Renders - JavaScript\nDESCRIPTION: This snippet features an advanced implementation of the Stringify component within a React function, useFoo, which employs conditional rendering based on input properties. Dependencies include react/compiler-runtime and shared-runtime. It requires structured inputs to avoid TypeErrors and manages state updates for efficient rendering.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/infer-function-uncond-access-hoisted.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n\nimport { c as _c } from \"react/compiler-runtime\"; // @enablePropagateDepsInHIR\n\nimport { Stringify } from \"shared-runtime\";\n\nfunction useFoo(t0) {\n  const $ = _c(2);\n  const { a } = t0;\n  let t1;\n  if ($[0] !== a.b.c) {\n    t1 = <Stringify fn={() => a.b.c} shouldInvokeFns={true} />;\n    $[0] = a.b.c;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ a: null }],\n  sequentialRenders: [{ a: null }, { a: { b: { c: 4 } } }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with Fragment and Memoization (JavaScript)\nDESCRIPTION: This snippet defines a React component that uses useFragment and useMemo hooks. It performs various array operations on the data retrieved from the fragment, including flatMap, filter, and map. The component also demonstrates the use of Flow type annotations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-missing-memoization-lack-of-phi-types-explicit-types.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @flow @validatePreserveExistingMemoizationGuarantees @enableUseTypeAnnotations\nimport {useMemo} from 'react';\nimport {useFragment} from 'shared-runtime';\n\n// This is a version of error.todo-repro-missing-memoization-lack-of-phi-types\n// with explicit type annotations and using enableUseTypeAnnotations to demonstrate\n// that type information is sufficient to preserve memoization in this example\nfunction Component() {\n  const data = useFragment();\n  const nodes: Array<any> = data.nodes ?? [];\n  const flatMap: Array<any> = nodes.flatMap(node => node.items);\n  const filtered: Array<any> = flatMap.filter(item => item != null);\n  const map: Array<any> = useMemo(() => filtered.map(), [filtered]);\n  const index: Array<any> = filtered.findIndex(x => x === null);\n\n  return (\n    <div>\n      {map}\n      {index}\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using Optional Chaining in React Component with JavaScript\nDESCRIPTION: This JavaScript function, 'useFoo', demonstrates safe property access in a React context using optional chaining. The function checks and collects nested properties into an array using optional chaining to avoid errors caused by null or undefined values.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/infer-sequential-optional-chain-nonnull.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\n// @enablePropagateDepsInHIR\n\nfunction useFoo({a}) {\n  let x = [];\n  x.push(a?.b.c?.d.e);\n  x.push(a.b?.c.d?.e);\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{a: null}],\n  sequentialRenders: [\n    {a: null},\n    {a: null},\n    {a: {}},\n    {a: {b: {c: {d: {e: 42}}}}},\n    {a: {b: {c: {d: {e: 43}}}}},\n    {a: {b: {c: {d: {e: undefined}}}}},\n    {a: {b: undefined}},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing a conditional function with React test fixture (Input version)\nDESCRIPTION: A simple JavaScript function that sets a variable based on a condition and returns it. Includes an export of FIXTURE_ENTRYPOINT that specifies test parameters for this function.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-phi-primitive.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(a, b) {\n  let x;\n  if (a) {\n    x = 1;\n  } else {\n    x = 2;\n  }\n\n  let y = x;\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [true, false],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Incorrect useMemo Implementation\nDESCRIPTION: This code snippet demonstrates an incorrect implementation of a custom hook that breaks memoization guarantees. The `useMemo` hook is not used to memoize a value; instead, it uses conditional logic to assign value `t0`. This results in the value being recomputed on every render, negating the benefits of memoization. The `identity` function is used for cases where `cond` is false.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/prune-nonescaping-useMemo-mult-returns-primitive.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees\n\nimport { useMemo } from \"react\";\nimport { identity } from \"shared-runtime\";\n\nfunction useFoo(cond) {\n  let t0;\n  if (cond) {\n    t0 = 2;\n  } else {\n    t0 = identity(5);\n  }\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [true],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: Simple React component that demonstrates exception handling and potential array mutation. Uses a throwInput function that may throw the input array, which is then caught and modified.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-with-catch-param.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst {throwInput} = require('shared-runtime');\n\nfunction Component(props) {\n  let x = [];\n  try {\n    // foo could throw its argument...\n    throwInput(x);\n  } catch (e) {\n    // ... in which case this could be mutating `x`!\n    e.push(null);\n    return e;\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining and Exporting Function in JavaScript\nDESCRIPTION: This snippet defines a JavaScript function, Foo, which appears to demonstrate function typing with a TypeScript type declaration (type X) and an interface (Bar). It also shows how to export this function in React as FIXTURE_ENTRYPOINT with empty parameters. The interface and type are not actually used in the function return and the snippet relies on the standard JavaScript and TypeScript setup.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ignore-inner-interface-types.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Foo() {\n  type X = number;\n  interface Bar {\n    baz: number;\n  }\n  return 0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Memoized Click Handlers with Compiler Runtime - JavaScript\nDESCRIPTION: This snippet implements the 'hoisting' function with memoization using React's compiler runtime. It also defines the click handlers ('onClick' and 'onClick2') that access properties of a 'bar' object. It includes logic to handle if the cache sentinel is present. Dependencies include 'react/compiler-runtime' and 'shared-runtime'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-computed-member-expression.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { Stringify } from \"shared-runtime\";\n\nfunction hoisting() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const onClick = function onClick() {\n      return bar.baz;\n    };\n\n    const onClick2 = function onClick2() {\n      return bar[baz];\n    };\n\n    const baz = \"baz\";\n    const bar = { baz: 1 };\n\n    t0 = (\n      <Stringify onClick={onClick} onClick2={onClick2} shouldInvokeFns={true} />\n    );\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: hoisting,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Using Refs and State in React Component\nDESCRIPTION: This code snippet defines a React component that manages a ref and state using various hooks. It demonstrates how to access a ref within a child component while adhering to the rules of React. Key functionalities include setting a ref value when the component mounts and updating the state to trigger re-renders, allowing validation of ref access.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-ref-access-in-effect-indirect.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validateRefAccessDuringRender @validateNoSetStateInRender:false\nimport {useCallback, useEffect, useRef, useState} from 'react';\n\nfunction Component() {\n  const ref = useRef(null);\n  const [state, setState] = useState(false);\n  const setRef = useCallback(() => {\n    ref.current = 'Ok';\n  }, []);\n\n  useEffect(() => {\n    setRef();\n  }, []);\n\n  useEffect(() => {\n    setState(true);\n  }, []);\n\n  // We use state to force a re-render and observe whether the\n  // ref updated. This lets us check that the effect actually ran\n  // and wasn't DCE'd\n  return <Child key={String(state)} ref={ref} />;\n}\n\nfunction Child({ref}) {\n  // This violates the rules of React, so we access the ref in a child\n  // component\n  return ref.current;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n\n```\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @validateRefAccessDuringRender @validateNoSetStateInRender:false\nimport { useCallback, useEffect, useRef, useState } from \"react\";\n\nfunction Component() {\n  const $ = _c(7);\n  const ref = useRef(null);\n  const [state, setState] = useState(false);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = () => {\n      ref.current = \"Ok\";\n    };\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const setRef = t0;\n  let t1;\n  let t2;\n  if ($[1] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = () => {\n      setRef();\n    };\n    t2 = [];\n    $[1] = t1;\n    $[2] = t2;\n  } else {\n    t1 = $[1];\n    t2 = $[2];\n  }\n  useEffect(t1, t2);\n  let t3;\n  let t4;\n  if ($[3] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t3 = () => {\n      setState(true);\n    };\n    t4 = [];\n    $[3] = t3;\n    $[4] = t4;\n  } else {\n    t3 = $[3];\n    t4 = $[4];\n  }\n  useEffect(t3, t4);\n\n  const t5 = String(state);\n  let t6;\n  if ($[5] !== t5) {\n    t6 = <Child key={t5} ref={ref} />;\n    $[5] = t5;\n    $[6] = t6;\n  } else {\n    t6 = $[6];\n  }\n  return t6;\n}\n\nfunction Child(t0) {\n  const { ref } = t0;\n  return ref.current;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Memoization (Compiled Output)\nDESCRIPTION: The compiled version of the component that implements memoization using a cache array. It only recalculates values when inputs change, preserving the previous result when inputs remain the same, improving performance across renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/context-variable-reassigned-reactive-capture.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { invoke } from \"shared-runtime\";\n\nfunction Component(t0) {\n  const $ = _c(2);\n  const { value } = t0;\n  let x;\n  if ($[0] !== value) {\n    x = null;\n    const reassign = () => {\n      x = value;\n    };\n\n    invoke(reassign);\n    $[0] = value;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ value: 2 }],\n  sequentialRenders: [{ value: 2 }, { value: 4 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Function with Memoization\nDESCRIPTION: Compiled version of the function that includes React's memoization logic using Symbol.for() check. Uses compiler runtime utilities and implements caching mechanism.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/assignment-variations-complex-lvalue-array.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction foo() {\n  const $ = _c(1);\n  let a;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    a = [[1]];\n    const first = a.at(0);\n    first.set(0, 2);\n    $[0] = a;\n  } else {\n    a = $[0];\n  }\n  return a;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Compiler Runtime\nDESCRIPTION: This snippet demonstrates an optimized version of the React component using the `react/compiler-runtime`. It utilizes the `_c` function to memoize the rendered output, potentially avoiding unnecessary re-renders if the props haven't changed. The `$` variable stores the memoized data.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/temporary-at-start-of-value-block.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction component(props) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== props) {\n    t0 = isMenuShown ? <Bar> {props.a ? props.b : props.c}</Bar> : null;\n    $[0] = props;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const x = t0;\n  return x;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Original JavaScript Function with Object References\nDESCRIPTION: A JavaScript function that creates objects with references to each other and mutates one of the objects before returning another. This demonstrates object aliasing and mutation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-property-alias-mutate.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo() {\n  const a = {};\n  const x = a;\n\n  const y = {};\n  y.x = x;\n\n  mutate(a); // y & x are aliased to a\n  return y;\n}\n```\n\n----------------------------------------\n\nTITLE: React Component with Object Mutation and Memoization\nDESCRIPTION: A React component that creates and mutates objects, demonstrating advanced state management techniques using compiler runtime and shared runtime\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-fun-alias-captured-mutate-arr-2.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {mutate} from 'shared-runtime';\n\nfunction Component({foo, bar}) {\n  let x = {foo};\n  let y = {bar};\n  const f0 = function () {\n    let a = [y];\n    let b = x;\n    a.x = b;\n  };\n  f0();\n  mutate(y);\n  return x;\n}\n```\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { mutate } from \"shared-runtime\";\n\nfunction Component(t0) {\n  const $ = _c(3);\n  const { foo, bar } = t0;\n  let x;\n  if ($[0] !== bar || $[1] !== foo) {\n    x = { foo };\n    const y = { bar };\n    const f0 = function () {\n      const a = [y];\n      const b = x;\n      a.x = b;\n    };\n\n    f0();\n    mutate(y);\n    $[0] = bar;\n    $[1] = foo;\n    $[2] = x;\n  } else {\n    x = $[2];\n  }\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Function foo with React Compiler Runtime\nDESCRIPTION: This snippet modifies the foo function to incorporate React's compiler runtime, aiming to optimize the function's performance by tracking state using compiler runtime cache. Dependencies include the react/compiler-runtime. The function accepts parameters x and y, and adds caching logic to reduce redundant calculations, especially for recursive scenarios, based on the state of x. It returns an array with the computed value of y multiplied by 10, utilizing caching for optimization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/simple.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nexport default function foo(x, y) {\n  const $ = _c(4);\n  if (x) {\n    let t0;\n    if ($[0] !== y) {\n      t0 = foo(false, y);\n      $[0] = y;\n      $[1] = t0;\n    } else {\n      t0 = $[1];\n    }\n    return t0;\n  }\n\n  const t0 = y * 10;\n  let t1;\n  if ($[2] !== t0) {\n    t1 = [t0];\n    $[2] = t0;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  return t1;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Compiler-Optimized React Component\nDESCRIPTION: The compiler-optimized version of the same component using react/compiler-runtime. It implements memoization to avoid regenerating the div array when the 'b' prop hasn't changed.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-missing-dependency-if-within-while.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nconst someGlobal = true;\nexport default function Component(props) {\n  const $ = _c(2);\n  const { b } = props;\n  let t0;\n  if ($[0] !== b) {\n    const items = [];\n    let i = 0;\n    while (i < 10) {\n      if (someGlobal) {\n        items.push(<div key={i}>{b}</div>);\n        i++;\n      }\n    }\n\n    t0 = <>{items}</>;\n    $[0] = b;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ b: 42 }],\n  sequentialRenders: [\n    { b: 0 },\n    { b: 0 },\n    { b: 42 },\n    { b: 42 },\n    { b: 0 },\n    { b: 42 },\n    { b: 0 },\n    { b: 42 },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Rendering Error View Using Stringify Component in JavaScript\nDESCRIPTION: This snippet constructs an ErrorView component that utilizes the Stringify component to display errors in a React application. It exports the component and defines a FIXTURE_ENTRYPOINT for integration, evaluating ErrorView in runtime. Dependencies include 'shared-runtime' for Stringify.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/arrow-function-expr-gating-test.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @gating\nimport {Stringify} from 'shared-runtime';\nconst ErrorView = ({error, _retry}) => <Stringify error={error}></Stringify>;\n\nexport default ErrorView;\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: eval('ErrorView'),\n  params: [{}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Using React Hook in JavaScript\nDESCRIPTION: This JavaScript snippet demonstrates a function `useFoo` that utilizes a custom hook from React, `useVideoPlayer`. The hook is called inside the function and its result is returned. However, there is an error related to the dynamic use of hooks, which violates React's rules. Refer to the provided documentation link for more details. The snippet requires React as a dependency and does not handle cases of dynamic changes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-hook-from-hook-return.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction useFoo({data}) {\n  const useMedia = useVideoPlayer();\n  const foo = useMedia();\n  return foo;\n}\n```\n\n----------------------------------------\n\nTITLE: Using Memoization in React Component - JavaScript\nDESCRIPTION: This snippet illustrates a React functional component that utilizes memoization to cache computation results. The component checks for a cached value and either returns it or creates a new object. It uses the 'react/compiler-runtime' for the memoization logic and exports a similar FIXTURE_ENTRYPOINT.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-objectexpression.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = { a: 1, b: 2 };\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const x = t0;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with React Compiler Runtime\nDESCRIPTION: This code presents the compiled version of the `Component` function using React's compiler runtime. It imports `_c` from `react/compiler-runtime` and utilizes it to manage the component's state. The compiled code efficiently updates the rendered output based on changes in the `props.cond` value while optimizing for scenarios where `x` remains unchanged. The `FIXTURE_ENTRYPOINT` configuration defines the component and provides a sequence of `cond` values for testing.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-if.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  let x;\n  if (props.cond) {\n    x = 1;\n  } else {\n    x = 2;\n  }\n  let t0;\n  if ($[0] !== x) {\n    t0 = [x];\n    $[0] = x;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  sequentialRenders: [\n    { cond: true },\n    { cond: true },\n    { cond: false },\n    { cond: false },\n    { cond: true },\n    { cond: false },\n    { cond: true },\n    { cond: false },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining TypeScript Function with Type Alias in React\nDESCRIPTION: This snippet defines a TypeScript function using a type alias. It demonstrates the use of type annotations and a higher-order function pattern. The function is exported as part of a FIXTURE_ENTRYPOINT object.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-alias-used-as-variable-annotation.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// @enableAssumeHooksFollowRulesOfReact @enableTransitivelyFreezeFunctionExpressions\ntype Bar = string;\nfunction TypeAliasUsedAsVariableAnnotation() {\n  type Foo = Bar;\n  const fun = f => {\n    let g: Foo = f;\n    console.log(g);\n  };\n  fun('hello, world');\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: TypeAliasUsedAsVariableAnnotation,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Invalid React Mutation Error\nDESCRIPTION: This error message highlights an attempt to mutate a value that should not be mutated directly within a React component. Specifically, it flags the direct mutation of the `sharedVal.value` property within the `onPress` handler of the button. The message indicates that the mutation is invalid and violates React's principles of immutability.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-non-imported-reanimated-shared-value-writes.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n   9 |   return (\n  10 |     <Button\n> 11 |       onPress={() => (sharedVal.value = Math.random())}\n     |                       ^^^^^^^^^ InvalidReact: Mutating a value returned from a function whose return value should not be mutated. Found mutation of `sharedVal` (11:11)\n  12 |       title=\"Randomize\"\n  13 |     />\n  14 |   );\n\n```\n\n----------------------------------------\n\nTITLE: React Component with Explicit Undefined Check\nDESCRIPTION: Alternative implementation that explicitly checks for undefined using a ternary operator instead of destructuring defaults. Assigns 42 if the value is undefined, otherwise uses the provided value.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-default-at-explicit-null.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const [t0] = props.value;\n  const x = t0 === undefined ? 42 : t0;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ value: [null] }],\n};\n```\n\n----------------------------------------\n\nTITLE: Invalid Component with JSX in Try/Catch Blocks\nDESCRIPTION: The original component function attempts to render a JSX element inside a catch block, which is invalid in React. This pattern is flagged by the React compiler as it violates React's error boundary pattern.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/invalid-jsx-in-catch-in-outer-try-with-catch.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @logger @validateNoJSXInTryStatements\nimport {identity} from 'shared-runtime';\n\nfunction Component(props) {\n  let el;\n  try {\n    let value;\n    try {\n      value = identity(props.foo);\n    } catch {\n      el = <div value={value} />;\n    }\n  } catch {\n    return null;\n  }\n  return el;\n}\n```\n\n----------------------------------------\n\nTITLE: Reading Contexts in outer tree\nDESCRIPTION: This snippet demonstrates where to find the logic for reading React Contexts in the outer React tree and combining them into a single object for passing down to the inner tree. It points to the `src/modern/lazyLegacyRoot.js` file as the location for this functionality, specifically highlighting the `useContext` calls and their aggregation.\nSOURCE: https://github.com/facebook/react/blob/main/fixtures/nesting/README.md#2025-04-21_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\n/*\n* `src/modern/lazyLegacyRoot.js`: Look for `useContext` calls, and how their results are combined into a single object that is passed through. **You can read more Contexts there** if your app requires them.\n*/\n```\n\n----------------------------------------\n\nTITLE: Optimized useSupportsTouchEvent Hook Implementation in React\nDESCRIPTION: This snippet presents an optimized version of the useSupportsTouchEvent hook. It removes the useMemo wrapper and uses a label-based control flow to improve performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-preds-undefined-try-catch-return-primitive.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableAssumeHooksFollowRulesOfReact @enableTransitivelyFreezeFunctionExpressions\n\nimport { useMemo } from \"react\";\n\nconst checkforTouchEvents = true;\nfunction useSupportsTouchEvent() {\n  let t0;\n  bb0: {\n    if (checkforTouchEvents) {\n      try {\n        document.createEvent(\"TouchEvent\");\n        t0 = true;\n        break bb0;\n      } catch {\n        t0 = false;\n        break bb0;\n      }\n    }\n    t0 = undefined;\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useSupportsTouchEvent,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Invalid Conditional Hook Usage in React Component\nDESCRIPTION: Example showing an incorrect implementation of a React hook that uses optional chaining (?.), which violates the Rules of Hooks by making the hook call conditional. This pattern is not allowed as hooks must be called in the same order on every render.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-hook-optional-methodcall.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component() {\n  const {result} = Module.useConditionalHook?.() ?? {};\n  return result;\n}\n```\n\nLANGUAGE: plaintext\nCODE:\n```\n  1 | function Component() {\n> 2 |   const {result} = Module.useConditionalHook?.() ?? {};\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^ InvalidReact: Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning) (2:2)\n  3 |   return result;\n  4 | }\n  5 |\n```\n\n----------------------------------------\n\nTITLE: React useCallback with Dependency Array Mismatch\nDESCRIPTION: This code defines a React component, `Component`, that uses `useCallback` to memoize a function. The function returns an object with properties derived from the component's props (`propA` and `propB`).  The dependency array provided to `useCallback` is `[propA, propB.x.y]`.  The React Compiler detected that the manually specified dependencies do not match the inferred dependencies, preventing optimization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.useCallback-conditional-access-noAlloc.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees\nimport {useCallback} from 'react';\n\nfunction Component({propA, propB}) {\n  return useCallback(() => {\n    return {\n      value: propB?.x.y,\n      other: propA,\n    };\n  }, [propA, propB.x.y]);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{propA: 2, propB: {x: {y: []}}}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Initializing Conditional Dependency Tracking Function\nDESCRIPTION: Function demonstrating conditional object property access and reactive scope management in React Compiler. Handles different execution paths while tracking dependencies on props.a.b.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/cfg-ifelse.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {identity} from 'shared-runtime';\n\nfunction useCondDepInDirectIfElse(props, cond) {\n  const x = {};\n  if (identity(cond)) {\n    x.b = props.a.b;\n  } else {\n    x.c = props.a.b;\n  }\n  return x;\n}\n```\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\n\nfunction useCondDepInDirectIfElse(props, cond) {\n  const $ = _c(3);\n  let x;\n  if ($[0] !== cond || $[1] !== props.a.b) {\n    x = {};\n    if (identity(cond)) {\n      x.b = props.a.b;\n    } else {\n      x.c = props.a.b;\n    }\n    $[0] = cond;\n    $[1] = props.a.b;\n    $[2] = x;\n  } else {\n    x = $[2];\n  }\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid React Error\nDESCRIPTION: This error message indicates that the code is attempting to modify a variable defined outside of the component or hook. This can lead to unexpected side effects and make it difficult to reason about the component's behavior. React enforces restrictions on directly modifying external variables to maintain predictable state management.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.store-property-in-global.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n  2 |\n  3 | function Foo() {\n> 4 |   wat.test = 1;\n    |   ^^^ InvalidReact: Writing to a variable defined outside a component or hook is not allowed. Consider using an effect (4:4)\n  5 |   return wat;\n  6 | }\n  7 |\n\n```\n\n----------------------------------------\n\nTITLE: Initializing Object References with 'let' in React Component\nDESCRIPTION: This snippet demonstrates object reference assignment using 'let' variable declarations in a React component function. It creates multiple objects and assigns references between them before calling a 'mutate' function.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transitive-alias-fields.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component() {\n  let x = {};\n  let p = {};\n  let q = {};\n  let y = {};\n\n  x.y = y;\n  p.y = x.y;\n  q.y = p.y;\n\n  mutate(q);\n}\n```\n\n----------------------------------------\n\nTITLE: Using Default Export in React Component\nDESCRIPTION: This snippet imports a default export from a module and uses it within a functional React component. The primary purpose is to illustrate how to return rendered content from the component. Dependencies include React and the specified module, which should ideally export a hook. Expected input is the default export function, and the output is a div containing the result of that function. It highlights a common mistake of not adhering to the expected type configuration for hooks.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-type-provider-hooklike-module-default-not-hook.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport foo from 'useDefaultExportNotTypedAsHook';\n\nfunction Component() {\n  return <div>{foo()}</div>;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Error Handling for React Hook Usage - JavaScript\nDESCRIPTION: This section presents an error output indicating that Hooks cannot be referenced as normal values but must be invoked. It shows the specific line where the issue occurs and provides a link to the relevant React documentation for further guidance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-assign-hook-to-local.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n  1 | function Component(props) {\n> 2 |   const x = useState;\n    |             ^^^^^^^^ InvalidReact: Hooks may not be referenced as normal values, they must be called. See https://react.dev/reference/rules/react-calls-components-and-hooks#never-pass-around-hooks-as-regular-values (2:2)\n  3 |   const state = x(null);\n  4 |   return state[0];\n  5 | }\n```\n\n----------------------------------------\n\nTITLE: React Component with Implicit Return\nDESCRIPTION: Similar React component using implicit return instead of explicit undefined. Includes same fixture configuration but with double-quoted strings.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/return-undefined.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  if (props.cond) {\n    return;\n  }\n  return props.value;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Hook with Memoization\nDESCRIPTION: Compiled version of the useFoo hook with added memoization from the React compiler. Uses an array of cached values to prevent unnecessary recalculations when inputs haven't changed, optimizing performance across renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/assume-invoked/jsx-and-passed.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { createHookWrapper } from \"shared-runtime\";\n\nfunction useFoo(t0) {\n  const $ = _c(8);\n  const { arr1 } = t0;\n  let t1;\n  if ($[0] !== arr1[0]) {\n    t1 = (e) => arr1[0].value + e.value;\n    $[0] = arr1[0];\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  const cb1 = t1;\n  let t2;\n  if ($[2] !== arr1 || $[3] !== cb1) {\n    t2 = arr1.map(cb1);\n    $[2] = arr1;\n    $[3] = cb1;\n    $[4] = t2;\n  } else {\n    t2 = $[4];\n  }\n  const x = t2;\n  let t3;\n  if ($[5] !== cb1 || $[6] !== x) {\n    t3 = [x, cb1];\n    $[5] = cb1;\n    $[6] = x;\n    $[7] = t3;\n  } else {\n    t3 = $[7];\n  }\n  return t3;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: createHookWrapper(useFoo),\n  params: [{ arr1: [], arr2: [] }],\n  sequentialRenders: [\n    { arr1: [], arr2: [] },\n    { arr1: [], arr2: null },\n    { arr1: [{ value: 1 }, { value: 2 }], arr2: [{ value: -1 }] },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component Implementation\nDESCRIPTION: Enhanced version of the component with Forget optimization, including both optimized and unoptimized paths with caching mechanism for props and ref.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/gating-use-before-decl-ref.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { isForgetEnabled_Fixtures } from \"ReactForgetFeatureFlag\"; // @gating\nimport { createRef, forwardRef } from \"react\";\nimport { Stringify } from \"shared-runtime\";\n\nconst Foo = forwardRef(Foo_withRef);\nconst isForgetEnabled_Fixtures_result = isForgetEnabled_Fixtures();\nfunction Foo_withRef_optimized(props, ref) {\n  const $ = _c(3);\n  let t0;\n  if ($[0] !== props || $[1] !== ref) {\n    t0 = <Stringify ref={ref} {...props} />;\n    $[0] = props;\n    $[1] = ref;\n    $[2] = t0;\n  } else {\n    t0 = $[2];\n  }\n  return t0;\n}\nfunction Foo_withRef_unoptimized(props, ref) {\n  return <Stringify ref={ref} {...props} />;\n}\nfunction Foo_withRef(arg0, arg1) {\n  if (isForgetEnabled_Fixtures_result) return Foo_withRef_optimized(arg0, arg1);\n  else return Foo_withRef_unoptimized(arg0, arg1);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: eval(\"(...args) => React.createElement(Foo, args)\"),\n  params: [{ prop1: 1, prop2: 2, ref: createRef() }],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized Component with Shared Runtime - JavaScript\nDESCRIPTION: This snippet provides an optimized version of the `useComponentFactory` function that maintains component state using a closure and an internal cache. It prevents unnecessary re-renders by checking existing cached values before invoking the callback function.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-lowercase-localvar-memberexpr-in-lambda.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport * as SharedRuntime from \"shared-runtime\";\nimport { invoke } from \"shared-runtime\";\nfunction useComponentFactory(t0) {\n  const $ = _c(4);\n  const { name } = t0;\n  let t1;\n  if ($[0] !== name) {\n    t1 = () => (\n      <SharedRuntime.Stringify>hello world {name}</SharedRuntime.Stringify>\n    );\n    $[0] = name;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  const cb = t1;\n  let t2;\n  if ($[2] !== cb) {\n    t2 = invoke(cb);\n    $[2] = cb;\n    $[3] = t2;\n  } else {\n    t2 = $[3];\n  }\n  return t2;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useComponentFactory,\n  params: [{ name: \"sathya\" }],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Inferred Effect Dependencies\nDESCRIPTION: Shows the transformed code after React's compiler has processed it to automatically infer and track dependencies for the useEffect hook. The compiler adds caching logic to optimize re-renders and correctly identifies the ref objects as dependencies rather than their .current properties.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/nonreactive-ref-helper.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @inferEffectDependencies\nimport { useEffect } from \"react\";\nimport { print } from \"shared-runtime\";\n\n/**\n * We never include a .current access in a dep array because it may be a ref access.\n * This might over-capture objects that are not refs and happen to have fields named\n * current, but that should be a rare case and the result would still be correct\n * (assuming the effect is idempotent). In the worst case, you can always write a manual\n * dep array.\n */\nfunction RefsInEffects() {\n  const $ = _c(3);\n  const ref = useRefHelper();\n  const wrapped = useDeeperRefHelper();\n  let t0;\n  if ($[0] !== ref.current || $[1] !== wrapped.foo.current) {\n    t0 = () => {\n      print(ref.current);\n      print(wrapped.foo.current);\n    };\n    $[0] = ref.current;\n    $[1] = wrapped.foo.current;\n    $[2] = t0;\n  } else {\n    t0 = $[2];\n  }\n  useEffect(t0, [ref, wrapped.foo]);\n}\n\nfunction useRefHelper() {\n  return useRef(0);\n}\n\nfunction useDeeperRefHelper() {\n  const $ = _c(2);\n  const t0 = useRefHelper();\n  let t1;\n  if ($[0] !== t0) {\n    t1 = { foo: t0 };\n    $[0] = t0;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: Basic React component implementation showing state management and event handling with a conditional render and form integration.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/function-expression-captures-value-later-frozen-jsx.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let x = {};\n  // onChange should be inferred as immutable, because the value\n  // it captures (`x`) is frozen by the time the function is referenced\n  const onChange = e => {\n    maybeMutate(x, e.target.value);\n  };\n  if (props.cond) {\n    <div>{x}</div>;\n  }\n  return <Foo value={x} onChange={onChange} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Function Definition for Component in JavaScript\nDESCRIPTION: This JavaScript function, Component, initializes a local object using the input parameter and modifies it with an external mutate function. It highlights basic object manipulation. The function takes one parameter, c, and depends on an external mutate method for modification.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/issue852.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(c) {\n  let x = {c};\n  mutate(x);\n  let a = x;\n  let b = a;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Initializing React Hook with Compiler Support in JavaScript\nDESCRIPTION: This snippet offers an enhanced version of the `useFoo` function utilizing a compiler utility `_c` from 'react/compiler-runtime' to optimize changes and state tracking. The function efficiently manages state over multiple renders by minimizing redundant computations through caching with `_c`. It is intended to work with a shared runtime for state mutations and is driven by properties `bar`, `foo`, and `cond`.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-renaming-ternary-with-mutation.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { mutate } from \"shared-runtime\";\n\nfunction useFoo(props) {\n  const $ = _c(4);\n  let x;\n  if ($[0] !== props.bar || $[1] !== props.cond || $[2] !== props.foo) {\n    x = [];\n    x.push(props.bar);\n    props.cond ? ((x = []), x.push(props.foo)) : null;\n    mutate(x);\n    $[0] = props.bar;\n    $[1] = props.cond;\n    $[2] = props.foo;\n    $[3] = x;\n  } else {\n    x = $[3];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ cond: false, foo: 2, bar: 55 }],\n  sequentialRenders: [\n    { cond: false, foo: 2, bar: 55 },\n    { cond: false, foo: 3, bar: 55 },\n    { cond: true, foo: 3, bar: 55 },\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Optimized Ref and Event Handling\nDESCRIPTION: This snippet shows the compiled version of the React component, optimized for performance. It uses the React compiler runtime and implements memoization techniques to cache certain computations. The component's functionality remains the same as the input version, managing an input field's reference and providing a button to clear its value.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-mutating-ref-property-in-callback-passed-to-jsx-indirect.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @validateRefAccessDuringRender\nimport { useRef } from \"react\";\n\nfunction Component() {\n  const $ = _c(2);\n  const ref = useRef(null);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const setRef = () => {\n      if (ref.current !== null) {\n        ref.current.value = \"\";\n      }\n    };\n\n    t0 = () => {\n      setRef();\n    };\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const onClick = t0;\n  let t1;\n  if ($[1] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = (\n      <>\n        <input ref={ref} />\n        <button onClick={onClick} />\n      </>\n    );\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component using useMemo\nDESCRIPTION: This snippet defines a React component named `Component` that utilizes `useMemo` to memoize the `props.value`. The `useMemo` hook ensures that the value is only recalculated when `props.value` changes. The `FIXTURE_ENTRYPOINT` is an object used for testing and specifies the component, its parameters, and component identifier.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-labeled-statement-unconditional-return.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const x = useMemo(() => {\n    label: {\n      return props.value;\n    }\n  });\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component Function Using Compiler Runtime\nDESCRIPTION: This snippet shows the optimized version of the 'foo' function using React's compiler runtime. It implements memoization for object creation and method calls, improving performance by avoiding unnecessary recalculations when inputs haven't changed.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/method-call-computed.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction foo(a, b, c) {\n  const $ = _c(8);\n  let t0;\n  if ($[0] !== a) {\n    t0 = makeObject(a);\n    $[0] = a;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const x = t0;\n  let t1;\n  if ($[2] !== a) {\n    t1 = makeObject(a);\n    $[2] = a;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  const y = t1;\n  let t2;\n  if ($[4] !== b || $[5] !== x || $[6] !== y.method) {\n    t2 = x[y.method](b);\n    $[4] = b;\n    $[5] = x;\n    $[6] = y.method;\n    $[7] = t2;\n  } else {\n    t2 = $[7];\n  }\n  const z = t2;\n  return z;\n}\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Memoization - JavaScript\nDESCRIPTION: This code snippet shows the compiled and optimized version of the React component. It uses memoization to avoid unnecessary reassignments and computations, improving performance for sequential renders with the same props.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/context-variable-reactive-explicit-control-flow.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { invoke } from \"shared-runtime\";\n\nfunction Component(t0) {\n  const $ = _c(2);\n  const { shouldReassign } = t0;\n  let x;\n  if ($[0] !== shouldReassign) {\n    x = null;\n    const reassign = () => {\n      if (shouldReassign) {\n        x = 2;\n      }\n    };\n\n    invoke(reassign);\n    $[0] = shouldReassign;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ shouldReassign: true }],\n  sequentialRenders: [{ shouldReassign: false }, { shouldReassign: true }],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with Stringify and User IDs\nDESCRIPTION: This snippet defines a React component 'Foo' that renders a Stringify component. It takes an array of user IDs as input and creates a new array from them. The FIXTURE_ENTRYPOINT is defined for testing purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-backedge-reference-effect.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {Stringify} from 'shared-runtime';\n\nfunction Foo({userIds}) {\n  return (\n    <Stringify\n      fn={() => {\n        const arr = [];\n\n        for (const selectedUser of userIds) {\n          arr.push(selectedUser);\n        }\n        return arr;\n      }}\n      shouldInvokeFns={true}\n    />\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{userIds: [1, 2, 3]}],\n  sequentialRenders: [{userIds: [1, 2, 4]}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled useMakeCallback Hook with React Compiler Optimizations\nDESCRIPTION: The React compiler-transformed version of the hook with memoization. It uses a closure array (_c(5)) to cache values between renders, only recreating the callback and return array when dependencies change, improving performance by avoiding unnecessary recreations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/assume-invoked/direct-call.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useState } from \"react\";\nimport { useIdentity } from \"shared-runtime\";\n\nfunction useMakeCallback(t0) {\n  const $ = _c(5);\n  const { obj } = t0;\n  const [state, setState] = useState(0);\n  let t1;\n  if ($[0] !== obj.value || $[1] !== state) {\n    t1 = () => {\n      if (obj.value !== state) {\n        setState(obj.value);\n      }\n    };\n    $[0] = obj.value;\n    $[1] = state;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  const cb = t1;\n\n  useIdentity();\n  cb();\n  let t2;\n  if ($[3] !== cb) {\n    t2 = [cb];\n    $[3] = cb;\n    $[4] = t2;\n  } else {\n    t2 = $[4];\n  }\n  return t2;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useMakeCallback,\n  params: [{ obj: { value: 1 } }],\n  sequentialRenders: [{ obj: { value: 1 } }, { obj: { value: 2 } }],\n};\n```\n\n----------------------------------------\n\nTITLE: React Compiler Error for Unmemoized Effect Dependencies\nDESCRIPTION: Error output from the React Compiler showing that it has skipped optimizing the component because the effect dependencies could not be memoized. The error warns that unmemoized effect dependencies can trigger infinite loops or unexpected behavior.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.validate-memoized-effect-deps-invalidated-dep-value.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n   9 |   const y = [x];\n  10 |\n> 11 |   useEffect(() => {\n     |   ^^^^^^^^^^^^^^^^^\n> 12 |     console.log(y);\n     | ^^^^^^^^^^^^^^^^^^^\n> 13 |   }, [y]);\n     | ^^^^^^^^^^ CannotPreserveMemoization: React Compiler has skipped optimizing this component because the effect dependencies could not be memoized. Unmemoized effect dependencies can trigger an infinite loop or other unexpected behavior (11:13)\n  14 | }\n  15 |\n  16 | export const FIXTURE_ENTRYPOINT = {\n```\n\n----------------------------------------\n\nTITLE: Initializing Component with Shared Runtime in JavaScript\nDESCRIPTION: This snippet defines a function, `component`, that mutates and returns an object using properties from its parameters. It imports `mutate` from the `shared-runtime` module and structures objects using scoped variables. The snippet requires a runtime capable of handling imports and basic JavaScript operations like object mutation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-alias-captured-mutate-iife.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst {mutate} = require('shared-runtime');\n\nfunction component(foo, bar) {\n  let x = {foo};\n  let y = {bar};\n  (function () {\n    let a = {y};\n    let b = x;\n    a.x = b;\n  })();\n  mutate(y);\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: ['foo', 'bar'],\n};\n```\n\n----------------------------------------\n\nTITLE: Creating a Stateful Component with React Compiler Runtime in JavaScript\nDESCRIPTION: This snippet implements a component function using the React compiler runtime. It checks for changes in input values and maintains state in an array. The function returns another function that logs the current state of 'a'. This pattern showcases a more dynamic way to handle functional components in React with efficient state management.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-member-expr.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction component(a) {\n  const $ = _c(4);\n  let t0;\n  if ($[0] !== a) {\n    t0 = { a };\n    $[0] = a;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const z = t0;\n  let t1;\n  if ($[2] !== z.a) {\n    t1 = function () {\n      console.log(z.a);\n    };\n    $[2] = z.a;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  const x = t1;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: React Hermes Compiler Error Output\nDESCRIPTION: The error output from the React Hermes compiler when encountering value blocks (such as conditional operators, logical expressions, optional chaining) within a try/catch statement. The error specifically points to the comparison operation in the for loop condition.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-repro-declaration-for-all-identifiers.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n  3 |     // NOTE: this fixture previously failed during LeaveSSA;\n  4 |     // double-check this code when supporting value blocks in try/catch\n> 5 |     for (let i = 0; i < 2; i++) {}\n    |                     ^ Todo: Support value blocks (conditional, logical, optional chaining, etc) within a try/catch statement (5:5)\n  6 |   } catch {}\n  7 | }\n  8 |\n```\n\n----------------------------------------\n\nTITLE: Defining a React Component with Hooks in JavaScript\nDESCRIPTION: This code snippet demonstrates the creation of a React component using the useState hook to manage a state variable. It includes a function 'onChange' to update the state based on user input. The snippet also showcases the use of a hypothetical custom hook 'useOtherHook' and the 'foo' function, which highlights a memoization technique applied to 'x' and 'onChange'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inadvertent-mutability-readonly-lambda.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const [value, setValue] = useState(null);\n  // NOTE: this lambda does not capture any mutable values (only the state setter)\n  // and thus should be treated as readonly\n  const onChange = e => setValue(value => value + e.target.value);\n\n  useOtherHook();\n\n  // x should be independently memoizeable, since foo(x, onChange) cannot modify onChange\n  const x = {};\n  foo(x, onChange);\n  return x;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Runtime Optimization\nDESCRIPTION: Compiled version of the code that implements caching mechanism using React compiler runtime. It creates a cache array and only creates new objects when the values change, improving performance by avoiding unnecessary object allocations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/obj-literal-cached-in-if-else.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction foo(a, b, c, d) {\n  const $ = _c(4);\n  let x;\n  if (someVal) {\n    let t0;\n    if ($[0] !== b) {\n      t0 = { b };\n      $[0] = b;\n      $[1] = t0;\n    } else {\n      t0 = $[1];\n    }\n    x = t0;\n  } else {\n    let t0;\n    if ($[2] !== c) {\n      t0 = { c };\n      $[2] = c;\n      $[3] = t0;\n    } else {\n      t0 = $[3];\n    }\n    x = t0;\n  }\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a React Hook with Conditional Rendering\nDESCRIPTION: This snippet defines a React hook named `useFoo` that takes `props` as an argument. Inside the hook, the value of `x` is conditionally set based on the `props.cond` property. The `mutate` function is called to update the state, and finally, `x` is returned.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-renaming-unconditional-with-mutation.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {mutate} from 'shared-runtime';\n\nfunction useFoo(props) {\n  let x = [];\n  x.push(props.bar);\n  if (props.cond) {\n    x = {};\n    x = [];\n    x.push(props.foo);\n  } else {\n    x = [];\n    x = [];\n    x.push(props.bar);\n  }\n  mutate(x);\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{bar: 'bar', foo: 'foo', cond: true}],\n  sequentialRenders: [\n    {bar: 'bar', foo: 'foo', cond: true},\n    {bar: 'bar', foo: 'foo', cond: true},\n    {bar: 'bar', foo: 'foo', cond: false},\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Rendering React Component with Props\nDESCRIPTION: Demonstrates a basic rendering of a React component where nested components are passed props, showcasing how properties are used to pass data. The component utilizes props.p0 to populate and iterate a list and updates a data attribute with this list.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/property-assignment.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const x = {};\n  const y = [];\n  x.y = y;\n  const child = <Component data={y} />;\n  x.y.push(props.p0);\n  return <Component data={x}>{child}</Component>;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Incorrect Hook Usage in React - JavaScript\nDESCRIPTION: This snippet shows two JavaScript functions that incorrectly use hooks inside functions that are not valid React component or custom hook definitions. The usage of `useHookInsideNormalFunction` within a plain JavaScript function violates React's rules of hooks, which state that hooks can only be called at the top level of a React function component or a custom hook. No specific dependencies are required, but correct understanding of React hooks usage is expected. Inputs and outputs are not applicable as the functions themselves are faulty by demonstration.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.invalid.invalid-rules-of-hooks-5a7ac9a6e8fa.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\n// @skip\n// Passed but should have failed\n\n// These are neither functions nor hooks.\nfunction _normalFunctionWithHook() {\n  useHookInsideNormalFunction();\n}\n\nfunction _useNotAHook() {\n  useHookInsideNormalFunction();\n}\n\n```\n\n----------------------------------------\n\nTITLE: React Component with Input Mutation and Shared Runtime\nDESCRIPTION: A React functional component that demonstrates object mutation, nested object assignment, and dynamic state manipulation using shared runtime mutation techniques\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-alias-captured-mutate.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {mutate} from 'shared-runtime';\n\nfunction Component({foo, bar}) {\n  let x = {foo};\n  let y = {bar};\n  const f0 = function () {\n    let a = [y];\n    let b = x;\n    // this writes y.x = x\n    a[0].x = b;\n  };\n  f0();\n  mutate(y.x);\n  return y;\n}\n```\n\n----------------------------------------\n\nTITLE: React Component Compiled Output\nDESCRIPTION: This code shows the compiled version of the React component. It imports `_c` from `react/compiler-runtime`. The component uses `_c` to potentially memoize the result of the rendering. It checks if a memoized value exists and reuses it or renders the component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-call-jsx.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction foo() {}\n\nfunction Component(props) {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const a = [];\n    const b = {};\n    foo(a, b);\n\n    foo(a, b);\n    t0 = <div a={a} b={b} />;\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: Compiled version of the component with added memoization logic using compiler runtime. Includes caching of props and return values for optimization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-within-object-method-returns-caught-value.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { throwInput } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== props) {\n    const object = {\n      foo() {\n        try {\n          throwInput([props.value]);\n        } catch (t1) {\n          const e = t1;\n          return e;\n        }\n      },\n    };\n\n    t0 = object.foo();\n    $[0] = props;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ value: 42 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Caching\nDESCRIPTION: Optimized version with compiler runtime integration and caching mechanism using array $_c. Implements memoization for props.items.edges and length calculations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/memberexpr-join-optional-chain2.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enablePropagateDepsInHIR\nfunction Component(props) {\n  const $ = _c(5);\n  let x;\n  if ($[0] !== props.items?.edges || $[1] !== props.items?.length) {\n    x = [];\n    x.push(props.items?.length);\n    let t0;\n    if ($[3] !== props.items?.edges) {\n      t0 = props.items?.edges?.map?.(render)?.filter?.(Boolean) ?? [];\n      $[3] = props.items?.edges;\n      $[4] = t0;\n    } else {\n      t0 = $[4];\n    }\n    x.push(t0);\n    $[0] = props.items?.edges;\n    $[1] = props.items?.length;\n    $[2] = x;\n  } else {\n    x = $[2];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ items: { edges: null, length: 0 } }],\n};\n```\n\n----------------------------------------\n\nTITLE: Input React Component Implementation\nDESCRIPTION: Original React component that spreads props.value into a new object and iterates through its properties until encountering a 'break' key. Returns the last visited property value.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-in-statement-break.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let x;\n  const object = {...props.value};\n  for (const y in object) {\n    if (y === 'break') {\n      break;\n    }\n    x = object[y];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  // should return 'a'\n  params: [{a: 'a', break: null, c: 'C!'}],\n};\n```\n\n----------------------------------------\n\nTITLE: Initializing Component with Props - JavaScript\nDESCRIPTION: This code snippet defines a function component in JavaScript that takes props as its input. The component utilizes an inner function to manipulate a local array and outputs the first element of this array. It is intended to serve as a demonstration of how props input can be used to affect a component's behavior in React.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactivity-via-aliased-mutation-lambda.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const x = [];\n  const f = arg => {\n    const y = x;\n    y.push(arg);\n  };\n  f(props.input);\n\n  return [x[0]];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  sequentialRenders: [\n    {input: 42},\n    {input: 42},\n    {input: 'sathya'},\n    {input: 'sathya'},\n    {input: 42},\n    {input: 'sathya'},\n    {input: 42},\n    {input: 'sathya'},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom React Hook with Array Manipulation\nDESCRIPTION: A React custom hook that creates and manipulates an array based on input props. The hook takes props with 'bar', 'cond', and 'foo' properties, using conditional logic to push values into the array and return it.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-renaming-ternary-destruction.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction useFoo(props) {\n  let x = [];\n  x.push(props.bar);\n  props.cond ? (({x} = {x: {}}), ([x] = [[]]), x.push(props.foo)) : null;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{cond: false, foo: 2, bar: 55}],\n  sequentialRenders: [\n    {cond: false, foo: 2, bar: 55},\n    {cond: false, foo: 3, bar: 55},\n    {cond: true, foo: 3, bar: 55},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled Array.at Implementation with React Optimization\nDESCRIPTION: The compiled version of the Array.at component with React's compiler optimizations. Includes caching mechanism using _c compiler runtime and conditional execution based on prop changes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-at-effect.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // arrayInstance.at should have the following effects:\n//  - read on arg0\n//  - read on receiver\n//  - mutate on lvalue\nfunction ArrayAtTest(props) {\n  const $ = _c(9);\n  let t0;\n  if ($[0] !== props.x) {\n    t0 = foo(props.x);\n    $[0] = props.x;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  let t1;\n  if ($[2] !== t0) {\n    t1 = [t0];\n    $[2] = t0;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  const arr = t1;\n  let t2;\n  if ($[4] !== arr || $[5] !== props.y) {\n    let t3;\n    if ($[7] !== props.y) {\n      t3 = bar(props.y);\n      $[7] = props.y;\n      $[8] = t3;\n    } else {\n      t3 = $[8];\n    }\n    t2 = arr.at(t3);\n    $[4] = arr;\n    $[5] = props.y;\n    $[6] = t2;\n  } else {\n    t2 = $[6];\n  }\n  const result = t2;\n  return result;\n}\n```\n\n----------------------------------------\n\nTITLE: Input React Component Definition\nDESCRIPTION: Simple React functional component definition with a single div element and export configuration for testing.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/arrow-function-with-implicit-return.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @compilationMode(infer)\nconst Test = () => <div />;\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Test,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: React Error: Unexpected Variable Reassignment\nDESCRIPTION: This code block presents the error output generated when attempting to reassign values to variables defined outside of the React component. The error message suggests that components and hooks should be pure and side-effect free, which is violated by variable reassignment. It recommends using `useState` hook if variable is used in rendering.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.reassignment-to-global-indirect.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n  2 |   const foo = () => {\n  3 |     // Cannot assign to globals\n> 4 |     someUnknownGlobal = true;\n    |     ^^^^^^^^^^^^^^^^^ InvalidReact: Unexpected reassignment of a variable which was defined outside of the component. Components and hooks should be pure and side-effect free, but variable reassignment is a form of side-effect. If this variable is used in rendering, use useState instead. (4:4)\n  5 |     moduleLocal = true;\n  6 |   };\n  7 |   foo();\n```\n\n----------------------------------------\n\nTITLE: Optimizing React Component with Compiler Runtime\nDESCRIPTION: This snippet shows the optimized version of the Component using React's compiler runtime. It implements memoization to avoid unnecessary re-renders and computations when props haven't changed.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/do-while-compound-test.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  let ret;\n  if ($[0] !== props) {\n    const x = [1, 2, 3];\n    ret = [];\n    do {\n      const item = x.pop();\n      ret.push(item * 2);\n    } while (x.length && props.cond);\n    $[0] = props;\n    $[1] = ret;\n  } else {\n    ret = $[1];\n  }\n  return ret;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Input Component Function with Simple Closure\nDESCRIPTION: Original component function that creates a closure capturing a nested object. The component takes a parameter 'a', creates an object with a nested reference to that parameter, and returns a function that logs the nested value.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-nested-member-expr.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component(a) {\n  let z = {a: {a}};\n  let x = function () {\n    console.log(z.a.a);\n  };\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Original Router Component in React\nDESCRIPTION: Defines a Router component that takes title and mapping props to create arrays of route entries. Includes test fixture setup with sequential renders using different titles.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-of-immutable-collection.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Router({title, mapping}) {\n  const array = [];\n  for (let [, entry] of mapping) {\n    array.push([title, entry]);\n  }\n  return array;\n}\n\nconst routes = new Map([\n  ['about', '/about'],\n  ['contact', '/contact'],\n]);\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Router,\n  params: [],\n  sequentialRenders: [\n    {\n      title: 'Foo',\n      mapping: routes,\n    },\n    {\n      title: 'Bar',\n      mapping: routes,\n    },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component with Function Dependencies\nDESCRIPTION: Initial implementation of a React component that checks a property length with a nested function. Uses the @enableTreatFunctionDepsAsConditional directive for optimization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/functionexprconditional-access.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableTreatFunctionDepsAsConditional\nfunction Component(props) {\n  function getLength() {\n    return props.bar.length;\n  }\n\n  return props.bar && getLength();\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{bar: null}],\n};\n```\n\n----------------------------------------\n\nTITLE: Invalid Conditional Hook Usage in React Component\nDESCRIPTION: This code shows an incorrect implementation where a hook (created by makeObject_Primitives) is called conditionally inside an if statement, which violates React's Rules of Hooks. Hooks must be called in the same order on every render and cannot be placed inside conditions.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-conditionally-call-local-named-like-hook.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {makeObject_Primitives} from 'shared-runtime';\n\nfunction Component(props) {\n  const useFoo = makeObject_Primitives();\n  if (props.cond) {\n    useFoo();\n  }\n}\n```\n\nLANGUAGE: text\nCODE:\n```\n  4 |   const useFoo = makeObject_Primitives();\n  5 |   if (props.cond) {\n> 6 |     useFoo();\n    |     ^^^^^^ InvalidReact: Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning) (6:6)\n  7 |   }\n  8 | }\n  9 |\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with State Mutation - JavaScript\nDESCRIPTION: This code defines a React component named 'Component' that utilizes the 'mutate' function from 'shared-runtime' to update state based on input properties. It processes inputs 'foo' and 'bar' and performs state mutation based on the conditions provided.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-fun-alias-captured-mutate-2.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {mutate} from 'shared-runtime';\n\nfunction Component({foo, bar}) {\n  let x = {foo};\n  let y = {bar};\n  const f0 = function () {\n    let a = {y};\n    let b = x;\n    a.x = b;\n  };\n  f0();\n  mutate(y);\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{foo: 2, bar: 3}],\n  sequentialRenders: [\n    {foo: 2, bar: 3},\n    {foo: 2, bar: 3},\n    {foo: 2, bar: 4},\n    {foo: 3, bar: 4},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Invalid useRef Usage in React Component\nDESCRIPTION: This JavaScript snippet demonstrates an incorrect pattern where the 'useRef' hook is used to update a ref during the render phase of a React component. This practice is discouraged as it can lead to unexpected behavior since ref updates should occur after render or in a callback. The example shows a function component attempting to update a ref value, which leads to an error due to accessing the ref's 'current' property during render.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-disallow-mutating-refs-in-render-transitive.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validateRefAccessDuringRender\nfunction Component() {\n  const ref = useRef(null);\n\n  const setRef = () => {\n    ref.current = false;\n  };\n  const changeRef = setRef;\n  changeRef();\n\n  return <button ref={ref} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a JavaScript Function with Variable Assignment in React\nDESCRIPTION: Defines a function 'foo' with variable assignment operations and conditional logic. Exports a fixture entrypoint object that references the function for testing purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-complex-single-if.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo() {\n  let x = 1;\n  let y = 2;\n  if (y === 2) {\n    x = 3;\n  }\n\n  y = x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Optimized Memoization\nDESCRIPTION: This is the compiler-optimized version of the component where useMemo has been replaced with a custom caching mechanism. It uses a Symbol.for('react.memo_cache_sentinel') to determine if recalculation is needed, storing the component and render results in a cache array.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/context-variable-as-jsx-element-tag.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useMemo } from \"react\";\nimport { Stringify } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(3);\n  let Component;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    Component = Stringify;\n    let t0;\n\n    t0 = Component;\n    Component = t0;\n    $[0] = Component;\n  } else {\n    Component = $[0];\n  }\n  let t0;\n  if ($[1] !== props) {\n    t0 = <Component {...props} />;\n    $[1] = props;\n    $[2] = t0;\n  } else {\n    t0 = $[2];\n  }\n  return t0;\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Shared Runtime Mutation in JavaScript\nDESCRIPTION: Defines a component function that creates an object with nested properties and applies a mutation using shared runtime. The function handles object creation and mutation with a closure.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-alias-mutate-iife.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst {mutate} = require('shared-runtime');\n\nfunction component(a) {\n  let x = {a};\n  let y = {};\n  (function () {\n    y.x = x;\n  })();\n  mutate(y);\n  return y;\n}\n```\n\n----------------------------------------\n\nTITLE: React Compiler Logs for Dynamic Component Creation\nDESCRIPTION: Compiler logs showing React validation errors. Two errors are reported: one for components created during render resetting state, and another for potential dynamic component creation. The compilation succeeds despite the warnings, with details about memoization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/static-components/invalid-dynamically-constructed-component-method-call.expect.md#2025-04-21_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\"kind\":\"CompileError\",\"detail\":{\"options\":{\"reason\":\"Components created during render will reset their state each time they are created. Declare components outside of render. \",\"description\":null,\"severity\":\"InvalidReact\",\"suggestions\":null,\"loc\":{\"start\":{\"line\":4,\"column\":10,\"index\":110},\"end\":{\"line\":4,\"column\":19,\"index\":119},\"filename\":\"invalid-dynamically-constructed-component-method-call.ts\"}}}},\"fnLoc\":null}\n{\"kind\":\"CompileError\",\"detail\":{\"options\":{\"reason\":\"The component may be created during render\",\"description\":null,\"severity\":\"InvalidReact\",\"suggestions\":null,\"loc\":{\"start\":{\"line\":3,\"column\":20,\"index\":83},\"end\":{\"line\":3,\"column\":35,\"index\":98},\"filename\":\"invalid-dynamically-constructed-component-method-call.ts\"}}}},\"fnLoc\":null}\n{\"kind\":\"CompileSuccess\",\"fnLoc\":{\"start\":{\"line\":2,\"column\":0,\"index\":37},\"end\":{\"line\":5,\"column\":1,\"index\":125},\"filename\":\"invalid-dynamically-constructed-component-method-call.ts\"}},\"fnName\":\"Example\",\"memoSlots\":4,\"memoBlocks\":2,\"memoValues\":2,\"prunedMemoBlocks\":0,\"prunedMemoValues\":0}\n```\n\n----------------------------------------\n\nTITLE: Updated Object Property Assignment with Static Index\nDESCRIPTION: Modified version of the object manipulation function where dynamic index calculation is replaced with static value 3. Includes the same fixture export configuration.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-computed-access-assignment.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(a, b, c) {\n  const x = { ...a };\n  x[b] = c[b];\n  x[3] = c[b * 4];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple React Component with Constant (JavaScript)\nDESCRIPTION: This snippet defines a React component 'Foo' that returns a constant value through a nested function. It imports an 'identity' function and exports a FIXTURE_ENTRYPOINT object for testing.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/constant-prop-to-object-method.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {identity} from 'shared-runtime';\n\nfunction Foo() {\n  const CONSTANT = 1;\n  const x = {\n    foo() {\n      return identity(CONSTANT);\n    },\n  };\n  return x.foo();\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Invalid React Hooks Implementation in Loops\nDESCRIPTION: Example of a function that incorrectly calls React hooks inside a while loop, which breaks the fundamental rules of hooks usage. This code will trigger a static analysis error due to inconsistent hook call order.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-rules-of-hooks-d85c144bdf40.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction useHookInLoops() {\n  while (a) {\n    useHook1();\n    if (b) continue;\n    useHook2();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Memoized React Component with Compiler Runtime\nDESCRIPTION: This code defines a memoized React component, `Component2`, using `react/compiler-runtime`. It memoizes the results of mapping the `items` prop and the rendered `<ul>` element.  This optimization prevents unnecessary re-renders when the `items` prop remains unchanged. It also includes the FIXTURE_ENTRYPOINT.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/outlining-in-func-expr.expect.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nconst Component2 = (props) => {\n  const $ = _c(4);\n  let t0;\n  if ($[0] !== props.items) {\n    t0 = props.items.map(_temp);\n    $[0] = props.items;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  let t1;\n  if ($[2] !== t0) {\n    t1 = <ul>{t0}</ul>;\n    $[2] = t0;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  return t1;\n};\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component2,\n  params: [\n    {\n      items: [\n        { id: 2, name: \"foo\" },\n        { id: 3, name: \"bar\" },\n      ],\n    },\n  ],\n};\nfunction _temp(item) {\n  return <li key={item.id}>{item.name}</li>;\n}\n```\n\n----------------------------------------\n\nTITLE: Publish Experimental Release Script\nDESCRIPTION: This script publishes an experimental release to NPM with the `experimental` tag. It's used after the experimental release has been prepared using `prepare-release-from-ci`. The `experimental` tag ensures that consumers can specifically opt into using the experimental release.\nSOURCE: https://github.com/facebook/react/blob/main/scripts/release/README.md#2025-04-21_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nscripts/release/publish.js --tags experimental\n```\n\n----------------------------------------\n\nTITLE: Invalid React Hook Usage in Unnamed Function\nDESCRIPTION: This code snippet showcases an invalid usage of a function named `useNotAHook` (which is likely intended to be a hook) inside an unnamed function argument passed to `React.unknownFunction`. The linter flags this because the call to `useNotAHook` is conditional (within an `if` statement), violating the Rules of Hooks, which require hooks to be called in the same order on every render.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.error.rules-of-hooks-d0935abedc42.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @skip\n// Unsupported input\n\n// This is valid because \"use\"-prefixed functions called in\n// unnamed function arguments are not assumed to be hooks.\nReact.unknownFunction((foo, bar) => {\n  if (foo) {\n    useNotAHook(bar);\n  }\n});\n\n```\n\n----------------------------------------\n\nTITLE: Using useCallback for Memoization in React\nDESCRIPTION: This snippet defines a function `useFoo` that uses `useCallback` to memoize the return value based on identity. It demonstrates a case where a dependency, `x`, is not included in the memoization, showcasing scope pruning due to hook-call flattening. The code demonstrates the challenges and considerations in using memoization with React hooks.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useCallback-dep-scope-pruned.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees\nimport {useCallback} from 'react';\nimport {identity, useIdentity} from 'shared-runtime';\n\nfunction mutate(_: unknown) {}\n\n/**\n * Repro showing a manual memo whose declaration (useCallback's 1st argument)\n * is memoized, but not its dependency (x). In this case, `x`'s scope is pruned\n * due to hook-call flattening.\n */\nfunction useFoo(a) {\n  const x = identity(a);\n  useIdentity(2);\n  mutate(x);\n\n  return useCallback(() => [x, []], [x]);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [3],\n};\n```\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @validatePreserveExistingMemoizationGuarantees\nimport { useCallback } from \"react\";\nimport { identity, useIdentity } from \"shared-runtime\";\n\nfunction mutate(_) {}\n\n/**\n * Repro showing a manual memo whose declaration (useCallback's 1st argument)\n * is memoized, but not its dependency (x). In this case, `x`'s scope is pruned\n * due to hook-call flattening.\n */\nfunction useFoo(a) {\n  const $ = _c(2);\n  const x = identity(a);\n  useIdentity(2);\n  mutate(x);\n  let t0;\n  if ($[0] !== x) {\n    t0 = () => [x, []];\n    $[0] = x;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [3],\n};\n```\n\n----------------------------------------\n\nTITLE: Error Message for Invalid React State Update\nDESCRIPTION: This snippet shows the error message generated when attempting to update state unconditionally during render in a React component. It highlights the line causing the error and provides a link to the React documentation for further information.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.unconditional-set-state-in-render-with-loop-throw.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n   9 |     }\n  10 |   }\n> 11 |   setState(true);\n     |   ^^^^^^^^ InvalidReact: This is an unconditional set state during render, which will trigger an infinite loop. (https://react.dev/reference/react/useState) (11:11)\n  12 |   return state;\n  13 | }\n  14 |\n```\n\n----------------------------------------\n\nTITLE: Defining and Evaluating a Complex JavaScript Function\nDESCRIPTION: This JavaScript function exemplifies different aspects of the language, including destructuring, default parameters, class declarations and private fields, object methods, JSX elements, tagged template literals, and various loop constructs. It also contains multiple for-loops with early termination, switch cases, and comments indicating areas needing further implementation support. There are error comments related to unhandled parsing scenarios such as variable declarations and class handling.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-kitchensink.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo([a, b], {c, d, e = 'e'}, f = 'f', ...args) {\n  let i = 0;\n  var x = [];\n\n  class Bar {\n    #secretSauce = 42;\n    constructor() {\n      console.log(this.#secretSauce);\n    }\n  }\n\n  const g = {b() {}, c: () => {}};\n  const {z, aa = 'aa'} = useCustom();\n\n  <Button haha={1}></Button>;\n  <Button>{/** empty */}</Button>;\n\n  const j = function bar([quz, qux], ...args) {};\n\n  for (; i < 3; i += 1) {\n    x.push(i);\n  }\n  for (; i < 3; ) {\n    break;\n  }\n  for (;;) {\n    break;\n  }\n\n  graphql`\n    ${g}\n  `;\n\n  graphql`\\t\\n`;\n\n  for (c of [1, 2]) {\n  }\n  for ([v] of [[1], [2]]) {\n  }\n  for ({v} of [{v: 1}, {v: 2}]) {\n  }\n\n  for (let x in {a: 1}) {\n  }\n\n  let updateIdentifier = 0;\n  --updateIdentifier;\n  ++updateIdentifier;\n  updateIdentifier.y++;\n  updateIdentifier.y--;\n\n  switch (i) {\n    case 1 + 1: {\n    }\n    case foo(): {\n    }\n    case x.y: {\n    }\n    default: {\n    }\n  }\n\n  function component(a) {\n    // Add support for function declarations once we support `var` hoisting.\n    function t() {}\n    t();\n  }\n}\n\nlet moduleLocal = false;\n\n```\n\n----------------------------------------\n\nTITLE: Original React Component with Class Instantiation and Array Creation\nDESCRIPTION: The input code defines a simple React component that creates a class instance, an array, and returns them. It imports an identity function and defines a Foo class that gets wrapped by the identity function.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/new-does-not-mutate-class.expect.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {identity} from 'shared-runtime';\n\nclass Foo {}\nfunction Component({val}) {\n  const MyClass = identity(Foo);\n  const x = [val];\n  const y = new MyClass();\n\n  return [x, y];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{val: 0}],\n};\n```\n\n----------------------------------------\n\nTITLE: Mapping Items with React Component in JavaScript\nDESCRIPTION: This JavaScript snippet defines a React component that uses the useFreeze hook to retrieve read-only data and map its items to JSX elements. The code highlights considerations for read effects and memoization when rendering items in a component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/todo.unnecessary-lambda-memoization.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const data = useFreeze(); // assume this returns {items: Array<{...}>}\n  // In this call `data` and `data.items` have a read effect *and* the lambda itself\n  // is readonly (it doesn\\'t capture ony mutable references). Further, we ca\n  // theoretically determine that the lambda doesn\\'t need to be memoized, since\n  // data.items is an Array and Array.prototype.map does not capture its input (callback)\n  // in the return value.\n  // An observation is that even without knowing the exact type of `data`, if we know\n  // that it is a plain, readonly javascript object, then we can infer that any `.map()`\n  // calls *must* be Array.prototype.map (or else they are a runtime error), since no\n  // other builtin has a .map() function.\n  const items = data.items.map(item => <Item item={item} />);\n  return <div>{items}</div>;\n}\n\n```\n\n----------------------------------------\n\nTITLE: React Array Memoization Compiled Output\nDESCRIPTION: Compiled version of the test fixture with implemented memoization logic. Shows how the compiler transforms the source code to include cache checks and memoization optimizations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-inference-array-from.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useIdentity, ValidateMemoization } from \"shared-runtime\";\n\n/**\n * Fixture to assert that we can infer the type and effects of an array created\n * with `Array.from`.\n */\nfunction Validate({ x, val1, val2 }) {\n  \"use no memo\";\n  return (\n    <>\n      <ValidateMemoization\n        inputs={[val1]}\n        output={x[0]}\n        onlyCheckCompiled={true}\n      />\n\n      <ValidateMemoization\n        inputs={[val2]}\n        output={x[1]}\n        onlyCheckCompiled={true}\n      />\n    </>\n  );\n}\nfunction useFoo(t0) {\n  \"use memo\";\n  const $ = _c(9);\n  const { val1, val2 } = t0;\n  let t1;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = [];\n    $[0] = t1;\n  } else {\n    t1 = $[0];\n  }\n  const x = Array.from(t1);\n  useIdentity();\n  let t2;\n  if ($[1] !== val1) {\n    t2 = [val1];\n    $[1] = val1;\n    $[2] = t2;\n  } else {\n    t2 = $[2];\n  }\n  x.push(t2);\n  let t3;\n  if ($[3] !== val2) {\n    t3 = [val2];\n    $[3] = val2;\n    $[4] = t3;\n  } else {\n    t3 = $[4];\n  }\n  x.push(t3);\n  let t4;\n  if ($[5] !== val1 || $[6] !== val2 || $[7] !== x) {\n    t4 = <Validate x={x} val1={val1} val2={val2} />;\n    $[5] = val1;\n    $[6] = val2;\n    $[7] = x;\n    $[8] = t4;\n  } else {\n    t4 = $[8];\n  }\n  return t4;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ val1: 1, val2: 2 }],\n  params: [\n    { val1: 1, val2: 2 },\n    { val1: 1, val2: 2 },\n    { val1: 1, val2: 3 },\n    { val1: 4, val2: 2 },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Unreachable Code Error in Function Declaration\nDESCRIPTION: An error highlighting issues with function declaration placement and potential hoisting challenges in the code snippet\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-hoist-function-decls.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n1 | function Component() {\n2 |   return get2();\n> 3 |   function get2() {\n    |   ^^^^^^^^^^^^^^^^^^\n> 4 |     return 2;\n    | ^^^^^^^^^^^^^\n> 5 |   }\n    | ^^^^ Todo: Support functions with unreachable code that may contain hoisted declarations (3:5)\n6 | }\n7 |\n```\n\n----------------------------------------\n\nTITLE: React Component with JSX and Array Mapping\nDESCRIPTION: This React component, `Component`, takes an array (`arr`) as a prop, maps over it, and renders a `Bar` component for each item. Inside `Bar`, `Baz` and `Foo` components are rendered with props derived from the array item and a custom hook `useX`. The component uses JSX syntax and functional components.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-outlining-dup-key-diff-value.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableJsxOutlining\nfunction Component({arr}) {\n  const x = useX();\n  return (\n    <>\n      {arr.map((i, id) => {\n        return (\n          <Bar key={id} x={x}>\n            <Baz i={i + 'i'}></Baz>\n            <Foo k={i + 'j'}></Foo>\n          </Bar>\n        );\n      })}\n    </>\n  );}\nfunction Bar({x, children}) {\n  return (\n    <>\n      {x}\n      {children}\n    </>\n  );\n}\n\nfunction Baz({i}) {\n  return i;\n}\n\nfunction Foo({k}) {\n  return k;\n}\n\nfunction useX() {\n  return 'x';\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{arr: ['foo', 'bar']}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Component Transformation with Compiler Runtime\nDESCRIPTION: This code shows the transformed version of the React component `Component` and its helper components using `react/compiler-runtime`. The `_c` function seems to be a core part of the compiler runtime, managing memoization and caching. The code optimizes the re-rendering of components by caching previous results based on prop changes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-outlining-child-stored-in-id.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enableJsxOutlining\nfunction Component(t0) {\n  const $ = _c(3);\n  const { arr } = t0;\n  const x = useX();\n  let t1;\n  if ($[0] !== arr || $[1] !== x) {\n    t1 = arr.map((i) => {\n      arr.map((i_0, id) => {\n        const T0 = _temp;\n        const child = <T0 i={i_0} x={x} />;\n\n        const jsx = <div>{child}</div>;\n        return jsx;\n      });\n    });\n    $[0] = arr;\n    $[1] = x;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  return t1;\n}\nfunction _temp(t0) {\n  const $ = _c(5);\n  const { i: i, x: x } = t0;\n  let t1;\n  if ($[0] !== i) {\n    t1 = <Baz i={i} />;\n    $[0] = i;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  let t2;\n  if ($[2] !== t1 || $[3] !== x) {\n    t2 = <Bar x={x}>{t1}</Bar>;\n    $[2] = t1;\n    $[3] = x;\n    $[4] = t2;\n  } else {\n    t2 = $[4];\n  }\n  return t2;\n}\n\nfunction Bar(t0) {\n  const $ = _c(3);\n  const { x, children } = t0;\n  let t1;\n  if ($[0] !== children || $[1] !== x) {\n    t1 = (\n      <>\n        {x}\n        {children}\n      </>\n    );\n    $[0] = children;\n    $[1] = x;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  return t1;\n}\n\nfunction Baz(t0) {\n  const $ = _c(2);\n  const { i } = t0;\n  let t1;\n  if ($[0] !== i) {\n    t1 = <>{i}</>;\n    $[0] = i;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n\nfunction useX() {\n  return \"x\";\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ arr: [\"foo\", \"bar\"] }],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Closure in JavaScript\nDESCRIPTION: This snippet defines a React component function that creates a closure to maintain access to a local variable. It also exports a FIXTURE_ENTRYPOINT object for testing or integration purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-variable-in-nested-function.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component(a) {\n  let z = {a};\n  let x = function () {\n    (function () {\n      console.log(z);\n    })();\n  };\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: React Component Definition\nDESCRIPTION: This snippet defines a React component `useFoo` that utilizes a `Stringify` component from `shared-runtime`. The component returns the result of invoking a callback function that renders the `Stringify` component with a value of 4. The component is then exported as `FIXTURE_ENTRYPOINT` for testing or usage.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-local-tag-in-lambda.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {Stringify} from 'shared-runtime';\nfunction useFoo() {\n  const MyLocal = Stringify;\n  const callback = () => {\n    return <MyLocal value={4} />;\n  };\n  return callback();\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Using Identity with Conditional Returns - JavaScript\nDESCRIPTION: Defines a function 'useFoo' that processes an input with a conditional check, utilizing 'identity' from a shared runtime. The function constructs an array based on conditions, interacting with external identity functions. Dependencies include 'shared-runtime'. Takes an object with 'input' and 'cond'. Returns null if 'cond' is true or an array derived from 'input'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-poisoned/return-poisons-outer-scope.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport {identity} from 'shared-runtime';\n\nfunction useFoo({input, cond}) {\n  const x = [];\n  if (cond) {\n    return null;\n  }\n  x.push(identity(input.a.b));\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{input: {a: {b: 2}}, cond: false}],\n  sequentialRenders: [\n    {input: {a: {b: 2}}, cond: false},\n    // preserve nullthrows\n    {input: null, cond: false},\n    {input: null, cond: true},\n    {input: {}, cond: false},\n    {input: {a: {b: null}}, cond: false},\n    {input: {a: null}, cond: false},\n    {input: {a: {b: 3}}, cond: false},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with Array Destructuring (Rest Operator)\nDESCRIPTION: Defines a React component `foo` that receives props and uses array destructuring with the rest operator to extract the first two elements and the rest into separate variables. The function returns the sum of the first two elements (x and y).\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unused-array-rest-element.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(props) {\n  const [x, y, ...z] = props.a;\n  return x + y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Optimization\nDESCRIPTION: Compiler-optimized version of the component using React's memo cache sentinel for performance optimization. Implements the same array transformation logic with caching mechanism.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-of-destructure.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component() {\n  const $ = _c(1);\n  let x;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    x = [];\n    const items = [{ v: 0 }, { v: 1 }, { v: 2 }];\n    for (const { v } of items) {\n      x.push(v * 2);\n    }\n    $[0] = x;\n  } else {\n    x = $[0];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: React useRef Access Error\nDESCRIPTION: This snippet shows an error message indicating that ref values (the `current` property) should not be accessed during render. The error occurs on line 13 of the component code.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.useCallback-set-ref-nested-property-dont-preserve-memoization.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n  11 |   });\n  12 |\n> 13 |   ref.current.inner = null;\n     |   ^^^^^^^^^^^ InvalidReact: Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef) (13:13)\n  14 |\n  15 |   return <input onChange={onChange} />;\n  16 | }\n```\n\n----------------------------------------\n\nTITLE: Input: Promoting Unconditional Access to Dependency in React\nDESCRIPTION: Original function that conditionally accesses nested properties. It demonstrates how React should promote the nearest unconditional access to a dependency when a conditional dependency (props.a.b.c) has no unconditional dependency in its subpath or superpath.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/promote-uncond.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// When a conditional dependency `props.a.b.c` has no unconditional dependency\n// in its subpath or superpath, we should find the nearest unconditional access\n\nimport {identity} from 'shared-runtime';\n\n// and promote it to an unconditional dependency.\nfunction usePromoteUnconditionalAccessToDependency(props, other) {\n  const x = {};\n  x.a = props.a.a.a;\n  if (identity(other)) {\n    x.c = props.a.b.c;\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: usePromoteUnconditionalAccessToDependency,\n  params: [{a: {a: {a: 3}}}, false],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Memoization (JavaScript)\nDESCRIPTION: This snippet shows an optimized version of the 'Foo' component using React's compiler runtime for memoization. It uses a Symbol-based caching mechanism to avoid unnecessary recalculations of the constant value.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/constant-prop-to-object-method.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { identity } from \"shared-runtime\";\n\nfunction Foo() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const x = {\n      foo() {\n        return identity(1);\n      },\n    };\n\n    t0 = x.foo();\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Hook with Optimizations\nDESCRIPTION: The compiled version of the hook with React compiler optimizations. Includes memoization logic to prevent unnecessary recomputation of makeArray calls and Set creation when inputs haven't changed.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/global-types/set-constructor.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { makeArray } from \"shared-runtime\";\n\nfunction useHook(t0) {\n  const $ = _c(7);\n  const { el1, el2 } = t0;\n  let s;\n  if ($[0] !== el1 || $[1] !== el2) {\n    s = new Set();\n    let t1;\n    if ($[3] !== el1) {\n      t1 = makeArray(el1);\n      $[3] = el1;\n      $[4] = t1;\n    } else {\n      t1 = $[4];\n    }\n    s.add(t1);\n    let t2;\n    if ($[5] !== el2) {\n      t2 = makeArray(el2);\n      $[5] = el2;\n      $[6] = t2;\n    } else {\n      t2 = $[6];\n    }\n    s.add(t2);\n    $[0] = el1;\n    $[1] = el2;\n    $[2] = s;\n  } else {\n    s = $[2];\n  }\n  return s.size;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useHook,\n  params: [{ el1: 1, el2: \"foo\" }],\n  sequentialRenders: [\n    { el1: 1, el2: \"foo\" },\n    { el1: 2, el2: \"foo\" },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: React useState Hook Used Conditionally\nDESCRIPTION: This React component attempts to use the `useState` hook conditionally based on the `props.cond` value. This is an anti-pattern in React, as hooks must be called in the same order on every render. The expected input is a React component with a `cond` prop, and the output is a potential render with an error due to the conditional hook usage.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-conditional-call-aliased-react-hook.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useState as state} from 'react';\n\nfunction Component(props) {\n  let s;\n  if (props.cond) {\n    [s] = state();\n  }\n  return s;\n}\n\n```\n\n----------------------------------------\n\nTITLE: React Hook: Using a Hook Within Another Hook (JavaScript) - Repeated Code\nDESCRIPTION: This code snippet, identical to the previous one, demonstrates a valid React custom hook, `useHookWithHook`, which internally calls another hook, `useHook`.  This pattern is permitted and allows for the composition of hook logic. The assumption is that `useHook` is a previously defined hook in the same scope or imported from elsewhere.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-844a496db20b.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// Valid because hooks can use hooks.\nfunction useHookWithHook() {\n  useHook();\n}\n\n```\n\n----------------------------------------\n\nTITLE: Utilizing Optional Chaining in React Component - JavaScript\nDESCRIPTION: This code sample shows a React component function making use of optional chaining for safe property access within a JavaScript object. It expects 'a' to be declared in outer scope and its structure 'a?.b.c[0]' to potentially provide the desired value or undefined. Optional chaining requires compatibility with ES2020 or higher.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-computed-load-static.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const x = a?.b.c[0];\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Using Compiler Runtime for React Optimizations\nDESCRIPTION: This snippet uses the React compiler runtime to optimize component rendering. It implements a comparison-based rendering approach to prevent unnecessary re-renders by checking previous prop values and state before updating the local variables and the JSX output.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/same-variable-as-dep-and-redeclare.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // note: comments are for the ideal scopes, not what is currently\n// emitted\nfunction foo(props) {\n  const $ = _c(14);\n  let t0;\n  let x;\n  if ($[0] !== props.a) {\n    x = [];\n    x.push(props.a);\n\n    t0 = <div>{x}</div>;\n    $[0] = props.a;\n    $[1] = t0;\n    $[2] = x;\n  } else {\n    t0 = $[1];\n    x = $[2];\n  }\n  const header = t0;\n  let y;\n  if ($[3] !== props.b || $[4] !== props.c || $[5] !== x) {\n    y = [x];\n    x = [];\n    y.push(props.b);\n    x.push(props.c);\n    $[3] = props.b;\n    $[4] = props.c;\n    $[5] = x;\n    $[6] = y;\n    $[7] = x;\n  } else {\n    y = $[6];\n    x = $[7];\n  }\n  let t1;\n  if ($[8] !== x || $[9] !== y) {\n    t1 = (\n      <div>\n        {x}\n        {y}\n      </div>\n    );\n    $[8] = x;\n    $[9] = y;\n    $[10] = t1;\n  } else {\n    t1 = $[10];\n  }\n  const content = t1;\n  let t2;\n  if ($[11] !== content || $[12] !== header) {\n    t2 = (\n      <>\n        {header}\n        {content}\n      </>\n    );\n    $[11] = content;\n    $[12] = header;\n    $[13] = t2;\n  } else {\n    t2 = $[13];\n  }\n  return t2;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized VideoTab with React Compiler Runtime Memoization\nDESCRIPTION: An enhanced version of the VideoTab component using React's compiler runtime for memoization, with cached rendering and Symbol-based memo sentinel\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ref-current-write-not-added-to-dep.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction VideoTab() {\n  const $ = _c(1);\n  const ref = useRef();\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const x = () => {\n      ref.current = 1;\n    };\n\n    t0 = <VideoList videos={x} />;\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with Test Fixture\nDESCRIPTION: Defines a React component that processes props and exports a test fixture configuration. The component performs conditional rendering based on props.a, props.b and props.c values.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/escape-analysis-not-conditional-test.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const x = [props.a];\n  const y = x ? props.b : props.c;\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const x = [props.a];\n  const y = x ? props.b : props.c;\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Memoized React Component with Compiler Runtime\nDESCRIPTION: A React component that uses compiler runtime memoization to cache and reuse rendered Button components based on prop changes. The component implements a manual memoization check using an array to store previous prop values and rendered results.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/apps/playground/__tests__/e2e/__snapshots__/page.spec.ts/module-scope-use-memo-output.txt#2025-04-21_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\n\"use memo\";\nimport { c as _c } from \"react/compiler-runtime\";\nexport default function TestComponent(t0) {\n  const $ = _c(2);\n  const { x } = t0;\n  let t1;\n  if ($[0] !== x) {\n    t1 = <Button>{x}</Button>;\n    $[0] = x;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Component with Optimized Checks - JavaScript\nDESCRIPTION: This snippet introduces a more optimized version of the previous component, utilizing React's compiler runtime for internal state management. It contains a block control statement to check and update the state based on conditions. Like the previous snippet, it also exports the same FIXTURE_ENTRYPOINT, providing configuration options for the component with specific parameters and an identifier.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-inlining-block-return.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction component(a, b) {\n  const $ = _c(2);\n  let t0;\n  bb0: {\n    if (a) {\n      let t1;\n      if ($[0] !== b) {\n        t1 = { b };\n        $[0] = b;\n        $[1] = t1;\n      } else {\n        t1 = $[1];\n      }\n      t0 = t1;\n      break bb0;\n    }\n    t0 = undefined;\n  }\n  const x = t0;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining a React Component\nDESCRIPTION: This snippet defines a simple React component that receives props and returns an array containing an empty object and a prop value. The component is then exported as part of the FIXTURE_ENTRYPOINT object, which also includes sample parameter values. It demonstrates a basic component structure.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-dependency-nonreactive-captured-with-reactive.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const x = {};\n  const y = props.y;\n  return [x, y]; // x is captured here along with a reactive value. this shouldn't make `x` reactive!\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{y: 42}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Optimization\nDESCRIPTION: Compiled and optimized version of the React component with memoization and caching logic implemented through compiler runtime. Includes optimized fragment handling and event callback memoization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-mixed-scope-declarations-and-locals.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useFragment } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(4);\n  const post = useFragment(\n    graphql`\n      fragment F on T {\n        id\n      }\n    `,\n    props.post,\n  );\n  let t0;\n  if ($[0] !== post) {\n    const allUrls = [];\n\n    const { media, comments, urls } = post;\n    let t1;\n    if ($[2] !== comments.length) {\n      t1 = (e) => {\n        if (!comments.length) {\n          return;\n        }\n\n        console.log(comments.length);\n      };\n      $[2] = comments.length;\n      $[3] = t1;\n    } else {\n      t1 = $[3];\n    }\n    const onClick = t1;\n\n    allUrls.push(...urls);\n    t0 = <Media media={media} onClick={onClick} />;\n    $[0] = post;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n```\n\n----------------------------------------\n\nTITLE: Transpiled React Component Implementation\nDESCRIPTION: This snippet shows the transpiled version of the React component function. It handles the array destructuring and default parameter logic explicitly, making it compatible with environments that don't support these ES6 features natively.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-array-param-default.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(t0) {\n  const [t1] = t0;\n  const a = t1 === undefined ? 2 : t1;\n  return a;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React forwardRef with Hooks and Compiler\nDESCRIPTION: This code shows an optimized version of the `FancyButton` component, utilizing React's compiler-runtime (`_c`) for memoization. The component checks if the props or ref have changed before re-rendering the button. This optimization avoids unnecessary re-renders and improves performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-e66a744cffbe.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // Valid because hooks can be used in anonymous function arguments to\n// forwardRef.\nconst FancyButton = forwardRef(function (props, ref) {\n  const $ = _c(3);\n  useHook();\n  let t0;\n  if ($[0] !== props || $[1] !== ref) {\n    t0 = <button {...props} ref={ref} />;\n    $[0] = props;\n    $[1] = ref;\n    $[2] = t0;\n  } else {\n    t0 = $[2];\n  }\n  return t0;\n});\n\n```\n\n----------------------------------------\n\nTITLE: React Component with Local Reassignment\nDESCRIPTION: This React component defines a local variable `local` and a function `reassignLocal` that attempts to reassign its value. The `onClick` handler calls `reassignLocal` and then checks if the reassignment was successful. The purpose is to demonstrate an issue with React's rendering behavior when reassigning local variables in functions that escape.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-reassign-local-variable-in-jsx-callback.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component() {\n  let local;\n\n  const reassignLocal = newValue => {\n    local = newValue;\n  };\n\n  const onClick = newValue => {\n    reassignLocal('hello');\n\n    if (local === newValue) {\n      // Without React Compiler, `reassignLocal` is freshly created\n      // on each render, capturing a binding to the latest `local`,\n      // such that invoking reassignLocal will reassign the same\n      // binding that we are observing in the if condition, and\n      // we reach this branch\n      console.log('`local` was updated!');\n    } else {\n      // With React Compiler enabled, `reassignLocal` is only created\n      // once, capturing a binding to `local` in that render pass.\n      // Therefore, calling `reassignLocal` will reassign the wrong\n      // version of `local`, and not update the binding we are checking\n      // in the if condition.\n      //\n      // To protect against this, we disallow reassigning locals from\n      // functions that escape\n      throw new Error('`local` not updated!');\n    }\n  };\n\n  return <button onClick={onClick}>Submit</button>;\n}\n```\n\n----------------------------------------\n\nTITLE: Error Message for Invalid React State Update\nDESCRIPTION: This error message is generated when the React component attempts to unconditionally set state during render. It points to the specific line causing the issue and provides a link to the React documentation for further information.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.unconditional-set-state-in-render-after-loop-break.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n   9 |     }\n  10 |   }\n> 11 |   setState(true);\n     |   ^^^^^^^^ InvalidReact: This is an unconditional set state during render, which will trigger an infinite loop. (https://react.dev/reference/react/useState) (11:11)\n  12 |   return state;\n  13 | }\n  14 |\n```\n\n----------------------------------------\n\nTITLE: React Component with Event Firing\nDESCRIPTION: This snippet shows a React component that imports a 'fire' function (presumably custom) and uses it within a useEffect hook to trigger a function ('foo') with the component's props. The 'foo' function simply logs the props to the console. The intent is to execute 'foo' as a side effect when the component mounts or when props change.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/basic.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableFire\nimport {fire} from 'react';\n\nfunction Component(props) {\n  const foo = props => {\n    console.log(props);\n  };\n  useEffect(() => {\n    fire(foo(props));\n  });\n\n  return null;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Checking Bridge Protocol Version Compatibility in React DevTools\nDESCRIPTION: During initialization, DevTools checks if it's compatible with the backend embedded in renderers like React Native. If incompatible, upgrade instructions are shown.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/CHANGELOG.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Example usage:\nDevTools.initialize({\n  // ...\n  checkBridgeProtocolVersion: true\n});\n```\n\n----------------------------------------\n\nTITLE: Compiled React Hook with Memoization Optimization\nDESCRIPTION: The compiler-optimized version of useFoo that implements memoization using React's memo cache sentinel. Adds caching for both the Set creation and spread operation results.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/global-types/call-spread-argument-set.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useIdentity } from \"shared-runtime\";\n\n/**\n * Forked version of call-spread-argument-mutable-iterator that is known to not mutate\n * the spread argument since it is a Set\n */\nfunction useFoo() {\n  const $ = _c(2);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = new Set([1, 2]);\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const s = t0;\n  useIdentity(null);\n  let t1;\n  if ($[1] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = [Math.max(...s), s];\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{}],\n  sequentialRenders: [{}, {}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Conditional Items in React Component - JavaScript\nDESCRIPTION: This snippet defines a React component that initializes an array based on the condition passed through props. It utilizes optional chaining to manipulate the array, allowing elements to be pushed conditionally based on the prop's availability.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/iife-return-modified-later-phi.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enablePropagateDepsInHIR\nfunction Component(props) {\n  const items = (() => {\n    if (props.cond) {\n      return [];\n    } else {\n      return null;\n    }\n  })();\n  items?.push(props.a);\n  return items;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{a: {}}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization Cache\nDESCRIPTION: The compiled version of the React components with memoization cache implementation. Uses compiler runtime utilities to optimize rendering and maintain memoization state.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/use-operator-call-expression.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { ValidateMemoization } from \"shared-runtime\";\nimport { use, useMemo } from \"react\";\n\nconst FooContext = React.createContext(null);\nfunction Component(props) {\n  const $ = _c(3);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = <Inner />;\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  let t1;\n  if ($[1] !== props.value) {\n    t1 = <FooContext.Provider value={props.value}>{t0}</FooContext.Provider>;\n    $[1] = props.value;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  return t1;\n}\n\nfunction Inner(props) {\n  const $ = _c(7);\n  const input = use(FooContext);\n  let t0;\n  let t1;\n  if ($[0] !== input) {\n    t1 = [input];\n    $[0] = input;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  t0 = t1;\n  const output = t0;\n  let t2;\n  if ($[2] !== input) {\n    t2 = [input];\n    $[2] = input;\n    $[3] = t2;\n  } else {\n    t2 = $[3];\n  }\n  let t3;\n  if ($[4] !== output || $[5] !== t2) {\n    t3 = <ValidateMemoization inputs={t2} output={output} />;\n    $[4] = output;\n    $[5] = t2;\n    $[6] = t3;\n  } else {\n    t3 = $[6];\n  }\n  return t3;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ value: 42 }],\n  sequentialRenders: [\n    { value: null },\n    { value: 42 },\n    { value: 42 },\n    { value: null },\n    { value: null },\n    { value: 42 },\n    { value: null },\n    { value: 42 },\n    { value: null },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with idx macro usage\nDESCRIPTION: This code defines a React component that uses a custom `idx` macro to access nested properties within the `props` object. It demonstrates both outlined and not outlined usages of the `idx` macro. The purpose is to show the original component structure before the transformation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/idx-method-no-outlining.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n```javascript\n// @customMacros(idx.a)\n\nfunction Component(props) {\n  // outlined\n  const groupName1 = idx(props, _ => _.group.label);\n  // not outlined\n  const groupName2 = idx.a(props, _ => _.group.label);\n  // outlined\n  const groupName3 = idx.a.b(props, _ => _.group.label);\n  return (\n    <div>\n      {groupName1}\n      {groupName2}\n      {groupName3}\n    </div>\n  );\n}\n\n```\n```\n\n----------------------------------------\n\nTITLE: Original React Hook Implementation\nDESCRIPTION: Implements a custom React hook that creates a Set from two array elements using makeArray utility. Takes two parameters el1 and el2, converts them to arrays, and returns the size of the resulting Set.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/global-types/set-constructor.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {makeArray} from 'shared-runtime';\n\nfunction useHook({el1, el2}) {\n  const s = new Set();\n  s.add(makeArray(el1));\n  s.add(makeArray(el2));\n  return s.size;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useHook,\n  params: [{el1: 1, el2: 'foo'}],\n  sequentialRenders: [\n    {el1: 1, el2: 'foo'},\n    {el1: 2, el2: 'foo'},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Optimizations\nDESCRIPTION: The transformed component after React's compiler processing. It includes cache sentinel values, memoization of computations, and tracking of dependency changes to optimize rendering performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/partial-early-return-within-reactive-scope.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(6);\n  let t0;\n  let y;\n  if ($[0] !== props.a || $[1] !== props.b || $[2] !== props.cond) {\n    t0 = Symbol.for(\"react.early_return_sentinel\");\n    bb0: {\n      const x = [];\n      if (props.cond) {\n        x.push(props.a);\n        t0 = x;\n        break bb0;\n      } else {\n        let t1;\n        if ($[5] === Symbol.for(\"react.memo_cache_sentinel\")) {\n          t1 = foo();\n          $[5] = t1;\n        } else {\n          t1 = $[5];\n        }\n        y = t1;\n        if (props.b) {\n          t0 = undefined;\n          break bb0;\n        }\n      }\n    }\n    $[0] = props.a;\n    $[1] = props.b;\n    $[2] = props.cond;\n    $[3] = t0;\n    $[4] = y;\n  } else {\n    t0 = $[3];\n    y = $[4];\n  }\n  if (t0 !== Symbol.for(\"react.early_return_sentinel\")) {\n    return t0;\n  }\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ cond: true, a: 42 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Caching\nDESCRIPTION: Compiled version of the component with added caching logic using React compiler runtime. Implements memoization for object creation and function references.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-variable-in-nested-block.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction component(a) {\n  const $ = _c(4);\n  let t0;\n  if ($[0] !== a) {\n    t0 = { a };\n    $[0] = a;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const z = t0;\n  let t1;\n  if ($[2] !== z) {\n    t1 = function () {\n      console.log(z);\n    };\n    $[2] = z;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  const x = t1;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Input React Hook Implementation\nDESCRIPTION: Original source code for a React custom hook that handles numerical arguments and conditional array manipulation. Uses identity and useIdentity hooks from shared runtime with TypeScript-style type annotations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/infer-non-null-destructure.expect.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enablePropagateDepsInHIR\nimport {identity, useIdentity} from 'shared-runtime';\n\nfunction useFoo({arg, cond}: {arg: number; cond: boolean}) {\n  const maybeObj = useIdentity({value: arg});\n  const {value} = maybeObj;\n  useIdentity(null);\n  /**\n   * maybeObj.value should be inferred as the dependency of this scope\n   * since we know that maybeObj is safe to read from (i.e. non-null)\n   * due to the above destructuring instruction\n   */\n  const arr = [];\n  if (cond) {\n    arr.push(identity(maybeObj.value));\n  }\n  return {arr, value};\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{arg: 2, cond: false}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Component and Fixture Entrypoint in JavaScript\nDESCRIPTION: This JavaScript snippet defines a function component that takes an input, modifies an object using a closure, and employs a mutation function from a shared runtime. It sets up the component for testing or further integration by exporting the function alongside parameters as FIXTURE_ENTRYPOINT. The snippet is dependent on the 'shared-runtime' for the mutate function. The function accepts a parameter 'a', constructs a mutable object, and returns it. The code snippet is intended for environments where advanced manipulation of state is needed.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-alias-receiver-computed-mutate-iife.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {mutate} from 'shared-runtime';\n\nfunction component(a) {\n  let x = {a};\n  let y = {};\n  (function () {\n    let a = y;\n    a['x'] = x;\n  })();\n  mutate(y);\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: ['foo'],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Invalid Conditional Hook Usage in React Component\nDESCRIPTION: Example of incorrect React Hook implementation where useHook() is called conditionally inside an else block. This violates React's Rules of Hooks which require hooks to be called in the same order on every render.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-hook-if-alternate.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let x = null;\n  if (props.cond) {\n  } else {\n    x = useHook();\n  }\n  return x;\n}\n```\n\nLANGUAGE: text\nCODE:\n```\n  3 |   if (props.cond) {\n  4 |   } else {\n> 5 |     x = useHook();\n    |         ^^^^^^^ InvalidReact: Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning) (5:5)\n  6 |   }\n  7 |   return x;\n  8 | }\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Optimization\nDESCRIPTION: Compiler-optimized version of the component using React's compiler runtime for state management. Implements caching mechanism to avoid redundant calculations and maintain state consistency.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/context-variable-reassigned-objectmethod.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { invoke } from \"shared-runtime\";\n\nfunction Component(t0) {\n  const $ = _c(2);\n  const { cond } = t0;\n  let x;\n  if ($[0] !== cond) {\n    x = 2;\n    const obj = {\n      method(cond_0) {\n        if (cond_0) {\n          x = 4;\n        }\n      },\n    };\n\n    invoke(obj.method, cond);\n    $[0] = cond;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ cond: true }],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component Definition\nDESCRIPTION: This code defines a React component that takes a single argument 'a'. Inside the component, it creates an object 'z' with 'a' as a property and a function 'x' that logs the value of 'z'. The component then returns the function 'x'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-1.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component(a) {\n  let z = {a};\n  let x = function () {\n    console.log(z);\n  };\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: A React component that takes a value prop, stores it in an array, and renders it within a span element inside a clickable div. Uses useEffect hook and includes click handling functionality.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-memoize-array-with-immutable-map-after-hook.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useEffect, useState} from 'react';\n\nfunction Component(props) {\n  const x = [props.value];\n  useEffect(() => {}, []);\n  const onClick = () => {\n    console.log(x.length);\n  };\n  return (\n    <div onClick={onClick}>\n      {x.map(item => {\n        return <span key={item}>{item}</span>;\n      })}\n    </div>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: 42}],\n  isComponent: true,\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Compiler Runtime\nDESCRIPTION: This code snippet represents the compiled version of the `List` component using React's compiler runtime (`_c`).  It demonstrates how the React compiler handles the rendering of list items, including memoization of the rendered items. The `_c` function likely handles memoization, preventing re-renders when the `items` prop hasn't changed.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.invalid.invalid-rules-of-hooks-e675f0a672d8.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @skip\n// Passed but should have failed\n\n// Invalid because it's dangerous and might not warn otherwise.\n// This *must* be invalid.\nfunction renderItem() {\n  useState();\n}\n\nfunction List(props) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== props.items) {\n    t0 = props.items.map(renderItem);\n    $[0] = props.items;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Runtime Optimizations\nDESCRIPTION: The transformed version of the component using React compiler runtime. Shows memoization and optimization techniques including cache sentinel checks and state management optimizations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/nested-function-shadowed-identifiers.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(3);\n  const [x, setX] = useState(null);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = (e) => {\n      setX(_temp);\n    };\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const onChange = t0;\n  let t1;\n  if ($[1] !== x) {\n    t1 = <input value={x} onChange={onChange} />;\n    $[1] = x;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  return t1;\n}\nfunction _temp(currentX) {\n  return currentX + null;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized VideoTab Component with Compiler Runtime\nDESCRIPTION: An enhanced version of the VideoTab component using React compiler runtime for memoization and caching, with explicit caching logic and Symbol-based cache management\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ref-current-not-added-to-dep.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction VideoTab() {\n  const $ = _c(1);\n  const ref = useRef();\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const x = () => {\n      console.log(ref.current);\n    };\n\n    t0 = <VideoList videos={x} />;\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n```\n\n----------------------------------------\n\nTITLE: React Compiler Error with Fire Usage\nDESCRIPTION: This error message indicates that the `fire` function call was not transformed by the compiler, likely because it's a compiler-required feature and the transformation process failed. The error message suggests either removing the `fire` call or ensuring successful transformation by the compiler. This typically involves configuring the build process to correctly handle the `fire` function.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/bailout-retry/error.use-no-memo.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n  13 |   };\n  14 |   useEffect(() => {\n> 15 |     fire(foo(props));\n     |     ^^^^ InvalidReact: [Fire] Untransformed reference to compiler-required feature. Either remove this `fire` call or ensure it is successfully transformed by the compiler (15:15)\n  16 |     fire(foo());\n  17 |     fire(bar());\n  18 |   });\n\n```\n\n----------------------------------------\n\nTITLE: React Test Fixture for Component Rendering Scenarios\nDESCRIPTION: Test fixture defining multiple render scenarios to validate React compiler's memoization and function tracking behavior across different input states\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/array-map-named-callback-cross-context.expect.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{arr1: [], arr2: []}],\n  sequentialRenders: [\n    {arr1: [], arr2: []},\n    {arr1: [], arr2: null},\n    {arr1: [{value: 1}, {value: 2}], arr2: [{value: -1}]},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled useMemo Hook with React Compiler\nDESCRIPTION: This is the compiled version of the `useFoo` hook using `react/compiler-runtime`. It optimizes the `useMemo` call by potentially reducing the dependency list. The compiler replaces the standard `useMemo` with a custom `_c` function that manages the memoization cache.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useMemo-infer-fewer-deps.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @validatePreserveExistingMemoizationGuarantees\n\nimport { useMemo } from \"react\";\n\n// It's correct to produce memo blocks with fewer deps than source\nfunction useFoo(a, b) {\n  const $ = _c(2);\n  let t0;\n  let t1;\n  if ($[0] !== a) {\n    t1 = [a];\n    $[0] = a;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  t0 = t1;\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [1, 2],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Rendering React Component without Compiler Runtime - JavaScript\nDESCRIPTION: Defines a basic React component that initializes and renders elements using arrays and objects without involving any compiler runtime. It highlights a simple approach to component rendering that involves invoking a 'foo' function.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-call-jsx-2.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @Pass runMutableRangeAnalysis\nfunction foo() {}\n\nfunction Component(props) {\n  const a = [];\n  const b = {};\n  foo(a, b);\n  if (foo()) {\n    let _ = <div a={a} />;\n  }\n  foo(a, b);\n  return <div a={a} b={b} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Validating JSX Usage in React Component\nDESCRIPTION: This JavaScript code snippet demonstrates a React component where JSX is used inside a try statement. It attempts to validate if JSX usage within try statements is allowed or not. This snippet shows a basic React component implementation where JSX is used, and errors can potentially be thrown if the pattern is disallowed.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-invalid-jsx-in-try-with-finally.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\n// @validateNoJSXInTryStatements\nfunction Component(props) {\n  let el;\n  try {\n    el = <div />;\n  } finally {\n    console.log(el);\n  }\n  return el;\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled: Optimized React Component with Compiler Runtime\nDESCRIPTION: Compiler-transformed version of the React component using React compiler runtime. Implements memoization and optimized event handling with conditional state tracking.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/repeated-calls.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c, useFire } from \"react/compiler-runtime\"; // @enableFire\nimport { fire } from \"react\";\n\nfunction Component(props) {\n  const $ = _c(5);\n  let t0;\n  if ($[0] !== props) {\n    t0 = () => {\n      console.log(props);\n    };\n    $[0] = props;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const foo = t0;\n  const t1 = useFire(foo);\n  let t2;\n  if ($[2] !== props || $[3] !== t1) {\n    t2 = () => {\n      t1(props);\n      t1(props);\n    };\n    $[2] = props;\n    $[3] = t1;\n    $[4] = t2;\n  } else {\n    t2 = $[4];\n  }\n  useEffect(t2);\n  return null;\n}\n```\n\n----------------------------------------\n\nTITLE: React Component Definition with Destructuring\nDESCRIPTION: This code defines a React component named 'Foo' that receives props. It destructures the 'a' property of props to extract 'x'. The component then returns the value of 'x'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unused-object-element.expect.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Foo(props) {\n  const { x } = props.a;\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Enhanced Custom Hook with State Management - JavaScript\nDESCRIPTION: This snippet enhances the previous 'useHook' function by including internal state management using a closure. It checks if the passed props are different from the previous inputs and uses caching to improve performance by returning earlier results when appropriate. It also utilizes the same 'setProperty' function to combine results.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-method-maybe-alias.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { createHookWrapper, setProperty } from \"shared-runtime\";\nfunction useHook(props) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== props) {\n    const x = {\n      getX() {\n        return props;\n      },\n    };\n\n    const y = {\n      getY() {\n        return \"y\";\n      },\n    };\n\n    t0 = setProperty(x, y);\n    $[0] = props;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: createHookWrapper(useHook),\n  params: [{ value: 0 }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Component with Compiler Optimization\nDESCRIPTION: This code defines a React component named `Component` that conditionally returns an array, optimized using the React compiler. It uses `_c` from `react/compiler-runtime` for memoization. If the props `a`, `b`, or `cond` change, it re-computes the return value, otherwise using a cached version.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/early-return-within-reactive-scope.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { makeArray } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(6);\n  let t0;\n  if ($[0] !== props.a || $[1] !== props.b || $[2] !== props.cond) {\n    t0 = Symbol.for(\"react.early_return_sentinel\");\n    bb0: {\n      const x = [];\n      if (props.cond) {\n        x.push(props.a);\n        t0 = x;\n        break bb0;\n      } else {\n        let t1;\n        if ($[4] !== props.b) {\n          t1 = makeArray(props.b);\n          $[4] = props.b;\n          $[5] = t1;\n        } else {\n          t1 = $[5];\n        }\n        t0 = t1;\n        break bb0;\n      }\n    }\n    $[0] = props.a;\n    $[1] = props.b;\n    $[2] = props.cond;\n    $[3] = t0;\n  } else {\n    t0 = $[3];\n  }\n  if (t0 !== Symbol.for(\"react.early_return_sentinel\")) {\n    return t0;\n  }\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  sequentialRenders: [\n    // pattern 1\n    { cond: true, a: 42 },\n    { cond: true, a: 42 },\n    // pattern 2\n    { cond: false, b: 3.14 },\n    { cond: false, b: 3.14 },\n    // pattern 1\n    { cond: true, a: 42 },\n    // pattern 2\n    { cond: false, b: 3.14 },\n    // pattern 1\n    { cond: true, a: 42 },\n    // pattern 2\n    { cond: false, b: 3.14 },\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Optimized Custom Hook and Component with React Compiler - JavaScript\nDESCRIPTION: This snippet showcases a similar component but uses a compiler runtime optimization, with react's memos and caching. The custom hook and component Foo are enhanced to cache objects and reuse them to leverage memoization for optimized re-renders. It requires that the react/compiler-runtime is available for _c function used in memoization. This snippet is intended to demonstrate advanced optimization using compiler-level hooks in React.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ref-like-name-in-useCallback-2.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enableTreatRefLikeIdentifiersAsRefs @validatePreserveExistingMemoizationGuarantees\\nimport { useRef, useCallback } from \"react\";\\n\\nfunction useCustomRef() {\\n  const $ = _c(1);\\n  let t0;\\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\\n    t0 = { click: _temp };\\n    $[0] = t0;\\n  } else {\\n    t0 = $[0];\\n  }\\n  return useRef(t0);\\n}\\nfunction _temp() {}\\n\\nfunction Foo() {\\n  const $ = _c(2);\\n  const ref = useCustomRef();\\n  let t0;\\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\\n    t0 = () => {\\n      ref.current?.click();\\n    };\\n    $[0] = t0;\\n  } else {\\n    t0 = $[0];\\n  }\\n  const onClick = t0;\\n  let t1;\\n  if ($[1] === Symbol.for(\"react.memo_cache_sentinel\")) {\\n    t1 = <button onClick={onClick} />;\\n    $[1] = t1;\\n  } else {\\n    t1 = $[1];\\n  }\\n  return t1;\\n}\\n\\nexport const FIXTURE_ENTRYPOINT = {\\n  fn: Foo,\\n  params: [],\\n  isComponent: true,\\n};\n```\n\n----------------------------------------\n\nTITLE: Using Shared Runtime with Component in JavaScript\nDESCRIPTION: This JavaScript snippet defines a React functional component using hooks and functions from 'shared-runtime'. It imports 'useIdentity' and 'Stringify' to manipulate and display an array derived from a passed value. The component demonstrates the non-mutating use of 'Array.from'. The snippet includes an exported entry point to instantiate the component with various initial states.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-from-captures-arg0.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useIdentity, Stringify} from 'shared-runtime';\n\n/**\n * TODO: Note that this `Array.from` is inferred to be mutating its first\n * argument. This is because React Compiler's typing system does not yet support\n * annotating a function with a set of argument match cases + distinct\n * definitions (polymorphism)\n *\n * In this case, we should be able to infer that the `Array.from` call is\n * not mutating its 0th argument.\n * The 0th argument should be typed as having `effect:Mutate` only when\n * (1) it might be a mutable iterable or\n * (2) the 1st argument might mutate its callee\n */\nfunction Component({value}) {\n  const arr = [{value: 'foo'}, {value: 'bar'}, {value}];\n  useIdentity();\n  const derived = Array.from(arr);\n  return <Stringify>{derived.at(-1)}</Stringify>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: 5}],\n  sequentialRenders: [{value: 5}, {value: 6}, {value: 6}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Exporting Simple Function as Fixture Entrypoint in JavaScript\nDESCRIPTION: This snippet initializes and exports an object 'FIXTURE_ENTRYPOINT' in JavaScript after defining a function 'f' which simply returns the integer 1. The object has properties for the function, parameter list, and a boolean indicating if it's a component. This showcases basic function definition and export syntax in JavaScript, highlighting the export of simple default return functions.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/assignment-variations.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction f() {\n  return 1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: f,\n  params: [],\n  isComponent: false,\n};\n\n```\n\n----------------------------------------\n\nTITLE: Using Conditional Hook in React JavaScript Component\nDESCRIPTION: This snippet demonstrates an improper usage of a hook called conditionally within a React component. It requires a conditional check ('cond') and uses the 'Namespace.useConditionalHook' function. The primary focus is to showcase an invalid pattern for hooks in React, which must always be used unconditionally at the top level of a React function component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.error.invalid-rules-of-hooks-a0058f0b446d.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @skip\n// Passed but should have failed\n\n// Invalid because it's dangerous and might not warn otherwise.\n// This *must* be invalid.\nfunction ComponentWithConditionalHook() {\n  if (cond) {\n    Namespace.useConditionalHook();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Function with Object Destructuring in JavaScript\nDESCRIPTION: This snippet defines a function 'foo' that uses object destructuring in its parameter to extract the 'data' property and rename it to 'dataTestID'. It also exports a constant 'FIXTURE_ENTRYPOINT' with the function and its parameters.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructure-param-string-literal-key.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo({data: dataTestID}) {\n  return dataTestID;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [{data: {}}],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Optimized React Component in JavaScript\nDESCRIPTION: This code snippet demonstrates an optimized React component leveraging compiler runtime utilities. It avoids unnecessary recomputation by retaining previously computed values in a cache. The component directly manipulates internal state based on value comparison and sharing, optimizing performance for repeated renders. Dependencies include `react` and `react/compiler-runtime`.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/drop-methodcall-usememo.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport * as React from \"react\";\n\nfunction Component(props) {\n  const $ = _c(2);\n  let t0;\n  let x;\n  if ($[0] !== props.value) {\n    x = [];\n    x.push(props.value);\n    $[0] = props.value;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  t0 = x;\n  const x_0 = t0;\n  return x_0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ value: 42 }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Optimizing HomeDiscoStoreItemTileRating Component with Compiler-Generated Code\nDESCRIPTION: This snippet demonstrates the optimized version of the HomeDiscoStoreItemTileRating component. It uses compiler-generated code to implement memoization and conditional rendering, potentially improving performance by avoiding unnecessary recalculations and re-renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-scope-missing-mutable-range.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction HomeDiscoStoreItemTileRating(props) {\n  const $ = _c(4);\n  const item = useFragment();\n  let count;\n  if ($[0] !== item?.aggregates) {\n    count = 0;\n    const aggregates = item?.aggregates || [];\n    aggregates.forEach((aggregate) => {\n      count = count + (aggregate.count || 0);\n      count;\n    });\n    $[0] = item?.aggregates;\n    $[1] = count;\n  } else {\n    count = $[1];\n  }\n  let t0;\n  if ($[2] !== count) {\n    t0 = <Text>{count}</Text>;\n    $[2] = count;\n    $[3] = t0;\n  } else {\n    t0 = $[3];\n  }\n  return t0;\n}\n```\n\n----------------------------------------\n\nTITLE: React Fixture Entrypoint Configuration\nDESCRIPTION: Test fixture defining the function, initial parameters, and sequential rendering scenarios for the compiler transformation\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/infer-nested-function-uncond-access-local-var.expect.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ a: null }],\n  sequentialRenders: [{ a: null }, { a: { b: { c: 4 } } }]\n};\n```\n\n----------------------------------------\n\nTITLE: Creating Memoized Component Function with Original Implementation\nDESCRIPTION: A basic function component that creates an object and returns a closure function. Shows the initial implementation before compiler optimization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/prop-capturing-function-1.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component(a, b) {\n  let z = {a, b};\n  let x = function () {\n    console.log(z);\n  };\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Re-Implementing useFoo with React Compiler Runtime\nDESCRIPTION: This code imports '_c' from 'react/compiler-runtime' and re-defines the function 'useFoo' with added state tracking using '_c' to track changes and optimize array assembly operations. The implementation targets efficient conditional processing dependent on input changes with emphasis on object referencing and avoiding unnecessary computations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-unpoisoned/throw-before-scope-starts.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { arrayPush } from \"shared-runtime\";\n\nfunction useFoo(t0) {\n  const $ = _c(2);\n  const { input, cond } = t0;\n  if (cond) {\n    throw new Error(\"throw with error!\");\n  }\n  let x;\n  if ($[0] !== input.a.b) {\n    x = [];\n    arrayPush(x, input.a.b);\n    $[0] = input.a.b;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ input: { a: { b: 2 } }, cond: false }],\n  sequentialRenders: [\n    { input: null, cond: true },\n    { input: { a: { b: 2 } }, cond: false },\n    { input: null, cond: true },\n    // preserve nullthrows\n    { input: {}, cond: false },\n    { input: { a: { b: null } }, cond: false },\n    { input: { a: null }, cond: false },\n    { input: { a: { b: 3 } }, cond: false },\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiler-Transformed React Component with Memoization Logic\nDESCRIPTION: The compiler-optimized version of the React component that implements memoization logic explicitly. It uses a cache array to store computed values and dependencies, avoiding unnecessary recalculations when inputs haven't changed. This demonstrates how React's compiler transforms useMemo hooks.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-modify-global-in-callback-jsx.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useMemo } from \"react\";\n\nconst someGlobal = { value: 0 };\n\nfunction Component(t0) {\n  const $ = _c(4);\n  const { value } = t0;\n  let t1;\n  if ($[0] !== value) {\n    t1 = () => {\n      someGlobal.value = value;\n    };\n    $[0] = value;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  const onClick = t1;\n  let t2;\n  let t3;\n  if ($[2] !== onClick) {\n    t3 = <div onClick={onClick}>{someGlobal.value}</div>;\n    $[2] = onClick;\n    $[3] = t3;\n  } else {\n    t3 = $[3];\n  }\n  t2 = t3;\n  return t2;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ value: 0 }],\n  sequentialRenders: [\n    { value: 1 },\n    { value: 1 },\n    { value: 42 },\n    { value: 42 },\n    { value: 0 },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: React Error Message for Invalid Ref Access\nDESCRIPTION: The error message produced when trying to access ref.current during render, which is not allowed in React. The error points to line 5 and includes a link to the React documentation about useRef.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.ref-optional.expect.md#2025-04-22_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n  3 | function Component(props) {\n  4 |   const ref = useRef();\n> 5 |   return ref?.current;\n    |          ^^^^^^^^^^^^ InvalidReact: Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef) (5:5)\n  6 | }\n  7 |\n  8 | export const FIXTURE_ENTRYPOINT = {\n```\n\n----------------------------------------\n\nTITLE: Using React useMemo with Conditional Dependency List in JavaScript\nDESCRIPTION: This React component demonstrates an improper pattern with useMemo where the dependency array is conditionally defined. The code uses a ternary operator to either pass null or an array containing 'text' as the dependency list, which violates React hooks rules and triggers a linting error.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.useMemo-non-literal-depslist.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useMemo} from 'react';\n\n// react-hooks-deps would error on this code (complex expression in depslist),\n// so Forget could bailout here\nfunction App({text, hasDeps}) {\n  const resolvedText = useMemo(\n    () => {\n      return text.toUpperCase();\n    },\n    hasDeps ? null : [text], // should be DCE'd\n  );\n  return resolvedText;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: App,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Compiler Runtime\nDESCRIPTION: This snippet presents an optimized version of the React component using the compiler runtime. It includes memoization techniques to improve performance by caching rendered elements and data. The useData hook is also optimized using a cache sentinel.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-loop-with-context-variable-iterator.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component() {\n  const $ = _c(2);\n  const data = useData();\n  let t0;\n  if ($[0] !== data) {\n    const items = [];\n    for (let i = MIN; i <= MAX; i = i + INCREMENT, i) {\n      items.push(<div key={i} onClick={() => data.set(i)} />);\n    }\n\n    t0 = <>{items}</>;\n    $[0] = data;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\nconst MIN = 0;\nconst MAX = 3;\nconst INCREMENT = 1;\n\nfunction useData() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = new Map();\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  params: [],\n  fn: Component,\n};\n```\n\n----------------------------------------\n\nTITLE: Labeled Break in Switch Statement in JavaScript\nDESCRIPTION: This JavaScript code defines a function 'foo' that uses a switch statement with labeled breaks. The switch statement evaluates the value '1' and immediately breaks out of the switch statement using the label 'bb0' in both cases. The 'FIXTURE_ENTRYPOINT' exports the 'foo' function.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-switch.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo() {\n  bb0: switch (1) {\n    case 1: {\n      break bb0;\n    }\n    case 2: {\n      break bb0;\n    }\n    default: {\n    }\n  }\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Initializing React Component with Shared Runtime in JavaScript\nDESCRIPTION: This snippet defines a React component that imports shared runtime dependencies. It extracts a specific element, `StaticText1`, from the `something` prop and returns it as the component. The exported object, `FIXTURE_ENTRYPOINT`, includes the function and its parameters. Ensure `shared-runtime` is available for import prior to execution.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-reactive-local-variable-member-expr.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as sharedRuntime from 'shared-runtime';\n\nfunction Component({something}: {something: {StaticText1: React.ElementType}}) {\n  const Foo = something.StaticText1;\n  return () => <Foo />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{something: sharedRuntime}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Input Snippet: Dynamic Array Manipulation in React Hook\nDESCRIPTION: Initial implementation of useFoo hook with array mutation and conditional logic based on props\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-renaming-via-destructuring-with-mutation.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {mutate} from 'shared-runtime';\n\nfunction useFoo(props) {\n  let {x} = {x: []};\n  x.push(props.bar);\n  if (props.cond) {\n    ({x} = {x: {}});\n    ({x} = {x: []});\n    x.push(props.foo);\n  }\n  mutate(x);\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Component with Reactive State Management - JavaScript\nDESCRIPTION: This snippet enhances the `Component` to manage reactive state using a custom `c` function from the `react/compiler-runtime`. The same logic to determine `x` is applied, but it also tracks the previous value of `x` for reactivity. The component returns the reactive output based on value changes from the props.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-forof-collection.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  let x;\n  for (const i of props.values) {\n    if (i > 10) {\n      x = 10;\n    } else {\n      x = 1;\n    }\n  }\n  let t0;\n  if ($[0] !== x) {\n    t0 = [x];\n    $[0] = x;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  sequentialRenders: [\n    { values: [12] },\n    { values: [12] },\n    { values: [1] },\n    { values: [1] },\n    { values: [12] },\n    { values: [1] },\n    { values: [12] },\n    { values: [1] },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a Reactive Component with Props - JavaScript\nDESCRIPTION: This snippet defines a simple React component called 'Component' which processes incoming props through two arrays to illustrate reactivity. The component generates a reactive output based on mutations in arrays 'a' and 'b'. Key parameters include 'props' which contains the input condition 'cond'. The output is an array containing the reactive value of 'x'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-from-interleaved-reactivity-for-update.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  // a and b are independent but their mutations are interleaved, so\n  // they get grouped in a reactive scope. this means that a becomes\n  // reactive since it will effectively re-evaluate based on a reactive\n  // input\n  const a = [];\n  const b = [];\n  b.push(props.cond);\n  a.push(10);\n\n  // Downstream consumer of a, which initially seems non-reactive except\n  // that a becomes reactive, per above\n  const c = [a];\n\n  let x;\n  for (let i = 0; i < 10; i += c[0][0]) {\n    x = 1;\n  }\n  // The values assigned to `x` are non-reactive, but the value of `x`\n  // depends on the \"control\" value `c[0]` which becomes reactive via\n  // being interleaved with `b`.\n  // Therefore x should be treated as reactive too.\n  return [x];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{cond: true}],\n};\n```\n\n----------------------------------------\n\nTITLE: React Hook Implementation with Inline Function\nDESCRIPTION: This snippet defines a React hook, `useMyHook`, that returns an inline function. This inline function, when called, updates the value of the variable `b` to 2. The module also exports a `FIXTURE_ENTRYPOINT` to facilitate testing of the hook's functionality.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reassign-global-return.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nlet b = 1;\n\nexport default function useMyHook() {\n  const fn = () => {\n    b = 2;\n  };\n  return fn;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useMyHook,\n  params: [],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: The compiled version of the component with React compiler-runtime features added. It implements memoization to cache the dynamically created component and rendered output, using an array to store previous values.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/static-components/invalid-dynamically-constructed-component-method-call.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @logger @validateStaticComponents\nfunction Example(props) {\n  const $ = _c(4);\n  let t0;\n  if ($[0] !== props.foo) {\n    t0 = props.foo.bar();\n    $[0] = props.foo;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const Component = t0;\n  let t1;\n  if ($[2] !== Component) {\n    t1 = <Component />;\n    $[2] = Component;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  return t1;\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled React Fragment Implementation\nDESCRIPTION: Compiled version with React compiler runtime optimizations. Implements memoization using array-based caching for data and transformed values. Includes compiler-specific transformations for performance optimization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allocating-logical-expression-instruction-scope.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; /**\n * This is a weird case as data has type `BuiltInMixedReadonly`.\n * The only scoped value we currently infer in this program is the\n * PropertyLoad `data?.toString`.\n */\nimport { useFragment } from \"shared-runtime\";\n\nfunction Foo() {\n  const $ = _c(4);\n  const data = useFragment();\n  let t0;\n  if ($[0] !== data) {\n    t0 = data?.toString() || \"\";\n    $[0] = data;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  let t1;\n  if ($[2] !== t0) {\n    t1 = [t0];\n    $[2] = t0;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Original Component Function Implementation in JavaScript\nDESCRIPTION: Defines a component function that creates an object with nested properties and a closure function. The FIXTURE_ENTRYPOINT exports configuration for testing with the 'TodoAdd' component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-nested-member-call.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component(a) {\n  let z = {a: {a}};\n  let x = function () {\n    z.a.a();\n  };\n  return z;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Memoization\nDESCRIPTION: This snippet shows an optimized version of the React component using compiler runtime functions. It implements memoization to avoid unnecessary re-renders and object creations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/logical-expression-object.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction component(props) {\n  const $ = _c(3);\n\n  const a = props.a || (props.b && props.c && props.d);\n  const b = (props.a && props.b && props.c) || props.d;\n  let t0;\n  if ($[0] !== a || $[1] !== b) {\n    t0 = { a, b };\n    $[0] = a;\n    $[1] = b;\n    $[2] = t0;\n  } else {\n    t0 = $[2];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Managing Errors and State in React Component\nDESCRIPTION: This snippet defines a React functional component that uses functions 'shallowCopy' and 'throwErrorWithMessage' from 'shared-runtime' to manage component state and error handling. The 'Component' function pushes an error message onto an array and uses a shallow copy of an object to handle exceptions. It then exports an object 'FIXTURE_ENTRYPOINT' containing 'Component' as function and parameters for testing. The component expects a 'props' object and outputs an array.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/try-catch-mutate-outer-value.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enablePropagateDepsInHIR\nconst {shallowCopy, throwErrorWithMessage} = require('shared-runtime');\n\nfunction Component(props) {\n  const x = [];\n  try {\n    x.push(throwErrorWithMessage('oops'));\n  } catch {\n    x.push(shallowCopy({a: props.a}));\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{a: 1}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Memoized React Hook: useFoo with React Compiler Runtime\nDESCRIPTION: This JavaScript code defines a memoized React hook `useFoo` leveraging React's compiler runtime. It imports `makeReadOnly` and `_c` from `react-compiler-runtime` and `react/compiler-runtime` respectively. The hook uses `_c` to memoize the result of `foo(props.x, __DEV__)`, updating the memoized value only when `props.x` changes. In development, `makeReadOnly` is used to ensure immutability of the returned value.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/emit-freeze-nonconflicting-global-reference.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { makeReadOnly } from \"react-compiler-runtime\";\nimport { c as _c } from \"react/compiler-runtime\"; // @enableEmitFreeze @instrumentForget\nfunction useFoo(props) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== props.x) {\n    t0 = foo(props.x, __DEV__);\n    $[0] = props.x;\n    $[1] = __DEV__ ? makeReadOnly(t0, \"useFoo\") : t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: Simple React component with conditional rendering based on props. Shows basic array manipulation and conditional returns without proper memoization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/partial-early-return-within-reactive-scope.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enablePropagateDepsInHIR\nfunction Component(props) {\n  let x = [];\n  let y = null;\n  if (props.cond) {\n    x.push(props.a);\n    // oops no memo!\n    return x;\n  } else {\n    y = foo();\n    if (props.b) {\n      return;\n    }\n  }\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{cond: true, a: 42}],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component Definition with Hoisting\nDESCRIPTION: This JavaScript code defines a React component named `hoisting` that demonstrates variable and function hoisting. It imports `Stringify` from `shared-runtime` and defines an `onClick` function within the scope of the component, which accesses the `bar` object defined later. The component returns a `Stringify` element with the `onClick` function passed as a prop.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-member-expression.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {Stringify} from 'shared-runtime';\n\nfunction hoisting() {\n  function onClick(x) {\n    return x + bar.baz;\n  }\n  const bar = {baz: 1};\n\n  return <Stringify onClick={onClick} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: hoisting,\n  params: [],\n  isComponent: false,\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiled and Optimized Array Filtering in React\nDESCRIPTION: This snippet shows the compiled and optimized version of the useArray function. It implements memoization for the filtered result and separates the filter callback into a standalone function. The compiler runtime is imported for optimization purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-annotations/todo_type-annotations-props.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enableUseTypeAnnotations\nfunction useArray(items) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== items) {\n    t0 = items.filter(_temp);\n    $[0] = items;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\nfunction _temp(x) {\n  return x !== 0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useArray,\n  params: [[1, 0, 2, 0, 3, 0, 42]],\n};\n```\n\n----------------------------------------\n\nTITLE: React Compiler Runtime Memoization Implementation\nDESCRIPTION: Enhanced version of the function with React compiler runtime memoization and caching mechanism, using _c for tracking object references\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/uncond-subpath-order1.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction TestDepsSubpathOrder1(props) {\n  const $ = _c(2);\n  let x;\n  if ($[0] !== props.a) {\n    x = {};\n    x.b = props.a.b;\n    x.a = props.a;\n    x.c = props.a.b.c;\n    $[0] = props.a;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Using Memoization in Functional Component - JavaScript\nDESCRIPTION: This snippet demonstrates the use of the 'useMemo' hook in a functional React component to cache computed data based on specific props, ensuring that the output is only recalculated when certain inputs change. It relies on the 'ValidateMemoization' component to manage inputs and outputs for validation purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-member-expression-inverted-optionals-parallel-paths.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees @enableOptionalDependencies\nimport {ValidateMemoization} from 'shared-runtime';\nfunction Component(props) {\n  const data = useMemo(() => {\n    const x = [];\n    x.push(props?.a.b?.c.d?.e);\n    x.push(props.a?.b.c?.d.e);\n    return x;\n  }, [props.a.b.c.d.e]);\n  return <ValidateMemoization inputs={[props.a.b.c.d.e]} output={x} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Compiler Runtime\nDESCRIPTION: This snippet shows the compiled output of the `f` component using React's compiler runtime. It uses `_c` from `react/compiler-runtime` to memoize the rendered `div` element. The component efficiently reuses the memoized element on subsequent renders unless the input dependencies change. `useReducer` hook is still used.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useReducer-returned-dispatcher-is-non-reactive.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useReducer } from \"react\";\n\nfunction f() {\n  const $ = _c(1);\n  const [, dispatch] = useReducer();\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const onClick = () => {\n      dispatch();\n    };\n\n    t0 = <div onClick={onClick} />;\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: f,\n  params: [],\n  isComponent: true,\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining useFoo function with array.map\nDESCRIPTION: This code snippet defines a React component `useFoo` that takes two arrays, `arr1` and `arr2`, as input. It then uses the `map` method on `arr1` twice, with two different named lambda functions `cb1` and `cb2`, to create two new arrays, `x` and `y`. Finally, it returns an array containing `x` and `y`.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/array-map-named-callback.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n/**\n * Forked from array-map-simple.js\n * \n * Whether lambdas are named or passed inline shouldn't affect whether we expect\n * it to be called.\n */\nfunction useFoo({arr1, arr2}) {\n  const cb1 = e => arr1[0].value + e.value;\n  const x = arr1.map(cb1);\n  const cb2 = e => arr2[0].value + e.value;\n  const y = arr1.map(cb2);\n  return [x, y];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{arr1: [], arr2: []}],\n  sequentialRenders: [\n    {arr1: [], arr2: []},\n    {arr1: [], arr2: null},\n    {arr1: [{value: 1}, {value: 2}], arr2: [{value: -1}]},\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Compiler-Transformed Function with Memoization\nDESCRIPTION: The transformed version of the 'foo' function with React compiler optimizations. It uses memoization via an array created by '_c(4)' to cache parameters and results, preventing unnecessary recalculations when inputs haven't changed.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/extend-scopes-if.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction foo(a, b, c) {\n  const $ = _c(4);\n  let x;\n  if ($[0] !== a || $[1] !== b || $[2] !== c) {\n    x = [];\n    if (a) {\n      if (b) {\n        if (c) {\n          x.push(0);\n        }\n      }\n    }\n    $[0] = a;\n    $[1] = b;\n    $[2] = c;\n    $[3] = x;\n  } else {\n    x = $[3];\n  }\n  if (x.length) {\n    return x;\n  }\n  return null;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with useFragment (Input)\nDESCRIPTION: This React component `Component` uses the `useFragment` hook to fetch user data based on a GraphQL fragment. It iterates over the user's timeline posts, rendering each post with a `<Post>` component. The component then adds an empty object to the posts array, calculates the length, and passes the length to a `foo` function before rendering the posts.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/readonly-object-method-calls-mutable-lambda.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useFragment} from 'shared-runtime';\n\nfunction Component(props) {\n  const x = makeObject();\n  const user = useFragment(\n    graphql`\n      fragment Component_user on User {\n        name\n      }\n    `,\n    props.user\n  );\n  const posts = user.timeline.posts.edges.nodes.map(node => {\n    x.y = true;\n    return <Post post={node} />;\n  });\n  posts.push({});\n  const count = posts.length;\n  foo(count);\n  return <>{posts}</>;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining React Component and Fixture Entrypoint - JavaScript\nDESCRIPTION: Defines a React component that processes props and maps over an internal array. It exports a FIXTURE_ENTRYPOINT object which serves as the entry point for testing or execution. The component doesn't depend on props values and focuses on creating and returning a tuple of arrays.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-map-frozen-array.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\n\"function Component(props) {\\n  const x = [];\\n  <dif>{x}</dif>;\\n  const y = x.map(item => item);\\n  return [x, y];\\n}\\n\\nexport const FIXTURE_ENTRYPOINT = {\\n  fn: Component,\\n  params: [{}],\\n  isComponent: false,\\n};\"\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: Simple React component 'Foo' that conditionally initializes and returns an array. Shows the basic implementation before compilation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/memoize-value-block-value-logical-no-sequence.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Foo(props) {\n  let x;\n  true && (x = []);\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: Shows the compiler-transformed version of the Foo component with added memoization. The React compiler has added a cache array (_c) to store previous prop values and output, optimizing rendering by skipping computation when inputs haven't changed.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/align-scopes-within-nested-valueblock-in-array.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { Stringify, identity, makeArray, mutate } from \"shared-runtime\";\n\n/**\n * Here, identity('foo') is an immutable allocating instruction.\n * `arr` is a mutable value whose mutable range ends at `arr.map`.\n *\n * The previous (reactive function) version of alignScopesToBlocks set the range of\n * both scopes to end at value blocks within the <></> expression.\n * However, both scope ranges should be aligned to the outer value block\n * (e.g. `cond1 ? <>: null`). The HIR version of alignScopesToBlocks\n * handles this correctly.\n */\nfunction Foo(t0) {\n  const $ = _c(3);\n  const { cond1, cond2 } = t0;\n  let t1;\n  if ($[0] !== cond1 || $[1] !== cond2) {\n    const arr = makeArray({ a: 2 }, 2, []);\n\n    t1 = cond1 ? (\n      <>\n        <div>{identity(\"foo\")}</div>\n        <Stringify value={cond2 ? arr.map(mutate) : null} />\n      </>\n    ) : null;\n    $[0] = cond1;\n    $[1] = cond2;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{ cond1: true, cond2: true }],\n};\n```\n\n----------------------------------------\n\nTITLE: FIXTURE_ENTRYPOINT Configuration for Testing\nDESCRIPTION: Exports a test fixture with a function and predefined parameters to validate the useFoo hook's behavior under specific conditions.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/maybe-invalid-useMemo-no-memoblock-sideeffect.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{minWidth: 2, styles: {width: 1}, setStyles: () => {}}]\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: Transformed version of the component with React's internal memoization logic added. Uses Symbol.for() to implement a cache sentinel and stores computed values for reuse.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/uninitialized-declaration-in-reactive-scope.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const x = mutate();\n    let y;\n    foo(x);\n    t0 = [y, x];\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n```\n\n----------------------------------------\n\nTITLE: Original JavaScript Function with Conditional Logic\nDESCRIPTION: A JavaScript function that declares variables, performs a conditional check, and returns an object. This represents the input code before React compiler optimization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-objectexpression-phi.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo() {\n  let x = 1;\n  let y = 2;\n\n  if (x > 1) {\n    x = 2;\n  } else {\n    y = 3;\n  }\n\n  let t = {x: x, y: y};\n  return t;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Logging Fire Usage in React - JavaScript\nDESCRIPTION: This snippet demonstrates an attempt to log the 'fire' function from the 'react' library, which is conditionally imported. Dependencies include the React library itself. The main issue is an untransformed reference, causing a compiler error, indicating the need for proper transformation of the 'fire' call. Critical parameters are the '@enableFire' annotation and '@panicThreshold(none)', which seem to influence code transformation behavior. Outputs are logged to the console, but a compiler error is likely unless resolved.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/bailout-retry/error.untransformed-fire-reference.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableFire @panicThreshold(none)\nimport {fire} from 'react';\n\nconsole.log(fire == null);\n\n```\n\n----------------------------------------\n\nTITLE: React Compiler Transformed Component with Memoization\nDESCRIPTION: The transformed version uses React's compiler runtime to implement memoization. It uses a special sentinel value to determine if it should recompute the result or return a cached version, improving performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-reassign-in-rval.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // Forget should call the original x (x = foo()) to compute result\nfunction Component() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    let x = foo();\n    const result = x((x = bar()), 5);\n    t0 = [result, x];\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Optimization\nDESCRIPTION: Compiled version of the React component showing optimized memoization implementation using compiler runtime utilities. Implements the same functionality with manual cache checking and updating using an array-based caching system.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-of-nonmutating-loop-local-collection.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useMemo } from \"react\";\nimport { ValidateMemoization } from \"shared-runtime\";\n\nfunction Component(t0) {\n  const $ = _c(19);\n  const { a, b } = t0;\n  let t1;\n  let t2;\n  if ($[0] !== a) {\n    t2 = [a];\n    $[0] = a;\n    $[1] = t2;\n  } else {\n    t2 = $[1];\n  }\n  t1 = t2;\n  const x = t1;\n  let t3;\n  let items;\n  if ($[2] !== b || $[3] !== x) {\n    items = [b];\n    for (const i of x) {\n      items.push(i);\n    }\n    $[2] = b;\n    $[3] = x;\n    $[4] = items;\n  } else {\n    items = $[4];\n  }\n\n  t3 = items;\n  const y = t3;\n  let t4;\n  if ($[5] !== a) {\n    t4 = [a];\n    $[5] = a;\n    $[6] = t4;\n  } else {\n    t4 = $[6];\n  }\n  let t5;\n  if ($[7] !== t4 || $[8] !== x) {\n    t5 = <ValidateMemoization inputs={t4} output={x} />;\n    $[7] = t4;\n    $[8] = x;\n    $[9] = t5;\n  } else {\n    t5 = $[9];\n  }\n  let t6;\n  if ($[10] !== b || $[11] !== x) {\n    t6 = [x, b];\n    $[10] = b;\n    $[11] = x;\n    $[12] = t6;\n  } else {\n    t6 = $[12];\n  }\n  let t7;\n  if ($[13] !== t6 || $[14] !== y) {\n    t7 = <ValidateMemoization inputs={t6} output={y} />;\n    $[13] = t6;\n    $[14] = y;\n    $[15] = t7;\n  } else {\n    t7 = $[15];\n  }\n  let t8;\n  if ($[16] !== t5 || $[17] !== t7) {\n    t8 = (\n      <>\n        {t5}\n        {t7}\n      </>\n    );\n    $[16] = t5;\n    $[17] = t7;\n    $[18] = t8;\n  } else {\n    t8 = $[18];\n  }\n  return t8;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ a: 0, b: 0 }],\n  sequentialRenders: [\n    { a: 1, b: 0 },\n    { a: 1, b: 1 },\n    { a: 0, b: 1 },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization Logic\nDESCRIPTION: This snippet shows the compiled version of the React component with detailed memoization logic. It uses a cache array ($) to store previous values and conditionally updates variables and renders components based on changed inputs. The compilation adds granular memoization checks for optimal performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/dont-merge-if-dep-is-inner-declaration-of-previous-scope.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { ValidateMemoization } from \"shared-runtime\";\n\n// Achieving Forget's level of memoization precision in this example isn't possible with useMemo\n// without significantly altering the code, so disable the non-Forget evaluation of this fixture.\n// @disableNonForgetInSprout\nfunction Component(t0) {\n  const $ = _c(25);\n  const { a, b, c } = t0;\n  let x;\n  let y;\n  if ($[0] !== a || $[1] !== b || $[2] !== c) {\n    x = [];\n    if (a) {\n      let t1;\n      if ($[5] !== b) {\n        t1 = [b];\n        $[5] = b;\n        $[6] = t1;\n      } else {\n        t1 = $[6];\n      }\n      y = t1;\n    }\n\n    x.push(c);\n    $[0] = a;\n    $[1] = b;\n    $[2] = c;\n    $[3] = x;\n    $[4] = y;\n  } else {\n    x = $[3];\n    y = $[4];\n  }\n  let t1;\n  if ($[7] !== y) {\n    t1 = [y];\n    $[7] = y;\n    $[8] = t1;\n  } else {\n    t1 = $[8];\n  }\n  const z = t1;\n  let t2;\n  if ($[9] !== a || $[10] !== b || $[11] !== c) {\n    t2 = [a, b, c];\n    $[9] = a;\n    $[10] = b;\n    $[11] = c;\n    $[12] = t2;\n  } else {\n    t2 = $[12];\n  }\n  let t3;\n  if ($[13] !== t2 || $[14] !== x) {\n    t3 = <ValidateMemoization inputs={t2} output={x} />;\n    $[13] = t2;\n    $[14] = x;\n    $[15] = t3;\n  } else {\n    t3 = $[15];\n  }\n  let t4;\n  if ($[16] !== a || $[17] !== b) {\n    t4 = [a, b];\n    $[16] = a;\n    $[17] = b;\n    $[18] = t4;\n  } else {\n    t4 = $[18];\n  }\n  let t5;\n  if ($[19] !== t4 || $[20] !== z) {\n    t5 = <ValidateMemoization inputs={t4} output={z} />;\n    $[19] = t4;\n    $[20] = z;\n    $[21] = t5;\n  } else {\n    t5 = $[21];\n  }\n  let t6;\n  if ($[22] !== t3 || $[23] !== t5) {\n    t6 = (\n      <>\n        {t3}\n        {t5}\n      </>\n    );\n    $[22] = t3;\n    $[23] = t5;\n    $[24] = t6;\n  } else {\n    t6 = $[24];\n  }\n  return t6;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ a: false, b: null, c: 0 }],\n  sequentialRenders: [\n    { a: false, b: null, c: 0 },\n    { a: false, b: null, c: 1 },\n    { a: true, b: 0, c: 1 },\n    { a: true, b: 1, c: 1 },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Object Mutation and Condition Checking in JavaScript\nDESCRIPTION: This snippet defines functions for mutating objects and checking conditions, along with a test function that demonstrates object aliasing and mutation. It's designed to test React compiler behavior.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/mutable-lifetime-loops.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction mutate(x, y) {\n  'use no forget';\n  if (x != null) {\n    x.value = (x.value ?? 0) + 1;\n  }\n  if (y != null) {\n    y.value = (y.value ?? 0) + 1;\n  }\n}\nfunction cond(x) {\n  'use no forget';\n  return x.value > 5;\n}\n\nfunction testFunction(props) {\n  let a = {};\n  let b = {};\n  let c = {};\n  let d = {};\n  while (true) {\n    let z = a;\n    a = b;\n    b = c;\n    c = d;\n    d = z;\n    mutate(a, b);\n    if (cond(a)) {\n      break;\n    }\n  }\n\n  // all of these tests are seemingly readonly, since the values are never directly\n  // mutated again. but they are all aliased by `d`, which is later modified, and\n  // these are therefore mutable references:\n  if (a) {\n  }\n  if (b) {\n  }\n  if (c) {\n  }\n  if (d) {\n  }\n\n  mutate(d, null);\n  return {a, b, c, d};\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: testFunction,\n  params: [{}],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Input Hook Implementation in JavaScript\nDESCRIPTION: Initial implementation of a React hook using createHookWrapper and mutate function, creating an object with a method that mutates its input\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-method-shorthand-3.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {createHookWrapper, mutate} from 'shared-runtime';\n\nfunction useHook(a) {\n  const x = {a};\n  let obj = {\n    method() {\n      mutate(x);\n      return x;\n    },\n  };\n  return obj.method();\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: createHookWrapper(useHook),\n  params: [{x: 1}],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component Compiled Implementation\nDESCRIPTION: Compiler-optimized version of the component with memoization using Symbol.for() and Unicode escape sequences for non-ASCII characters.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-string-attribute-expression-container.expect.md#2025-04-22_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = (\n      <div>\n        <Text value={\"\\n\"} />\n        <Text value={\"A\\tE\"} />\n        <Text value={\"\\uB098\\uC740\"} />\n        <Text value=\"Lauren\" />\n        <Text value={\"\\u0B9A\\u0BA4\\u0BCD\\u0BAF\\u0BBE\"} />\n        <Text value=\"Sathya\" />\n      </div>\n    );\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nfunction Text(t0) {\n  const $ = _c(2);\n  const { value } = t0;\n  let t1;\n  if ($[0] !== value) {\n    t1 = <span>{value}</span>;\n    $[0] = value;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component with Default Array Destructuring\nDESCRIPTION: A React component that destructures an array value from props with a default value of [-1, 1]. Uses array destructuring pattern with default values.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructure-default-array-with-unary.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const [x = [-1, 1]] = props.value;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: []}],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component with Identity Function\nDESCRIPTION: A React component that imports an identity function, uses it to create jQuery reference and wraps it in an array. The component returns this wrapped value.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/conflicting-dollar-sign-variable.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {identity} from 'shared-runtime';\n\nfunction Component(props) {\n  const $ = identity('jQuery');\n  const t0 = identity([$]);\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimizing Component State with React Compiler Runtime - JavaScript\nDESCRIPTION: This snippet involves the use of the React 'compiler-runtime' to optimize component state by caching and tracking changes to inputs. It illustrates how conditionally updated objects are used to minimize computations and maintain consistent outputs. This is implemented in a JavaScript environment within React and requires the 'react/compiler-runtime' package.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-pattern-params.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction component(t0) {\n  const $ = _c(7);\n  const [a, b] = t0;\n  let t1;\n  if ($[0] !== a) {\n    t1 = { a };\n    $[0] = a;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  const y = t1;\n  let t2;\n  if ($[2] !== b) {\n    t2 = { b };\n    $[2] = b;\n    $[3] = t2;\n  } else {\n    t2 = $[3];\n  }\n  const z = t2;\n  let t3;\n  if ($[4] !== y || $[5] !== z) {\n    t3 = [y, z];\n    $[4] = y;\n    $[5] = z;\n    $[6] = t3;\n  } else {\n    t3 = $[6];\n  }\n  return t3;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: [[\"val1\", \"val2\"]],\n  isComponent: false,\n};\n\n```\n\n----------------------------------------\n\nTITLE: Analyzing React/JavaScript Hook Naming Conventions\nDESCRIPTION: The code snippet demonstrates various valid naming patterns for hooks in a React JavaScript environment, clarifying common misconceptions associated with naming. It requires familiarity with React and JavaScript syntax. The examples illustrate valid patterns that do not match the use[A-Z] or PascalCase naming conventions and do not result in warnings or errors.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-df4d750736f3.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Valid because they're not matching use[A-Z].\nfooState();\n_use();\n_useState();\nuse_hook();\n// also valid because it's not matching the PascalCase namespace\njest.useFakeTimer();\n\n```\n\n----------------------------------------\n\nTITLE: React Component Definition\nDESCRIPTION: This React component `Foo` takes `props` as input, accesses `props.a`, and calls the `bar` function with it. It then uses optional chaining to access the `b` property of the result. Finally, it calls the `useBar` hook with the value of `y` and returns the result.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-member-expression.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Foo(props) {\n  let x = bar(props.a);\n  let y = x?.b;\n\n  let z = useBar(y);\n  return z;\n}\n```\n\n----------------------------------------\n\nTITLE: React Component with Type Annotations\nDESCRIPTION: A React component example using TypeScript annotations and identity function processing. Shows prop type definitions and type assertions with a numeric ID parameter.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-annotations/type-annotation-as-number.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableUseTypeAnnotations\nimport {identity} from 'shared-runtime';\n\nfunction Component(props: {id: number}) {\n  const x = identity(props.id);\n  const y = x as number;\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{id: 42}],\n};\n```\n\n----------------------------------------\n\nTITLE: Starting React DevTools Development Server\nDESCRIPTION: This command starts a development server that watches for changes in the source code and automatically rebuilds the package.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools-inline/README.md#2025-04-21_snippet_12\n\nLANGUAGE: sh\nCODE:\n```\nyarn start\n```\n\n----------------------------------------\n\nTITLE: React Component Test Fixture Definition\nDESCRIPTION: Test fixture configuration for a React component that defines the component function, parameters, and component identifier for testing purposes. The fixture is configured for a 'TodoAdd' component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/escape-analysis-not-if-test.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const x = [props.a];\n  let y;\n  if (x) {\n    y = props.b;\n  } else {\n    y = props.c;\n  }\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Hook Implementation\nDESCRIPTION: Compiled output of the React hook showing optimization with memoization using an array for storing previous condition and log values. Maintains same functionality with additional runtime optimizations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unlabeled-break-within-label-switch.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { CONST_STRING0 } from \"shared-runtime\";\n\nfunction useHook(cond) {\n  const $ = _c(2);\n  let log;\n  if ($[0] !== cond) {\n    log = [];\n    bb0: switch (CONST_STRING0) {\n      case CONST_STRING0: {\n        log.push(`@A`);\n        if (cond) {\n          break bb0;\n        }\n\n        log.push(`@B`);\n\n        log.push(`@C`);\n      }\n    }\n    $[0] = cond;\n    $[1] = log;\n  } else {\n    log = $[1];\n  }\n  return log;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useHook,\n  params: [true],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with useIdentity and setPropertyByKey\nDESCRIPTION: The 'Foo' component takes a 'count' prop and initializes an object 'x'. It then uses 'useIdentity' to create a memoized callback 'cb' that sets the 'value' property of 'x' to 'count' using 'setPropertyByKey'. The key functionality is demonstrated by the mutation of 'x' after the hook call which causes a React error.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.hook-call-freezes-captured-identifier.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableTransitivelyFreezeFunctionExpressions\nimport {setPropertyByKey, Stringify, useIdentity} from 'shared-runtime';\n\nfunction Foo({count}) {\n  const x = {value: 0};\n  /**\n   * After this custom hook call, it's no longer valid to mutate x.\n   */\n  const cb = useIdentity(() => {\n    setPropertyByKey(x, 'value', count);\n  });\n\n  x.value += count;\n  return <Stringify x={x} cb={cb} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{count: 1}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Component with Continue Statement\nDESCRIPTION: Original implementation of a React component that calculates a sum using a for loop with continue statement and compound operators (+=). Takes props.count as input and returns accumulated sum.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-empty-update-with-continue.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let x = 0;\n  for (let i = 0; i < props.count; ) {\n    x += i;\n    i += 1;\n    continue;\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Unconditional Dependency in Switch Statement Input - JavaScript\nDESCRIPTION: A test case function demonstrating props.a.b as an unconditional dependency accessed in all branches of a switch statement. This input code will be processed by React's compiler to optimize reactive scoping.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/cfg-switch-exhaustive.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// props.a.b should be added as a unconditional dependency to the reactive\n// scope that produces x, since it is accessed unconditionally in all cfg\n// paths\n\nimport {identity} from 'shared-runtime';\n\nfunction useCondDepInSwitch(props, other) {\n  const x = {};\n  switch (identity(other)) {\n    case 1:\n      x.a = props.a.b;\n      break;\n    case 2:\n      x.b = props.a.b;\n      break;\n    default:\n      x.c = props.a.b;\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useCondDepInSwitch,\n  params: [{a: {b: 2}}, 2],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimizing React Component with Compiler Runtime in JavaScript\nDESCRIPTION: This snippet demonstrates an optimized version of the React component 'Component' using an imported '_c' function from 'react/compiler-runtime'. It employs memoization to minimize recalculation and re-rendering by caching computed values based on prop changes. This requires the 'react/compiler-runtime' package. The export section remains similar to the initial snippet, facilitating parameterized testing of the component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ignore-use-no-forget.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @ignoreUseNoForget\nfunction Component(prop) {\n  \"use no forget\";\n  const $ = _c(4);\n  let t0;\n  if ($[0] !== prop.x) {\n    t0 = prop.x.toFixed();\n    $[0] = prop.x;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const result = t0;\n  let t1;\n  if ($[2] !== result) {\n    t1 = <div>{result}</div>;\n    $[2] = result;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ x: 1 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Component Initialization and Execution in React with JavaScript\nDESCRIPTION: Defines a function Component that initializes state variables z and y, and updates z based on a specific logic. It uses Math.max to potentially modify y.b. The component supports sequential rendering with specified parameters in FIXTURE_ENTRYPOINT. Dependencies include React and must export a default component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-no-mutate.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nfunction Component({a, b}) {\n  let z = {a};\n  let y = {b};\n  let x = function () {\n    z.a = 2;\n    return Math.max(y.b, 0);\n  };\n  x();\n  return z;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{a: 2, b: 3}],\n  sequentialRenders: [\n    {a: 2, b: 3},\n    {a: 2, b: 3},\n    {a: 4, b: 3},\n    {a: 4, b: 5},\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memo Cache\nDESCRIPTION: The transformed version of the component after compilation, using React's memo cache system. It introduces a cache sentinel check to avoid redundant computation on re-renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reassign-object-in-context.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(1);\n  let x;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    x = [];\n    const foo = () => {\n      x = {};\n    };\n\n    foo();\n    $[0] = x;\n  } else {\n    x = $[0];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimizing Component with Compiler Runtime in React - JavaScript\nDESCRIPTION: This snippet showcases an optimized React component using 'react/compiler-runtime'. It employs caching for performance, ensuring object properties are updated only when necessary. The component function interacts with the FIXTURE_ENTRYPOINT to define its behavior and identify it as 'TodoAdd'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-pattern-params.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction component(t0) {\n  const $ = _c(7);\n  const { a, b } = t0;\n  let t1;\n  if ($[0] !== a) {\n    t1 = { a };\n    $[0] = a;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  const y = t1;\n  let t2;\n  if ($[2] !== b) {\n    t2 = { b };\n    $[2] = b;\n    $[3] = t2;\n  } else {\n    t2 = $[3];\n  }\n  const z = t2;\n  let t3;\n  if ($[4] !== y || $[5] !== z) {\n    t3 = { y, z };\n    $[4] = y;\n    $[5] = z;\n    $[6] = t3;\n  } else {\n    t3 = $[6];\n  }\n  return t3;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining and Exporting a Function with Parameters in Javascript\nDESCRIPTION: This code defines a function `bar` that takes an argument `a`, initializes variables, defines an inner function `f0`, and returns a value derived from the input. It then exports the function `bar` along with its parameter configuration and a flag indicating it is not a React component, packaged as `FIXTURE_ENTRYPOINT`.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-alias-computed-load-4.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n```javascript\nfunction bar(a) {\n  let x = [a];\n  let y = {};\n  const f0 = function () {\n    y = x[0].a[1];\n  };\n  f0();\n\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: bar,\n  params: [{a: ['val1', 'val2']}],\n  isComponent: false,\n};\n\n```\n```\n\n----------------------------------------\n\nTITLE: Optimizing React Component with Caching (JavaScript)\nDESCRIPTION: This snippet shows an optimized version of the MyComponentName component. It uses caching to store previous prop values and their computed results, avoiding unnecessary recalculations when props haven't changed. It also includes development-specific read-only behavior.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/codegen-emit-make-read-only.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { makeReadOnly } from \"react-compiler-runtime\";\nimport { c as _c } from \"react/compiler-runtime\"; // @enableEmitFreeze true\n\nfunction MyComponentName(props) {\n  const $ = _c(3);\n  let y;\n  if ($[0] !== props.a || $[1] !== props.b) {\n    const x = {};\n    foo(x, props.a);\n    foo(x, props.b);\n\n    y = [];\n    y.push(x);\n    $[0] = props.a;\n    $[1] = props.b;\n    $[2] = __DEV__ ? makeReadOnly(y, \"MyComponentName\") : y;\n  } else {\n    y = $[2];\n  }\n  return y;\n}\n```\n\n----------------------------------------\n\nTITLE: Optimizing React Function with Compiler Runtime in JavaScript\nDESCRIPTION: This snippet is an optimized variant of the useFoo function that uses react/compiler-runtime for performance improvements. It leverages caching and early returns to minimize repeated calculations when input data remains unchanged. Dependencies include 'react' and 'shared-runtime' packages. It operates on inputs with specific structure, using conditions to return early or construct arrays based on nested object properties.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/reduce-if-exhaustive-poisoned-deps.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { identity } from \"shared-runtime\";\n\nfunction useFoo(t0) {\n  const $ = _c(11);\n  const { input, inputHasAB, inputHasABC } = t0;\n  let t1;\n  let x;\n  if ($[0] !== input.a || $[1] !== inputHasAB || $[2] !== inputHasABC) {\n    t1 = Symbol.for(\"react.early_return_sentinel\");\n    bb0: {\n      x = [];\n      if (!inputHasABC) {\n        let t2;\n        if ($[5] !== input.a) {\n          t2 = identity(input.a);\n          $[5] = input.a;\n          $[6] = t2;\n        } else {\n          t2 = $[6];\n        }\n        x.push(t2);\n        if (!inputHasAB) {\n          t1 = null;\n          break bb0;\n        }\n        let t3;\n        if ($[7] !== input.a.b) {\n          t3 = identity(input.a.b);\n          $[7] = input.a.b;\n          $[8] = t3;\n        } else {\n          t3 = $[8];\n        }\n        x.push(t3);\n      } else {\n        let t2;\n        if ($[9] !== input.a.b.c) {\n          t2 = identity(input.a.b.c);\n          $[9] = input.a.b.c;\n          $[10] = t2;\n        } else {\n          t2 = $[10];\n        }\n        x.push(t2);\n      }\n    }\n    $[0] = input.a;\n    $[1] = inputHasAB;\n    $[2] = inputHasABC;\n    $[3] = t1;\n    $[4] = x;\n  } else {\n    t1 = $[3];\n    x = $[4];\n  }\n  if (t1 !== Symbol.for(\"react.early_return_sentinel\")) {\n    return t1;\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ input: { b: 1 }, inputHasAB: false, inputHasABC: false }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: Input version of a React component that creates a Set from an array, applies mutations, and renders the result through a Stringify component. Uses useIdentity hook and handles dynamic value props.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/global-types/set-foreach-mutate.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {mutateAndReturn, Stringify, useIdentity} from 'shared-runtime';\n\nfunction Component({value}) {\n  const arr = [{value: 'foo'}, {value: 'bar'}, {value}];\n  useIdentity();\n  const derived = new Set(arr).forEach(mutateAndReturn);\n  return <Stringify>{[...derived]}</Stringify>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: 5}],\n  sequentialRenders: [{value: 5}, {value: 6}, {value: 6}, {value: 7}],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component Input\nDESCRIPTION: This code defines a simple React component named `Component` that accepts props. It initializes an array `a` and an object `b`, calls a function `foo` with them, and then returns a div element with `a` and `b` passed as props. The function `foo` is defined but empty.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-call-jsx.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo() {}\n\nfunction Component(props) {\n  const a = [];\n  const b = {};\n  foo(a, b);\n  let _ = <div a={a} />;\n  foo(a, b);\n  return <div a={a} b={b} />;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining React Component Function with Closure\nDESCRIPTION: This snippet defines a React component function 'f' that creates a closure and renders a div element. It also exports a FIXTURE_ENTRYPOINT object for testing purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/lambda-mutated-ref-non-reactive.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction f(a) {\n  let x;\n  (() => {\n    x = {};\n  })();\n  // this is not reactive on `x` as `x` is never reactive\n  return <div x={x} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: f,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with useRef\nDESCRIPTION: This code defines a simple React component that uses the useRef hook to create a reference to a child component (Foo).  The ref is passed to the Foo component. The component is expected to render the Foo component and allow access to its underlying DOM node or React component instance via the ref.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-passing-refs-as-props.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const ref = useRef(null);\n  return <Foo ref={ref} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Component with Props Dependent Caching in React (JavaScript)\nDESCRIPTION: This snippet imports a compiler runtime function and defines a component that optimizes rendering by caching results based on the input props. It checks if the props have changed and updates the cached value accordingly, enhancing performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/property-call-spread.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(3);\n  let t0;\n  if ($[0] !== props.a || $[1] !== props.b) {\n    t0 = foo.bar(...props.a, null, ...props.b);\n    $[0] = props.a;\n    $[1] = props.b;\n    $[2] = t0;\n  } else {\n    t0 = $[2];\n  }\n  const x = t0;\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Original React Component with Object Spread\nDESCRIPTION: Simple React component that spreads props.foo object and returns it. Includes fixture configuration for testing.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-literal-spread-element.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const x = {...props.foo};\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Input: React Component with Fire Event Handler\nDESCRIPTION: Initial implementation of a React component using fire events and logging props. Uses basic React hooks and event firing mechanism with minimal optimization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/repeated-calls.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableFire\nimport {fire} from 'react';\n\nfunction Component(props) {\n  const foo = () => {\n    console.log(props);\n  };\n  useEffect(() => {\n    fire(foo(props));\n    fire(foo(props));\n  });\n\n  return null;\n}\n```\n\n----------------------------------------\n\nTITLE: Error Message from Blocklisted Import Validation\nDESCRIPTION: This shows the error output that occurs when attempting to import from a blocklisted module. The validation tool catches the blocklisted import from 'DangerousImport' and provides a detailed error message pointing to the exact line and issue.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.validate-blocklisted-imports.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n  1 | // @validateBlocklistedImports(DangerousImport)\n> 2 | import {foo} from 'DangerousImport';\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Todo: Bailing out due to blocklisted import. Import from module DangerousImport (2:2)\n  3 | import {useIdentity} from 'shared-runtime';\n  4 |\n  5 | function useHook() {\n```\n\n----------------------------------------\n\nTITLE: React Component with Icon Rendering\nDESCRIPTION: This React component, `ViewModeSelector`, renders a `Dropdown` component with a custom checkable indicator.  The `renderIcon` function is defined to return an `AcceptIcon` component.  The code attempts to set the `displayName` property of the `renderIcon` function, which causes an immutability error.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.mutate-function-property.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nexport function ViewModeSelector(props) {\n  const renderIcon = () => <AcceptIcon />;\n  renderIcon.displayName = 'AcceptIcon';\n\n  return <Dropdown checkableIndicator={{children: renderIcon}} />;\n}\n```\n\n----------------------------------------\n\nTITLE: React Compiler Runtime Function Optimization\nDESCRIPTION: Transformed function using React compiler runtime with memoization and cache management using Symbol sentinel\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/nested-function-with-param-as-captured-dep.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Foo() {\n  const $ = _c(1);\n  let t0;\n  let t1;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = function a(t2) {\n      const x_0 = t2 === undefined ? _temp : t2;\n      return x_0;\n    };\n    $[0] = t1;\n  } else {\n    t1 = $[0];\n  }\n  t0 = t1;\n  return t0;\n}\nfunction _temp() {}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Original JavaScript Function Implementation\nDESCRIPTION: This snippet shows the original implementation of a function 'foo' with conditional logic and object creation. It takes four parameters and returns an object with a modified property.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/obj-mutated-after-nested-if-else-with-alias.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(a, b, c, d) {\n  let x = someObj();\n  if (a) {\n    let z;\n    if (b) {\n      const w = someObj();\n      z = w;\n    } else {\n      z = someObj();\n    }\n    const y = z;\n    x = z;\n  } else {\n    x = someObj();\n  }\n\n  x.f = 1;\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: The compiled version of the component with React's compiler runtime optimizations. Includes memoization logic to prevent unnecessary recalculations of values using an internal cache array.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/update-expression-on-function-parameter-4.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(t0) {\n  const $ = _c(4);\n  let [b] = t0;\n  const f = b--;\n  const g = --b;\n  let t1;\n  if ($[0] !== b || $[1] !== f || $[2] !== g) {\n    t1 = [b, f, g];\n    $[0] = b;\n    $[1] = f;\n    $[2] = g;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [[3]],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Memoization in React Component with Compiler Runtime in JavaScript\nDESCRIPTION: This snippet extends the React component logic by integrating the `react/compiler-runtime` import for memoization. The `$` variable holds a react.memo_cache_sentinel symbol to cache the component output. It includes a conditional check to reuse the memoized output or render and reassign the new output. It demonstrates basic memoization strategy. Dependencies include the `react/compiler-runtime` library.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/call.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction foo() {}\n\nfunction Component(props) {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const a = [];\n    const b = {};\n    foo(a, b);\n\n    foo(b);\n    t0 = <div a={a} b={b} />;\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Compiler Error with Object Getter Functions\nDESCRIPTION: An error message from the React compiler showing that it's unable to handle getter functions in ObjectExpression. The error points to the getter definition in the component code.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-object-expression-get-syntax.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n  1 | function Component({value}) {\n  2 |   const object = {\n> 3 |     get value() {\n    |     ^^^^^^^^^^^^^\n> 4 |       return value;\n    | ^^^^^^^^^^^^^^^^^^^\n> 5 |     },\n    | ^^^^^^ Todo: (BuildHIR::lowerExpression) Handle get functions in ObjectExpression (3:5)\n  6 |   };\n  7 |   return <div>{object.value}</div>;\n  8 | }\n```\n\n----------------------------------------\n\nTITLE: React Component Definition with Mutable Array Logic (Input)\nDESCRIPTION: This code snippet defines a React component that conditionally initializes an array `y` based on `props.cond` and `props.cond2`. It then pushes an object `x` into the array and returns both `x` and `y`. The snippet demonstrates a scenario where the mutable range of array literals must be handled carefully for proper memoization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/phi-type-inference-array-push-consecutive-phis.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enablePropagateDepsInHIR\nimport {makeArray} from 'shared-runtime';\n\nfunction Component(props) {\n  const x = {};\n  let y;\n  if (props.cond) {\n    if (props.cond2) {\n      y = [props.value];\n    } else {\n      y = [props.value2];\n    }\n  } else {\n    y = [];\n  }\n  // This should be inferred as `<store> y` s.t. `x` can still\n  // be independently memoized. *But* this also must properly\n  // extend the mutable range of the array literals in the\n  // if/else branches\n  y.push(x);\n\n  return [x, y];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{cond: true, cond2: true, value: 42}],\n  sequentialRenders: [\n    {cond: true, cond2: true, value: 3.14},\n    {cond: true, cond2: true, value: 42},\n    {cond: true, cond2: true, value: 3.14},\n    {cond: true, cond2: false, value2: 3.14},\n    {cond: true, cond2: false, value2: 42},\n    {cond: true, cond2: false, value2: 3.14},\n    {cond: false},\n    {cond: false},\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Calculating Aggregate Counts in React - JavaScript\nDESCRIPTION: This snippet defines a React functional component 'HomeDiscoStoreItemTileRating' that calculates the total count of aggregates for a given item. It initializes a count variable and iterates over item aggregates to sum their counts, which is then displayed in a Text component. The use of 'useFragment' suggests reliance on a library for efficient data fetching or state management. Key dependencies include React and the specific library that facilitates 'useFragment'. Expect inputs related to the item structure and outputs as a visual representation of count in the UI. Limitations include the necessity of correctly structured item data.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/repro-scope-missing-mutable-range.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enablePropagateDepsInHIR\nfunction HomeDiscoStoreItemTileRating(props) {\n  const item = useFragment();\n  let count = 0;\n  const aggregates = item?.aggregates || [];\n  aggregates.forEach(aggregate => {\n    count += aggregate.count || 0;\n  });\n\n  return <Text>{count}</Text>;\n}\n\n```\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enablePropagateDepsInHIR\nfunction HomeDiscoStoreItemTileRating(props) {\n  const $ = _c(4);\n  const item = useFragment();\n  let count;\n  if ($[0] !== item?.aggregates) {\n    count = 0;\n    const aggregates = item?.aggregates || [];\n    aggregates.forEach((aggregate) => {\n      count = count + (aggregate.count || 0);\n      count;\n    });\n    $[0] = item?.aggregates;\n    $[1] = count;\n  } else {\n    count = $[1];\n  }\n  let t0;\n  if ($[2] !== count) {\n    t0 = <Text>{count}</Text>;\n    $[2] = count;\n    $[3] = t0;\n  } else {\n    t0 = $[3];\n  }\n  return t0;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating a React Component with Helper Function and Test Fixture\nDESCRIPTION: This code defines a React component that calls an external function, contains an internal helper function that returns JSX, and exports a test fixture entry point. The component takes props, processes them with function f, renders a helper component, and returns the result.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-no-component-nested-jsx.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @compilationMode(infer)\nfunction Component(props) {\n  const result = f(props);\n  function helper() {\n    return <foo />;\n  }\n  helper();\n  return result;\n}\n\nfunction f(props) {\n  return props;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a React Component with Hooks in JavaScript\nDESCRIPTION: This snippet demonstrates the creation of a React component using hooks, which are used for managing state and lifecycle methods in function components. The given structure allows for inferred compilation mode, indicative of build time optimizations. No external dependencies are explicitly required other than a valid React and hooks environment.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-8f1c2c3f71c9.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @compilationMode(infer)\n// Valid because components can use hooks.\nfunction createComponentWithHook() {\n  return function ComponentWithHook() {\n    useHook();\n  };\n}\n\n```\n\n----------------------------------------\n\nTITLE: React Component Definition with Early Return\nDESCRIPTION: Defines a React functional component `MyApp` that conditionally returns `undefined` (implicitly) based on the value of the `cond` prop. If `props.cond` is truthy, the component returns nothing. The component is exported as part of a `FIXTURE_ENTRYPOINT` object, providing metadata such as the component function, parameters, and component name for testing or demonstration purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/early-return.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction MyApp(props) {\n  if (props.cond) {\n    return;\n  }\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: MyApp,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component using react/compiler-runtime\nDESCRIPTION: This snippet shows the compiled output of the `Foo` component using `react/compiler-runtime`. It utilizes the `_c` function for memoization and optimization. The compiled code avoids recomputing the factorial if the component is rendered with the same props, using a cache stored in `$[0]`.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-recursive-call-within-lambda.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Foo(t0) {\n  const $ = _c(1);\n  const outer = _temp;\n  let t1;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = outer(3);\n    $[0] = t1;\n  } else {\n    t1 = $[0];\n  }\n  return t1;\n}\nfunction _temp(val) {\n  const fact = (x) => {\n    if (x <= 0) {\n      return 1;\n    }\n    return x * fact(x - 1);\n  };\n  return fact(val);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{}]\n};\n\n```\n\n----------------------------------------\n\nTITLE: Exporting a React fixture entry point in Javascript\nDESCRIPTION: This code snippet exports a constant named `FIXTURE_ENTRYPOINT`, which is an object that defines a React fixture. It specifies the function to be used (`foo`), the parameters to be passed to the function, and whether the function is a component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-sibling-phis.expect.md#2025-04-21_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: Basic React component implementation that creates an array and processes items with a conditional break statement. Includes fixture export for testing purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-of-conditional-break.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component() {\n  const x = [];\n  for (const item of [1, 2]) {\n    if (item === 1) {\n      break;\n    }\n    x.push(item);\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Memoized React Component using Compiler Runtime\nDESCRIPTION: This snippet shows the transformed React component after being processed by the React compiler runtime. The `_c` function from `react/compiler-runtime` is used to memoize the function. This approach avoids manual `useCallback` usage, potentially improving performance by leveraging compiler optimizations. The compiler generates the memoization logic with the $[0], $[1], and $[2] array to save previous values.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useCallback-alias-property-load-dep.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @validatePreserveExistingMemoizationGuarantees\nimport { useCallback } from \"react\";\nimport { sum } from \"shared-runtime\";\n\nfunction Component(t0) {\n  const $ = _c(3);\n  const { propA, propB } = t0;\n  const x = propB.x.y;\n  let t1;\n  if ($[0] !== propA.x || $[1] !== x) {\n    t1 = () => sum(propA.x, x);\n    $[0] = propA.x;\n    $[1] = x;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ propA: { x: 2 }, propB: { x: { y: 3 } } }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Reproducing React Compiler Bug with useFoo Function\nDESCRIPTION: This JavaScript code defines a React component `useFoo` that demonstrates a bug in the React compiler related to mutable ranges. The component initializes an array `x` and an object `y`, pushes `y` into `x`, and then modifies a property of the object within `x`. The issue arises when the compiler incorrectly infers mutable ranges, leading to incorrect memoization and potential mutation issues in specific scenarios such as function expressions with `enableTransitivelyFreezeFunctionExpressions:false`.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/bug-aliased-capture-aliased-mutate.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @flow @enableTransitivelyFreezeFunctionExpressions:false\nimport {arrayPush, setPropertyByKey, Stringify} from 'shared-runtime';\n\n/**\n * 1. `InferMutableRanges` derives the mutable range of identifiers and their\n *     aliases from `LoadLocal`, `PropertyLoad`, etc\n *   - After this pass, y's mutable range only extends to `arrayPush(x, y)`\n *   - We avoid assigning mutable ranges to loads after y's mutable range, as\n *     these are working with an immutable value. As a result, `LoadLocal y` and\n *     `PropertyLoad y` do not get mutable ranges\n * 2. `InferReactiveScopeVariables` extends mutable ranges and creates scopes,\n *    as according to the 'co-mutation' of different values\n *   - Here, we infer that\n *     - `arrayPush(y, x)` might alias `x` and `y` to each other\n *     - `setPropertyKey(x, ...)` may mutate both `x` and `y`\n *   - This pass correctly extends the mutable range of `y`\n *   - Since we didn't run `InferMutableRange` logic again, the LoadLocal /\n *     PropertyLoads still don't have a mutable range\n *\n * Note that the this bug is an edge case. Compiler output is only invalid for:\n *  - function expressions with\n *    `enableTransitivelyFreezeFunctionExpressions:false`\n *  - functions that throw and get retried without clearing the memocache\n *\n * Found differences in evaluator results\n * Non-forget (expected):\n *   (kind: ok)\n *   <div>{\"cb\":{\"kind\":\"Function\",\"result\":10},\"shouldInvokeFns\":true}</div>\n *   <div>{\"cb\":{\"kind\":\"Function\",\"result\":11},\"shouldInvokeFns\":true}</div>\n * Forget:\n *   (kind: ok)\n *   <div>{\"cb\":{\"kind\":\"Function\",\"result\":10},\"shouldInvokeFns\":true}</div>\n *   <div>{\"cb\":{\"kind\":\"Function\",\"result\":10},\"shouldInvokeFns\":true}</div>\n */\nfunction useFoo({a, b}: {a: number, b: number}) {\n  const x = [];\n  const y = {value: a};\n\n  arrayPush(x, y); // x and y co-mutate\n  const y_alias = y;\n  const cb = () => y_alias.value;\n  setPropertyByKey(x[0], 'value', b); // might overwrite y.value\n  return <Stringify cb={cb} shouldInvokeFns={true} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{a: 2, b: 10}],\n  sequentialRenders: [\n    {a: 2, b: 10},\n    {a: 2, b: 11},\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Optimized Effect Dependencies\nDESCRIPTION: The compiled output after the React compiler processes the component. It introduces memoization through a closure variable $ and conditionally recreates callbacks and dependency arrays only when values change.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/infer-deps-custom-config.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @inferEffectDependencies\nimport { print, useSpecialEffect } from \"shared-runtime\";\n\nfunction CustomConfig(t0) {\n  const $ = _c(7);\n  const { propVal } = t0;\n  let t1;\n  let t2;\n  if ($[0] !== propVal) {\n    t1 = () => print(propVal);\n    t2 = [propVal];\n    $[0] = propVal;\n    $[1] = t1;\n    $[2] = t2;\n  } else {\n    t1 = $[1];\n    t2 = $[2];\n  }\n  useSpecialEffect(t1, t2, [propVal]);\n  let t3;\n  let t4;\n  let t5;\n  if ($[3] !== propVal) {\n    t3 = () => print(propVal);\n    t4 = [propVal];\n    t5 = [propVal];\n    $[3] = propVal;\n    $[4] = t3;\n    $[5] = t4;\n    $[6] = t5;\n  } else {\n    t3 = $[4];\n    t4 = $[5];\n    t5 = $[6];\n  }\n  useSpecialEffect(t3, t4, t5);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Functional Component in React\nDESCRIPTION: This snippet defines a functional component named `Foo` that takes `props` as an argument. It attempts to mutate the `test` property of `props`, which is against React's rules. Instead, local variables should be used for managing state or computations from props.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.mutate-props.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Foo(props) {\n  props.test = 1;\n  return null;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining useFoo Hook with Nested Functions in JavaScript\nDESCRIPTION: This snippet defines a custom React hook 'useFoo' with nested functions and console logging. It imports an 'identity' function and exports a fixture for testing. The code uses specific variable names for module-level constants.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rename-source-variables-nested-object-method.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableChangeVariableCodegen\nimport {identity} from 'shared-runtime';\n\nconst $ = 'module_$';\nconst t0 = 'module_t0';\nconst c_0 = 'module_c_0';\nfunction useFoo(props: {value: number}): number {\n  const a = {\n    foo() {\n      const b = {\n        bar() {\n          console.log($);\n          console.log(t0);\n          console.log(c_0);\n          return identity(props.value);\n        },\n      };\n      return b;\n    },\n  };\n  return a.foo().bar();\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{value: 42}],\n};\n```\n\n----------------------------------------\n\nTITLE: Function Implementation: useFoo with Dynamic Lambda Optimization\nDESCRIPTION: A React compiler runtime function that demonstrates safe array mapping with memoized lambda functions, preventing unnecessary property reads and maintaining performance\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/array-map-simple.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction useFoo(t0) {\n  const $ = _c(12);\n  const { arr1, arr2 } = t0;\n  let t1;\n  if ($[0] !== arr1) {\n    let t2;\n    if ($[2] !== arr1[0]) {\n      t2 = (e) => arr1[0].value + e.value;\n      $[2] = arr1[0];\n      $[3] = t2;\n    } else {\n      t2 = $[3];\n    }\n    t1 = arr1.map(t2);\n    $[0] = arr1;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  const x = t1;\n  let t2;\n  if ($[4] !== arr1 || $[5] !== arr2) {\n    let t3;\n    if ($[7] !== arr2) {\n      t3 = (e_0) => arr2[0].value + e_0.value;\n      $[7] = arr2;\n      $[8] = t3;\n    } else {\n      t3 = $[8];\n    }\n    t2 = arr1.map(t3);\n    $[4] = arr1;\n    $[5] = arr2;\n    $[6] = t2;\n  } else {\n    t2 = $[6];\n  }\n  const y = t2;\n  let t3;\n  if ($[9] !== x || $[10] !== y) {\n    t3 = [x, y];\n    $[9] = x;\n    $[10] = y;\n    $[11] = t3;\n  } else {\n    t3 = $[11];\n  }\n  return t3;\n}\n```\n\n----------------------------------------\n\nTITLE: React Compiler-Optimized Function with Memoization\nDESCRIPTION: The compiler-transformed version of useFoo with memoization applied. It uses React's compiler runtime to cache computation results and implement early returns. The optimized version maintains functionality while reducing redundant calculations across renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-poisoned/reduce-if-nonexhaustive-poisoned-deps1.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { identity } from \"shared-runtime\";\n\nfunction useFoo(t0) {\n  const $ = _c(11);\n  const { input, cond, hasAB } = t0;\n  let t1;\n  let x;\n  if ($[0] !== cond || $[1] !== hasAB || $[2] !== input) {\n    t1 = Symbol.for(\"react.early_return_sentinel\");\n    bb0: {\n      x = [];\n      if (cond) {\n        if (!hasAB) {\n          t1 = null;\n          break bb0;\n        } else {\n          let t2;\n          if ($[5] !== input.a.b) {\n            t2 = identity(input.a.b);\n            $[5] = input.a.b;\n            $[6] = t2;\n          } else {\n            t2 = $[6];\n          }\n          x.push(t2);\n        }\n        let t2;\n        if ($[7] !== input.a.b) {\n          t2 = identity(input.a.b);\n          $[7] = input.a.b;\n          $[8] = t2;\n        } else {\n          t2 = $[8];\n        }\n        x.push(t2);\n      } else {\n        let t2;\n        if ($[9] !== input.a.b) {\n          t2 = identity(input.a.b);\n          $[9] = input.a.b;\n          $[10] = t2;\n        } else {\n          t2 = $[10];\n        }\n        x.push(t2);\n      }\n    }\n    $[0] = cond;\n    $[1] = hasAB;\n    $[2] = input;\n    $[3] = t1;\n    $[4] = x;\n  } else {\n    t1 = $[3];\n    x = $[4];\n  }\n  if (t1 !== Symbol.for(\"react.early_return_sentinel\")) {\n    return t1;\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ input: { b: 1 }, cond: true, hasAB: false }],\n  sequentialRenders: [\n    { input: { a: { b: 1 } }, cond: true, hasAB: true },\n    { input: null, cond: true, hasAB: false },\n    // preserve nullthrows\n    { input: { a: { b: undefined } }, cond: true, hasAB: true },\n    { input: { a: null }, cond: true, hasAB: true },\n    { input: { a: { b: undefined } }, cond: true, hasAB: true },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: React Compiler Runtime Component with Caching\nDESCRIPTION: An optimized version of the component using React compiler runtime for memoization, with conditional rendering and state preservation\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-fun-alias-captured-mutate-2-iife.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { mutate } from \"shared-runtime\";\n\nfunction component(foo, bar) {\n  const $ = _c(3);\n  let x;\n  if ($[0] !== bar || $[1] !== foo) {\n    x = { foo };\n    const y = { bar };\n\n    const a = { y };\n    const b = x;\n    a.x = b;\n\n    mutate(y);\n    $[0] = bar;\n    $[1] = foo;\n    $[2] = x;\n  } else {\n    x = $[2];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: [\"foo\", \"bar\"],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimizing Component Rendering with React Compiler - JavaScript\nDESCRIPTION: This snippet optimizes component rendering using the 'react/compiler-runtime'. It caches props to avoid unnecessary rendering. Dependencies include 'react/compiler-runtime' and 'shared-runtime'. Key parameters 'foo' and 'bar' dictate rendering conditions. Outputs are dynamic based on internal component mutations and state caching mechanisms.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-alias-captured-mutate-arr.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { mutate } from \"shared-runtime\";\nfunction Component(t0) {\n  const $ = _c(3);\n  const { foo, bar } = t0;\n  let y;\n  if ($[0] !== bar || $[1] !== foo) {\n    const x = { foo };\n    y = { bar };\n    const f0 = function () {\n      const a = [y];\n      const b = x;\n      a.x = b;\n    };\n\n    f0();\n    mutate(y);\n    $[0] = bar;\n    $[1] = foo;\n    $[2] = y;\n  } else {\n    y = $[2];\n  }\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ foo: 2, bar: 3 }],\n  sequentialRenders: [\n    { foo: 2, bar: 3 },\n    { foo: 2, bar: 3 },\n    { foo: 2, bar: 4 },\n    { foo: 3, bar: 4 },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Unoptimized React Component Implementation\nDESCRIPTION: This snippet shows the original, unoptimized implementation of a React component. It processes an array by popping items and doubling them.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/do-while-simple.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component() {\n  let x = [1, 2, 3];\n  let ret = [];\n  do {\n    let item = x.pop();\n    ret.push(item * 2);\n  } while (x.length);\n  return ret;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Input Snippet: Nested Function React Component\nDESCRIPTION: Initial implementation of a React component with nested functions and fire event handling, using useEffect and prop logging\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/deep-scope.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableFire\\nimport {fire} from 'react';\\n\\nfunction Component(props) {\\n  const foo = props => {\\n    console.log(props);\\n  };\\n  useEffect(() => {\\n    function nested() {\\n      function nestedAgain() {\\n        function nestedThrice() {\\n          fire(foo(props));\\n        }\\n        nestedThrice();\\n      }\\n      nestedAgain();\\n    }\\n    nested();\\n  });\\n\\n  return null;\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: React Component with Delete Operation (JavaScript)\nDESCRIPTION: Defines a React component that creates an object, attempts to delete a property based on the `props.value`, and returns the result of the delete operation (which will be a boolean). Assumes `makeObject()` is a globally available function that returns an object.  Note that deleting a non-existent property results in `true`.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-computed-delete.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @debug\nfunction Component(props) {\n  const x = makeObject();\n  const y = delete x[props.value];\n  return y;\n}\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Compiler Runtime\nDESCRIPTION: This JavaScript code defines an optimized asynchronous React component named `Component` that uses the React compiler runtime (`_c`) to memoize the data fetched based on `props.id`. It checks if the `props.id` has changed since the last render. If it has, it fetches the data, updates the memoized value, and returns the data. Otherwise, it returns the memoized data.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/await-side-effecting-promise.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nasync function Component(props) {\n  const $ = _c(2);\n  let x;\n  if ($[0] !== props.id) {\n    x = [];\n    await populateData(props.id, x);\n    $[0] = props.id;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: The original implementation of a React component that creates a closure with a function y and an object x. It demonstrates basic component structure with parameter passing and function exports.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/mutate-captured-arg-separately.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component(a) {\n  let y = function () {\n    m(x);\n  };\n\n  let x = {a};\n  m(x);\n  return y;\n}\n\nfunction m(x) {}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: [{name: 'Jason'}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled Component with Automatic Dependency Tracking\nDESCRIPTION: The compiled output of the React component after transformation by React's compiler. It implements a caching mechanism using an array for tracking changes to variables and memoizing computed values, while automatically adding the correct dependency (obj.a) to the useEffect hook.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/reactive-optional-chain.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @inferEffectDependencies\nimport { useEffect } from \"react\";\nimport { print } from \"shared-runtime\";\n\n// TODO: take optional chains as dependencies\nfunction ReactiveMemberExpr(t0) {\n  const $ = _c(7);\n  const { cond, propVal } = t0;\n  let t1;\n  if ($[0] !== cond || $[1] !== propVal) {\n    t1 = cond ? { b: propVal } : null;\n    $[0] = cond;\n    $[1] = propVal;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  let t2;\n  if ($[3] !== t1) {\n    t2 = { a: t1 };\n    $[3] = t1;\n    $[4] = t2;\n  } else {\n    t2 = $[4];\n  }\n  const obj = t2;\n  let t3;\n  if ($[5] !== obj.a?.b) {\n    t3 = () => print(obj.a?.b);\n    $[5] = obj.a?.b;\n    $[6] = t3;\n  } else {\n    t3 = $[6];\n  }\n  useEffect(t3, [obj.a]);\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component Output\nDESCRIPTION: Optimized and compiled version of the component with memoization logic. Uses Symbol.for('react.memo_cache_sentinel') for caching and includes compiler runtime optimizations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-duplicate-instruction-from-merge-consecutive-scopes.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { Stringify } from \"shared-runtime\";\n\nfunction Component(t0) {\n  const $ = _c(3);\n  const { id } = t0;\n  let t1;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = <Stringify title={undefined} />;\n    $[0] = t1;\n  } else {\n    t1 = $[0];\n  }\n  const t2 = id ? true : false;\n  let t3;\n  if ($[1] !== t2) {\n    t3 = (\n      <>\n        {t1}\n        <Stringify title={t2} />\n      </>\n    );\n    $[1] = t2;\n    $[2] = t3;\n  } else {\n    t3 = $[2];\n  }\n  return t3;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Invalid React useContext Mutation Error\nDESCRIPTION: This error message indicates that a value returned from `useContext()` is being mutated, which is not allowed in React.  Specifically, it points to the line where `FooContext.current` is being set to `true`. React context should be updated using a state management solution (e.g., useState, useReducer) or a dedicated context provider that handles updates.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-mutate-context-in-callback.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n  10 |   // independently\n  11 |   const onClick = () => {\n> 12 |     FooContext.current = true;\n     |     ^^^^^^^^^^ InvalidReact: Mutating a value returned from 'useContext()', which should not be mutated. Found mutation of `FooContext` (12:12)\n  13 |   };\n  14 |   return <div onClick={onClick} />;\n  15 | }\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization Transformations\nDESCRIPTION: The compiled output of the test component showing how React's compiler transforms useMemo calls into explicit cache checks using Symbol.for(\"react.memo_cache_sentinel\"). This demonstrates the internal implementation of React's memoization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fast-refresh-dont-refresh-const-changes-prod.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @compilationMode(infer)\nimport { useEffect, useMemo, useState } from \"react\";\nimport { ValidateMemoization } from \"shared-runtime\";\n\nlet pretendConst = 0;\n\nfunction unsafeResetConst() {\n  pretendConst = 0;\n}\n\nfunction unsafeUpdateConst() {\n  pretendConst += 1;\n}\n\nfunction Component() {\n  const $ = _c(2);\n  useState(_temp);\n\n  unsafeUpdateConst();\n  let t0;\n  let t1;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = [{ pretendConst }];\n    $[0] = t1;\n  } else {\n    t1 = $[0];\n  }\n  t0 = t1;\n  const value = t0;\n  let t2;\n  if ($[1] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t2 = <ValidateMemoization inputs={[]} output={value} />;\n    $[1] = t2;\n  } else {\n    t2 = $[1];\n  }\n  return t2;\n}\nfunction _temp() {\n  unsafeResetConst();\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n  sequentialRenders: [{}, {}],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Memoization\nDESCRIPTION: This snippet shows an optimized version of the Component function. It uses memoization to avoid unnecessary array creations and imports a compiler runtime function for optimization. The FIXTURE_ENTRYPOINT remains the same.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/escape-analysis-logical.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(6);\n  let t0;\n  if ($[0] !== props.a) {\n    t0 = [props.a];\n    $[0] = props.a;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const a = t0;\n  let t1;\n  if ($[2] !== props.b) {\n    t1 = [props.b];\n    $[2] = props.b;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  const b = t1;\n  let t2;\n  if ($[4] !== props.c) {\n    t2 = [props.c];\n    $[4] = props.c;\n    $[5] = t2;\n  } else {\n    t2 = $[5];\n  }\n  const c = t2;\n  return (a && b) || c;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized Component Rendering with Caching in React - JavaScript\nDESCRIPTION: This snippet is an optimized version of the previous component, using caching to prevent re-computation of functions when prop values remain unchanged. It employs a compiler runtime utility for cache management. Dependencies are React and the shared-runtime library, requiring a specific cache management utility.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/assume-invoked/conditional-call-chain.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useRef } from \"react\";\nimport { Stringify } from \"shared-runtime\";\n\nfunction Component(t0) {\n  const $ = _c(9);\n  const { a, b } = t0;\n  let t1;\n  if ($[0] !== a.value) {\n    t1 = () => {\n      console.log(a.value);\n    };\n    $[0] = a.value;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  const logA = t1;\n  let t2;\n  if ($[2] !== b.value) {\n    t2 = () => {\n      console.log(b.value);\n    };\n    $[2] = b.value;\n    $[3] = t2;\n  } else {\n    t2 = $[3];\n  }\n  const logB = t2;\n\n  const hasLogged = useRef(false);\n  let t3;\n  if ($[4] !== logA || $[5] !== logB) {\n    t3 = () => {\n      if (!hasLogged.current) {\n        logA();\n        logB();\n        hasLogged.current = true;\n      }\n    };\n    $[4] = logA;\n    $[5] = logB;\n    $[6] = t3;\n  } else {\n    t3 = $[6];\n  }\n  const log = t3;\n  let t4;\n  if ($[7] !== log) {\n    t4 = <Stringify log={log} shouldInvokeFns={true} />;\n    $[7] = log;\n    $[8] = t4;\n  } else {\n    t4 = $[8];\n  }\n  return t4;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ a: { value: 1 }, b: { value: 2 } }],\n  sequentialRenders: [\n    { a: { value: 1 }, b: { value: 2 } },\n    { a: { value: 3 }, b: { value: 4 } },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Optimized Memoization\nDESCRIPTION: This snippet shows the compiled version of the React component, optimized for performance. It uses the React compiler runtime to implement efficient memoization and conditional rendering based on prop changes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useMemo-conditional-access-own-scope.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @validatePreserveExistingMemoizationGuarantees\nimport { useMemo } from \"react\";\n\nfunction Component(t0) {\n  const $ = _c(2);\n  const { propA, propB } = t0;\n  let t1;\n  bb0: {\n    if (propA) {\n      let t2;\n      if ($[0] !== propB.x.y) {\n        t2 = { value: propB.x.y };\n        $[0] = propB.x.y;\n        $[1] = t2;\n      } else {\n        t2 = $[1];\n      }\n      t1 = t2;\n      break bb0;\n    }\n    t1 = undefined;\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ propA: 1, propB: { x: { y: [] } } }],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized Hook with Conditional Mutation - JavaScript\nDESCRIPTION: This snippet enhances the previous hook implementation by adding conditional checks to optimize value changes. It ensures that the value is only mutated when necessary, thus improving performance. It still exports a fixture entry point to interface with React's hook system.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-method-shorthand-derived-value.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { createHookWrapper, mutateAndReturn } from \"shared-runtime\";\nfunction useHook(t0) {\n  const $ = _c(4);\n  const { value } = t0;\n  let t1;\n  if ($[0] !== value) {\n    t1 = mutateAndReturn({ value });\n    $[0] = value;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  const x = t1;\n  let t2;\n  if ($[2] !== x) {\n    t2 = {\n      getValue() {\n        return x;\n      },\n    };\n    $[2] = x;\n    $[3] = t2;\n  } else {\n    t2 = $[3];\n  }\n  const obj = t2;\n  return obj;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: createHookWrapper(useHook),\n  params: [{ value: 0 }],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with Compiler Runtime Fire Handling\nDESCRIPTION: Refined implementation using useFire for more explicit fire event management and prop deconstruction\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/bailout-retry/bailout-validate-preserve-memo.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useFire } from \"react/compiler-runtime\"; // @validatePreserveExistingMemoizationGuarantees @enableFire @panicThreshold(none)\nimport { fire } from \"react\";\nimport { sum } from \"shared-runtime\";\n\nfunction Component(t0) {\n  const { prop1, bar } = t0;\n  const foo = () => {\n    console.log(prop1);\n  };\n  const t1 = useFire(foo);\n  const t2 = useFire(bar);\n\n  useEffect(() => {\n    t1(prop1);\n    t1();\n    t2();\n  });\n  return useMemo(() => sum(bar), []);\n}\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Memoization\nDESCRIPTION: This snippet shows an optimized version of the component using memoization. It imports a compiler runtime function, memoizes the object creation and mutation, and only recalculates when props change.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/function-expression-with-store-to-parameter.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  const mutate = _temp;\n  let x;\n  if ($[0] !== props) {\n    x = makeObject(props);\n    mutate(x);\n    $[0] = props;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  return x;\n}\nfunction _temp(object, key, value) {\n  object.updated = true;\n  object[key] = value;\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Compiler Runtime\nDESCRIPTION: Transformed component using React compiler runtime with memoization and cache handling for JSX element creation\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/invalid-jsx-in-try-with-catch.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @logger @validateNoJSXInTryStatements\nfunction Component(props) {\n  const $ = _c(1);\n  let el;\n  try {\n    let t0;\n    if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n      t0 = <div />;\n      $[0] = t0;\n    } else {\n      t0 = $[0];\n    }\n    el = t0;\n  } catch {\n    return null;\n  }\n  return el;\n}\n```\n\n----------------------------------------\n\nTITLE: Transformed JavaScript Function\nDESCRIPTION: This snippet presents the transformed JavaScript function `foo`, presumably by the React compiler. It utilizes the `_c` function from `react/compiler-runtime` which likely implements a memoization cache.  The function checks if the cache is empty, and if so, executes the original logic while storing the results in the cache; otherwise, it retrieves the results from the cache. The `mutate` function remains unchanged.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/simple-alias.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction mutate() {}\nfunction foo() {\n  const $ = _c(2);\n  let a;\n  let c;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    let b = {};\n    c = {};\n    a = b;\n    b = c;\n    c = a;\n    mutate(a, b);\n    $[0] = c;\n    $[1] = a;\n  } else {\n    c = $[0];\n    a = $[1];\n  }\n  return c;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Component with Incorrect Hook Usage in React\nDESCRIPTION: This JavaScript snippet demonstrates an improper use of the React Hook useState within a callback function. This is a common error as hooks must be called at the top level of a function component or a custom hook as per the Rules of Hooks. No specific dependencies are required, but it's assumed that React is being used. The intended input is a functional component, and the erroneous output is an InvalidReact error.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid.invalid-rules-of-hooks-449a37146a83.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Invalid because it's a common misunderstanding.\\n// We *could* make it valid but the runtime error could be confusing.\\nfunction createComponent() {\\n  return function ComponentWithHookInsideCallback() {\\n    function handleClick() {\\n      useState();\\n    }\\n  };\\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Caching\nDESCRIPTION: Compiled version of the component with added memoization using React compiler runtime. Implements caching for array creation and element access operations to optimize performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-annotations/type-annotation-as-array.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enableUseTypeAnnotations\nfunction Component(props) {\n  const $ = _c(4);\n  let t0;\n  if ($[0] !== props.id) {\n    t0 = makeArray(props.id);\n    $[0] = props.id;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const x = t0 as number[];\n  let t1;\n  if ($[2] !== x) {\n    t1 = x.at(0);\n    $[2] = x;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  const y = t1;\n  return y;\n}\n\nfunction makeArray(x) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== x) {\n    t0 = [x];\n    $[0] = x;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ id: 42 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Optional Chaining in React Component - JavaScript\nDESCRIPTION: The snippet demonstrates a React component function using optional chaining to safely access deeply nested properties of an object. 'a' is assumed to be an object accessible in the scope, and the component returns the first element of the nested array if it exists. This code requires JavaScript ES11 (ECMAScript 2020) support for optional chaining.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-computed-load-static.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let x = a?.b.c[0];\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing React Function Hook with Memoization\nDESCRIPTION: A React function component that uses compiler runtime memoization to track and optimize state changes, with conditional array manipulation based on input props\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/ssa-renaming-ternary.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enablePropagateDepsInHIR\nfunction useFoo(props) {\n  let x = [];\n  x.push(props.bar);\n  props.cond ? ((x = {}), (x = []), x.push(props.foo)) : null;\n  return x;\n}\n```\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enablePropagateDepsInHIR\nfunction useFoo(props) {\n  const $ = _c(5);\n  let x;\n  if ($[0] !== props.bar) {\n    x = [];\n    x.push(props.bar);\n    $[0] = props.bar;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  if ($[2] !== props.cond || $[3] !== props.foo) {\n    props.cond ? ((x = []), x.push(props.foo)) : null;\n    $[2] = props.cond;\n    $[3] = props.foo;\n    $[4] = x;\n  } else {\n    x = $[4];\n  }\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Nested Scopes\nDESCRIPTION: This snippet defines a React component with nested scopes and potential variable shadowing. It demonstrates a function that mutates a local array and returns an object.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/lambda-mutate-shadowed-object.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component() {\n  const x = {};\n  {\n    const x = [];\n    const fn = function () {\n      mutate(x);\n    };\n    fn();\n  }\n  return x; // should return {}\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Functions with useState Hook in JavaScript\nDESCRIPTION: This snippet showcases different function definitions (function declarations, expressions, and arrow functions) that all attempt to call the useState hook. It highlights invalid patterns that do not conform to the PascalCase or useFoo naming convention for hooks. The required context indicates that currently only certain naming formats are accepted for hooks.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.bail.rules-of-hooks-fadd52c1e460.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @skip\n// Unsupported input\n\n// Currently invalid.\n// These are variations capturing the current heuristic--\n// we only allow hooks in PascalCase or useFoo functions.\n// We *could* make some of these valid. But before doing it,\n// consider specific cases documented above that contain reasoning.\nfunction a() {\n  useState();\n}\nconst whatever = function b() {\n  useState();\n};\nconst c = () => {\n  useState();\n};\nlet d = () => useState();\ne = () => {\n  useState();\n};\n({\n  f: () => {\n    useState();\n  },\n});\n({\n  g() {\n    useState();\n  },\n});\nconst {\n  j = () => {\n    useState();\n  },\n} = {};\n({\n  k = () => {\n    useState();\n  },\n} = {});\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: This snippet presents the compiled version of the React component, utilizing `react/compiler-runtime` for optimization. It uses `_c` for memoization and manages state to avoid unnecessary re-renders. The component's logic remains the same, conditionally returning an array based on `props.cond`, but with added memoization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/early-return-within-reactive-scope.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enablePropagateDepsInHIR\nimport { makeArray } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(6);\n  let t0;\n  if ($[0] !== props.a || $[1] !== props.b || $[2] !== props.cond) {\n    t0 = Symbol.for(\"react.early_return_sentinel\");\n    bb0: {\n      const x = [];\n      if (props.cond) {\n        x.push(props.a);\n        t0 = x;\n        break bb0;\n      } else {\n        let t1;\n        if ($[4] !== props.b) {\n          t1 = makeArray(props.b);\n          $[4] = props.b;\n          $[5] = t1;\n        } else {\n          t1 = $[5];\n        }\n        t0 = t1;\n        break bb0;\n      }\n    }\n    $[0] = props.a;\n    $[1] = props.b;\n    $[2] = props.cond;\n    $[3] = t0;\n  } else {\n    t0 = $[3];\n  }\n  if (t0 !== Symbol.for(\"react.early_return_sentinel\")) {\n    return t0;\n  }\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  sequentialRenders: [\n    // pattern 1\n    { cond: true, a: 42 },\n    { cond: true, a: 42 },\n    // pattern 2\n    { cond: false, b: 3.14 },\n    { cond: false, b: 3.14 },\n    // pattern 1\n    { cond: true, a: 42 },\n    // pattern 2\n    { cond: false, b: 3.14 },\n    // pattern 1\n    { cond: true, a: 42 },\n    // pattern 2\n    { cond: false, b: 3.14 },\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: React useCallback Hook with Incorrect Dependencies\nDESCRIPTION: This React component uses the useCallback hook to memoize a function that depends on a property of the propA object. The dependency array includes propA.x, but the React Compiler detects a mismatch between the inferred and specified dependencies, causing an error. This typically occurs when propA.x is not a stable reference or changes unexpectedly.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.useCallback-property-call-dep.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees\nimport {useCallback} from 'react';\n\nfunction Component({propA}) {\n  return useCallback(() => {\n    return propA.x();\n  }, [propA.x]);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Function Definition in JavaScript\nDESCRIPTION: This snippet defines a simple JavaScript function `foo` that creates an object, passes it to a recursive call of itself, mutates the returned object, and finally returns the original object. This demonstrates object handling and mutation in JavaScript.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/store-via-call.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo() {\n  const x = {};\n  const y = foo(x);\n  y.mutate();\n  return x;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Memoization\nDESCRIPTION: This snippet defines a React component that demonstrates memoization techniques. It conditionally renders elements based on prop values and uses ValidateMemoization for testing. The component is designed to showcase fine-grained memoization that is difficult to achieve with useMemo.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/dont-merge-if-dep-is-inner-declaration-of-previous-scope.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {ValidateMemoization} from 'shared-runtime';\n\n// Achieving Forget's level of memoization precision in this example isn't possible with useMemo\n// without significantly altering the code, so disable the non-Forget evaluation of this fixture.\n// @disableNonForgetInSprout\nfunction Component({a, b, c}) {\n  const x = [];\n  let y;\n  if (a) {\n    y = [b];\n  }\n  x.push(c);\n\n  // this scope should not merge with the above scope because y does not invalidate\n  // on changes to `c`\n  const z = [y];\n\n  // return [x, z];\n  return (\n    <>\n      <ValidateMemoization inputs={[a, b, c]} output={x} />\n      <ValidateMemoization inputs={[a, b]} output={z} />\n    </>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{a: false, b: null, c: 0}],\n  sequentialRenders: [\n    {a: false, b: null, c: 0},\n    {a: false, b: null, c: 1},\n    {a: true, b: 0, c: 1},\n    {a: true, b: 1, c: 1},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component Definition with Ternary Logic (Code)\nDESCRIPTION: Defines a React functional component named 'ternary' that accepts 'props' as input. It uses nested ternary operators to conditionally assign values to variables 'a' and 'b' based on the values of props. The component returns 'b' if 'a' is truthy, otherwise it returns null. This snippet is nearly identical to the \"Input\" snippet but uses double quotes around the string 'TodoAdd' in the params array.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ternary-expression.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction ternary(props) {\n  const a = props.a && props.b ? props.c || props.d : (props.e ?? props.f);\n  const b = props.a ? (props.b && props.c ? props.d : props.e) : props.f;\n  return a ? b : null;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: ternary,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining a React Component and State Update\nDESCRIPTION: This function defines a React component that attempts to modify an external variable 'x'. However, this approach is invalid in React because state should be managed using hooks or component props. The snippet highlights an invalid operation error that occur when trying to write to a variable defined outside the component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.not-useEffect-external-mutate.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n\"let x = {a: 42};\\n\\nfunction Component(props) {\\n  foo(() => {\\n    x.a = 10;\\n    x.a = 20;\\n  });\\n}\\n\"\n```\n\n----------------------------------------\n\nTITLE: React Compiler Runtime Optimized Component Function\nDESCRIPTION: An optimized version of the component function using React's compiler runtime. Implements memoization and prevents unnecessary re-renders by tracking state changes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/prop-capturing-function-1.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction component(a, b) {\n  const $ = _c(5);\n  let t0;\n  if ($[0] !== a || $[1] !== b) {\n    t0 = { a, b };\n    $[0] = a;\n    $[1] = b;\n    $[2] = t0;\n  } else {\n    t0 = $[2];\n  }\n  const z = t0;\n  let t1;\n  if ($[3] !== z) {\n    t1 = function () {\n      console.log(z);\n    };\n    $[3] = z;\n    $[4] = t1;\n  } else {\n    t1 = $[4];\n  }\n  const x = t1;\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with react/compiler-runtime\nDESCRIPTION: This is the compiled version of the React component using `react/compiler-runtime`. It utilizes the `_c` function for memoization and optimizes rendering by caching results based on props and dependencies.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/react-namespace.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nconst FooContext = React.createContext({ current: null });\n\nfunction Component(props) {\n  const $ = _c(5);\n  React.useContext(FooContext);\n  const ref = React.useRef();\n  const [, setX] = React.useState(false);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = () => {\n      setX(true);\n      ref.current = true;\n    };\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const onClick = t0;\n  let t1;\n  if ($[1] !== props.children) {\n    t1 = React.cloneElement(props.children);\n    $[1] = props.children;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  let t2;\n  if ($[3] !== t1) {\n    t2 = <div onClick={onClick}>{t1}</div>;\n    $[3] = t1;\n    $[4] = t2;\n  } else {\n    t2 = $[4];\n  }\n  return t2;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ children: <div>Hello</div> }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Optimizations\nDESCRIPTION: Compiled version of the React component with internal optimizations. Shows how useCallback is transformed and includes additional caching logic for rendered elements using compiler runtime utilities.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useCallback-call-second-function-which-captures-maybe-mutable-value-dont-preserve-memoization.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enablePreserveExistingMemoizationGuarantees:false @enableTransitivelyFreezeFunctionExpressions:false\nimport { useCallback } from \"react\";\nimport {\n  identity,\n  logValue,\n  makeObject_Primitives,\n  useHook,\n} from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(2);\n  const object = makeObject_Primitives();\n\n  useHook();\n\n  const log = () => {\n    logValue(object);\n  };\n\n  const onClick = () => {\n    log();\n  };\n\n  identity(object);\n  let t0;\n  if ($[0] !== onClick) {\n    t0 = <div onClick={onClick} />;\n    $[0] = onClick;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component with Dynamic Component Creation\nDESCRIPTION: A React functional component that dynamically creates a component during render by calling a method on a prop. This pattern can cause state reset issues and is flagged by React's validation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/static-components/invalid-dynamically-constructed-component-method-call.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @logger @validateStaticComponents\nfunction Example(props) {\n  const Component = props.foo.bar();\n  return <Component />;\n}\n```\n\n----------------------------------------\n\nTITLE: Input React Component with Conditional Object Creation\nDESCRIPTION: A React component that creates objects and establishes relationships between them based on conditional logic. It demonstrates a pattern where objects need to reference each other.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/phi-type-inference-property-store.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @debug\nfunction Component(props) {\n  const x = {};\n  let y;\n  if (props.cond) {\n    y = {};\n  } else {\n    y = {a: props.a};\n  }\n  // This should be inferred as `<store> y` s.t. `x` can still\n  // be independently memoized. *But* this also must properly\n  // extend the mutable range of the object literals in the\n  // if/else branches\n  y.x = x;\n\n  return [x, y];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{cond: false, a: 'a!'}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Counter Component with Optimizations\nDESCRIPTION: Optimized version of the counter component with compiler-runtime modifications. Implements memoization and conditional rendering based on state changes using compiler-generated variables and checks.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/merge-consecutive-scopes-reordering.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enableInstructionReordering\nimport { useState } from \"react\";\nimport { Stringify } from \"shared-runtime\";\n\nfunction Component() {\n  const $ = _c(7);\n  const [state, setState] = useState(0);\n  let t0;\n  let t1;\n  if ($[0] !== state) {\n    t0 = (\n      <button data-testid=\"button\" onClick={() => setState(state + 1)}>\n        increment\n      </button>\n    );\n    t1 = <span>{state}</span>;\n    $[0] = state;\n    $[1] = t0;\n    $[2] = t1;\n  } else {\n    t0 = $[1];\n    t1 = $[2];\n  }\n  let t2;\n  if ($[3] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t2 = <Stringify text=\"Counter\" />;\n    $[3] = t2;\n  } else {\n    t2 = $[3];\n  }\n  let t3;\n  if ($[4] !== t0 || $[5] !== t1) {\n    t3 = (\n      <div>\n        {t2}\n        {t1}\n        {t0}\n      </div>\n    );\n    $[4] = t0;\n    $[5] = t1;\n    $[6] = t3;\n  } else {\n    t3 = $[6];\n  }\n  return t3;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ value: 42 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a Non-React Function with useEffect\nDESCRIPTION: This function, nonReactFn, incorrectly attempts to use the useEffect hook from React. Proper dependency handling is necessary to avoid build errors. The function takes an argument which is used within the useEffect hook. Prerequisites include a React environment and knowledge of hooks.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/bailout-retry/error.callsite-in-non-react-fn.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @inferEffectDependencies @compilationMode(infer) @panicThreshold(none)\nimport {useEffect} from 'react';\n\nfunction nonReactFn(arg) {\n  useEffect(() => [1, 2, arg]);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining React Component and Test Fixture\nDESCRIPTION: This snippet defines a React component that renders a list of prop keys, and exports a fixture for testing the component with various prop combinations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-in-statement.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let items = [];\n  for (const key in props) {\n    items.push(<div key={key}>{key}</div>);\n  }\n  return <div>{items}</div>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{hello: null, world: undefined, '!': true}],\n  sequentialRenders: [\n    {a: null, b: null, c: null},\n    {lauren: true, mofei: true, sathya: true, jason: true},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Alternative Component Structure - JavaScript\nDESCRIPTION: This snippet provides an alternative structure for the same component function. It replaces the inner function declaration with a named function '_temp' for better readability. The function assignment to 'x' and export of FIXTURE_ENTRYPOINT remain consistent.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/simple-function-1.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component() {\n  const x = _temp;\n  return x;\n}\nfunction _temp(a) {\n  a.foo();\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: React Hook Compiled Implementation\nDESCRIPTION: Compiled version of the hook showing the internal React compiler optimizations. Implements the same functionality but with additional caching logic using array-based memoization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/consecutive-use-memo.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useMemo } from \"react\";\nimport { identity } from \"shared-runtime\";\n\nfunction useHook(t0) {\n  const $ = _c(7);\n  const { a, b } = t0;\n  let t1;\n  let t2;\n  if ($[0] !== a) {\n    t2 = identity({ a });\n    $[0] = a;\n    $[1] = t2;\n  } else {\n    t2 = $[1];\n  }\n  t1 = t2;\n  const valA = t1;\n  let t3;\n  let t4;\n  if ($[2] !== b) {\n    t4 = identity([b]);\n    $[2] = b;\n    $[3] = t4;\n  } else {\n    t4 = $[3];\n  }\n  t3 = t4;\n  const valB = t3;\n  let t5;\n  if ($[4] !== valA || $[5] !== valB) {\n    t5 = [valA, valB];\n    $[4] = valA;\n    $[5] = valB;\n    $[6] = t5;\n  } else {\n    t5 = $[6];\n  }\n  return t5;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useHook,\n  params: [{ a: 2, b: 3 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Implementation with Block Fallthrough\nDESCRIPTION: Compiled version of the fixture with explicit block handling, memoization, and early returns. Implements the same logic but with compiler-specific optimizations and block labeling.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/align-scopes-nested-block-structure.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { mutate } from \"shared-runtime\";\n\nfunction useFoo(t0) {\n  const $ = _c(4);\n  const { cond1, cond2 } = t0;\n  let s;\n  let t1;\n  if ($[0] !== cond1 || $[1] !== cond2) {\n    t1 = Symbol.for(\"react.early_return_sentinel\");\n    bb0: {\n      if (cond1) {\n        s = {};\n      } else {\n        t1 = null;\n        break bb0;\n      }\n      if (cond2) {\n        mutate(s);\n      }\n    }\n    $[0] = cond1;\n    $[1] = cond2;\n    $[2] = t1;\n    $[3] = s;\n  } else {\n    t1 = $[2];\n    s = $[3];\n  }\n  if (t1 !== Symbol.for(\"react.early_return_sentinel\")) {\n    return t1;\n  }\n  return s;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ cond1: true, cond2: false }],\n  sequentialRenders: [\n    { cond1: true, cond2: false },\n    { cond1: true, cond2: false },\n    { cond1: true, cond2: true },\n    { cond1: true, cond2: true },\n    { cond1: false, cond2: true },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: Optimized version of the component with compiler-generated memoization. Uses a cache array to store previous values and implements conditional recomputation based on input changes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/memoization-comments.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enableMemoizationComments\nimport { addOne, getNumber, identity } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(9);\n  let t0;\n  let x; // \"useMemo\" for t0 and x:\n  // check if props.a changed\n  if ($[0] !== props.a) {\n    // Inputs changed, recompute\n    x = identity(props.a);\n    t0 = addOne(x);\n    $[0] = props.a;\n    $[1] = t0;\n    $[2] = x;\n  } else {\n    // Inputs did not change, use cached value\n    t0 = $[1];\n    x = $[2];\n  }\n  const y = t0;\n  let t1; // \"useMemo\" for t1:\n  // check if props.b changed\n  if ($[3] !== props.b) {\n    // Inputs changed, recompute\n    t1 = identity(props.b);\n    $[3] = props.b;\n    $[4] = t1;\n  } else {\n    // Inputs did not change, use cached value\n    t1 = $[4];\n  }\n  const z = t1;\n  let t2; // \"useMemo\" for t2:\n  // check if x, y, or z changed\n  if ($[5] !== x || $[6] !== y || $[7] !== z) {\n    // Inputs changed, recompute\n    t2 = [x, y, z];\n    $[5] = x;\n    $[6] = y;\n    $[7] = z;\n    $[8] = t2;\n  } else {\n    // Inputs did not change, use cached value\n    t2 = $[8];\n  }\n  return t2;\n}\nexport const FIXTURE_ENTRYPOINT = { fn: Component, params: [{ a: 1, b: 10 }] };\n```\n\n----------------------------------------\n\nTITLE: Initial Function Implementation with Basic Logic\nDESCRIPTION: A JavaScript function that processes input arrays and performs internal transformations with nested function invocation\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-alias-computed-load-3.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction bar(a, b) {\n  let x = [a, b];\n  let y = {};\n  let t = {};\n  const f0 = function () {\n    y = x[0][1];\n    t = x[1][0];\n  };\n  f0();\n\n  return y;\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Invalid React Hook Usage in JavaScript\nDESCRIPTION: This snippet illustrates an invalid JavaScript function where a React Hook is conditionally called within a 'normal' function, which is against React's Hook rules. The function does not execute without warnings, emphasizing the need to adhere to consistent hook usage patterns. The example does not depend on external libraries but requires an understanding of React Hooks. It announces conditional variables like 'cond'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-rules-of-hooks-d740d54e9c21.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Expected to fail\n\n// Invalid because it's dangerous and might not warn otherwise.\n// This *must* be invalid.\nfunction normalFunctionWithConditionalHook() {\n  if (cond) {\n    useHookInsideNormalFunction();\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Memoization in JavaScript\nDESCRIPTION: This snippet shows an optimized version of the React component using compiler-runtime and memoization. It uses a Symbol-based cache sentinel to determine whether to execute the callback or return a cached result.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-within-function-expression.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(1);\n  const callback = _temp;\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = callback();\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\nfunction _temp() {\n  try {\n    return [];\n  } catch (t0) {\n    return;\n  }\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Conditional Rendering in React Component\nDESCRIPTION: This snippet defines a React component that conditionally renders based on props. It uses the useState hook and handles an array of items. The component showcases different rendering scenarios based on the 'cond' prop and the 'items' array.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-mutable-range-extending-into-ternary.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useState } from \"react\";\n\nfunction Component(props) {\n  const items = props.items ? props.items.slice() : [];\n  const [state] = useState(\"\");\n  return props.cond ? <div>{state}</div> : <div>{items.map(_temp)}</div>;\n}\nfunction _temp(item) {\n  return <div key={item.id}>{item.name}</div>;\n}\n```\n\n----------------------------------------\n\nTITLE: React Component Rendering\nDESCRIPTION: This example shows how different React components can now be rendered using the same DOM node. It demonstrates the ability to render one component, such as a `div`, and then subsequently render another component, such as a `span`, into the same DOM node without issues.  This allows for more dynamic and flexible rendering scenarios.\nSOURCE: https://github.com/facebook/react/blob/main/CHANGELOG.md#2025-04-21_snippet_28\n\nLANGUAGE: JavaScript\nCODE:\n```\n\"React.renderComponent(<div/>, domNode); React.renderComponent(<span/>, domNode);\"\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: Original React component showing a simple implementation that processes a listItem and thread, using hooks and conditional rendering based on thread type.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-no-value-for-temporary.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @flow @enableAssumeHooksFollowRulesOfReact @enableTransitivelyFreezeFunctionExpressions\nfunction Component(listItem, thread) {\n  const isFoo = isFooThread(thread.threadType);\n  const body = useBar(listItem, [getBadgeText(listItem, isFoo)]);\n\n  return body;\n}\n```\n\n----------------------------------------\n\nTITLE: Original React Component with Computed Properties\nDESCRIPTION: An example React component that computes values from props and conditionally calls functions. This represents the source code before compilation optimization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/interdependent-across-if.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction compute() {}\nfunction foo() {}\nfunction Foo() {}\n\n/**\n * Should produce 1 scope:\n *\n * return: inputs=props.a & props.b & props.c; outputs=return\n *   const a = compute(props.a);\n *   const b = compute(props.b);\n *   if (props.c)\n *     foo(a, b);\n *   return = <Foo a={a} b={b} />\n */\nfunction Component(props) {\n  const a = compute(props.a);\n  const b = compute(props.b);\n  if (props.c) {\n    foo(a, b);\n  }\n  return <Foo a={a} b={b} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Running ESLint v8 React Hooks Fixture\nDESCRIPTION: CLI commands to set up, build, and lint the React Hooks ESLint fixture project using Yarn package manager\nSOURCE: https://github.com/facebook/react/blob/main/fixtures/eslint-v8/README.md#2025-04-21_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ncd fixtures/eslint-v8\nyarn\nyarn build\nyarn lint\n```\n\n----------------------------------------\n\nTITLE: Optimizing React Component with Memoization in JavaScript\nDESCRIPTION: This snippet shows the optimized version of the component using React's compiler-runtime functions. It implements memoization to cache values and limit the mutable range of variables, potentially improving performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/alias-capture-in-method-receiver.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component() {\n  const $ = _c(2);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = someObj();\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const a = t0;\n  let t1;\n  if ($[1] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const x = [];\n    x.push(a);\n\n    t1 = [x, a];\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n```\n\n----------------------------------------\n\nTITLE: Running Default React Benchmarks\nDESCRIPTION: Runs benchmarks with default settings, building local and remote React and ReactDOM UMD bundles and executing all benchmark tests\nSOURCE: https://github.com/facebook/react/blob/main/scripts/bench/README.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn start\n```\n\n----------------------------------------\n\nTITLE: Compiled useMakeCallback Hook with React Compiler-Runtime\nDESCRIPTION: This is the compiled version of the `useMakeCallback` hook using React's compiler-runtime.  It utilizes `_c` to memoize the callback function based on `obj.value` and `setState`.  This optimization prevents unnecessary callback recreation on subsequent renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/assume-invoked/conditionally-return-fn.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { createHookWrapper } from \"shared-runtime\";\n\n/**\n * Assume that conditionally returned functions can be invoked and that their\n * property loads are hoistable to the function declaration site.\n */\nfunction useMakeCallback(t0) {\n  const $ = _c(3);\n  const { obj, shouldMakeCb, setState } = t0;\n  let t1;\n  if ($[0] !== obj.value || $[1] !== setState) {\n    t1 = () => setState(obj.value);\n    $[0] = obj.value;\n    $[1] = setState;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  const cb = t1;\n  if (shouldMakeCb) {\n    return cb;\n  } else {\n    return null;\n  }\n}\n\nconst setState = (arg: number) => {\n  \"use no memo\";\n  return arg;\n};\nexport const FIXTURE_ENTRYPOINT = {\n  fn: createHookWrapper(useMakeCallback),\n  params: [{ obj: { value: 1 }, shouldMakeCb: true, setState }],\n  sequentialRenders: [\n    { obj: { value: 1 }, shouldMakeCb: true, setState },\n    { obj: { value: 2 }, shouldMakeCb: true, setState },\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining a React Component with Function Returning Arrow Function (Input)\nDESCRIPTION: Original React component that creates a context object with a testFn method returning an arrow function. The component renders a Stringify component to display the context object with function invocation enabled.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-nested-object-method.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @compilationMode(infer)\n\nimport {Stringify} from 'shared-runtime';\n\nfunction Test() {\n  const context = {\n    testFn() {\n      // if it is an arrow function its work\n      return () => 'test'; // it will break compile if returns an arrow fn\n    },\n  };\n\n  return <Stringify value={context} shouldInvokeFns={true} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Test,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: React Compiler-Transformed Function with Memoization\nDESCRIPTION: The compiler-transformed version of the function uses React's compiler runtime to cache computation results. It tracks previous parameter values and only recomputes when inputs change, improving performance by avoiding unnecessary recreations of arrays.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/overlapping-scopes-within-block.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction foo(a, b, c) {\n  const $ = _c(7);\n  let x;\n  if ($[0] !== a || $[1] !== b || $[2] !== c) {\n    x = [];\n    if (a) {\n      let y;\n      if ($[4] !== b || $[5] !== c) {\n        y = [];\n        if (b) {\n          y.push(c);\n        }\n        $[4] = b;\n        $[5] = c;\n        $[6] = y;\n      } else {\n        y = $[6];\n      }\n\n      x.push(y);\n    }\n    $[0] = a;\n    $[1] = b;\n    $[2] = c;\n    $[3] = x;\n  } else {\n    x = $[3];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled FBT Output Implementation\nDESCRIPTION: Compiled JavaScript output showing how FBT transforms the plural handling into optimized code. Includes caching mechanism for repeated renders and complex plural logic handling through nested conditions.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/bug-fbt-plural-multiple-mixed-call-tag.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport fbt from \"fbt\";\n\nfunction useFoo(t0) {\n  const $ = _c(3);\n  const { apples, bananas } = t0;\n  let t1;\n  if ($[0] !== apples || $[1] !== bananas) {\n    t1 = (\n      <div>\n        {fbt._(\n          {\n            \"*\": {\n              \"*\": \"{number of apples} apples and {number of bananas} bananas\",\n            },\n            _1: { _1: \"{number of apples} apple and 1 banana\" },\n          },\n          [\n            fbt._plural(apples),\n            fbt._plural(bananas, \"number of bananas\"),\n            fbt._param(\"number of apples\", apples),\n          ],\n          { hk: \"2xXrUW\" },\n        )}\n      </div>\n    );\n    $[0] = apples;\n    $[1] = bananas;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ apples: 1, bananas: 2 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Basic GraphQL Fragment Component\nDESCRIPTION: Simple React component defining a GraphQL fragment with an ID field, without memoization\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/tagged-template-literal.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component() {\n  let t = graphql`\n    fragment F on T {\n      id\n    }\n  `;\n\n  return t;\n}\n```\n\n----------------------------------------\n\nTITLE: Using Conditional Logic in a Custom Hook in React\nDESCRIPTION: This snippet shows an alternative implementation of the 'useFoo' function without memoization. It directly assigns values based on the condition provided as an argument. This implementation serves a similar purpose but does not optimize for performance using 'useMemo'. The outputs remain the same (10 or 5), depending on the input condition.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/prune-nonescaping-useMemo-mult-returns.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees\n\nimport { useMemo } from \"react\";\nimport { identity } from \"shared-runtime\";\n\nfunction useFoo(cond) {\n  let t0;\n  if (cond) {\n    t0 = identity(10);\n  } else {\n    t0 = identity(5);\n  }\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [true],\n};\n```\n\n----------------------------------------\n\nTITLE: Original String Concatenation Implementation\nDESCRIPTION: Initial implementation of a function that concatenates string literals using multiple variables and concatenation operations. Includes fixture setup for testing.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/constant-propagation-string-concat.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo() {\n  const a = 'a' + 'b';\n  const c = 'c';\n  return a + c;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple React Component Function\nDESCRIPTION: This snippet defines a JavaScript function using destructuring to extract values from an object, and exposes it via an export. It requires no external dependencies and outputs a constant value extracted from the input. Parameters are fixed and the function is not designed as a React component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructure-string-literal-invalid-identifier-property-key.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo() {\n  const {'data-foo-bar': t} = {'data-foo-bar': 1};\n  return t;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Fire Component in React - JavaScript\nDESCRIPTION: This snippet illustrates a React functional component called FireComponent. It employs fire to handle its properties through a defined foo function that logs its received props. The component uses the useEffect hook, which calls fire with the function wrapped in a conditional check based on props. Required dependencies include React and fire.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/bailout-retry/no-fire-todo-syntax-shouldnt-throw.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c, useFire } from \"react/compiler-runtime\"; // @enableFire @panicThreshold(none)\nimport { fire } from \"react\";\n\n/**\n * Compilation of this file should succeed.\n */\nfunction FireComponent(props) {\n  const $ = _c(3);\n\n  const foo = _temp;\n  const t0 = useFire(foo);\n  let t1;\n  if ($[0] !== props || $[1] !== t0) {\n    t1 = () => {\n      t0(props);\n    };\n    $[0] = props;\n    $[1] = t0;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  useEffect(t1);\n  return null;\n}\nfunction _temp(props_0) {\n  console.log(props_0);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Initializing React Component with Fire Method\nDESCRIPTION: A React component that attempts to use the `fire()` method with an invalid method call, which triggers a compilation error. The code demonstrates an incorrect approach to invoking the `fire()` method.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/error.todo-method.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableFire\nimport {fire} from 'react';\n\nfunction Component(props) {\n  const foo = () => {\n    console.log(props);\n  };\n  useEffect(() => {\n    fire(props.foo());\n  });\n\n  return null;\n}\n```\n\n----------------------------------------\n\nTITLE: Simplified Function Throwing a Value and Exporting in JavaScript\nDESCRIPTION: This snippet defines a minimal JavaScript function named foo that immediately throws the value 2. It is then exported in an object named FIXTURE_ENTRYPOINT, similar to the previous example. The function lacks inputs and uses a hardcoded throw statement, simplifying its logic. This export maintains the same structure with a params array and a boolean flagging it as not a component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-throw.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo() {\n  throw 2;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Handling ReactiveScope with Shared Runtime in JavaScript\nDESCRIPTION: This snippet creates a React component and shows an edge case for how ReactiveScope propagates variables. Dependencies include 'shared-runtime'. It illustrates a potential invariant violation due to differences in evaluator results, and includes logic to render a component using a Stringify function. This snippet expects inputs from shared constants and utilities, and outputs JSX with a component's serialized state.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/bug-invalid-phi-as-dependency.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {CONST_TRUE, Stringify, mutate, useIdentity} from 'shared-runtime';\n\n/**\n * Fixture showing an edge case for ReactiveScope variable propagation.\n *\n * Found differences in evaluator results\n *   Non-forget (expected):\n *   <div>{\"obj\":{\"inner\":{\"value\":\"hello\"},\"wat0\":\"joe\"},\"inner\":[\"[[ cyclic ref *2 ]]\"]}</div>\n *   <div>{\"obj\":{\"inner\":{\"value\":\"hello\"},\"wat0\":\"joe\"},\"inner\":[\"[[ cyclic ref *2 ]]\"]}</div>\n *   Forget:\n *   <div>{\"obj\":{\"inner\":{\"value\":\"hello\"},\"wat0\":\"joe\"},\"inner\":[\"[[ cyclic ref *2 ]]\"]}</div>\n *   [[ (exception in render) Error: invariant broken ]]\n *\n */\nfunction Component() {\n  const obj = CONST_TRUE ? {inner: {value: 'hello'}} : null;\n  const boxedInner = [obj?.inner];\n  useIdentity(null);\n  mutate(obj);\n  if (boxedInner[0] !== obj?.inner) {\n    throw new Error('invariant broken');\n  }\n  return <Stringify obj={obj} inner={boxedInner} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{arg: 0}],\n  sequentialRenders: [{arg: 0}, {arg: 1}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Inferred Effect Dependencies\nDESCRIPTION: The compiled version of the component with React compiler optimizations applied. The compiler has detected that 'arr' depends on 'propVal' and automatically added it to the dependency array. It also includes memoization logic to prevent unnecessary recreations of the array and effect callback.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/reactive-variable.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @inferEffectDependencies\nimport { useEffect } from \"react\";\nimport { print } from \"shared-runtime\";\n\nfunction ReactiveVariable(t0) {\n  const $ = _c(4);\n  const { propVal } = t0;\n  let t1;\n  if ($[0] !== propVal) {\n    t1 = [propVal];\n    $[0] = propVal;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  const arr = t1;\n  let t2;\n  if ($[2] !== arr) {\n    t2 = () => print(arr);\n    $[2] = arr;\n    $[3] = t2;\n  } else {\n    t2 = $[3];\n  }\n  useEffect(t2, [arr]);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Function with React Compiler Runtime\nDESCRIPTION: This snippet defines an enhanced version of the `bar` function that integrates with React's compiler runtime. It uses a hook pattern to maintain state across invocations, checking if the input has changed and updating the output accordingly. The exported constant remains similar, providing a structure for taking parameters for tests.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-alias-computed-load-2-iife.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction bar(a) {\n  const $ = _c(2);\n  let y;\n  if ($[0] !== a) {\n    const x = [a];\n    y = {};\n\n    y = x[0][1];\n    $[0] = a;\n    $[1] = y;\n  } else {\n    y = $[1];\n  }\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: bar,\n  params: [[\"val1\", \"val2\"]],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Hook with Memoization\nDESCRIPTION: The compiled version of the useFoo hook with automatic memoization added by React Compiler. It includes render counting in development, dependency tracking, and result caching to avoid redundant calculations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/codegen-emit-imports-same-source.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport {\n  makeReadOnly,\n  shouldInstrument,\n  useRenderCounter,\n} from \"react-compiler-runtime\";\nimport { c as _c } from \"react/compiler-runtime\"; // @enableEmitFreeze @enableEmitInstrumentForget\n\nfunction useFoo(props) {\n  if (DEV && shouldInstrument)\n    useRenderCounter(\"useFoo\", \"/codegen-emit-imports-same-source.ts\");\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== props.x) {\n    t0 = foo(props.x);\n    $[0] = props.x;\n    $[1] = __DEV__ ? makeReadOnly(t0, \"useFoo\") : t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Function and Fixture Entry Point in JavaScript\nDESCRIPTION: The snippet defines a function 'bar' that manipulates elements of arrays using closures and returns a specific element. It also exports an object 'FIXTURE_ENTRYPOINT' that includes the function and its parameters for testing. The function 'bar' requires no additional dependencies and is invoked with tuples where each tuple contains two numbers.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-alias-computed-load-3-iife.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction bar(a, b) {\n  let x = [a, b];\n  let y = {};\n  let t = {};\n  (function () {\n    y = x[0][1];\n    t = x[1][0];\n  })();\n\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: bar,\n  params: [\n    [1, 2],\n    [2, 3],\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: React Compiler Optimized Component with Memoization\nDESCRIPTION: An enhanced version of the component using React compiler runtime for memoization and cache management. Implements a caching mechanism to optimize rendering performance\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-member-expression-tag-grouping.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const maybeMutable = new MaybeMutable();\n    t0 = <Foo.Bar>{maybeMutate(maybeMutable)}</Foo.Bar>;\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n```\n\n----------------------------------------\n\nTITLE: Starting SSR Fixtures in Production Mode\nDESCRIPTION: Command to run the SSR fixtures in production mode. This pre-builds all static resources and starts a server-side rendering HTTP server without hot reloading.\nSOURCE: https://github.com/facebook/react/blob/main/fixtures/ssr/README.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nyarn start:prod\n```\n\n----------------------------------------\n\nTITLE: Transformed React Component with memoization\nDESCRIPTION: This code represents the transformed React component after applying the custom `idx` macro. It uses the `react/compiler-runtime` to optimize the component's rendering by memoizing the results of the `idx` calls. This improves performance by avoiding redundant calculations when the input `props` object remains unchanged.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/idx-method-no-outlining.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n```javascript\nimport { c as _c } from \"react/compiler-runtime\"; // @customMacros(idx.a)\n\nfunction Component(props) {\n  const $ = _c(10);\n  let t0;\n  if ($[0] !== props) {\n    t0 = idx(props, _temp);\n    $[0] = props;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const groupName1 = t0;\n  let t1;\n  if ($[2] !== props) {\n    t1 = idx.a(props, (__0) => __0.group.label);\n    $[2] = props;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  const groupName2 = t1;\n  let t2;\n  if ($[4] !== props) {\n    t2 = idx.a.b(props, _temp2);\n    $[4] = props;\n    $[5] = t2;\n  } else {\n    t2 = $[5];\n  }\n  const groupName3 = t2;\n  let t3;\n  if ($[6] !== groupName1 || $[7] !== groupName2 || $[8] !== groupName3) {\n    t3 = (\n      <div>\n        {groupName1}\n        {groupName2}\n        {groupName3}\n      </div>\n    );\n    $[6] = groupName1;\n    $[7] = groupName2;\n    $[8] = groupName3;\n    $[9] = t3;\n  } else {\n    t3 = $[9];\n  }\n  return t3;\n}\nfunction _temp2(__1) {\n  return __1.group.label;\n}\nfunction _temp(_) {\n  return _.group.label;\n}\n\n```\n```\n\n----------------------------------------\n\nTITLE: Exporting a Fixture Entry Point - JavaScript\nDESCRIPTION: Exports a constant 'FIXTURE_ENTRYPOINT' containing the 'MyApp' function, an empty parameter array, and a flag indicating it's not a component. This is useful for module exports in JavaScript and allows for easy integration into other parts of the application.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/issue933-disjoint-set-infinite-loop.expect.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nexport const FIXTURE_ENTRYPOINT = {\n  fn: MyApp,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with Data Processing\nDESCRIPTION: This snippet defines a React component that processes an array of data objects, summing the 'current' values and calling an identity function on 'other' values. It also includes a test fixture for the component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-dce-circular-reference.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {identity} from 'shared-runtime';\n\nfunction Component({data}) {\n  let x = 0;\n  for (const item of data) {\n    const {current, other} = item;\n    x += current;\n    identity(other);\n  }\n  return [x];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\n    {\n      data: [\n        {current: 2, other: 3},\n        {current: 4, other: 5},\n      ],\n    },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with Conditional Array Initialization in JavaScript\nDESCRIPTION: A React component that conditionally initializes an array based on props, then mutates it by pushing an object. This demonstrates how array mutability affects memoization in React components.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/phi-type-inference-array-push-consecutive-phis.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {makeArray} from 'shared-runtime';\n\nfunction Component(props) {\n  const x = {};\n  let y;\n  if (props.cond) {\n    if (props.cond2) {\n      y = [props.value];\n    } else {\n      y = [props.value2];\n    }\n  } else {\n    y = [];\n  }\n  // This should be inferred as `<store> y` s.t. `x` can still\n  // be independently memoized. *But* this also must properly\n  // extend the mutable range of the array literals in the\n  // if/else branches\n  y.push(x);\n\n  return [x, y];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{cond: true, cond2: true, value: 42}],\n  sequentialRenders: [\n    {cond: true, cond2: true, value: 3.14},\n    {cond: true, cond2: true, value: 42},\n    {cond: true, cond2: true, value: 3.14},\n    {cond: true, cond2: false, value2: 3.14},\n    {cond: true, cond2: false, value2: 42},\n    {cond: true, cond2: false, value2: 3.14},\n    {cond: false},\n    {cond: false},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage of useRef in useEffect Dependency Array\nDESCRIPTION: This code demonstrates an error case where ref.current is used in a useEffect dependency array. In React, ref values should not be accessed during render, and including ref.current in the dependency array causes this violation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.hook-ref-value.expect.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useEffect, useRef} from 'react';\n\nfunction Component(props) {\n  const ref = useRef();\n  useEffect(() => {}, [ref.current]);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: React Compiler Runtime Optimized Component\nDESCRIPTION: Advanced implementation of React component using compiler runtime memoization. Implements caching mechanism to optimize repeated renders and minimize unnecessary data fetching.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/await.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nasync function Component(props) {\n  const $ = _c(4);\n  let t0;\n  if ($[0] !== props.id) {\n    t0 = await load(props.id);\n    $[0] = props.id;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const user = t0;\n  let t1;\n  if ($[2] !== user.name) {\n    t1 = <div>{user.name}</div>;\n    $[2] = user.name;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  return t1;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing useCallback for Memoization in React Component - JavaScript\nDESCRIPTION: This snippet demonstrates a React component that uses the useCallback hook to memoize a function based on an entity property. The memoization ensures that the function is not re-created unnecessarily unless its dependencies change. Dependencies include the React library and the useCallback hook. The Component is meant to render conditional content based on whether an entity is present and display a message using children nodes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useCallback-nonescaping-invoked-callback-escaping-return.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees @enableAssumeHooksFollowRulesOfReact @enableTransitivelyFreezeFunctionExpressions\nimport {useCallback} from 'react';\n\nfunction Component({entity, children}) {\n  const showMessage = useCallback(() => entity != null);\n\n  // We currently model functions as if they could escape intor their return value\n  // but if we ever changed that (or did optimization to figure out cases where they\n  // are known not to) we could get a false positive validation error here, since\n  // showMessage doesn't need to be memoized since it doesn't escape in this instance.\n  const shouldShowMessage = showMessage();\n  return (\n    <div>\n      <div>{shouldShowMessage}</div>\n      <div>{children}</div>\n    </div>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\n    {\n      entity: {name: 'Sathya'},\n      children: [<div key=\"gsathya\">Hi Sathya!</div>],\n    },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component Definition (Compiled Code)\nDESCRIPTION: This JavaScript code represents the compiled version of a React component. It utilizes `react/compiler-runtime`'s `_c` function, likely for memoization or optimization. The code checks if the input `a` has changed, and if so, updates a cached object `t0`. This optimizes rendering by preventing unnecessary re-renders when the input remains the same. The `FIXTURE_ENTRYPOINT` remains consistent with the input code.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-mutate-3.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction component(a, b) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== a) {\n    t0 = { a };\n    $[0] = a;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const z = t0;\n  return z;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Component Definition with Reactive Props\nDESCRIPTION: This code defines a React component that uses a for loop whose update expression is determined by the `props.update` value. Although the variable `x` is directly assigned non-reactive values, its value depends on the loop variable `i`, whose update is influenced by `props.update`. This makes `x` implicitly reactive. The component returns an array containing `x`.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-for-update.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let x;\n  for (let i = 0; i < 10; i += props.update) {\n    if (i > 0 && i % 2 === 0) {\n      x = 2;\n    } else {\n      x = 1;\n    }\n  }\n  // The values assigned to `x` are non-reactive, but the value of `x`\n  // depends on the \"control\" variable `i`, whose possible values are\n  // affected by `props.update` which is reactive.\n  // Therefore x should be treated as reactive too.\n  return [x];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  sequentialRenders: [\n    {update: 2},\n    {update: 2},\n    {update: 1},\n    {update: 1},\n    {update: 2},\n    {update: 1},\n    {update: 2},\n    {update: 1},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with Context Input Test\nDESCRIPTION: Defines React components that test context access patterns and memoization. Component renders a Provider with an Inner component that conditionally uses context value and validates memoization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/use-operator-conditional.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {ValidateMemoization} from 'shared-runtime';\nimport {use, useMemo} from 'react';\n\nconst FooContext = React.createContext(null);\nfunction Component(props) {\n  return (\n    <FooContext.Provider value={props.value}>\n      <Inner cond={props.cond} />\n    </FooContext.Provider>\n  );\n}\n\nfunction Inner(props) {\n  let input = null;\n  if (props.cond) {\n    input = use(FooContext);\n  }\n  const output = useMemo(() => [input], [input]);\n  return <ValidateMemoization inputs={[input]} output={output} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{cond: true, value: 42}],\n  sequentialRenders: [\n    // change cond true->false\n    {cond: true, value: 42},\n    {cond: false, value: 42},\n\n    // change value\n    {cond: false, value: null},\n    {cond: false, value: 42},\n\n    // change cond false->true\n    {cond: true, value: 42},\n\n    // change cond true->false, change unobserved value, change cond false->true\n    {cond: false, value: 42},\n    {cond: false, value: null},\n    {cond: true, value: 42},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Input React Component With Primitive Objects\nDESCRIPTION: Original React component implementation that uses makeObject_Primitives and handles primitive object operations within JSX.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/allow-locals-named-like-hooks.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {makeObject_Primitives, Stringify} from 'shared-runtime';\n\nfunction Component(props) {\n  let useFeature = makeObject_Primitives();\n  let x;\n  if (useFeature) {\n    x = [useFeature + useFeature].push(-useFeature);\n  }\n  let y = useFeature;\n  let z = useFeature.useProperty;\n  return (\n    <Stringify val={useFeature}>\n      {x}\n      {y}\n      {z}\n    </Stringify>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Installing React and React Markup\nDESCRIPTION: This snippet provides installation instructions for the react and react-markup packages using npm, allowing the rendering of standalone HTML for embedded contexts.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-markup/README.md#2025-04-21_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm install react react-markup\n```\n\n----------------------------------------\n\nTITLE: Optimized React Compiler GraphQL Fragment\nDESCRIPTION: React component with compiler runtime optimization for GraphQL fragment memoization, using a cached approach to prevent redundant fragment creation\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/tagged-template-literal.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction component() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = graphql`\n      fragment F on T {\n        id\n      }\n    `;\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const t = t0;\n  return t;\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled React Hook with Memoization\nDESCRIPTION: Compiled version of the hook with added memoization logic using React's compiler runtime. It includes dependency tracking and caching mechanism to prevent unnecessary recalculations when inputs haven't changed.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/computed-store-alias.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { mutate } from \"shared-runtime\";\nfunction useHook(t0) {\n  const $ = _c(3);\n  const { a, b } = t0;\n  let x;\n  if ($[0] !== a || $[1] !== b) {\n    const y = { a };\n    x = { b };\n    x.y = y;\n    mutate(x);\n    $[0] = a;\n    $[1] = b;\n    $[2] = x;\n  } else {\n    x = $[2];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useHook,\n  params: [{ a: 2, b: 3 }],\n  sequentialRenders: [\n    { a: 2, b: 3 },\n    { a: 2, b: 3 },\n    { a: 3, b: 3 },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized Component Props Handling - JavaScript\nDESCRIPTION: This enhanced JavaScript function 'Component' uses an imported module from 'react/compiler-runtime' for optimized state handling. It checks for changes in props and updates its internal state accordingly while caching result values to avoid unnecessary re-renders. The code illustrates efficient state management techniques in a React-like infrastructure while employing hooks-like caching for performance improvements.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-cascading-eliminated-phis.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(7);\n  let x = 0;\n  let values;\n  if (\n    $[0] !== props.a ||\n    $[1] !== props.b ||\n    $[2] !== props.c ||\n    $[3] !== props.d ||\n    $[4] !== x\n  ) {\n    values = [];\n    const y = props.a || props.b;\n    values.push(y);\n    if (props.c) {\n      x = 1;\n    }\n\n    values.push(x);\n    if (props.d) {\n      x = 2;\n    }\n\n    values.push(x);\n    $[0] = props.a;\n    $[1] = props.b;\n    $[2] = props.c;\n    $[3] = props.d;\n    $[4] = x;\n    $[5] = values;\n    $[6] = x;\n  } else {\n    values = $[5];\n    x = $[6];\n  }\n  return values;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ a: 0, b: 1, c: true, d: true }],\n  sequentialRenders: [\n    { a: 0, b: 1, c: true, d: true },\n    { a: 4, b: 1, c: true, d: true },\n    { a: 4, b: 1, c: false, d: true },\n    { a: 4, b: 1, c: false, d: false },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Preparing Release from NPM in Shell\nDESCRIPTION: This script promotes a specific commit version to stable in the NPM registry. It requires a version tag as an argument, which represents the commit ID and date. The expected input is a version string, and upon execution, it prepares the release for publication.\nSOURCE: https://github.com/facebook/react/blob/main/scripts/release/README.md#2025-04-21_snippet_11\n\nLANGUAGE: sh\nCODE:\n```\nscripts/release/prepare-release-from-npm.js --version=0.0.0-241c4467e-20200129\n```\n\n----------------------------------------\n\nTITLE: Custom Hook for Value Retrieval\nDESCRIPTION: A simple custom hook that returns a static string value, used for demonstration purposes\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-outlining-simple.expect.md#2025-04-21_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nfunction useX() {\n  return 'x';\n}\n```\n\n----------------------------------------\n\nTITLE: React Compiler Error Message for Memoization Issues\nDESCRIPTION: This error message shows how React Compiler detects and reports a situation where it cannot preserve memoization guarantees. The error occurs when a dependency array contains a reference that might be mutated later, potentially causing unexpected value changes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.false-positive-useMemo-infer-mutate-deps.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n  12 |   return useMemo(() => {\n  13 |     return identity(val);\n> 14 |   }, [val]);\n     |       ^^^ CannotPreserveMemoization: React Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. This dependency may be mutated later, which could cause the value to change unexpectedly (14:14)\n  15 | }\n  16 |\n  17 | export const FIXTURE_ENTRYPOINT = {\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: The compiled version of the component using React compiler runtime. Implements memoization using an array cache to prevent unnecessary re-renders when props haven't changed.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-propagate-type-of-ternary-jsx.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction V0(t0) {\n  const $ = _c(4);\n  const { v1, v2 } = t0;\n  const v5 = v1.v6?.v7;\n  let t1;\n  if ($[0] !== v1 || $[1] !== v2 || $[2] !== v5) {\n    t1 = (\n      <Component8 c9={va} cb=\"apqjx\">\n        {v5 != null ? (\n          <ComponentC cd={v5}>\n            <ComponentE cf={v1} c10={v2} />\n          </ComponentC>\n        ) : (\n          <ComponentE cf={v1} c10={v2} />\n        )}\n      </Component8>\n    );\n    $[0] = v1;\n    $[1] = v2;\n    $[2] = v5;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  return t1;\n}\n```\n\n----------------------------------------\n\nTITLE: Original React Component with useEffect\nDESCRIPTION: A React function component that creates an object with nested properties and uses useEffect to print a value. The @inferEffectDependencies directive indicates that effect dependencies should be automatically inferred.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/reactive-memberexpr.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @inferEffectDependencies\nimport {useEffect} from 'react';\nimport {print} from 'shared-runtime';\n\nfunction ReactiveMemberExpr({propVal}) {\n  const obj = {a: {b: propVal}};\n  useEffect(() => print(obj.a.b));\n}\n```\n\n----------------------------------------\n\nTITLE: Function with For Loop in Try/Catch Block (JavaScript)\nDESCRIPTION: A JavaScript function that demonstrates a compiler error case where a for loop with comparison operations is placed within a try/catch block. This specific code pattern previously failed during the LeaveSSA phase of compilation and is identified as an unsupported feature in the Hermes compiler.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-repro-declaration-for-all-identifiers.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Foo() {\n  try {\n    // NOTE: this fixture previously failed during LeaveSSA;\n    // double-check this code when supporting value blocks in try/catch\n    for (let i = 0; i < 2; i++) {}\n  } catch {}\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Optimization\nDESCRIPTION: Compiled version of the component with React compiler runtime optimizations. Includes conditional rendering based on forget feature flag and memoization implementation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/gating-with-hoisted-type-reference.flow.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { isForgetEnabled_Fixtures } from \"ReactForgetFeatureFlag\";\nimport { memo } from \"react\";\n\ntype Props = React.ElementConfig<typeof Component>;\nconst Component = isForgetEnabled_Fixtures()\n  ? function Component(t0) {\n      const $ = _c(2);\n      const { value } = t0;\n      let t1;\n      if ($[0] !== value) {\n        t1 = <div>{value}</div>;\n        $[0] = value;\n        $[1] = t1;\n      } else {\n        t1 = $[1];\n      }\n      return t1;\n    }\n  : function Component({ value }: $ReadOnly<{ value: string }>) {\n      return <div>{value}</div>;\n    };\n\nexport default memo<Props>(Component);\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: eval(\"Component\"),\n  params: [{ value: \"foo\" }],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: This code represents the compiled version of the React component, leveraging the `react/compiler-runtime` to memoize portions of the virtual DOM tree. The `_c` function is used to store and retrieve previously rendered `div` elements based on the `props.value` and `x` variables.  `useHook()` is used to prevent certain memoizations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/prune-scopes-whose-deps-invalidate-jsx.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useHook } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(6);\n  const o = {};\n  let t0;\n  if ($[0] !== props.value) {\n    t0 = <div>{props.value}</div>;\n    $[0] = props.value;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const x = t0;\n  useHook();\n  o.value = props.value;\n  let t1;\n  if ($[2] !== x) {\n    t1 = <div>{x}</div>;\n    $[2] = x;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  const y = t1;\n  let t2;\n  if ($[4] !== y) {\n    t2 = <div>{y}</div>;\n    $[4] = y;\n    $[5] = t2;\n  } else {\n    t2 = $[5];\n  }\n  return t2;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ value: \"sathya\" }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Evaluating Expression Sequence Points in JavaScript React Fixture\nDESCRIPTION: A function that demonstrates sequence point evaluation in JavaScript. It contains a variable initialization and a complex return statement where the variable is both read and modified within the same expression.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/expression-with-assignment.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction f() {\n  let x = 1;\n  return x + (x = 2) + x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: f,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component Definition\nDESCRIPTION: This code shows the compiled version of the `Component` after it has been processed by the React compiler. It uses `_c` from `react/compiler-runtime` to create a cache for the `div` element. It also calls `useCustomHook` with the string \"hello\".\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/import-as-local.expect.md#2025-04-21_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component() {\n  const $ = _c(1);\n  useCustomHook(\"hello\");\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = <div>Hello</div>;\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n```\n\n----------------------------------------\n\nTITLE: React Compiler Runtime with Component in JavaScript\nDESCRIPTION: This code snippet defines a React functional component augmented by 'react/compiler-runtime' to manage component state with memoization. It optimizes rendering by caching results of operations using symbolic placeholders, reducing unnecessary computations when values are unchanged. This version complements 'shared-runtime' methods with additional runtime-specific state handling.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-from-captures-arg0.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useIdentity, Stringify } from \"shared-runtime\";\n\n/**\n * TODO: Note that this `Array.from` is inferred to be mutating its first\n * argument. This is because React Compiler's typing system does not yet support\n * annotating a function with a set of argument match cases + distinct\n * definitions (polymorphism)\n *\n * In this case, we should be able to infer that the `Array.from` call is\n * not mutating its 0th argument.\n * The 0th argument should be typed as having `effect:Mutate` only when\n * (1) it might be a mutable iterable or\n * (2) the 1st argument might mutate its callee\n */\nfunction Component(t0) {\n  const $ = _c(10);\n  const { value } = t0;\n  let t1;\n  let t2;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = { value: \"foo\" };\n    t2 = { value: \"bar\" };\n    $[0] = t1;\n    $[1] = t2;\n  } else {\n    t1 = $[0];\n    t2 = $[1];\n  }\n  let t3;\n  if ($[2] !== value) {\n    t3 = [t1, t2, { value }];\n    $[2] = value;\n    $[3] = t3;\n  } else {\n    t3 = $[3];\n  }\n  const arr = t3;\n  useIdentity();\n  let t4;\n  if ($[4] !== arr) {\n    t4 = Array.from(arr);\n    $[4] = arr;\n    $[5] = t4;\n  } else {\n    t4 = $[5];\n  }\n  const derived = t4;\n  let t5;\n  if ($[6] !== derived) {\n    t5 = derived.at(-1);\n    $[6] = derived;\n    $[7] = t5;\n  } else {\n    t5 = $[7];\n  }\n  let t6;\n  if ($[8] !== t5) {\n    t6 = <Stringify>{t5}</Stringify>;\n    $[8] = t5;\n    $[9] = t6;\n  } else {\n    t6 = $[9];\n  }\n  return t6;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ value: 5 }],\n  sequentialRenders: [{ value: 5 }, { value: 6 }, { value: 6 }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Input: React Component with useSharedValue Hook\nDESCRIPTION: A React component that uses the useSharedValue hook from react-native-reanimated to create a button that updates a shared value with random numbers. The component demonstrates how shared values can be modified in event handlers.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reanimated-shared-value-writes.expect.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableCustomTypeDefinitionForReanimated\nimport {useSharedValue} from 'react-native-reanimated';\n\n/**\n * https://docs.swmansion.com/react-native-reanimated/docs/2.x/api/hooks/useSharedValue/\n *\n * Test that shared values are treated as ref-like, i.e. allowing writes outside\n * of render\n */\nfunction SomeComponent() {\n  const sharedVal = useSharedValue(0);\n  return (\n    <Button\n      onPress={() => (sharedVal.value = Math.random())}\n      title=\"Randomize\"\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Original React Component with useFragment and useFreeze Hooks\nDESCRIPTION: A React component that uses useFragment and useFreeze hooks to manage data. It creates a MaybeMutable instance and renders nested Views with text content.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-memo-value-not-promoted-to-outer-scope-dynamic.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const item = useFragment(FRAGMENT, props.item);\n  useFreeze(item);\n\n  const count = new MaybeMutable(item);\n  return (\n    <View>\n      <View>\n        {<span>Text</span>}\n        {<span>{maybeMutate(count)}</span>}\n      </View>\n    </View>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying React Hook Using Compiler Runtime with State Reallocation in JavaScript\nDESCRIPTION: The code snippet introduces a more complex version of `useFoo`, utilizing a compiler-runtime hook (`_c`) for stateful logic within a React hook. It checks and reallocates an array `x` based on changes in properties such as `bar`, `cond`, and `foo`. Required dependencies include `react/compiler-runtime` for state management. The input includes conditional and numerical properties with the output being an adjusted state maintained over time. It's constrained by the complexity of managing multiple state checks inline.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-renaming-ternary.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction useFoo(props) {\n  const $ = _c(5);\n  let x;\n  if ($[0] !== props.bar) {\n    x = [];\n    x.push(props.bar);\n    $[0] = props.bar;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  if ($[2] !== props.cond || $[3] !== props.foo) {\n    props.cond ? ((x = []), x.push(props.foo)) : null;\n    $[2] = props.cond;\n    $[3] = props.foo;\n    $[4] = x;\n  } else {\n    x = $[4];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ cond: false, foo: 2, bar: 55 }],\n  sequentialRenders: [\n    { cond: false, foo: 2, bar: 55 },\n    { cond: false, foo: 3, bar: 55 },\n    { cond: true, foo: 3, bar: 55 },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with State Update and Export\nDESCRIPTION: This snippet defines a React component named 't' that uses the useState hook to trigger a state update with `setstate(1)`. It then returns the value of the `foo` prop. The `FIXTURE_ENTRYPOINT` object exports metadata about the component, including a reference to the component function, the expected parameter names ('TodoAdd'), and the component's name ('TodoAdd').\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/holey-array.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction t(props) {\n  const [, setstate] = useState();\n  setstate(1);\n  return props.foo;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: t,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n\n```\n\n----------------------------------------\n\nTITLE: Memoizing Component Initialization in React\nDESCRIPTION: Enhances the Component function using React's internal memoization cache to avoid repeated initialization of object instances. Utilizes the '_c' function imported from 'react/compiler-runtime' to cache the component state, increasing efficiency by only initializing once per component lifecycle.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-newexpression.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Foo() {}\n\nfunction Component(props) {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const a = [];\n    const b = {};\n    t0 = new Foo(a, b);\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const c = t0;\n  return c;\n}\n\n```\n\n----------------------------------------\n\nTITLE: React Hook Call Error Message\nDESCRIPTION: This snippet contains an error message indicating that the useEffect hook must be called at the top level of the function component. This highlights the common rule violation when a hook is called inside another function or conditional statement.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/error.invalid-nested-use-effect.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n   7 |   };\n   8 |   useEffect(() => {\n>  9 |     useEffect(() => {\n     |     ^^^^^^^^^ InvalidReact: Hooks must be called at the top level in the body of a function component or custom hook, and may not be called within function expressions. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning). Cannot call useEffect within a function component (9:9)\n  10 |       function nested() {\n  11 |         fire(foo(props));\n  12 |       }\n\n```\n\n----------------------------------------\n\nTITLE: Defining and Exporting a React Component - JavaScript\nDESCRIPTION: This snippet defines a React component named 'Component' that takes a numerical prop, applies the 'useIdentity' hook to it, and returns the result of the 'identity' function. It exports a constant 'FIXTURE_ENTRYPOINT' which includes the Component and a set of parameters for testing the functionality.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-no-component-annot.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\n// @compilationMode(infer)\nimport {useIdentity, identity} from 'shared-runtime';\n\nfunction Component(fakeProps: number) {\n  const x = useIdentity(fakeProps);\n  return identity(x);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [42],\n};\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\n// @compilationMode(infer)\nimport { useIdentity, identity } from \"shared-runtime\";\n\nfunction Component(fakeProps: number) {\n  const x = useIdentity(fakeProps);\n  return identity(x);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [42],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with Unused Variable (Input)\nDESCRIPTION: This code snippet defines a React component named `Component` that receives `props` as an argument. Inside the component, an object is created using `makeObject()`, and an optional chaining expression `obj.a?.b?.(props.c)` is used. However, the result of this expression is assigned to an unused variable `_`. The component returns null, indicating that it does not render any visible content.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unused-optional-method-assigned-to-variable.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  // unused!\n  const obj = makeObject();\n  const _ = obj.a?.b?.(props.c);\n  return null;\n}\n```\n\n----------------------------------------\n\nTITLE: Compilation Success Logs\nDESCRIPTION: Compilation logs showing memoization statistics for both Component and Wrapper functions, including memo slots, blocks and pruned values.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/log-pruned-memoization.expect.md#2025-04-21_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\"kind\":\"CompileSuccess\",\"fnLoc\":{\"start\":{\"line\":10,\"column\":0,\"index\":159},\"end\":{\"line\":33,\"column\":1,\"index\":903},\"filename\":\"log-pruned-memoization.ts\"},\"fnName\":\"Component\",\"memoSlots\":6,\"memoBlocks\":2,\"memoValues\":2,\"prunedMemoBlocks\":2,\"prunedMemoValues\":3}\n{\"kind\":\"CompileSuccess\",\"fnLoc\":{\"start\":{\"line\":37,\"column\":0,\"index\":939},\"end\":{\"line\":43,\"column\":1,\"index\":1037},\"filename\":\"log-pruned-memoization.ts\"},\"fnName\":\"Wrapper\",\"memoSlots\":1,\"memoBlocks\":1,\"memoValues\":1,\"prunedMemoBlocks\":0,\"prunedMemoValues\":0}\n```\n\n----------------------------------------\n\nTITLE: Implementing Recursive Function in JavaScript\nDESCRIPTION: A recursive function that takes two parameters (x, y) and either makes a recursive call with modified parameters or returns an array containing y multiplied by 10. The function uses strict mode and is exported as default.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/use-no-forget-module-level.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n'use no forget';\n\nexport default function foo(x, y) {\n  if (x) {\n    return foo(false, y);\n  }\n  return [y * 10];\n}\n```\n\nLANGUAGE: javascript\nCODE:\n```\n\"use no forget\";\n\nexport default function foo(x, y) {\n  if (x) {\n    return foo(false, y);\n  }\n  return [y * 10];\n}\n```\n\n----------------------------------------\n\nTITLE: Encoding String Table Example in React DevTools\nDESCRIPTION: Example showing how the string table for component names is encoded in typed arrays. This demonstrates how 'Foo' and 'Bar' would be encoded with their string lengths and UTF codepoints.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/OVERVIEW.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n[\n  8,   // string table length\n  3,   // encoded display name size\n  70,  // \"F\"\n  111, // \"o\"\n  111, // \"o\"\n  3,   // encoded display name size\n  66,  // \"B\"\n  97,  // \"a\"\n  114, // \"r\"\n]\n```\n\n----------------------------------------\n\nTITLE: Original React Component with Effect Hooks\nDESCRIPTION: A React component that demonstrates various patterns of dependencies in useEffect hooks. It includes references to props, module constants, local variables, and refs, which the compiler will analyze to automatically infer the required dependencies.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/infer-effect-dependencies.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @inferEffectDependencies\nimport {useEffect, useRef} from 'react';\nimport useEffectWrapper from 'useEffectWrapper';\n\nconst moduleNonReactive = 0;\n\nfunction Component({foo, bar}) {\n  const localNonreactive = 0;\n  const ref = useRef(0);\n  const localNonPrimitiveReactive = {\n    foo,\n  };\n  const localNonPrimitiveNonreactive = {};\n  useEffect(() => {\n    console.log(foo);\n    console.log(bar);\n    console.log(moduleNonReactive);\n    console.log(localNonreactive);\n    console.log(globalValue);\n    console.log(ref.current);\n    console.log(localNonPrimitiveReactive);\n    console.log(localNonPrimitiveNonreactive);\n  });\n\n  // Optional chains and property accesses\n  // TODO: we may be able to save bytes by omitting property accesses if the\n  // object of the member expression is already included in the inferred deps\n  useEffect(() => {\n    console.log(bar?.baz);\n    console.log(bar.qux);\n  });\n\n  useEffectWrapper(() => {\n    console.log(foo);\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a React Component in JavaScript\nDESCRIPTION: This JavaScript snippet demonstrates a React component function that creates an object using the makeObject() function, deletes a value from the object using 'delete', and returns the result. Dependencies include React framework and the presence of a makeObject function. No inputs other than the use of props are specifically described, and the output is the result of the delete operation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-property-delete.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const x = makeObject();\n  const y = delete x.value;\n  return y;\n}\n```\n\n----------------------------------------\n\nTITLE: Using React Compiler Runtime for Component Definition in JavaScript\nDESCRIPTION: This snippet shows a more complex version of the `component` function that integrates React's `compiler-runtime` for JSX transformation. It sets up several temporary variables (t0, t1) to handle state management, updating them based on the state of the component. The `FIXTURE_ENTRYPOINT` is exported, orchestrating function execution with specific initialization parameters.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-arrow-function-1.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction component(a) {\n  const $ = _c(4);\n  let t0;\n  if ($[0] !== a) {\n    t0 = { a };\n    $[0] = a;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const z = t0;\n  let t1;\n  if ($[2] !== z) {\n    t1 = () => {\n      console.log(z);\n    };\n    $[2] = z;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  const x = t1;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n\n```\n\n----------------------------------------\n\nTITLE: Using Freeze Functionality in React Component - JavaScript\nDESCRIPTION: This code snippet defines a React component that initializes an array 'a' and applies the 'useFreeze' function twice to ensure that 'a' behaves as a frozen and readonly state. The 'call' function is also invoked on 'a', demonstrating its usage with a frozen state.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hooks-freeze-arguments.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component() {\n  const a = [];\n  useFreeze(a); // should freeze\n  useFreeze(a); // should be readonly\n  call(a); // should be readonly\n  return a;\n}\n\nfunction useFreeze(x) {}\nfunction call(x) {}\n```\n\n----------------------------------------\n\nTITLE: Optimized Component Function with Memoization - JavaScript\nDESCRIPTION: This code snippet is an optimized definition of the 'Component' function that includes memoization using a compiler runtime. It checks previous values to prevent unnecessary computations and updates. It also handles rendering through JSX that leverages the cached results. Required dependencies include 'react/compiler-runtime' and 'shared-runtime'. This functionality focuses on efficiency by minimizing re-renders based on property comparisons.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/todo-global-property-load-cached.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport * as SharedRuntime from \"shared-runtime\";\nimport { makeArray } from \"shared-runtime\";\n\n/**\n * Here, we don't need to memoize SharedRuntime.Stringify as it is a PropertyLoad\n * off of a global.\n * TODO: in PropagateScopeDeps (hir), we should produce a sidemap of global rvals\n * and avoid adding them to `temporariesUsedOutsideDefiningScope`.\n */\nfunction Component(t0) {\n  const $ = _c(6);\n  const { num } = t0;\n  let T0;\n  let t1;\n  if ($[0] !== num) {\n    const arr = makeArray(num);\n\n    T0 = SharedRuntime.Stringify;\n    t1 = arr.push(num);\n    $[0] = num;\n    $[1] = T0;\n    $[2] = t1;\n  } else {\n    T0 = $[1];\n    t1 = $[2];\n  }\n  let t2;\n  if ($[3] !== T0 || $[4] !== t1) {\n    t2 = <T0 value={t1} />;\n    $[3] = T0;\n    $[4] = t1;\n    $[5] = t2;\n  } else {\n    t2 = $[5];\n  }\n  return t2;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ num: 2 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Unoptimized React Component Implementation\nDESCRIPTION: A React component that creates an object with dynamic property assignment and function calls based on props. This represents the code before React's compiler optimizations are applied.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/constant-computed.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const index = 'foo';\n  const x = {};\n  x[index] = x[index] + x['bar'];\n  x[index](props.foo);\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Transformed React Component with memoization\nDESCRIPTION: This code shows the transformed React component using `react/compiler-runtime` for optimization. It uses the `_c` function for memoization, checking the cache for existing rendered elements before re-rendering. This can potentially reduce re-renders and improve performance, especially for static content.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-preserve-whitespace.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { StaticText1 } from \"shared-runtime\";\n\nfunction Component() {\n  const $ = _c(3);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = <StaticText1 />;\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  let t1;\n  if ($[1] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = <StaticText1 />;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  let t2;\n  if ($[2] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t2 = (\n      <div>\n        Before text{t0}Middle text\n        <StaticText1>\n          Inner before text{t1}Inner middle text\n          <StaticText1 />\n          Inner after text\n        </StaticText1>\n        After text\n      </div>\n    );\n    $[2] = t2;\n  } else {\n    t2 = $[2];\n  }\n  return t2;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Component Entrypoint Fixture\nDESCRIPTION: Test fixture defining the component function, initial parameters, and sequential render scenarios for testing\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-from-maybemutates-arg0.expect.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: 5}],\n  sequentialRenders: [{value: 5}, {value: 6}, {value: 6}, {value: 7}],\n};\n```\n\n----------------------------------------\n\nTITLE: Using useState and useEffect in React Component - JavaScript\nDESCRIPTION: This snippet defines a React functional component using useState and useEffect hooks to manage its state. The useEffect hook updates the state whenever the component mounts or updates, incrementing the state by 1 each time.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/invalid-setState-in-useEffect.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @logger @validateNoSetStateInPassiveEffects\nimport {useEffect, useState} from 'react';\n\nfunction Component() {\n  const [state, setState] = useState(0);\n  useEffect(() => {\n    setState(s => s + 1);\n  });\n  return state;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization (Output Version)\nDESCRIPTION: The React Compiler transformed version of the component with memoization. It uses the _c runtime function to create a persistent array that stores values between renders, only recalculating when props change. This optimizes performance by avoiding unnecessary recalculations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/context-variable-reassigned-two-lambdas.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { conditionalInvoke } from \"shared-runtime\";\n\nfunction Component(t0) {\n  const $ = _c(3);\n  const { doReassign1, doReassign2 } = t0;\n  let x;\n  if ($[0] !== doReassign1 || $[1] !== doReassign2) {\n    x = {};\n    const reassign1 = () => {\n      x = 2;\n    };\n\n    const reassign2 = () => {\n      x = 3;\n    };\n\n    conditionalInvoke(doReassign1, reassign1);\n    conditionalInvoke(doReassign2, reassign2);\n    $[0] = doReassign1;\n    $[1] = doReassign2;\n    $[2] = x;\n  } else {\n    x = $[2];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ doReassign1: true, doReassign2: true }],\n  sequentialRenders: [\n    { doReassign1: true, doReassign2: true },\n    { doReassign1: true, doReassign2: false },\n    { doReassign1: false, doReassign2: false },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Function with Conditional Rendering\nDESCRIPTION: A React function that conditionally manipulates arrays based on input parameters and renders JSX elements. It includes conditional logic, array operations, and JSX rendering with a switch statement for different cases.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reassignment-separate-scopes.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(a, b, c) {\n  let x = [];\n  if (a) {\n    x.push(a);\n  }\n  let y = <div>{x}</div>;\n\n  switch (b) {\n    case 0: {\n      x = [];\n      x.push(b);\n      break;\n    }\n    default: {\n      x = [];\n      x.push(c);\n    }\n  }\n  return (\n    <div>\n      {y}\n      {x}\n    </div>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: This snippet represents the compiled version of the `Foo` component. It uses `react/compiler-runtime` to access a memoization cache (`_c`). It checks if the cache contains a sentinel value, and if so, calculates the value using the same logic as the original component (array `x`, function `foo`, and `invoke`). The result is stored in the cache for subsequent calls. If the cache contains a value, it's returned directly.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/lambda-array-access-member-expr-param.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n```javascript\nimport { c as _c } from \"react/compiler-runtime\";\nimport { invoke } from \"shared-runtime\";\n\nfunction Foo() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const x = [{ value: 0 }, { value: 1 }, { value: 2 }];\n    const foo = (param) => x[param].value;\n\n    t0 = invoke(foo, 1);\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{}]\n};\n\n```\n```\n\n----------------------------------------\n\nTITLE: Calculating Factorial using TypeScript\nDESCRIPTION: This snippet defines a recursive function to calculate the factorial of a given number using TypeScript. The function takes an object with a 'value' property as input. The expected input is a numeric value, and the output is the computed factorial of that value.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-recursive-call.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nfunction Foo({value}: {value: number}) {\n  const factorial = (x: number) => {\n    if (x <= 1) {\n      return 1;\n    } else {\n      return x * factorial(x - 1);\n    }\n  };\n\n  return factorial(value);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{value: 3}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: Compiled version of the component showing how React transforms the code to implement memoization using compiler runtime. It caches previous parameter values and return results to avoid unnecessary recalculations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rest-param-with-object-spread-pattern.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(foo, ...t0) {\n  const $ = _c(3);\n  const { bar } = t0;\n  let t1;\n  if ($[0] !== bar || $[1] !== foo) {\n    t1 = [foo, bar];\n    $[0] = bar;\n    $[1] = foo;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\"foo\", { bar: \"bar\" }],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component Function\nDESCRIPTION: This snippet shows the original implementation of a React component function. It uses let declarations and includes an unused object declaration inside a conditional block.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-binary-operator.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component() {\n  let a = some();\n  let b = someOther();\n  if (a > b) {\n    let m = {};\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled React Hook Implementation\nDESCRIPTION: Compiled version of the hook using React compiler runtime with memoization optimizations. Includes state tracking using compiler-generated array for caching previous values and conditions.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-literal-method-in-ternary-consequent.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { createHookWrapper } from \"shared-runtime\";\n\nfunction useHook(t0) {\n  const $ = _c(3);\n  const { isCond, value } = t0;\n  let t1;\n  if ($[0] !== isCond || $[1] !== value) {\n    t1 = isCond\n      ? {\n          getValue() {\n            return value;\n          },\n        }\n      : 42;\n    $[0] = isCond;\n    $[1] = value;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: createHookWrapper(useHook),\n  params: [{ isCond: true, value: 0 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Error Handling for Invalid Side Effects in React Component\nDESCRIPTION: This section outlines the error message generated by the React library when a variable defined outside of a component is reassigned within the component. It emphasizes that components and hooks should be pure and free of side effects, recommending the use of 'useState' for managing state within components instead of directly modifying global variables.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.assign-global-in-jsx-children.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n  1 | function Component() {\n  2 |   const foo = () => {\n> 3 |     someGlobal = true;\n    |     ^^^^^^^^^^ InvalidReact: Unexpected reassignment of a variable which was defined outside of the component. Components and hooks should be pure and side-effect free, but variable reassignment is a form of side-effect. If this variable is used in rendering, use useState instead. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#side-effects-must-run-outside-of-render) (3:3)\n  4 |   };\n  5 |   // Children are generally access/called during render, so\n  6 |   // modifying a global in a children function is almost\n\n```\n\n----------------------------------------\n\nTITLE: Initializing React Component with useEffect Hook in JavaScript\nDESCRIPTION: The snippet demonstrates a React component that uses the useEffect hook to invoke a function after rendering. The component also relies on a custom hook, referenced by useDynamicHook, to possibly alter its behavior. It imports necessary functions from 'react'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/repro-dont-add-hook-guards-on-retry.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @flow @enableEmitHookGuards @panicThreshold(none) @enableFire\\nimport {useEffect, fire} from 'react';\\n\\nfunction Component(props, useDynamicHook) {\\n  'use memo';\\n  useDynamicHook();\\n  const foo = props => {\\n    console.log(props);\\n  };\\n  useEffect(() => {\\n    fire(foo(props));\\n  });\\n\\n  return <div>hello world</div>;\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Initializing React Component with useRef in JavaScript\nDESCRIPTION: This snippet demonstrates a React component using the useRef hook. It initially sets and checks a ref's current value. Dependencies include React's 'useRef'. The function C initializes and uses the ref 'r' with default value 'null'. During render, it checks if the current value is null and sets it to 1, leading to an error due to accessing the ref during render. React dependency is necessary.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.ref-initialization-post-access.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n//@flow\\nimport {useRef} from 'react';\\n\\ncomponent C() {\\n  const r = useRef(null);\\n  if (r.current == null) {\\n    r.current = 1;\\n  }\\n  r.current = 1;\\n}\\n\\nexport const FIXTURE_ENTRYPOINT = {\\n  fn: C,\\n  params: [{}],\\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled: React Component with Compiler Runtime\nDESCRIPTION: Compiler-transformed version of the React component with runtime optimization and memoization tracking\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-simple-preserved.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enablePreserveExistingManualUseMemo\nimport { useMemo } from \"react\";\n\nfunction Component(t0) {\n  const $ = _c(5);\n  const { a } = t0;\n  let t1;\n  if ($[0] !== a) {\n    t1 = () => [a];\n    $[0] = a;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  let t2;\n  if ($[2] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t2 = [];\n    $[2] = t2;\n  } else {\n    t2 = $[2];\n  }\n  const x = useMemo(t1, t2);\n  let t3;\n  if ($[3] !== x) {\n    t3 = <div>{x}</div>;\n    $[3] = x;\n    $[4] = t3;\n  } else {\n    t3 = $[4];\n  }\n  return t3;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ a: 42 }],\n  isComponent: true,\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Test Fixture for React Component\nDESCRIPTION: This snippet exports a FIXTURE_ENTRYPOINT object that includes the Component function and test parameters. It defines a series of sequential renders with different input arguments to test the component's behavior.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/optional-member-expression-as-memo-dep.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{arg: null}],\n  sequentialRenders: [\n    {arg: null},\n    {arg: null},\n    {arg: {items: {edges: null}}},\n    {arg: {items: {edges: null}}},\n    {arg: {items: {edges: {nodes: [1, 2, 'hello']}}}},\n    {arg: {items: {edges: {nodes: [1, 2, 'hello']}}}},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Hook Implementation\nDESCRIPTION: A simple React hook 'useFoo' that takes props and calls a function 'foo' with props.x. The compiler directives indicate freezing and instrumentation capabilities.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/codegen-emit-imports-same-source.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableEmitFreeze @enableEmitInstrumentForget\n\nfunction useFoo(props) {\n  return foo(props.x);\n}\n```\n\n----------------------------------------\n\nTITLE: React Compiler Runtime Optimized Function\nDESCRIPTION: Compiler-transformed version of the function with explicit memoization and dependency tracking using React compiler runtime\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-renaming.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction foo(props) {\n  const $ = _c(4);\n  let x;\n  if ($[0] !== props.bar) {\n    x = [];\n    x.push(props.bar);\n    $[0] = props.bar;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  if (props.cond) {\n    if ($[2] !== props.foo) {\n      x = [];\n      x.push(props.foo);\n      $[2] = props.foo;\n      $[3] = x;\n    } else {\n      x = $[3];\n    }\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Counter Component with Optimizations\nDESCRIPTION: This snippet shows the compiled version of the React counter component with optimizations. It uses memoization and conditional rendering to improve performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/merge-consecutive-scopes.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useState } from \"react\";\nimport { Stringify } from \"shared-runtime\";\n\nfunction Component() {\n  const $ = _c(8);\n  const [state, setState] = useState(0);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = <Stringify text=\"Counter\" />;\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  let t1;\n  if ($[1] !== state) {\n    t1 = <span>{state}</span>;\n    $[1] = state;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  let t2;\n  if ($[3] !== state) {\n    t2 = (\n      <button data-testid=\"button\" onClick={() => setState(state + 1)}>\n        increment\n      </button>\n    );\n    $[3] = state;\n    $[4] = t2;\n  } else {\n    t2 = $[4];\n  }\n  let t3;\n  if ($[5] !== t1 || $[6] !== t2) {\n    t3 = (\n      <div>\n        {t0}\n        {t1}\n        {t2}\n      </div>\n    );\n    $[5] = t1;\n    $[6] = t2;\n    $[7] = t3;\n  } else {\n    t3 = $[7];\n  }\n  return t3;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ value: 42 }],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component Definition with Reactivity Issue\nDESCRIPTION: This code defines a React component that illustrates a reactivity issue when dealing with nested arrays. Initially, the `z` array is non-reactive. The code then attempts to update `y` to make it reactive, which should ideally propagate back to `z`. However, the reactivity propagation requires a fixpoint, which the component attempts to handle by storing the potentially reactive array into another variable `a`. Finally the value `b` is conditionally updated based on the value within the array `a`.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactivity-via-readonly-alias-of-mutable-value.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const x = [];\n  const y = x;\n\n  // y isn't reactive yet when we first visit this, so z is initially non-reactive\n  const z = [y];\n\n  // then we realize y is reactive. we need a fixpoint to propagate this back to z\n  y.push(props.input);\n\n  // PruneNonReactiveDependencies partially propagates reactivity (for now) which\n  // we bypass with an indirection of storing into another variable\n  const a = [z];\n\n  // b's value is conditional on `a`, which is reactive per above\n  let b = 0;\n  if (a[0][0][0] === 42) {\n    b = 1;\n  }\n\n  return [b];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  sequentialRenders: [\n    {input: 42},\n    {input: 42},\n    {input: 'sathya'},\n    {input: 'sathya'},\n    {input: 42},\n    {input: 'sathya'},\n    {input: 42},\n    {input: 'sathya'},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Array Filtering and Rendering in JavaScript\nDESCRIPTION: This snippet defines a React component that creates an array, filters it using a mutateAndReturn function, and renders the first and last elements using a Stringify component. It also includes a FIXTURE_ENTRYPOINT for testing different renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/global-types/repro-array-filter-capture-mutate-bug.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {mutateAndReturn, Stringify, useIdentity} from 'shared-runtime';\n\n/**\n * Repro for bug with `mutableOnlyIfOperandsAreMutable` flag\n * Found differences in evaluator results\n  * Non-forget (expected):\n  * (kind: ok)\n  * <div>{\"children\":[{\"value\":\"foo\",\"wat0\":\"joe\"},{\"value\":5,\"wat0\":\"joe\"}]}</div>\n  * <div>{\"children\":[{\"value\":\"foo\",\"wat0\":\"joe\"},{\"value\":6,\"wat0\":\"joe\"}]}</div>\n  * <div>{\"children\":[{\"value\":\"foo\",\"wat0\":\"joe\"},{\"value\":6,\"wat0\":\"joe\"}]}</div>\n  * Forget:\n  * (kind: ok)\n  * <div>{\"children\":[{\"value\":\"foo\",\"wat0\":\"joe\"},{\"value\":5,\"wat0\":\"joe\"}]}</div>\n  * <div>{\"children\":[{\"value\":\"foo\",\"wat0\":\"joe\",\"wat1\":\"joe\"},{\"value\":6,\"wat0\":\"joe\"}]}</div>\n  * <div>{\"children\":[{\"value\":\"foo\",\"wat0\":\"joe\",\"wat1\":\"joe\"},{\"value\":6,\"wat0\":\"joe\"}]}</div>\n\n */\nfunction Component({value}) {\n  const arr = [{value: 'foo'}, {value: 'bar'}, {value}];\n  useIdentity(null);\n  const derived = arr.filter(mutateAndReturn);\n  return (\n    <Stringify>\n      {derived.at(0)}\n      {derived.at(-1)}\n    </Stringify>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: 5}],\n  sequentialRenders: [{value: 5}, {value: 6}, {value: 6}],\n};\n```\n\n----------------------------------------\n\nTITLE: Input: FBT Pluralization with Parameterized Counts\nDESCRIPTION: A React component that uses FBT to display pluralized text based on count parameters. It takes object parameters for apple and banana counts and returns a formatted text string with proper pluralization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/bug-fbt-plural-multiple-function-calls.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport fbt from 'fbt';\n\n/**\n * Similar to error.todo-multiple-fbt-plural\n *\n * Evaluator error:\n *   Found differences in evaluator results\n *   Non-forget (expected):\n *   (kind: ok) <div>1 apple and 2 bananas</div>\n *   Forget:\n *   (kind: ok) <div>1 apples and 2 bananas</div>\n */\n\nfunction useFoo({apples, bananas}) {\n  return fbt(\n    `${fbt.param('number of apples', apples)} ` +\n      fbt.plural('apple', apples) +\n      ` and ${fbt.param('number of bananas', bananas)} ` +\n      fbt.plural('banana', bananas),\n    'TestDescription',\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{apples: 1, bananas: 2}],\n};\n```\n\n----------------------------------------\n\nTITLE: Using a temporary function for returning a constant in React\nDESCRIPTION: This snippet also defines a function 'useFoo' that uses a temporary function '_temp' returning an array with a constant string. Although it serves the same purpose as the previous snippet, it illustrates an alternative implementation approach using an inner function. This implementation may not be as efficient as the previous one due to losing the memoization benefits of 'useCallback'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useCallback-infer-scope-global.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees\n\nimport { useCallback } from \"react\";\nimport { CONST_STRING0 } from \"shared-runtime\";\n\n// It's correct to infer a useCallback block has no reactive dependencies\nfunction useFoo() {\n  return _temp;\n}\nfunction _temp() {\n  return [CONST_STRING0];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Mutation Functionality\nDESCRIPTION: This snippet defines a JavaScript function component that uses a mutation function 'mutate' from a shared runtime. The component constructs an object with the passed parameter and mutates another object using the 'mutate' function. The component returns the mutated object and is configured to be used as a fixture entry point.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-alias-receiver-mutate.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {mutate} from 'shared-runtime';\n\nfunction Component({a}) {\n  let x = {a};\n  let y = {};\n  const f0 = function () {\n    let a = y;\n    a.x = x;\n  };\n  f0();\n  mutate(y);\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{a: 2}],\n  sequentialRenders: [{a: 2}, {a: 2}, {a: 3}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Compiler Memoization Error\nDESCRIPTION: This code snippet highlights the error message generated by the React Compiler when it fails to preserve existing manual memoization. The error, `CannotPreserveMemoization`, indicates that the compiler has skipped optimizing the component because the memoized value in source is not preserved in the compilation output, pinpointing the issue within the `useCallback` call.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.todo-useCallback-captures-invalidating-value.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n  11 |   x.push(props);\n  12 |\n> 13 |   return useCallback(() => [x], [x]);\n     |                      ^^^^^^^^^ CannotPreserveMemoization: React Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. This value was memoized in source but not in compilation output. (13:13)\n  14 | }\n  15 |\n  16 | export const FIXTURE_ENTRYPOINT = {\n```\n\n----------------------------------------\n\nTITLE: Hoisting Function Definition in JavaScript\nDESCRIPTION: This JavaScript function `hoisting` demonstrates variable hoisting. It conditionally defines functions `foo` and `bar` and calls them. The function returns an array of boolean values based on the execution of `foo` and `bar` within the conditional block.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-nested-let-declaration-2.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction hoisting(cond) {\n  let items = [];\n  if (cond) {\n    let foo = () => {\n      items.push(bar());\n    };\n    let bar = () => true;\n    foo();\n  }\n  return items;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: hoisting,\n  params: [true],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Basic React Component Implementation\nDESCRIPTION: Initial implementation of a React component using forwardRef and Stringify component with test fixture setup.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/gating-use-before-decl-ref.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @gating\nimport {createRef, forwardRef} from 'react';\nimport {Stringify} from 'shared-runtime';\n\nconst Foo = forwardRef(Foo_withRef);\nfunction Foo_withRef(props, ref) {\n  return <Stringify ref={ref} {...props} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: eval('(...args) => React.createElement(Foo, args)'),\n  params: [{prop1: 1, prop2: 2, ref: createRef()}],\n};\n```\n\n----------------------------------------\n\nTITLE: Initialize and Export useFoo Function with Parameters and Tests in JavaScript\nDESCRIPTION: Implements the useFoo function which conditionally returns a predefined object or an array with elements added via arrayPush. The function uses a condition value and input parameters, handling potential edge cases like null inputs. The function and its usage are exported as FIXTURE_ENTRYPOINT, alongside test scenarios for various input states. The use of arrayPush from 'shared-runtime' is required.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-unpoisoned/return-before-scope-starts.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {arrayPush} from 'shared-runtime';\n\nfunction useFoo({input, cond}) {\n  if (cond) {\n    return {result: 'early return'};\n  }\n\n  // unconditional\n  const x = [];\n  arrayPush(x, input.a.b);\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{input: {a: {b: 2}}, cond: false}],\n  sequentialRenders: [\n    {input: null, cond: true},\n    {input: {a: {b: 2}}, cond: false},\n    {input: null, cond: true},\n    // preserve nullthrows\n    {input: {}, cond: false},\n    {input: {a: {b: null}}, cond: false},\n    {input: {a: null}, cond: false},\n    {input: {a: {b: 3}}, cond: false},\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Installing React Compiler Playground Dependencies\nDESCRIPTION: Commands for building React Compiler from source and installing Playground dependencies using either yarn or npm package managers.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/apps/playground/README.md#2025-04-21_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n# Build React Compiler from source and install Playground dependencies.\n$ yarn\n\n# Or similarly\n$ npm install\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: Compiled version of the component that includes memoization logic using Symbol.for('react.memo_cache_sentinel') and compiler runtime utilities.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/context-variable-reassigned-outside-of-lambda.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { Stringify } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    let x;\n    x = null;\n    const callback = () => {\n      console.log(x);\n    };\n\n    x = {};\n    t0 = <Stringify callback={callback} shouldInvokeFns={true} />;\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: Basic React component that creates and modifies an array of objects using makeObject_Primitives helper. Includes test fixture configuration for multiple renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-of-mutate-item-of-local-collection.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {makeObject_Primitives} from 'shared-runtime';\n\nfunction Component(props) {\n  const items = [makeObject_Primitives(), makeObject_Primitives()];\n  for (const x of items) {\n    x.a += 1;\n  }\n  return items;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n  sequentialRenders: [{}, {}, {}],\n};\n```\n\n----------------------------------------\n\nTITLE: Using react-compiler-runtime with React Components\nDESCRIPTION: This code snippet enhances the previous component using the 'react-compiler-runtime' to manage rendering optimally. It introduces memoization to cache the output of the component, improving performance by avoiding unnecessary re-renders. The code exports the same component structure as a fixture entry point without additional parameters.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/target-flag.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react-compiler-runtime\"; // @target=\"18\"\n\nfunction Component() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = <div>Hello world</div>;\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  isComponent: true,\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiled useFoo function with memoization\nDESCRIPTION: This code snippet represents the compiled version of the `useFoo` function. It leverages the `_c` function (presumably from `react/compiler-runtime`) for memoization. The compiled code checks if the input arrays and lambda functions have changed before recomputing the map operations, optimizing for performance by reusing previously computed values.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/array-map-named-callback.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; /**\n * Forked from array-map-simple.js\n * \n * Whether lambdas are named or passed inline shouldn't affect whether we expect\n * it to be called.\n */\nfunction useFoo(t0) {\n  const $ = _c(13);\n  const { arr1, arr2 } = t0;\n  let t1;\n  if ($[0] !== arr1[0]) {\n    t1 = (e) => arr1[0].value + e.value;\n    $[0] = arr1[0];\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  const cb1 = t1;\n  let t2;\n  if ($[2] !== arr1 || $[3] !== cb1) {\n    t2 = arr1.map(cb1);\n    $[2] = arr1;\n    $[3] = cb1;\n    $[4] = t2;\n  } else {\n    t2 = $[4];\n  }\n  const x = t2;\n  let t3;\n  if ($[5] !== arr2) {\n    t3 = (e_0) => arr2[0].value + e_0.value;\n    $[5] = arr2;\n    $[6] = t3;\n  } else {\n    t3 = $[6];\n  }\n  const cb2 = t3;\n  let t4;\n  if ($[7] !== arr1 || $[8] !== cb2) {\n    t4 = arr1.map(cb2);\n    $[7] = arr1;\n    $[8] = cb2;\n    $[9] = t4;\n  } else {\n    t4 = $[9];\n  }\n  const y = t4;\n  let t5;\n  if ($[10] !== x || $[11] !== y) {\n    t5 = [x, y];\n    $[10] = x;\n    $[11] = y;\n    $[12] = t5;\n  } else {\n    t5 = $[12];\n  }\n  return t5;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ arr1: [], arr2: [] }],\n  sequentialRenders: [\n    { arr1: [], arr2: [] },\n    { arr1: [], arr2: null },\n    { arr1: [{ value: 1 }, { value: 2 }], arr2: [{ value: -1 }] },\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: Basic React component that initializes an empty array and contains an unused break loop. Exports a fixture entry point for testing purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-of-break.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component() {\n  const x = [];\n  for (const item of [1, 2]) {\n    break;\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Simplified React Component\nDESCRIPTION: Simplified version of the React component without error handling. The component directly returns the default prop value without any try-catch block.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-empty-try.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const x = props.default;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ default: 42 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing a Reactive Component with React Boilerplate\nDESCRIPTION: This snippet builds upon the previous component, introducing a mechanism to store and compare state-like values using an array `$`. The goal is to optimize re-computation of rendered output. It showcases the integration of a React-like runtime to track changes and store computed outputs in `t0`. This requires a React environment or runtime support to execute.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-for-test.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  let x;\n  for (let i = 0; i < props.test; i++) {\n    if (i > 10) {\n      x = 10;\n    } else {\n      x = 1;\n    }\n  }\n  let t0;\n  if ($[0] !== x) {\n    t0 = [x];\n    $[0] = x;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  sequentialRenders: [\n    { test: 12 },\n    { test: 12 },\n    { test: 1 },\n    { test: 1 },\n    { test: 12 },\n    { test: 1 },\n    { test: 12 },\n    { test: 1 },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Try-Catch Block in JavaScript\nDESCRIPTION: This snippet defines a React component that returns the result of a callback function. The callback function contains a try-catch block that returns an empty array or undefined.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-within-function-expression.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const callback = () => {\n    try {\n      return [];\n    } catch (e) {\n      return;\n    }\n  };\n  return callback();\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Advanced React Hook with Memoization\nDESCRIPTION: This snippet enhances the 'useFoo' hook by introducing memoization. It checks a sentinel value to either return a new text element or a cached one, improving performance by reducing unnecessary renders. It utilizes the 'react/compiler-runtime' for more complex runtime behavior.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-local-memberexpr-tag.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport * as SharedRuntime from \"shared-runtime\";\nfunction useFoo() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = <SharedRuntime.Text value={4} />;\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a Component with Conditional Fire and Effect - JavaScript\nDESCRIPTION: This snippet defines a React component that conditionally executes a function when a specific prop condition is met, leveraging the fire and useEffect hooks for side effects.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/bailout-validate-conditional-hook.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableFire @panicThreshold(none)\nimport {fire, useEffect} from 'react';\nimport {Stringify} from 'shared-runtime';\n\n/**\n * When @enableFire is specified, retry compilation with validation passes (e.g.\n * hook usage) disabled\n */\nfunction Component(props) {\n  const foo = props => {\n    console.log(props);\n  };\n\n  if (props.cond) {\n    useEffect(() => {\n      fire(foo(props));\n    });\n  }\n\n  return <Stringify />;\n}\n\n```\n\n----------------------------------------\n\nTITLE: React useFoo Hook - Transformed Code\nDESCRIPTION: This is the transformed version of the `useFoo` hook. It utilizes the `react/compiler-runtime` to memoize the array `x` and the conditional push operation based on the input `props`. The `_c` function is a compiler-generated function that handles dependency tracking and memoization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/ssa-renaming-ternary-destruction.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enablePropagateDepsInHIR\nfunction useFoo(props) {\n  const $ = _c(5);\n  let x;\n  if ($[0] !== props.bar) {\n    x = [];\n    x.push(props.bar);\n    $[0] = props.bar;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  if ($[2] !== props.cond || $[3] !== props.foo) {\n    props.cond ? (([x] = [[]]), x.push(props.foo)) : null;\n    $[2] = props.cond;\n    $[3] = props.foo;\n    $[4] = x;\n  } else {\n    x = $[4];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ cond: false, foo: 2, bar: 55 }],\n  sequentialRenders: [\n    { cond: false, foo: 2, bar: 55 },\n    { cond: false, foo: 3, bar: 55 },\n    { cond: true, foo: 3, bar: 55 },\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Original React Component with Change Detection Debugging\nDESCRIPTION: A simple React component with conditional array creation and modification based on props. The '@enableChangeDetectionForDebugging' directive is used to enable compiler debugging features.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/change-detect-reassign.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableChangeDetectionForDebugging\nfunction Component(props) {\n  let x = null;\n  if (props.cond) {\n    x = [];\n    x.push(props.value);\n  }\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Optimized useFoo Hook with Memoization in JavaScript\nDESCRIPTION: This snippet shows an optimized version of the 'useFoo' hook using memoization techniques. It imports a compiler runtime function '_c' for caching and implements conditional logic to avoid unnecessary recalculations. The optimization aims to improve performance in React components.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rename-source-variables-nested-object-method.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enableChangeVariableCodegen\nimport { identity } from \"shared-runtime\";\n\nconst $ = \"module_$\";\nconst t0 = \"module_t0\";\nconst c_0 = \"module_c_0\";\nfunction useFoo(props) {\n  const $0 = _c(2);\n  const c_00 = $0[0] !== props;\n  let t1;\n  if (c_00) {\n    const a = {\n      foo() {\n        const b = {\n          bar() {\n            console.log($);\n            console.log(t0);\n            console.log(c_0);\n            return identity(props.value);\n          },\n        };\n        return b;\n      },\n    };\n\n    t1 = a.foo().bar();\n    $0[0] = props;\n    $0[1] = t1;\n  } else {\n    t1 = $0[1];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ value: 42 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: Basic React component implementation that takes props with an x value, processes it through an identity function, and returns an object with the transformed value.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructure-object-declaration-to-context-var.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {identity} from 'shared-runtime';\n\nfunction Component(props) {\n  let {x} = props;\n  const foo = () => {\n    x = identity(props.x);\n  };\n  foo();\n  return {x};\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{x: 42}],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with Conditional Rendering (Input)\nDESCRIPTION: This snippet defines a React component that initializes an array conditionally based on the `props.cond` value. If `props.cond` is truthy, an empty array is initialized; otherwise, it's set to `null`.  The component then attempts to push `props.a` into the `items` array (if it's not null) and returns the `items` value.  The `FIXTURE_ENTRYPOINT` exports the component and sample parameters.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/iife-return-modified-later-phi.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const items = (() => {\n    if (props.cond) {\n      return [];\n    } else {\n      return null;\n    }\n  })();\n  items?.push(props.a);\n  return items;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{a: {}}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining Component and Exporting Fixture Entrypoint in JavaScript\nDESCRIPTION: This snippet demonstrates the creation of a JavaScript function `component` that returns a closure logging its internal state `z`. The returned function encapsulates the state and logs it when invoked. It is exported with the entry point `FIXTURE_ENTRYPOINT`, which specifies execution parameters. The component is defined with logging behavior to visualize its state management.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-arrow-function-1.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component(a) {\n  let z = {a};\n  let x = () => {\n    console.log(z);\n  };\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Component Definition with JSX Outlining\nDESCRIPTION: This code defines a React component `Component` that takes an array `arr` as a prop and renders a list of `Bar` components, each containing a `Baz` component. It uses `Array.map` to iterate over the array and generate JSX elements. The `useX` hook is used to provide a value `x` to the `Bar` component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-outlining-jsx-stored-in-id.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableJsxOutlining\nfunction Component({arr}) {\n  const x = useX();\n  return (\n    <>\n      {arr.map((i, id) => {\n        let jsx = (\n          <Bar key={id} x={x}>\n            <Baz i={i}></Baz>\n          </Bar>\n        );\n        return jsx;\n      })}\n    </>\n  );\n}\n\nfunction Bar({x, children}) {\n  return (\n    <>\n      {x}\n      {children}\n    </>\n  );\n}\n\nfunction Baz({i}) {\n  return i;\n}\n\nfunction useX() {\n  return 'x';\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{arr: ['foo', 'bar']}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Component Using Memoization with Import\nDESCRIPTION: This snippet imports a memoization utility from 'react/compiler-runtime' and defines the function 'g' to handle a memoized value conditionally. It initializes the object 'x' based on a sentinel value. The function manipulates the object's properties and handles caching. It also exports the same 'FIXTURE_ENTRYPOINT' for usage in React, indicating it is not a component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/assignment-variations-complex-lvalue.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction g() {\n  const $ = _c(1);\n  let x;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    x = { y: { z: 1 } };\n    x.y.z = x.y.z + 1;\n    x.y.z = x.y.z * 2;\n    $[0] = x;\n  } else {\n    x = $[0];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: g,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Native Log Function without Compiler Runtime\nDESCRIPTION: This snippet defines the 'getNativeLogFunction' which returns a custom logging function based on the provided log level. It processes log messages, adjusts log levels based on specific conditions, and handles multiple arguments appropriately.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capture-param-mutate.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction getNativeLogFunction(level) {\n  return function () {\n    let str;\n    if (arguments.length === 1 && typeof arguments[0] === 'string') {\n      str = arguments[0];\n    } else {\n      str = Array.prototype.map\n        .call(arguments, function (arg) {\n          return inspect(arg, {\n            depth: 10,\n          });\n        })\n        .join(', ');\n    }\n    const firstArg = arguments[0];\n    let logLevel = level;\n    if (\n      typeof firstArg === 'string' &&\n      firstArg.slice(0, 9) === 'Warning: ' &&\n      logLevel >= LOG_LEVELS.error\n    ) {\n      logLevel = LOG_LEVELS.warn;\n    }\n    if (global.__inspectorLog) {\n      global.__inspectorLog(\n        INSPECTOR_LEVELS[logLevel],\n        str,\n        [].slice.call(arguments),\n        INSPECTOR_FRAMES_TO_SKIP\n      );\n    }\n    if (groupStack.length) {\n      str = groupFormat('', str);\n    }\n    global.nativeLoggingHook(str, logLevel);\n  };\n}\n\n```\n\n----------------------------------------\n\nTITLE: React Component with onClick handler\nDESCRIPTION: This code defines a React component named `Component` that includes an `onClick` handler. The initial implementation attempts to define and then reassign the `onClick` variable inside the callback function, which leads to an error in React. The error suggests using state instead to manage changes after the render.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-function-expression-references-later-variable-declaration.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component() {\n  let callback = () => {\n    onClick = () => {};\n  };\n  let onClick;\n\n  return <div onClick={callback} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization (JavaScript)\nDESCRIPTION: This is the compiled version of the React component, incorporating memoization techniques. It uses React's compiler runtime and implements a cache sentinel for optimization. The component's logic remains similar to the input version but with added memoization handling.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-alias-try-values.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nconst { throwInput } = require(\"shared-runtime\");\n\nfunction Component(props) {\n  const $ = _c(1);\n  let x;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    let y;\n    x = [];\n    try {\n      throwInput(x);\n    } catch (t0) {\n      const e = t0;\n\n      y = e;\n    }\n\n    y.push(null);\n    $[0] = x;\n  } else {\n    x = $[0];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Hook Implementation Before Compiler Optimization\nDESCRIPTION: The original useFoo hook implementation that takes props, manipulates an array based on conditional logic, and returns it. It demonstrates array manipulation operations and conditional assignment patterns in React.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-renaming-ternary-destruction-with-mutation.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {mutate} from 'shared-runtime';\n\nfunction useFoo(props) {\n  let x = [];\n  x.push(props.bar);\n  props.cond ? (({x} = {x: {}}), ([x] = [[]]), x.push(props.foo)) : null;\n  mutate(x);\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{cond: false, foo: 2, bar: 55}],\n  sequentialRenders: [\n    {cond: false, foo: 2, bar: 55},\n    {cond: false, foo: 3, bar: 55},\n    {cond: true, foo: 3, bar: 55},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Input React Component with Primitive Dependencies\nDESCRIPTION: Original React component implementation showing how primitive values and expressions are handled as dependencies. Demonstrates usage of non-allocating expressions and property mutations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/primitive-as-dep-nested-scope.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// props.b + 1 is an non-allocating expression, which means Forget can\n// emit it trivially and repeatedly (e.g. no need to memoize props.b + 1\n// separately from props.b)\n// Correctness:\n\nimport {identity, mutate, setProperty} from 'shared-runtime';\n\n//   y depends on either props.b or props.b + 1\nfunction PrimitiveAsDepNested(props) {\n  let x = {};\n  mutate(x);\n  let y = identity(props.b + 1);\n  setProperty(x, props.a);\n  return [x, y];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: PrimitiveAsDepNested,\n  params: [{a: 1, b: 2}],\n  sequentialRenders: [\n    // change b\n    {a: 1, b: 3},\n    // change b\n    {a: 1, b: 4},\n    // change a\n    {a: 2, b: 4},\n    // change a\n    {a: 3, b: 4},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Finding Element at Index N Algorithm in React DevTools\nDESCRIPTION: Algorithm for finding the Nth element in the component tree using the weight attribute. First it finds which root contains the index by iterating through roots and checking their weights.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/OVERVIEW.md#2025-04-21_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\nlet rootID;\nlet root;\nlet rootWeight = 0;\nfor (let i = 0; i < this._roots.length; i++) {\n  rootID = this._roots[i];\n  root = this._idToElement.get(rootID);\n  if (root.children.length === 0) {\n    continue;\n  } else if (rootWeight + root.weight > index) {\n    break;\n  } else {\n    rootWeight += root.weight;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: FBT Component Compiled Output\nDESCRIPTION: Compiled version of the FBT component with optimization for parameter caching. Shows how the JSX-style FBT syntax is transformed into function calls with caching logic.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-preserve-whitespace.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport fbt from \"fbt\";\n\nconst _ = fbt;\nfunction Component(t0) {\n  const $ = _c(2);\n  const { value } = t0;\n  let t1;\n  if ($[0] !== value) {\n    t1 = fbt._(\n      \"Before text {paramName}\",\n      [\n        fbt._param(\n          \"paramName\",\n\n          value,\n        ),\n      ],\n      { hk: \"3z5SVE\" },\n    );\n    $[0] = value;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ value: \"hello world\" }],\n};\n```\n\n----------------------------------------\n\nTITLE: Memoized React Component with Conditional Array Manipulation (Code)\nDESCRIPTION: This code snippet shows a memoized version of the React component.  It uses `react/compiler-runtime`'s `_c` function for memoization. It conditionally initializes `y` and then pushes `x` into it. The memoization logic caches and reuses previous renders based on `props.cond`, `props.cond2`, `props.value`, and `props.value2`.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/phi-type-inference-array-push-consecutive-phis.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enablePropagateDepsInHIR\nimport { makeArray } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(6);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = {};\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const x = t0;\n  let t1;\n  if (\n    $[1] !== props.cond ||\n    $[2] !== props.cond2 ||\n    $[3] !== props.value ||\n    $[4] !== props.value2\n  ) {\n    let y;\n    if (props.cond) {\n      if (props.cond2) {\n        y = [props.value];\n      } else {\n        y = [props.value2];\n      }\n    } else {\n      y = [];\n    }\n\n    y.push(x);\n\n    t1 = [x, y];\n    $[1] = props.cond;\n    $[2] = props.cond2;\n    $[3] = props.value;\n    $[4] = props.value2;\n    $[5] = t1;\n  } else {\n    t1 = $[5];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ cond: true, cond2: true, value: 42 }],\n  sequentialRenders: [\n    { cond: true, cond2: true, value: 3.14 },\n    { cond: true, cond2: true, value: 42 },\n    { cond: true, cond2: true, value: 3.14 },\n    { cond: true, cond2: false, value2: 3.14 },\n    { cond: true, cond2: false, value2: 42 },\n    { cond: true, cond2: false, value2: 3.14 },\n    { cond: false },\n    { cond: false },\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Memoization Test Implementation\nDESCRIPTION: Shows the compiled version of the memoization test code with optimized caching logic. Implements memoization checks using Symbol.for('react.memo_cache_sentinel') and maintains cache references for props and rendered elements.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/use-operator-method-call.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { ValidateMemoization } from \"shared-runtime\";\nimport { useMemo } from \"react\";\nimport * as React from \"react\";\n\nconst FooContext = React.createContext(null);\nfunction Component(props) {\n  const $ = _c(3);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = <Inner />;\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  let t1;\n  if ($[1] !== props.value) {\n    t1 = <FooContext.Provider value={props.value}>{t0}</FooContext.Provider>;\n    $[1] = props.value;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  return t1;\n}\n\nfunction Inner(props) {\n  const $ = _c(7);\n  const input = React.use(FooContext);\n  let t0;\n  let t1;\n  if ($[0] !== input) {\n    t1 = [input];\n    $[0] = input;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  t0 = t1;\n  const output = t0;\n  let t2;\n  if ($[2] !== input) {\n    t2 = [input];\n    $[2] = input;\n    $[3] = t2;\n  } else {\n    t2 = $[3];\n  }\n  let t3;\n  if ($[4] !== output || $[5] !== t2) {\n    t3 = <ValidateMemoization inputs={t2} output={output} />;\n    $[4] = output;\n    $[5] = t2;\n    $[6] = t3;\n  } else {\n    t3 = $[6];\n  }\n  return t3;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ value: 42 }],\n  sequentialRenders: [\n    { value: null },\n    { value: 42 },\n    { value: 42 },\n    { value: null },\n    { value: null },\n    { value: 42 },\n    { value: null },\n    { value: 42 },\n    { value: null },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with State Update and Export\nDESCRIPTION: This snippet defines a React component named 't' that uses the useState hook to trigger a state update with `setstate(1)`. It then returns the value of the `foo` prop. The `FIXTURE_ENTRYPOINT` object exports metadata about the component, including a reference to the component function, the expected parameter names ('TodoAdd'), and the component's name ('TodoAdd').\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/holey-array.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction t(props) {\n  let [, setstate] = useState();\n  setstate(1);\n  return props.foo;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: t,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n\n```\n\n----------------------------------------\n\nTITLE: Input Component with Optional Chaining in useEffect\nDESCRIPTION: A React component example before compilation that uses optional chaining in a useEffect hook. The component creates an object with a conditional nested property and uses optional chaining to access that property in the effect.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/reactive-optional-chain.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @inferEffectDependencies\nimport {useEffect} from 'react';\nimport {print} from 'shared-runtime';\n\n// TODO: take optional chains as dependencies\nfunction ReactiveMemberExpr({cond, propVal}) {\n  const obj = {a: cond ? {b: propVal} : null};\n  useEffect(() => print(obj.a?.b));\n}\n```\n\n----------------------------------------\n\nTITLE: React Error Message for setState During Render\nDESCRIPTION: The error message shown when setState is called unconditionally during component render. It points to the function call that initiates the chain leading to setState and includes a link to React documentation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.unconditional-set-state-nested-function-expressions.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n  14 |     bar();\n  15 |   };\n> 16 |   baz();\n     |   ^^^ InvalidReact: This is an unconditional set state during render, which will trigger an infinite loop. (https://react.dev/reference/react/useState) (16:16)\n  17 |\n  18 |   return [x];\n  19 | }\n```\n\n----------------------------------------\n\nTITLE: Starting Request Render in React\nDESCRIPTION: Method to initiate rendering of a request, continuing until completion.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-server/README.md#2025-04-21_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nstartWork(request: Request): void\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component using Compiler-Runtime\nDESCRIPTION: This snippet shows an optimized version of the React component using React's compiler-runtime. It includes memoization and conditional rendering for improved performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-instruction-part-of-already-closed-scope.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enableAssumeHooksFollowRulesOfReact\nimport { Stringify, identity, useHook } from \"shared-runtime\";\n\nfunction Component(t0) {\n  const $ = _c(17);\n  const { index } = t0;\n  const data = useHook();\n  let T0;\n  let t1;\n  let t2;\n  let t3;\n  if ($[0] !== data || $[1] !== index) {\n    const a = identity(data, index);\n    const b = identity(data, index);\n    const c = identity(data, index);\n\n    const t4 = identity(b);\n    if ($[6] !== t4) {\n      t2 = <Stringify value={t4} />;\n      $[6] = t4;\n      $[7] = t2;\n    } else {\n      t2 = $[7];\n    }\n    const t5 = identity(a);\n    if ($[8] !== t5) {\n      t3 = <Stringify value={t5} />;\n      $[8] = t5;\n      $[9] = t3;\n    } else {\n      t3 = $[9];\n    }\n    T0 = Stringify;\n    t1 = identity(c);\n    $[0] = data;\n    $[1] = index;\n    $[2] = T0;\n    $[3] = t1;\n    $[4] = t2;\n    $[5] = t3;\n  } else {\n    T0 = $[2];\n    t1 = $[3];\n    t2 = $[4];\n    t3 = $[5];\n  }\n  let t4;\n  if ($[10] !== T0 || $[11] !== t1) {\n    t4 = <T0 value={t1} />;\n    $[10] = T0;\n    $[11] = t1;\n    $[12] = t4;\n  } else {\n    t4 = $[12];\n  }\n  let t5;\n  if ($[13] !== t2 || $[14] !== t3 || $[15] !== t4) {\n    t5 = (\n      <div>\n        {t2}\n        {t3}\n        {t4}\n      </div>\n    );\n    $[13] = t2;\n    $[14] = t3;\n    $[15] = t4;\n    $[16] = t5;\n  } else {\n    t5 = $[16];\n  }\n  return t5;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ index: 0 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Using Hook in Component - JavaScript\nDESCRIPTION: This snippet imports a hook from 'ReactCompilerTest' and attempts to use it within a functional component named 'Component'. It aims to demonstrate hook usage but encounters a type error due to incorrect configuration of the hook. Dependencies required include 'ReactCompilerTest'. Key parameters are the hook being invoked. The expected output is the return of the hook or a type error message if the hook is misconfigured.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-type-provider-hook-name-not-typed-as-hook.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useHookNotTypedAsHook} from 'ReactCompilerTest';\n\nfunction Component() {\n  return useHookNotTypedAsHook();\n}\n\n```\n\n----------------------------------------\n\nTITLE: Initial React Component Implementation in JavaScript\nDESCRIPTION: This snippet shows the initial implementation of a React component with unnecessary operations. It takes a prop 'i', performs some redundant operations, and returns the value of 'i'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/dce-unused-prefix-update.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let i = 0;\n  --i;\n  i = props.i;\n  return i;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{i: 42}],\n};\n```\n\n----------------------------------------\n\nTITLE: Transformed JavaScript Function in React\nDESCRIPTION: This snippet shows the JavaScript output after transforming the TypeScript code. Type annotations are removed, and the inner function is hoisted and named. The overall structure and functionality remain the same.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-alias-used-as-variable-annotation.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableAssumeHooksFollowRulesOfReact @enableTransitivelyFreezeFunctionExpressions\ntype Bar = string;\nfunction TypeAliasUsedAsVariableAnnotation() {\n  const fun = _temp;\n\n  fun(\"hello, world\");\n}\nfunction _temp(f) {\n  const g = f;\n  console.log(g);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: TypeAliasUsedAsVariableAnnotation,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Hook Implementation with Set Spread Operation\nDESCRIPTION: Defines a custom hook 'useFoo' that creates a Set and uses spread operator with Math.max(). Includes test fixture configuration for sequential renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/global-types/call-spread-argument-set.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useIdentity} from 'shared-runtime';\n\n/**\n * Forked version of call-spread-argument-mutable-iterator that is known to not mutate\n * the spread argument since it is a Set\n */\nfunction useFoo() {\n  const s = new Set([1, 2]);\n  useIdentity(null);\n  return [Math.max(...s), s];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{}],\n  sequentialRenders: [{}, {}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization Logic\nDESCRIPTION: Compiled version of the React component showing the internal memoization implementation using a cache array ($) and dependency checking. Includes test fixtures for sequential renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-provider-store-capture.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useMemo } from \"react\";\nimport { typedArrayPush, ValidateMemoization } from \"shared-runtime\";\n\nexport function Component(t0) {\n  const $ = _c(27);\n  const { a, b } = t0;\n  let t1;\n  let t2;\n  if ($[0] !== a) {\n    t2 = { a };\n    $[0] = a;\n    $[1] = t2;\n  } else {\n    t2 = $[1];\n  }\n  t1 = t2;\n  const item1 = t1;\n  let t3;\n  let t4;\n  if ($[2] !== b) {\n    t4 = { b };\n    $[2] = b;\n    $[3] = t4;\n  } else {\n    t4 = $[3];\n  }\n  t3 = t4;\n  const item2 = t3;\n  let t5;\n  let items;\n  if ($[4] !== item1 || $[5] !== item2) {\n    items = [];\n    typedArrayPush(items, item1);\n    typedArrayPush(items, item2);\n    $[4] = item1;\n    $[5] = item2;\n    $[6] = items;\n  } else {\n    items = $[6];\n  }\n  t5 = items;\n  const items_0 = t5;\n  let t6;\n  if ($[7] !== a) {\n    t6 = [a];\n    $[7] = a;\n    $[8] = t6;\n  } else {\n    t6 = $[8];\n  }\n  let t7;\n  if ($[9] !== items_0[0] || $[10] !== t6) {\n    t7 = <ValidateMemoization inputs={t6} output={items_0[0]} />;\n    $[9] = items_0[0];\n    $[10] = t6;\n    $[11] = t7;\n  } else {\n    t7 = $[11];\n  }\n  let t8;\n  if ($[12] !== b) {\n    t8 = [b];\n    $[12] = b;\n    $[13] = t8;\n  } else {\n    t8 = $[13];\n  }\n  let t9;\n  if ($[14] !== items_0[1] || $[15] !== t8) {\n    t9 = <ValidateMemoization inputs={t8} output={items_0[1]} />;\n    $[14] = items_0[1];\n    $[15] = t8;\n    $[16] = t9;\n  } else {\n    t9 = $[16];\n  }\n  let t10;\n  if ($[17] !== a || $[18] !== b) {\n    t10 = [a, b];\n    $[17] = a;\n    $[18] = b;\n    $[19] = t10;\n  } else {\n    t10 = $[19];\n  }\n  let t11;\n  if ($[20] !== items_0 || $[21] !== t10) {\n    t11 = <ValidateMemoization inputs={t10} output={items_0} />;\n    $[20] = items_0;\n    $[21] = t10;\n    $[22] = t11;\n  } else {\n    t11 = $[22];\n  }\n  let t12;\n  if ($[23] !== t11 || $[24] !== t7 || $[25] !== t9) {\n    t12 = (\n      <>\n        {t7}\n        {t9}\n        {t11}\n      </>\n    );\n    $[23] = t11;\n    $[24] = t7;\n    $[25] = t9;\n    $[26] = t12;\n  } else {\n    t12 = $[26];\n  }\n  return t12;\n}\n```\n\n----------------------------------------\n\nTITLE: React Component with Optimized Conditional Logic in JavaScript\nDESCRIPTION: This snippet demonstrates an optimized React component setup leveraging 'compiler-runtime' support using cache for condition evaluations. It still depends on 'makeObject_Primitives' for object creation, caching previous prop values using a Symbol mechanics to avoid redundant evaluations. Outputs an object based on the latest conditions utilizing cached states.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-mutated-in-consequent-alternate-both-return.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { makeObject_Primitives } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(3);\n  let t0;\n  if ($[0] !== props.cond || $[1] !== props.value) {\n    t0 = Symbol.for(\"react.early_return_sentinel\");\n    bb0: {\n      const object = makeObject_Primitives();\n      if (props.cond) {\n        object.value = 1;\n        t0 = object;\n        break bb0;\n      } else {\n        object.value = props.value;\n        t0 = object;\n        break bb0;\n      }\n    }\n    $[0] = props.cond;\n    $[1] = props.value;\n    $[2] = t0;\n  } else {\n    t0 = $[2];\n  }\n  if (t0 !== Symbol.for(\"react.early_return_sentinel\")) {\n    return t0;\n  }\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ cond: false, value: [0, 1, 2] }],\n};\n```\n\n----------------------------------------\n\nTITLE: Calculating Sum within a React Component (JavaScript)\nDESCRIPTION: This snippet defines a React component that calculates a sum starting from a base value, incrementing the loop index by a specified increment until a test condition is met. The results are rendered in a React div. No external dependencies are required beyond the usual React setup.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/primitive-reassigned-loop-force-scopes-enabled.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\n// @enableForest\\nfunction Component({base, start, increment, test}) {\\n  let value = base;\\n  for (let i = start; i < test; i += increment) {\\n    value += i;\\n  }\\n  return <div>{value}</div>;\\n}\\n\\nexport const FIXTURE_ENTRYPOINT = {\\n  fn: Component,\\n  params: [{base: 0, start: 0, test: 10, increment: 1}],\\n  sequentialRenders: [\\n    {base: 0, start: 1, test: 10, increment: 1},\\n    {base: 0, start: 0, test: 10, increment: 2},\\n    {base: 2, start: 0, test: 10, increment: 2},\\n    {base: 0, start: 0, test: 11, increment: 2},\\n  ],\\n};\\n\n```\n\n----------------------------------------\n\nTITLE: Incorrect React Component with Variable Reassignment\nDESCRIPTION: This snippet demonstrates a React component that incorrectly reassigns variables within the component function. It attempts to destructure values from props.value and assign them to variables 'a' and 'b'. This approach violates React's rules for pure components and hooks.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-destructure-to-local-global-variables.expect.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let a;\n  [a, b] = props.value;\n\n  return [a, b];\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: This is the compiled version of the React component, utilizing `react/compiler-runtime` for memoization. It uses a cache (`$[0]`, `$[1]`, etc.) to store the previous values of `props.cond` and `stateObject.setState` to avoid unnecessary re-renders.  It imports necessary modules and demonstrates compiler optimizations for efficient rendering based on prop and state changes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-phi-setState-type.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport invariant from \"invariant\";\nimport { useState } from \"react\";\n\nfunction Component(props) {\n  const $ = _c(5);\n  const [, setX] = useState(false);\n  const [, setY] = useState(false);\n  let setState;\n  if (props.cond) {\n    setState = setX;\n  } else {\n    setState = setY;\n  }\n\n  const setState2 = setState;\n  let t0;\n  if ($[0] !== setState2) {\n    t0 = { setState: setState2 };\n    $[0] = setState2;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const stateObject = t0;\n  let t1;\n  if ($[2] !== props.cond || $[3] !== stateObject.setState) {\n    t1 = (\n      <Foo\n        cond={props.cond}\n        setX={setX}\n        setY={setY}\n        setState={stateObject.setState}\n      />\n    );\n    $[2] = props.cond;\n    $[3] = stateObject.setState;\n    $[4] = t1;\n  } else {\n    t1 = $[4];\n  }\n  return t1;\n}\n\nfunction Foo(t0) {\n  const { cond, setX, setY, setState } = t0;\n  if (cond) {\n    invariant(setState === setX, \"Expected the correct setState function\");\n  } else {\n    invariant(setState === setY, \"Expected the correct setState function\");\n  }\n  return \"ok\";\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  sequentialRenders: [\n    { cond: true },\n    { cond: true },\n    { cond: false },\n    { cond: false },\n    { cond: true },\n    { cond: false },\n    { cond: true },\n    { cond: false },\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining a React Hook with Conditional Dependencies in Switch Statement\nDESCRIPTION: A React Hook that conditionally accesses props.a.b inside a switch statement, demonstrating how properties not accessed in every path are handled as conditional dependencies by the React compiler.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/cfg-switch-missing-case.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// props.a.b should NOT be added as a unconditional dependency to the reactive\n// scope that produces x if it is not accessed in every path\n\nimport {identity} from 'shared-runtime';\n\nfunction useCondDepInSwitchMissingCase(props, other) {\n  const x = {};\n  switch (identity(other)) {\n    case 1:\n      x.a = props.a.b;\n      break;\n    case 2:\n      x.b = 42;\n      break;\n    default:\n      x.c = props.a.b;\n      break;\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useCondDepInSwitchMissingCase,\n  params: [{a: {b: 2}}, 2],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Fire Mechanism in React Component\nDESCRIPTION: This snippet demonstrates a React functional component that imports the fire function from the React library. It defines a foo function to log prop1 and invokes it along with bar() using fire within the useEffect hook. The snippet follows rules about capitalized function calls, which are validated by decorators. The expected output includes calls to fire, logging of prop1, and the return value of CapitalizedCall.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/bailout-retry/bailout-capitalized-fn-call.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validateNoCapitalizedCalls @enableFire @panicThreshold(none)\nimport {fire} from 'react';\nconst CapitalizedCall = require('shared-runtime').sum;\n\nfunction Component({prop1, bar}) {\n  const foo = () => {\n    console.log(prop1);\n  };\n  useEffect(() => {\n    fire(foo(prop1));\n    fire(foo());\n    fire(bar());\n  });\n\n  return CapitalizedCall();\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining a React Component - JavaScript\nDESCRIPTION: This snippet defines a functional component in React and shows an improper reassignment attempt of a global variable, which results in an error. The comment clarifies that globals should not be assigned within React components to maintain purity.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.reassignment-to-global.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component() {\n  // Cannot assign to globals\n  someUnknownGlobal = true;\n  moduleLocal = true;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Component Logging Functionality in React - JavaScript\nDESCRIPTION: This snippet defines a React component that logs values of input properties 'a' and 'b' only once, using the 'useRef' hook to track whether logging has already occurred. It utilizes the shared-runtime's 'Stringify' component to handle rendering. The dependencies include React and shared-runtime.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/assume-invoked/conditional-call-chain.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useRef} from 'react';\nimport {Stringify} from 'shared-runtime';\n\nfunction Component({a, b}) {\n  const logA = () => {\n    console.log(a.value);\n  };\n  const logB = () => {\n    console.log(b.value);\n  };\n  const hasLogged = useRef(false);\n  const log = () => {\n    if (!hasLogged.current) {\n      logA();\n      logB();\n      hasLogged.current = true;\n    }\n  };\n  return <Stringify log={log} shouldInvokeFns={true} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{a: {value: 1}, b: {value: 2}}],\n  sequentialRenders: [\n    {a: {value: 1}, b: {value: 2}},\n    {a: {value: 3}, b: {value: 4}},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a Functional Component - JavaScript\nDESCRIPTION: This snippet defines a basic functional React component that utilizes props, initializes an empty array, and maps over it. It serves as a simple example of a React component structure.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-map-frozen-array-noAlias.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const x = [];\n  <dif>{x}</dif>;\n  const y = x.map(item => item);\n  return [x, y];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: React Compiler-Optimized JavaScript with Memoization\nDESCRIPTION: The optimized version of the function produced by React's compiler. It replaces the conditional logic with a memoization cache using React's compiler runtime, resulting in more efficient execution.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-objectexpression-phi.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction foo() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = { x: 1, y: 3 };\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const t = t0;\n  return t;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Using React Context API with JavaScript\nDESCRIPTION: This snippet demonstrates a basic React component utilizing the Context API. The App function accesses context values using the useContext hook, and displays them by rendering the Bar component. There are no external dependencies other than React, and the snippet requires a predefined MyContext. The component expects the context to provide an array from which it destructures values for use. It returns a JSX element representing the rendered component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/todo.lower-context-access-array-destructuring.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @lowerContextAccess\nfunction App() {\n  const [foo, bar] = useContext(MyContext);\n  return <Bar foo={foo} bar={bar} />;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing useFoo Custom Hook in React\nDESCRIPTION: This snippet defines a custom hook useFoo that creates and manipulates Set objects based on input props. It also includes a test fixture for sequential renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/global-types/set-copy-constructor-mutate.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {makeArray, mutate} from 'shared-runtime';\n\nfunction useFoo({propArr}: {propArr: Array<number>}) {\n  const s1 = new Set<number | Array<number>>([1, 2, 3]);\n  s1.add(makeArray(propArr[0]));\n\n  const s2 = new Set(s1);\n  // this may also may mutate s1\n  mutate(s2);\n\n  return [s1, s2];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{propArr: [7, 8, 9]}],\n  sequentialRenders: [\n    {propArr: [7, 8, 9]},\n    {propArr: [7, 8, 9]},\n    {propArr: [7, 8, 10]},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Enhancing useEffect with Custom Cache Logic - JavaScript\nDESCRIPTION: This snippet enhances the earlier implementation by integrating a custom caching mechanism using `Symbol.for` to determine if a React memo cache sentinel is present. It substitutes the useMemo implementation with custom logic that assigns memoized functions and dependencies, further showcasing internal runtime operations. It maintains dependencies on React's `useEffect` and a runtime compiler.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useEffect-global-pruned.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useEffect } from \"react\";\n\nfunction someGlobal() {}\nfunction useFoo() {\n  const $ = _c(2);\n  let t0;\n  t0 = _temp;\n  const fn = t0;\n  let t1;\n  let t2;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = () => {\n      fn();\n    };\n    t2 = [fn];\n    $[0] = t1;\n    $[1] = t2;\n  } else {\n    t1 = $[0];\n    t2 = $[1];\n  }\n  useEffect(t1, t2);\n  return null;\n}\nfunction _temp() {\n  someGlobal();\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [],\n  isComponent: false,\n};\n\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Memoization - JavaScript\nDESCRIPTION: This snippet shows a more complex React component that uses memoization for performance. It checks if the cached value corresponds to the previous props, updating the cache only when necessary, and utilizes a function `_c` from React's compiler runtime.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-member-expression-call-as-property.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(3);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = makeObject();\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const x = t0;\n  let t1;\n  if ($[1] !== props) {\n    t1 = x?.[foo(props.value)];\n    $[1] = props;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  return t1;\n}\n```\n\n----------------------------------------\n\nTITLE: React Hook Call Order Error (JavaScript)\nDESCRIPTION: This error message shows that the `useArray()` hook is being called conditionally within the `Component` function.  React's Rules of Hooks require that hooks be called in the same order during every render of a component. Calling a hook inside an `if` statement violates this rule, resulting in an `InvalidReact` error.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-conditional-call-non-hook-imported-as-hook.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n  4 |   let data;\n  5 |   if (props.cond) {\n> 6 |     data = useArray();\n    |            ^^^^^^^^ InvalidReact: Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning) (6:6)\n  7 |   }\n  8 |   return data;\n  9 | }\n\n```\n\n----------------------------------------\n\nTITLE: Optimizing a Custom Hook with Compiler Runtime in JavaScript\nDESCRIPTION: This code refines \"useHook\" by leveraging \"react/compiler-runtime\" to cache and compare dependencies, ensuring efficient updates to the closure \"x\". Specifically, it tracks changes to the function parameters and internal states to only recompute as necessary. This method reduces unnecessary computations and ensures stable function references across renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-conditional-capture-mutate.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction useHook(a, b) {\n  const $ = _c(5);\n  let t0;\n  if ($[0] !== a) {\n    t0 = { a };\n    $[0] = a;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const z = t0;\n  const y = b;\n  let t1;\n  if ($[2] !== y || $[3] !== z) {\n    t1 = function () {\n      if (y) {\n        maybeMutate(z);\n      }\n    };\n    $[2] = y;\n    $[3] = z;\n    $[4] = t1;\n  } else {\n    t1 = $[4];\n  }\n  const x = t1;\n  return x;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution Example in Foo Function - JavaScript\nDESCRIPTION: This snippet demonstrates a function 'Foo' that takes a boolean parameter 'cond'. Depending on the value of 'cond', it either logs 'other test' or 'fallthrough test'. It showcases variable scoping and conditional logic in JavaScript. Requires the 'log' function defined previously.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-shadowing.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Foo(cond) {\n  let str = '';\n  if (cond) {\n    let str = 'other test';\n    log(str);\n  } else {\n    str = 'fallthrough test';\n  }\n  log(str);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Hook with State Management - JavaScript\nDESCRIPTION: This snippet defines a custom React hook, `useHook`, which initializes a state variable and returns an object containing methods to retrieve state and a given value. It requires React and shared runtime dependencies. The expected input is an object with a `value` property, and the output includes an object with `getX` and its associated methods.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-shorthand-method-nested.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useState} from 'react';\nimport {createHookWrapper} from 'shared-runtime';\n\nfunction useHook({value}) {\n  const [state] = useState(false);\n\n  return {\n    getX() {\n      return {\n        a: [],\n        getY() {\n          return value;\n        },\n        state,\n      };\n    },\n  };\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: createHookWrapper(useHook),\n  params: [{value: 0}],\n};\n```\n\n----------------------------------------\n\nTITLE: Initializing Memoization Cache with React Compiler Runtime in JavaScript\nDESCRIPTION: This code snippet demonstrates initializing and utilizing a memoization cache using React's compiler runtime. It checks if the cache is a specific sentinel value and proceeds to execute the same function while caching its result. This is useful in performance optimization when using React.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/store-via-call.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction foo() {\n  const $ = _c(1);\n  let x;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    x = {};\n    const y = foo(x);\n    y.mutate();\n    $[0] = x;\n  } else {\n    x = $[0];\n  }\n  return x;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Optimizing React Component State Management with Cached References\nDESCRIPTION: This snippet shows an optimized method of managing component state by leveraging a custom cached array to track prop changes and computed results. It handles reactivity more efficiently, reducing unnecessary updates by checking and storing dependencies. Dependencies include React, a compiler runtime module, and the makeObject function.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-independently-memoizeable.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(10);\n  let t0;\n  let t1;\n  if ($[0] !== props.a) {\n    t1 = makeObject(props.a);\n    $[0] = props.a;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  const a = t1;\n  let t2;\n  if ($[2] !== props.b) {\n    t2 = makeObject(props.b);\n    $[2] = props.b;\n    $[3] = t2;\n  } else {\n    t2 = $[3];\n  }\n  const b = t2;\n  let t3;\n  if ($[4] !== a || $[5] !== b) {\n    t3 = [a, b];\n    $[4] = a;\n    $[5] = b;\n    $[6] = t3;\n  } else {\n    t3 = $[6];\n  }\n  t0 = t3;\n  const [a_0, b_0] = t0;\n  let t4;\n  if ($[7] !== a_0 || $[8] !== b_0) {\n    t4 = [a_0, b_0];\n    $[7] = a_0;\n    $[8] = b_0;\n    $[9] = t4;\n  } else {\n    t4 = $[9];\n  }\n  return t4;\n}\n```\n\n----------------------------------------\n\nTITLE: React Regression Test with Conditional Expression\nDESCRIPTION: This snippet demonstrates a regression test in React for a conditional expression assigned to a variable. It checks if the conditional ternary operator 'cond ? a : b' is correctly parsed within a function component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-c5d1f3143c4c.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Regression test for incorrectly flagged valid code.\nfunction RegressionTest() {\n  const foo = cond ? a : b;\n  useState();\n}\n\n```\n\n----------------------------------------\n\nTITLE: Initializing Basic React Component\nDESCRIPTION: A simple React functional component that creates a MaybeMutable instance and renders a component with dynamic content\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-member-expression-tag-grouping.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const maybeMutable = new MaybeMutable();\n  return <Foo.Bar>{maybeMutate(maybeMutable)}</Foo.Bar>;\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled Output of React Component with FBT Internationalization\nDESCRIPTION: This snippet shows the compiled output of the FBT-enabled React component. It includes performance optimizations such as caching the translated string when the input value doesn't change.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-whitespace-around-param-value.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport fbt from \"fbt\";\n\nconst _ = fbt;\nfunction Component(t0) {\n  const $ = _c(2);\n  const { value } = t0;\n  let t1;\n  if ($[0] !== value) {\n    t1 = fbt._(\n      \"Before text {paramName} after text\",\n      [fbt._param(\"paramName\", value)],\n      { hk: \"26pxNm\" },\n    );\n    $[0] = value;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ value: \"hello world\" }],\n};\n```\n\n----------------------------------------\n\nTITLE: Transformed React Component Implementation\nDESCRIPTION: Shows the compiled/transformed version of the component with explicit parameter destructuring and default value handling. Demonstrates how the syntactic sugar of default parameters is implemented under the hood.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-object-param-default.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(t0) {\n  const { a: t1 } = t0;\n  const a = t1 === undefined ? 2 : t1;\n  return a;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with Destructuring Parameter\nDESCRIPTION: A React component that destructures the 'foo' parameter, accesses its 'bar' property, and renders a Stringify component with a handler that modifies 'foo'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-reassign-const.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {Stringify} from 'shared-runtime';\n\nfunction Component({foo}) {\n  let bar = foo.bar;\n  return (\n    <Stringify\n      handler={() => {\n        foo = true;\n      }}\n    />\n  );\n}\n\n```\n\n----------------------------------------\n\nTITLE: Compiled Component with React Compiler Runtime Memoization\nDESCRIPTION: The transformed component after processing by React's compiler. It introduces memoization via a compiler runtime array ($) to track dependencies and prevent unnecessary recalculations. The array stores previous values and only recalculates when dependencies change.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-nested-member-expr.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction component(a) {\n  const $ = _c(4);\n  let t0;\n  if ($[0] !== a) {\n    t0 = { a: { a } };\n    $[0] = a;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const z = t0;\n  let t1;\n  if ($[2] !== z.a.a) {\n    t1 = function () {\n      console.log(z.a.a);\n    };\n    $[2] = z.a.a;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  const x = t1;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a Component with Array Manipulation in JavaScript\nDESCRIPTION: This snippet demonstrates defining a React component named 'Component' that utilizes 'makeArray' from 'shared-runtime'. It processes a set of numbers by popping elements from an array, calculating their sum, and returning the modified array along with the computed sum. Dependency on the 'shared-runtime' module is required.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reassign-in-while-loop-condition.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {makeArray} from 'shared-runtime';\n\n// @flow\nfunction Component() {\n  const items = makeArray(0, 1, 2);\n  let item;\n  let sum = 0;\n  while ((item = items.pop())) {\n    sum += item;\n  }\n  return [items, sum];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: React Compiler-Optimized Version with Memoization\nDESCRIPTION: The transformed version of the useFoo hook processed by React's compiler. It includes memoization using an array ($) to track state between renders and avoid unnecessary calculations, changing label to bb0 and implementing dependency tracking.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-poisoned/break-poisons-outer-scope.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { identity } from \"shared-runtime\";\n\nfunction useFoo(t0) {\n  const $ = _c(5);\n  const { input, cond } = t0;\n  let x;\n  if ($[0] !== cond || $[1] !== input) {\n    x = [];\n    bb0: {\n      if (cond) {\n        break bb0;\n      }\n      let t1;\n      if ($[3] !== input.a.b) {\n        t1 = identity(input.a.b);\n        $[3] = input.a.b;\n        $[4] = t1;\n      } else {\n        t1 = $[4];\n      }\n      x.push(t1);\n    }\n    $[0] = cond;\n    $[1] = input;\n    $[2] = x;\n  } else {\n    x = $[2];\n  }\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Event Priority Constants for getCurrentEventPriority\nDESCRIPTION: Demonstrates how to import and use event priority constants when implementing the getCurrentEventPriority method in a React renderer\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-reconciler/README.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport {\n  DiscreteEventPriority,\n  ContinuousEventPriority,\n  DefaultEventPriority,\n} from 'react-reconciler/constants';\n\nconst HostConfig = {\n  // ...\n  getCurrentEventPriority() {\n    return DefaultEventPriority;\n  },\n  // ...\n}\n\nconst MyRenderer = Reconciler(HostConfig);\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with Dynamic Theming in JavaScript\nDESCRIPTION: This snippet defines a React component that applies CSS classes dynamically based on a theme. It uses a custom 'cx' function for class name generation and a mock 'useTheme' hook. The code includes React compiler optimizations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/meta-isms/repro-cx-assigned-to-temporary.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @compilationMode(infer) @enableAssumeHooksFollowRulesOfReact:false @customMacros(cx)\nimport { identity } from \"shared-runtime\";\n\nconst DARK = \"dark\";\n\nfunction Component() {\n  const $ = _c(2);\n  const theme = useTheme();\n\n  const t0 = cx({\n    \"styles/light\": true,\n    \"styles/dark\": theme.getTheme() === DARK,\n  });\n  let t1;\n  if ($[0] !== t0) {\n    t1 = <div className={t0} />;\n    $[0] = t0;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n\nfunction cx(obj) {\n  const classes = [];\n  for (const [key, value] of Object.entries(obj)) {\n    if (value) {\n      classes.push(key);\n    }\n  }\n  return classes.join(\" \");\n}\n\nfunction useTheme() {\n  return {\n    getTheme() {\n      return DARK;\n    },\n  };\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing a Minimal JavaScript Function with Fixture in React\nDESCRIPTION: Defines an empty function 'foo' and exports a fixture entrypoint object that references the function. This minimal implementation serves as a testing template.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-complex-single-if.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo() {}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Error Handling for Unreachable Code in React Component - JavaScript\nDESCRIPTION: This snippet shows an error that arises when an unreachable function declaration 'Foo' is detected within the 'Component'. It addresses the limitation of the current compilation process in recognizing hoisted functions that are placed in unreachable code paths within React components.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-hoisted-function-in-unreachable-code.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n  4 |\n  5 |   // This is unreachable from a control-flow perspective, but it gets hoisted\n> 6 |   function Foo() {}\n    |   ^^^^^^^^^^^^^^^^^ Todo: Support functions with unreachable code that may contain hoisted declarations (6:6)\n  7 | }\n  8 |\n\n```\n\n----------------------------------------\n\nTITLE: React Compiler-Transformed Memoization Code in JavaScript\nDESCRIPTION: Compiler-transformed output that adds memoization to avoid redundant computations on re-renders. It uses React's compiler runtime to track the condition state and reuse the previously computed array when the condition hasn't changed.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/phi-reference-effects.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { arrayPush } from \"shared-runtime\";\n\nfunction Foo(cond) {\n  const $ = _c(2);\n  let x;\n  if ($[0] !== cond) {\n    x = null;\n    if (cond) {\n      x = [];\n    }\n\n    arrayPush(x, 2);\n    $[0] = cond;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{ cond: true }],\n  sequentialRenders: [{ cond: true }, { cond: true }],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with FBT Memoization\nDESCRIPTION: The compiler-transformed version of the component that uses memoization to optimize rendering. It tracks previous props values and caches rendered output to avoid unnecessary re-renders of internationalized content.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-params.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport fbt from \"fbt\";\n\nfunction Component(props) {\n  const $ = _c(7);\n  let t0;\n  if ($[0] !== props.name) {\n    t0 = fbt._(\"Hello {user name}\", [fbt._param(\"user name\", props.name)], {\n      hk: \"2zEDKF\",\n    });\n    $[0] = props.name;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  let t1;\n  if ($[2] !== props.actions) {\n    t1 = fbt._(\n      \"{actions|response}\",\n      [fbt._param(\"actions|response\", props.actions)],\n      { hk: \"1cjfbg\" },\n    );\n    $[2] = props.actions;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  let t2;\n  if ($[4] !== t0 || $[5] !== t1) {\n    t2 = (\n      <div>\n        {t0}\n        {t1}\n      </div>\n    );\n    $[4] = t0;\n    $[5] = t1;\n    $[6] = t2;\n  } else {\n    t2 = $[6];\n  }\n  return t2;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: React Component Input Code with Mutable State\nDESCRIPTION: Original React component code showing a component with mutable state handling. Uses MaybeMutable class and JSX with View component. Includes detailed HIR (High-level Intermediate Representation) comments explaining the compilation process.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/global-jsx-tag-lowered-between-mutations.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const maybeMutable = new MaybeMutable();\n  // NOTE: this will produce invalid output.\n  // The HIR is roughly:\n  //                                    mutable range of `maybeMutable`\n  // StoreLocal maybeMutable = ...     \n  // t0 = LoadGlobal View               <-- View is lowered inside this mutable range\n  //                                         and thus gets becomes an output of this scope,\n  //                                         gets promoted to temporary\n  // t1 = LoadGlobal maybeMutate       \n  // t2 = LoadLocal maybeMutable       \n  // t3 = Call t1(t2)                  \n  // t4 = Jsx tag=t0 props=[] children=[t3] <-- `t0` is an invalid tag\n  return <View>{maybeMutate(maybeMutable)}</View>;\n}\n```\n\n----------------------------------------\n\nTITLE: Extended Component Hook with Compiler Runtime - JavaScript\nDESCRIPTION: This snippet extends the Component function by integrating with react/compiler-runtime, manipulating state using a memoization concept. It introduces a caching mechanism for function components using the memo_cache_sentinel symbol to store and reuse function references. Key dependencies include react/compiler-runtime and a custom useFoo hook. Inputs include component props, and outputs are adjustments to the ref value based on cached state.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hook-ref-callback.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useEffect, useRef } from \"react\";\n\nfunction Component(props) {\n  const $ = _c(1);\n  const ref = useRef();\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = () => {\n      ref.current = 42;\n    };\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  useFoo(t0);\n}\n\nfunction useFoo(x) {}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Compiler Transformed Output with Memoization\nDESCRIPTION: The transformed code by React Compiler implements memoization to avoid recreating the JSX element on every render. It uses a special cache mechanism through the compiler runtime and extracts the JSX creation into a separate function.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/const-propagation-into-function-expression-global.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction foo() {\n  const $ = _c(1);\n\n  const getJSX = _temp;\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = getJSX();\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const result = t0;\n  return result;\n}\nfunction _temp() {\n  return <Child x={GLOBAL_IS_X} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Destructuring in JavaScript\nDESCRIPTION: This snippet defines a React component that uses array destructuring to extract values from props. It demonstrates a simple component structure with export for testing purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-object-pattern-within-rest.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const [y, ...{z}] = props.value;\n  return [y, z];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: ['y', {z: 'z!'}]}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple React Component - JavaScript\nDESCRIPTION: This snippet defines a simple React component that creates and returns an object based on a function `foo`, passing in a property from `props`. It demonstrates basic component structure and usage of optional chaining.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-member-expression-call-as-property.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const x = makeObject();\n  return x?.[foo(props.value)];\n}\n```\n\n----------------------------------------\n\nTITLE: Error Handling for useInvalidMutation - JavaScript\nDESCRIPTION: This section showcases the error output generated when attempting to mutate the 'options' object inside the 'test' function defined in the 'useInvalidMutation' hook. The error message highlights that modifying the props or hook arguments is not allowed and suggests using local variables instead. This serves as a warning for developers to adhere to immutability in their React applications.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-mutation-in-closure.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n  2 |   function test() {\n  3 |     foo(options.foo); // error should not point on this line\n> 4 |     options.foo = 'bar';\n    |     ^^^^^^^ InvalidReact: Mutating component props or hook arguments is not allowed. Consider using a local variable instead. Found mutation of `options` (4:4)\n  5 |   }\n  6 |   return test;\n  7 | }\n\n```\n\n----------------------------------------\n\nTITLE: Deprecated React API Removal\nDESCRIPTION: This snippet highlights the removal of the `React.autoBind` API in React version 0.5.0. The API was previously deprecated in version 0.4, and this change ensures its complete removal from the codebase, maintaining API consistency.\nSOURCE: https://github.com/facebook/react/blob/main/CHANGELOG.md#2025-04-21_snippet_23\n\nLANGUAGE: none\nCODE:\n```\n\"Removed `React.autoBind` - This was deprecated in v0.4 and now properly removed.\"\n```\n\n----------------------------------------\n\nTITLE: Defining a Conditional Component with Memoization in React - JavaScript\nDESCRIPTION: This snippet enhances the previous implementation by using a caching mechanism through the React compiler. It introduces a memoization pattern with 'Symbol.for(\"react.memo_cache_sentinel\")' to optimize performance when rendering the component. The returned value depends on the condition and also references 'useFreeze' and 'call' to ensure immutability as required.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hooks-freeze-possibly-mutable-arguments.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(1);\n  const cond = props.cond;\n  const x = props.x;\n  let a;\n  if (cond) {\n    a = x;\n  } else {\n    let t0;\n    if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n      t0 = [];\n      $[0] = t0;\n    } else {\n      t0 = $[0];\n    }\n    a = t0;\n  }\n\n  useFreeze(a);\n  useFreeze(a);\n  call(a);\n  return a;\n}\n\nfunction useFreeze(x) {}\nfunction call(x) {}\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization Logic\nDESCRIPTION: The React component after compilation, showing how the React compiler runtime implements memoization. It uses a cache array to store previous values and dependencies to avoid recreating objects when props haven't changed.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/escape-analysis-non-escaping-interleaved-allocating-dependency.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(5);\n  let t0;\n  if ($[0] !== props.a) {\n    t0 = [props.a];\n    $[0] = props.a;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const a = t0;\n  let b;\n  if ($[2] !== a || $[3] !== props.b) {\n    b = [];\n    const c = {};\n    c.a = a;\n    b.push(props.b);\n    $[2] = a;\n    $[3] = props.b;\n    $[4] = b;\n  } else {\n    b = $[4];\n  }\n  return b;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Memoization\nDESCRIPTION: This snippet shows an optimized version of the component function 'f' using React's compiler-runtime. It implements memoization to avoid unnecessary re-renders and computations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/lambda-mutated-non-reactive-to-reactive.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction f(a) {\n  const $ = _c(4);\n  let x;\n  if ($[0] !== a) {\n    x = { a };\n    $[0] = a;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  let t0;\n  if ($[2] !== x) {\n    t0 = <div x={x} />;\n    $[2] = x;\n    $[3] = t0;\n  } else {\n    t0 = $[3];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: f,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Optimizing a React Div Component with Memoization - Javascript\nDESCRIPTION: This snippet defines an optimized version of the 'useDiv' component that uses memoization for performance enhancements. It leverages React's compiler runtime to store and re-use rendered elements to avoid unnecessary re-renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-functions-hook-with-jsx.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @compilationMode(infer)\nfunction useDiv(props) {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = <div />;\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Using React's useEffect Hook in JavaScript\nDESCRIPTION: This snippet demonstrates a React function component utilizing the useEffect hook with a dependency on an object created by the makeObject_Primitives function. It showcases the necessity of managing dependencies manually when the React compiler cannot infer them. Dependencies include React itself and functions like makeObject_Primitives and print. Limitations include the requirement to manually define dependencies to prevent build errors.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/bailout-retry/error.todo-import-default-property-useEffect.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\n// @inferEffectDependencies @panicThreshold(none)\nimport React from 'react';\n\nfunction NonReactiveDepInEffect() {\n  const obj = makeObject_Primitives();\n  React.useEffect(() => print(obj));\n}\n```\n\n----------------------------------------\n\nTITLE: Optimized Key Command Hook with Memoization - JavaScript\nDESCRIPTION: This code snippet illustrates an enhanced version of the useKeyCommand hook, utilizing React's internal caching mechanism via memoization. It checks a memo cache symbol and updates the key commands accordingly. This approach is designed to prevent unnecessary recalculations and optimize performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capture-ref-for-later-mutation.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useRef } from \"react\";\nimport { addOne } from \"shared-runtime\";\n\nfunction useKeyCommand() {\n  const $ = _c(1);\n  const currentPosition = useRef(0);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const handleKey = (direction) => () => {\n      const position = currentPosition.current;\n      const nextPosition = direction === \"left\" ? addOne(position) : position;\n      currentPosition.current = nextPosition;\n    };\n\n    const moveLeft = { handler: handleKey(\"left\") };\n\n    const moveRight = { handler: handleKey(\"right\") };\n\n    t0 = [moveLeft, moveRight];\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useKeyCommand,\n  params: [],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Initializing React Component with Global State Mutation\nDESCRIPTION: Demonstrates problematic React component that modifies a global variable outside of state management, which can lead to unexpected rendering behaviors and React best practice violations\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-global-reassignment-indirect.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useEffect, useState} from 'react';\n\nlet someGlobal = false;\n\nfunction Component() {\n  const [state, setState] = useState(someGlobal);\n\n  const setGlobal = () => {\n    someGlobal = true;\n  };\n  const indirectSetGlobal = () => {\n    setGlobal();\n  };\n  indirectSetGlobal();\n\n  useEffect(() => {\n    setState(someGlobal);\n  }, [someGlobal]);\n\n  return <div>{String(state)}</div>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Original React Component with Dynamic Context\nDESCRIPTION: This snippet defines a React component that creates a dynamic context object using a computed property key. It imports an 'identity' function and exports a fixture for testing.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-expression-computed-key-constant-number.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {identity} from 'shared-runtime';\n\nfunction Component(props) {\n  const key = 42;\n  const context = {\n    [key]: identity([props.value]),\n  };\n  return context;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: 'hello!'}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: This snippet shows the compiled version of the `Foo` React component, likely generated by a compiler like React Compiler. It uses `_c` from `react/compiler-runtime` for memoization of intermediate values and function results. This aims to optimize rendering by reusing previously computed values when inputs remain the same.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/infer-function-uncond-optional-hoists-other-dep.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enablePropagateDepsInHIR\n\nimport { identity, makeArray, Stringify, useIdentity } from \"shared-runtime\";\n\nfunction Foo(t0) {\n  const $ = _c(8);\n  const { a, cond } = t0;\n  let t1;\n  if ($[0] !== a) {\n    t1 = () => [a, a.b?.c.d];\n    $[0] = a;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  const fn = t1;\n  useIdentity(null);\n  let arr;\n  if ($[2] !== a.b?.c.e || $[3] !== cond) {\n    arr = makeArray();\n    if (cond) {\n      arr.push(identity(a.b?.c.e));\n    }\n    $[2] = a.b?.c.e;\n    $[3] = cond;\n    $[4] = arr;\n  } else {\n    arr = $[4];\n  }\n  let t2;\n  if ($[5] !== arr || $[6] !== fn) {\n    t2 = <Stringify fn={fn} arr={arr} shouldInvokeFns={true} />;\n    $[5] = arr;\n    $[6] = fn;\n    $[7] = t2;\n  } else {\n    t2 = $[7];\n  }\n  return t2;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{ a: null, cond: true }],\n  sequentialRenders: [\n    { a: null, cond: true },\n    { a: { b: { c: { d: 5 } } }, cond: true },\n    { a: { b: null }, cond: false },\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Handling Invalid React Component Configuration Error\nDESCRIPTION: This snippet shows the error message generated when attempting to use `disableMemoizationForDebugging` and `enableChangeDetectionForDebugging` options together in a React component configuration. This indicates that the options are incompatible and cannot be used simultaneously.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.nomemo-and-change-detect.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nInvalidConfig: Invalid environment config: the 'disableMemoizationForDebugging' and 'enableChangeDetectionForDebugging' options cannot be used together\n```\n\n----------------------------------------\n\nTITLE: Input React Component with Parameter Destructuring\nDESCRIPTION: Original React component implementation showing parameter destructuring with rest parameters. The component takes a foo parameter and destructures a bar property from the rest parameter.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rest-param-with-object-spread-pattern.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(foo, ...{bar}) {\n  return [foo, bar];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: ['foo', {bar: 'bar'}],\n};\n```\n\n----------------------------------------\n\nTITLE: Component Definition with Mutation\nDESCRIPTION: This JavaScript code defines a component function that takes a parameter 'a', creates an object 'x' with 'a', assigns 'x' to 'y', mutates 'y' using the 'mutate' function from 'shared-runtime', and returns 'y'. The component is designed to demonstrate mutation and its interaction with the shared runtime.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-simple-alias-iife.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst {mutate} = require('shared-runtime');\n\nfunction component(a) {\n  let x = {a};\n  let y = {};\n  (function () {\n    y = x;\n  })();\n  mutate(y);\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: ['foo'],\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Component Input Implementation\nDESCRIPTION: Basic React component implementation that renders multiple Text components with different character values including whitespace, Korean, Tamil and English text.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-string-attribute-expression-container.expect.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component() {\n  return (\n    <div>\n      <Text value={'\\n'} />\n      <Text value={'A\\tE'} />\n      <Text value={''} />\n      <Text value={'Lauren'} />\n      <Text value={''} />\n      <Text value={'Sathya'} />\n    </div>\n  );\n}\n\nfunction Text({value}) {\n  return <span>{value}</span>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with Delete Operation (JavaScript)\nDESCRIPTION: Defines a React component that creates an object, attempts to delete a property based on the `props.value`, and returns the result of the delete operation (which will be a boolean). Assumes `makeObject()` is a globally available function that returns an object.  Note that deleting a non-existent property results in `true`.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-computed-delete.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// @debug\nfunction Component(props) {\n  const x = makeObject();\n  const y = delete x[props.value];\n  return y;\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component Definition\nDESCRIPTION: This code represents the transformed React component function after compilation. It utilizes `react/compiler-runtime` for optimization. It introduces memoization logic using the `_c` function to store and reuse previous calculations, avoiding redundant operations when the input `a` remains the same. The component now only re-computes the variable `z` if the input `a` has changed, otherwise it reuses the stored value from the `$`` cache.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-mutate-2.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction component(a, b) {\n  const $ = _c(2);\n  let z;\n  if ($[0] !== a) {\n    z = { a };\n    const x = function () {\n      z.a = 2;\n    };\n\n    x();\n    $[0] = a;\n    $[1] = z;\n  } else {\n    z = $[1];\n  }\n  return z;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: [{ a: \"val1\", b: \"val2\" }],\n  isComponent: false,\n};\n\n```\n\n----------------------------------------\n\nTITLE: Optimizing React Component Rendering with Compiler in JavaScript\nDESCRIPTION: This snippet offers an optimized version of a React component using 'react/compiler-runtime'. By caching inputs and outputs, it minimizes re-renders when properties remain unchanged. This approach showcases advanced performance techniques within React, leveraging internal compiler utilities.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-runs-inference.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { Stringify } from \"shared-runtime\";\nfunction Component(t0) {\n  const $ = _c(6);\n  const { a } = t0;\n  let t1;\n  if ($[0] !== a) {\n    t1 = { a };\n    $[0] = a;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  const z = t1;\n  let t2;\n  if ($[2] !== z) {\n    t2 = () => <Stringify>{z}</Stringify>;\n    $[2] = z;\n    $[3] = t2;\n  } else {\n    t2 = $[3];\n  }\n  const p = t2;\n  let t3;\n  if ($[4] !== p) {\n    t3 = p();\n    $[4] = p;\n    $[5] = t3;\n  } else {\n    t3 = $[5];\n  }\n  return t3;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ a: 1 }],\n  sequentialRenders: [{ a: 1 }, { a: 1 }, { a: 2 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Using Memoization with Function Component in React\nDESCRIPTION: This code snippet implements a more complex version of the 'Foo' component that incorporates memoization logic to store and retrieve a closure. It checks if a cache sentinel is present and conditionally assigns the function 'getX' to maintain local state. This demonstrates optimization in React by avoiding unnecessary re-computations, although initialization of 'x' must be handled correctly to avoid access issues. The snippet showcases the relationship between state management and performance in functional components.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-invalid-tdz-let.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Foo() {\n  const $ = _c(2);\n  let getX;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    getX = () => x;\n    console.log(getX());\n\n    let x;\n    x = 4;\n    x = x + 5;\n    $[0] = getX;\n  } else {\n    getX = $[0];\n  }\n  x;\n  let t0;\n  if ($[1] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = <Stringify getX={getX} shouldInvokeFns={true} />;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Using Stringify Component in React - JavaScript\nDESCRIPTION: This snippet demonstrates the use of the Stringify component to render a React component based on the evaluation of a nested property. It depends on the shared-runtime and expects an object parameter with nested properties to evaluate. Expected inputs are objects with deeply nested structures.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/infer-function-uncond-access-hoisted.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n\n// @enablePropagateDepsInHIR\n\nimport {Stringify} from 'shared-runtime';\n\nfunction useFoo({a}) {\n  return <Stringify fn={() => a.b.c} shouldInvokeFns={true} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{a: null}],\n  sequentialRenders: [{a: null}, {a: {b: {c: 4}}}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Compiler-Optimized Component Implementation in JavaScript\nDESCRIPTION: The transformed version of the component function using React compiler runtime. It implements memoization through the _c helper function to avoid recreating objects when inputs haven't changed.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-nested-member-call.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction component(a) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== a) {\n    t0 = { a: { a } };\n    $[0] = a;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const z = t0;\n  return z;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Component with Dynamic Key Extraction in JavaScript\nDESCRIPTION: This component function takes props as an argument and extracts a value from the 'val' property using a dynamic key defined in 'key'. It directly returns the extracted value. The intended use is for situations where you need to dynamically access properties based on input keys in a React application.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error._todo.computed-lval-in-destructure.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const computedKey = props.key;\n  const {[computedKey]: x} = props.val;\n\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with Fragment and Memoization (Input)\nDESCRIPTION: This snippet shows the original implementation of a React component using fragments and manual memoization. It includes a custom hook 'useFragment' and demonstrates destructuring with default values.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-mixed-scope-and-local-variables-with-default.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {Stringify, graphql} from 'shared-runtime';\n\nfunction useFragment(_arg1, _arg2) {\n  'use no forget';\n  return {\n    urls: ['url1', 'url2', 'url3'],\n    comments: ['comment1'],\n  };\n}\n\nfunction Component(props) {\n  const post = useFragment(\n    graphql`\n      fragment F on T {\n        id\n      }\n    `,\n    props.post\n  );\n  const allUrls = [];\n  // `media` and `urls` are exported from the scope that will wrap this code,\n  // but `comments` is not (it doesn't need to be memoized, bc the callback\n  // only checks `comments.length`)\n  // because of the scope, the let declaration for media and urls are lifted\n  // out of the scope, and the destructure statement ends up turning into\n  // a reassignment, instead of a const declaration. this means we try to\n  // reassign `comments` when there's no declaration for it.\n  const {media = null, comments = [], urls = []} = post;\n  const onClick = e => {\n    if (!comments.length) {\n      return;\n    }\n    console.log(comments.length);\n  };\n  allUrls.push(...urls);\n  return <Stringify media={media} allUrls={allUrls} onClick={onClick} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{post: {}}],\n  isComponent: true,\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Conditional Reference Hook in React\nDESCRIPTION: A React hook that uses conditional ref selection and attempts to create a memoized callback with potential optimization challenges\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.preserve-use-memo-ref-missing-reactive.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees\nimport {useCallback, useRef} from 'react';\n\nfunction useFoo({cond}) {\n  const ref1 = useRef<undefined | (() => undefined)>();\n  const ref2 = useRef<undefined | (() => undefined)>();\n  const ref = cond ? ref1 : ref2;\n\n  return useCallback(() => {\n    if (ref != null) {\n      ref.current();\n    }\n  }, []);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Memoization\nDESCRIPTION: Transformed component with React compiler runtime optimization. Implements memoization using Symbol.for() sentinel and conditional caching logic.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-test-polymorphic.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction component() {\n  const $ = _c(1);\n  const p = makePrimitive();\n  let x;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const o = {};\n\n    x = {};\n\n    x.t = p;\n\n    x.t = o;\n    $[0] = x;\n  } else {\n    x = $[0];\n  }\n  const y = x.t;\n  return y;\n}\n```\n\n----------------------------------------\n\nTITLE: Optimizing Component Definition with react/compiler-runtime in JavaScript\nDESCRIPTION: This snippet enhances a component definition by utilizing react/compiler-runtime for memoization or caching. It checks for updates to the input parameter and decides whether to reuse a cached function or define a new one. The export is structured the same as in the simpler implementation, enabling fixture testing.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/function-declaration-simple.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction component(a) {\n  const $ = _c(3);\n  let t;\n  if ($[0] !== a) {\n    t = { a };\n    let t0;\n    if ($[2] === Symbol.for(\"react.memo_cache_sentinel\")) {\n      t0 = function x(p) {\n        p.foo();\n      };\n      $[2] = t0;\n    } else {\n      t0 = $[2];\n    }\n    const x = t0;\n\n    x(t);\n    $[0] = a;\n    $[1] = t;\n  } else {\n    t = $[1];\n  }\n  return t;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a Function and Exporting in JavaScript\nDESCRIPTION: This snippet defines a function 'foo' that accepts two parameters 'a' and 'b', initializes two empty arrays, and adds the parameters to those arrays. It also exports a constant 'FIXTURE_ENTRYPOINT' which contains a reference to the function and additional metadata for its use in a React component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/overlapping-scopes-shadowed.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(a, b) {\\n  let x = [];\\n  let y = [];\\n  y.push(b);\\n  x.push(a);\\n}\\n\\nexport const FIXTURE_ENTRYPOINT = {\\n  fn: foo,\\n  params: ['TodoAdd'],\\n  isComponent: 'TodoAdd',\\n};\\n\n```\n\n----------------------------------------\n\nTITLE: React Compiler Error Logs\nDESCRIPTION: The logs produced by React's validation system that identify the errors in the component. It shows specific compiler errors about components being created during render, which will cause state reset issues.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/static-components/invalid-dynamically-constructed-component-function.expect.md#2025-04-21_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\"kind\":\"CompileError\",\"detail\":{\"options\":{\"reason\":\"Components created during render will reset their state each time they are created. Declare components outside of render. \",\"description\":null,\"severity\":\"InvalidReact\",\"suggestions\":null,\"loc\":{\"start\":{\"line\":6,\"column\":10,\"index\":122},\"end\":{\"line\":6,\"column\":19,\"index\":131},\"filename\":\"invalid-dynamically-constructed-component-function.ts\"}}}},\"fnLoc\":null}\n{\"kind\":\"CompileError\",\"detail\":{\"options\":{\"reason\":\"The component may be created during render\",\"description\":null,\"severity\":\"InvalidReact\",\"suggestions\":null,\"loc\":{\"start\":{\"line\":3,\"column\":2,\"index\":65},\"end\":{\"line\":5,\"column\":3,\"index\":111},\"filename\":\"invalid-dynamically-constructed-component-function.ts\"}}}},\"fnLoc\":null}\n{\"kind\":\"CompileSuccess\",\"fnLoc\":{\"start\":{\"line\":2,\"column\":0,\"index\":37},\"end\":{\"line\":7,\"column\":1,\"index\":137},\"filename\":\"invalid-dynamically-constructed-component-function.ts\"},\"fnName\":\"Example\",\"memoSlots\":1,\"memoBlocks\":1,\"memoValues\":1,\"prunedMemoBlocks\":0,\"prunedMemoValues\":0}\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Context Selectors\nDESCRIPTION: Compiled version of the component that uses context selectors for performance optimization. Implements memoization to prevent unnecessary re-renders and includes selector functions for individual context values.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/lower-context-acess-multiple.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useContext_withSelector } from \"react-compiler-runtime\";\nimport { c as _c } from \"react/compiler-runtime\"; // @lowerContextAccess\nfunction App() {\n  const $ = _c(3);\n  const { foo } = useContext_withSelector(MyContext, _temp);\n  const { bar } = useContext_withSelector(MyContext, _temp2);\n  let t0;\n  if ($[0] !== bar || $[1] !== foo) {\n    t0 = <Bar foo={foo} bar={bar} />;\n    $[0] = bar;\n    $[1] = foo;\n    $[2] = t0;\n  } else {\n    t0 = $[2];\n  }\n  return t0;\n}\nfunction _temp2(t0) {\n  return [t0.bar];\n}\nfunction _temp(t0) {\n  return [t0.foo];\n}\n```\n\n----------------------------------------\n\nTITLE: Memoized React Component using Compiler Runtime\nDESCRIPTION: This snippet shows the compiled version of the React component, leveraging `react/compiler-runtime` for memoization.  It caches values associated with props `a`, `b`, and `cond` to avoid re-computation when the props haven't changed. `Symbol.for(\"react.early_return_sentinel\")` is used to signal that the component returned early and needs to be re-evaluated during the next render if props have changed.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/early-return-nested-early-return-within-reactive-scope.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enablePropagateDepsInHIR\nfunction Component(props) {\n  const $ = _c(7);\n  let t0;\n  if ($[0] !== props.a || $[1] !== props.b || $[2] !== props.cond) {\n    t0 = Symbol.for(\"react.early_return_sentinel\");\n    bb0: {\n      const x = [];\n      if (props.cond) {\n        x.push(props.a);\n        if (props.b) {\n          let t1;\n          if ($[4] !== props.b) {\n            t1 = [props.b];\n            $[4] = props.b;\n            $[5] = t1;\n          } else {\n            t1 = $[5];\n          }\n          const y = t1;\n          x.push(y);\n          t0 = x;\n          break bb0;\n        }\n\n        t0 = x;\n        break bb0;\n      } else {\n        let t1;\n        if ($[6] === Symbol.for(\"react.memo_cache_sentinel\")) {\n          t1 = foo();\n          $[6] = t1;\n        } else {\n          t1 = $[6];\n        }\n        t0 = t1;\n        break bb0;\n      }\n    }\n    $[0] = props.a;\n    $[1] = props.b;\n    $[2] = props.cond;\n    $[3] = t0;\n  } else {\n    t0 = $[3];\n  }\n  if (t0 !== Symbol.for(\"react.early_return_sentinel\")) {\n    return t0;\n  }\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ cond: true, a: 42, b: 3.14 }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Component in React (JavaScript)\nDESCRIPTION: This snippet defines a simple functional component that calls a method, 'foo.bar', with a spread of props. It returns the result of that method call as the component's output.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/property-call-spread.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const x = foo.bar(...props.a, null, ...props.b);\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled FBT React Component with Compiler Runtime\nDESCRIPTION: This snippet shows the compiled version of the FBT React component. It uses React's compiler runtime for optimization and transforms the FBT syntax into efficient JavaScript code.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbtparam-text-must-use-expression-container.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport fbt from \"fbt\";\n\nfunction Component(props) {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = (\n      <Foo\n        value={fbt._(\"{ value}%\", [fbt._param(\"value\", \"0\")], { hk: \"10F5Cc\" })}\n      />\n    );\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Component Function - JavaScript\nDESCRIPTION: This snippet defines a component function that returns another function targeting an object's method 'foo'. It initializes 'x' as a function that takes an argument 'a' which is expected to be an object with the method 'foo'. Only the outer function is exported as part of the FIXTURE_ENTRYPOINT object.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/simple-function-1.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component() {\n  let x = function (a) {\n    a.foo();\n  };\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: The compiled version of the component that includes memoization logic using React's compiler runtime. It caches the computed value and only recalculates when the input parameter changes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/default-param-calls-global-function.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { identity } from \"shared-runtime\";\n\nfunction Component(t0) {\n  const $ = _c(2);\n  let t1;\n  if ($[0] !== t0) {\n    t1 = t0 === undefined ? identity([_temp, true, 42, \"hello\"]) : t0;\n    $[0] = t0;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  const x = t1;\n  return x;\n}\nfunction _temp() {}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: Basic React component using Stringify and identity functions. Renders two Stringify components with identity-transformed empty objects.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/renaming-jsx-tag-lowercase.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {Stringify, identity, useIdentity} from 'shared-runtime';\n\nfunction Foo({}) {\n  const x = {};\n  const y = {};\n  useIdentity(0);\n  return (\n    <>\n      <Stringify value={identity(y)} />\n      <Stringify value={identity(x)} />\n    </>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Alternative React Component Implementation - JavaScript\nDESCRIPTION: This snippet provides an alternative implementation of the 'Component', where 'x' is assigned a value in a slightly different manner using a comma operator. This variation produces the same output as the first snippet but showcases a different use of assignment and logical operations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unused-conditional.expect.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let x;\n  ((x = 1), 1) && (x = 2);\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Managing Reactive Dependencies in React with Compiler Runtime\nDESCRIPTION: This JavaScript code snippet enhances a React component using the compiler runtime's conditional dependency management. It maintains the reactivity of properties within the component by employing a caching technique, using the array '$' to store computed properties. If the property's old value differs from the new one, it updates and caches the result. This snippet depends on the 'react/compiler-runtime' import for the '_c' function which facilitates this caching mechanism. The snippet exports a fixture entry point as a testable part.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/conditional-member-expr.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enablePropagateDepsInHIR\n// To preserve the nullthrows behavior and reactive deps of this code,\n// Forget needs to add `props.a` as a dependency (since `props.a.b` is\n// a conditional dependency, i.e. gated behind control flow)\n\nfunction Component(props) {\n  const $ = _c(2);\n  let x;\n  if ($[0] !== props.a?.b) {\n    x = [];\n    x.push(props.a?.b);\n    $[0] = props.a?.b;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ a: null }],\n};\n```\n\n----------------------------------------\n\nTITLE: Memoizing React Component with Optional Data Access\nDESCRIPTION: A React functional component that uses useMemo to memoize data extraction with safe optional chaining, handling potential undefined nested properties\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-optional-member-expression-as-memo-dep-non-optional-in-body.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees\nfunction Component(props) {\n  const data = useMemo(() => {\n    // actual code is non-optional\n    return props.items.edges.nodes ?? [];\n    // deps are optional\n  }, [props.items?.edges?.nodes]);\n  return <Foo data={data} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled JavaScript code of useFoo function\nDESCRIPTION: This is the compiled JavaScript code for the `useFoo` function using the React compiler.  It showcases how the compiler optimizes and transforms the original code, including memoization and caching strategies. The `_c` function is likely a runtime helper for memoization. The compiled code utilizes a mutable array `$` to store cached values based on the inputs `a` and `b`.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/bug-aliased-capture-aliased-mutate.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { arrayPush, setPropertyByKey, Stringify } from \"shared-runtime\";\n\nfunction useFoo(t0) {\n  const $ = _c(5);\n  const { a, b } = t0;\n  let t1;\n  if ($[0] !== a || $[1] !== b) {\n    const x = [];\n    const y = { value: a };\n\n    arrayPush(x, y);\n    const y_alias = y;\n    let t2;\n    if ($[3] !== y_alias.value) {\n      t2 = () => y_alias.value;\n      $[3] = y_alias.value;\n      $[4] = t2;\n    } else {\n      t2 = $[4];\n    }\n    const cb = t2;\n    setPropertyByKey(x[0], \"value\", b);\n    t1 = <Stringify cb={cb} shouldInvokeFns={true} />;\n    $[0] = a;\n    $[1] = b;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ a: 2, b: 10 }],\n  sequentialRenders: [\n    { a: 2, b: 10 },\n    { a: 2, b: 11 },\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Compiler Runtime\nDESCRIPTION: This code presents the compiled version of the React component using the React compiler runtime. It leverages the '_c' function from 'react/compiler-runtime' to optimize the component's execution. The compiler runtime uses an array ($) to memoize values, improving performance by avoiding unnecessary re-computations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-1.expect.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction component(a) {\n  const $ = _c(4);\n  let t0;\n  if ($[0] !== a) {\n    t0 = { a };\n    $[0] = a;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const z = t0;\n  let t1;\n  if ($[2] !== z) {\n    t1 = function () {\n      console.log(z);\n    };\n    $[2] = z;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  const x = t1;\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: React Component Validation Code\nDESCRIPTION: This code snippet defines a React component similar to the previous one, but focuses on function calls without assigning them to variables.  It validates that calls like Boolean(true), Number(3), String(\"foo\"), React$useState(0), React.useState(1), and THIS_IS_A_CONSTANT() are correctly invoked within the component function.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capitalized-function-allowlist.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// @validateNoCapitalizedCalls @hookPattern:\".*\\b(use[^$]+)$\"\nimport * as React from \"react\";\nconst React$useState = React.useState;\nconst THIS_IS_A_CONSTANT = () => {};\nfunction Component() {\n  Boolean(true);\n  Number(3);\n  String(\"foo\");\n  React$useState(0);\n  React.useState(1);\n  THIS_IS_A_CONSTANT();\n  return 3;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  isComponent: true,\n};\n\n```\n\n----------------------------------------\n\nTITLE: React useMemo Error Message\nDESCRIPTION: Error message indicating an invalid usage of useMemo hook. The error suggests that the first argument must be an inline function expression, which is not present in the current implementation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.validate-useMemo-named-function.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nInvalidReact: Expected the first argument to be an inline function expression (9:9)\n```\n\n----------------------------------------\n\nTITLE: Utilizing Compiler Runtime for Array Mutations in JavaScript\nDESCRIPTION: This snippet uses the react/compiler-runtime library to illustrate a similar mutation process as in the first snippet, demonstrating the usage of _c for memoization. The function Foo is used to handle input arguments and manage array mutations, showcasing condition-based checks to decide when mutations should occur.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-concat-should-capture.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { mutate } from \"shared-runtime\";\n\n/**\n * Fixture showing why `concat` needs to capture both the callee and rest args.\n * Here, observe that arr1's values are captured into arr2.\n *  - Later mutations of arr2 may write to values within arr1.\n *  - Observe that it's technically valid to separately memoize the array arr1\n *    itself.\n */\nfunction Foo(t0) {\n  const $ = _c(2);\n  const { inputNum } = t0;\n  let arr2;\n  if ($[0] !== inputNum) {\n    const arr1 = [{ a: 1 }, {}];\n    arr2 = arr1.concat([1, inputNum]);\n    mutate(arr2[0]);\n    $[0] = inputNum;\n    $[1] = arr2;\n  } else {\n    arr2 = $[1];\n  }\n  return arr2;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{ inputNum: 2 }],\n  sequentialRenders: [{ inputNum: 2 }, { inputNum: 3 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing useFoo Function with Shallow Copy and Conditional Logic in JavaScript\nDESCRIPTION: This snippet defines the useFoo function that demonstrates scope management and conditional logic. It uses shallowCopy for input, creates a condition, and returns either a constant object or the result of a mutation based on the condition.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/mutate-outer-scope-within-value-block.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {CONST_TRUE, identity, shallowCopy} from 'shared-runtime';\n\nfunction mutate(_: unknown) {}\n\n/**\n * There are three values with their own scopes in this fixture.\n * - arr, whose mutable range extends to the `mutate(...)` call\n * - cond, which has a mutable range of exactly 1 (e.g. created but not\n *   mutated)\n * - { val: CONST_TRUE }, which is also not mutated after creation. However,\n *   its scope range becomes extended to the value block.\n *\n * After AlignScopesToBlockScopes, our scopes look roughly like this\n * ```js\n *  [1] arr = shallowCopy()            @0\n *  [2] cond = identity()        <- @1 |\n *  [3] $0 = Ternary test=cond     @2 |\n *  [4]        {val : CONST_TRUE}  |   |\n *  [5]        mutate(arr)         |   |\n *  [6] return $0                     \n * ```\n *\n * Observe that instruction 5 mutates scope 0, which means that scopes 0 and 2\n * should be merged.\n */\nfunction useFoo({input}) {\n  const arr = shallowCopy(input);\n\n  const cond = identity(false);\n  return cond ? {val: CONST_TRUE} : mutate(arr);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{input: 3}],\n};\n```\n\n----------------------------------------\n\nTITLE: Inferring Compilation Mode in React Components\nDESCRIPTION: This snippet demonstrates the usage of a function with a 'use' prefix inside an unnamed function argument, explaining that it is not treated as a hook. There are no prerequisites beyond basic JavaScript and React knowledge. It accepts a function with parameters 'foo' and 'bar', calls 'useNotAHook(bar)' if 'foo' is truthy, and does not return any output. The snippet requires no special dependencies.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-fe6042f7628b.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @compilationMode(infer)\\n// This is valid because \\\"use\\\"-prefixed functions called in\\n// unnamed function arguments are not assumed to be hooks.\\nunknownFunction(function (foo, bar) {\\n  if (foo) {\\n    useNotAHook(bar);\\n  }\\n});\n```\n\n----------------------------------------\n\nTITLE: Conditional Rendering with Memoization in React\nDESCRIPTION: This JavaScript snippet extends the use of memoization in a React component by importing compiler-runtime for internal React operations. It memoizes a functional component and conditionally updates a button element when props change, utilizing an array to store the props and element. Dependencies include React and react/compiler-runtime.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-eacfcaa6ef89.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // Valid because hooks can be used in anonymous function arguments to\n// memo.\nconst MemoizedFunction = memo(function (props) {\n  const $ = _c(2);\n  useHook();\n  let t0;\n  if ($[0] !== props) {\n    t0 = <button {...props} />;\n    $[0] = props;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n});\n```\n\n----------------------------------------\n\nTITLE: Defining useFoo Function with Shared Runtime Integration\nDESCRIPTION: The code snippet imports 'arrayPush' from 'shared-runtime' and defines a function 'useFoo' that processes an object with checks on boolean conditions to produce an output array of modified input. It assumes that 'arrayPush' is a side-effect driven utility affecting state, requiring 'input' objects with nested properties.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-unpoisoned/throw-before-scope-starts.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {arrayPush} from 'shared-runtime';\n\nfunction useFoo({input, cond}) {\n  if (cond) {\n    throw new Error('throw with error!');\n  }\n\n  // unconditional\n  const x = [];\n  arrayPush(x, input.a.b);\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{input: {a: {b: 2}}, cond: false}],\n  sequentialRenders: [\n    {input: null, cond: true},\n    {input: {a: {b: 2}}, cond: false},\n    {input: null, cond: true},\n    // preserve nullthrows\n    {input: {}, cond: false},\n    {input: {a: {b: null}}, cond: false},\n    {input: {a: null}, cond: false},\n    {input: {a: {b: 3}}, cond: false},\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Using Fragment Hooks in React\nDESCRIPTION: This code demonstrates the use of the useFragment hook to read fragment data within a React functional component. It shows how data is conditionally assigned based on a prop, but also reveals an important limitation regarding the consistent order of hook calls.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-conditional-call-aliased-hook-import.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useFragment as readFragment} from 'shared-runtime';\n\nfunction Component(props) {\n  let data;\n  if (props.cond) {\n    data = readFragment();\n  }\n  return data;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation (JavaScript)\nDESCRIPTION: This snippet shows the original implementation of the 'useFoo' component before compilation. It defines a function that returns a 'Stringify' component with a nested object containing a function accessing nested properties.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/infer-object-method-uncond-access.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// @enablePropagateDepsInHIR\n\nimport {identity, Stringify} from 'shared-runtime';\n\nfunction useFoo({a}) {\n  const x = {\n    fn() {\n      return identity(a.b.c);\n    },\n  };\n  return <Stringify x={x} shouldInvokeFns={true} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{a: null}],\n  sequentialRenders: [{a: null}, {a: {b: {c: 4}}}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a Component Function - JavaScript\nDESCRIPTION: This snippet defines a simple React component function that contains another function 'x' which calls a method 'foo' on the passed argument 'a'. Although the inner function 'x' is redefined as an empty function, it is still returned as the final output of the enclosing function. No external dependencies are required for this snippet.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/function-declaration-redeclare.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component() {\n  function x(a) {\n    a.foo();\n  }\n  function x() {}\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled FBT Output Code\nDESCRIPTION: Compiled version of the FBT code showing how the pluralization and parameter interpolation are transformed. Includes memoization logic and the final string template structure.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/repro-macro-property-not-handled.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport fbt from \"fbt\";\nimport { useIdentity } from \"shared-runtime\";\n\n/**\n * MemoizeFbtAndMacroOperandsInSameScope should also track PropertyLoads (e.g. fbt.plural).\n * This doesn't seem to be an issue for fbt, but affects other internal macros invoked as\n * `importSpecifier.funcName` (see https://fburl.com/code/72icxwmn)\n */\nfunction useFoo(t0) {\n  const $ = _c(2);\n  const { items } = t0;\n  let t1;\n  if ($[0] !== items) {\n    t1 = [...items];\n    $[0] = items;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return fbt._(\n    {\n      \"*\": \"There are {number of items} items\",\n      \"_1\": \"There is {number of items} items\",\n    },\n    [\n      fbt._plural(useIdentity(t1).length),\n      fbt._param(\n        \"number of items\",\n\n        items.length,\n      ),\n    ],\n    { hk: \"xsa7w\" },\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ items: [2, 3] }],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimizing React Component Rendering with Caching in JavaScript\nDESCRIPTION: This snippet enhances a React component by incorporating a caching mechanism using an array to track changes in props and reuse previously rendered outputs. It demonstrates an advanced rendering optimization technique within React by comparing current props with cached values, thereby reducing unnecessary re-rendering and improving performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/switch.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enablePropagateDepsInHIR\nfunction Component(props) {\n  const $ = _c(8);\n  let t0;\n  let y;\n  if ($[0] !== props.p0 || $[1] !== props.p2 || $[2] !== props.p3) {\n    const x = [];\n    switch (props.p0) {\n      case true: {\n        x.push(props.p2);\n        x.push(props.p3);\n      }\n      case false: {\n        y = x;\n      }\n    }\n\n    t0 = <Component data={x} />;\n    $[0] = props.p0;\n    $[1] = props.p2;\n    $[2] = props.p3;\n    $[3] = t0;\n    $[4] = y;\n  } else {\n    t0 = $[3];\n    y = $[4];\n  }\n  const child = t0;\n  y.push(props.p4);\n  let t1;\n  if ($[5] !== child || $[6] !== y) {\n    t1 = <Component data={y}>{child}</Component>;\n    $[5] = child;\n    $[6] = y;\n    $[7] = t1;\n  } else {\n    t1 = $[7];\n  }\n  return t1;\n}\n\n```\n\n----------------------------------------\n\nTITLE: React Component with Mutable Object and Function Expression\nDESCRIPTION: This code snippet defines a React component that demonstrates the complexities of managing dependencies when dealing with mutable objects and function expressions.  The `getId` function expression captures the value of `obj.id` which is later mutated. Correct dependency tracking is critical to ensure `getId` returns the updated value. The component uses utilities from 'shared-runtime' like `shallowCopy`, `identity`, `mutate`, and `setPropertyByKey`.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/aliased-nested-scope-fn-expr.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableTransitivelyFreezeFunctionExpressions:false\nimport {\n  Stringify,\n  mutate,\n  identity,\n  setPropertyByKey,\n  shallowCopy,\n} from 'shared-runtime';\n/**\n * Function expression version of `aliased-nested-scope-truncated-dep`.\n * \n * In this fixture, the output would be invalid if propagateScopeDeps did not\n * avoid adding MemberExpression dependencies which would other evaluate during\n * the mutable ranges of their base objects.\n * This is different from `aliased-nested-scope-truncated-dep` which *does*\n * produce correct output regardless of MemberExpression dependency truncation.\n * \n * Note while other expressions evaluate inline, function expressions *always*\n * represent deferred evaluation. This means that\n * (1) it's always safe to reorder function expression creation until its\n *     earliest potential invocation\n * (2) it's invalid to eagerly evaluate function expression dependencies during\n *     their respective mutable ranges.\n */\n\nfunction Component({prop}) {\n  let obj = shallowCopy(prop);\n\n  const aliasedObj = identity(obj);\n\n  // When `obj` is mutable (either directly or through aliases), taking a\n  // dependency on `obj.id` is invalid as it may change before getId() is invoked\n  const getId = () => obj.id;\n\n  mutate(aliasedObj);\n  setPropertyByKey(aliasedObj, 'id', prop.id + 1);\n\n  // Calling getId() should return prop.id + 1, not the prev\n  return <Stringify getId={getId} shouldInvokeFns={true} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{prop: {id: 1}}],\n  sequentialRenders: [{prop: {id: 1}}, {prop: {id: 1}}, {prop: {id: 2}}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining Component and Exporting Fixture Entry Point - JavaScript\nDESCRIPTION: This snippet defines a React component named 'Component' that retrieves a number from a shared runtime module and returns it. It also exports a constant 'FIXTURE_ENTRYPOINT' that holds the component along with parameters for testing or demonstration purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-types-through-type-cast.flow.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { getNumber } from \"shared-runtime\";\n\nfunction Component(props) {\n  const x = getNumber();\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n  isComponent: false,\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Component Definition with Conditional Logic (Input)\nDESCRIPTION: This code snippet defines a functional React component named `Component` that takes `props` as input. It initializes a local variable `x` and assigns it a value based on the conditional `props.cond`. If `props.cond` is truthy, `x` is set to 1; otherwise, it's set to 2. The component then returns the value of `x`.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unused-logical.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let x = 0;\n  props.cond ? (x = 1) : (x = 2);\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Components with Memoization using React Compiler Runtime\nDESCRIPTION: This snippet shows the compiled version of the four React components using React's compiler runtime. It demonstrates how the components are optimized for performance with memoization techniques, including the use of a cache array and early return checks.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/conditional-early-return.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; /**\n * props.b does *not* influence `a`\n */\nfunction ComponentA(props) {\n  const $ = _c(5);\n  let a_DEBUG;\n  let t0;\n  if ($[0] !== props.a || $[1] !== props.b || $[2] !== props.d) {\n    t0 = Symbol.for(\"react.early_return_sentinel\");\n    bb0: {\n      a_DEBUG = [];\n      a_DEBUG.push(props.a);\n      if (props.b) {\n        t0 = null;\n        break bb0;\n      }\n\n      a_DEBUG.push(props.d);\n    }\n    $[0] = props.a;\n    $[1] = props.b;\n    $[2] = props.d;\n    $[3] = a_DEBUG;\n    $[4] = t0;\n  } else {\n    a_DEBUG = $[3];\n    t0 = $[4];\n  }\n  if (t0 !== Symbol.for(\"react.early_return_sentinel\")) {\n    return t0;\n  }\n  return a_DEBUG;\n}\n\n/**\n * props.b *does* influence `a`\n */\nfunction ComponentB(props) {\n  const $ = _c(5);\n  let a;\n  if (\n    $[0] !== props.a ||\n    $[1] !== props.b ||\n    $[2] !== props.c ||\n    $[3] !== props.d\n  ) {\n    a = [];\n    a.push(props.a);\n    if (props.b) {\n      a.push(props.c);\n    }\n\n    a.push(props.d);\n    $[0] = props.a;\n    $[1] = props.b;\n    $[2] = props.c;\n    $[3] = props.d;\n    $[4] = a;\n  } else {\n    a = $[4];\n  }\n  return a;\n}\n\n/**\n * props.b *does* influence `a`, but only in a way that is never observable\n */\nfunction ComponentC(props) {\n  const $ = _c(6);\n  let a;\n  let t0;\n  if (\n    $[0] !== props.a ||\n    $[1] !== props.b ||\n    $[2] !== props.c ||\n    $[3] !== props.d\n  ) {\n    t0 = Symbol.for(\"react.early_return_sentinel\");\n    bb0: {\n      a = [];\n      a.push(props.a);\n      if (props.b) {\n        a.push(props.c);\n        t0 = null;\n        break bb0;\n      }\n\n      a.push(props.d);\n    }\n    $[0] = props.a;\n    $[1] = props.b;\n    $[2] = props.c;\n    $[3] = props.d;\n    $[4] = a;\n    $[5] = t0;\n  } else {\n    a = $[4];\n    t0 = $[5];\n  }\n  if (t0 !== Symbol.for(\"react.early_return_sentinel\")) {\n    return t0;\n  }\n  return a;\n}\n\n/**\n * props.b *does* influence `a`\n */\nfunction ComponentD(props) {\n  const $ = _c(6);\n  let a;\n  let t0;\n  if (\n    $[0] !== props.a ||\n    $[1] !== props.b ||\n    $[2] !== props.c ||\n    $[3] !== props.d\n  ) {\n    t0 = Symbol.for(\"react.early_return_sentinel\");\n    bb0: {\n      a = [];\n      a.push(props.a);\n      if (props.b) {\n        a.push(props.c);\n        t0 = a;\n        break bb0;\n      }\n\n      a.push(props.d);\n    }\n    $[0] = props.a;\n    $[1] = props.b;\n    $[2] = props.c;\n    $[3] = props.d;\n    $[4] = a;\n    $[5] = t0;\n  } else {\n    a = $[4];\n    t0 = $[5];\n  }\n  if (t0 !== Symbol.for(\"react.early_return_sentinel\")) {\n    return t0;\n  }\n  return a;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: ComponentA,\n  params: [{ a: 1, b: false, d: 3 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Input React.forwardRef Component Definition\nDESCRIPTION: Simple React component using forwardRef that renders a div element. Uses compilation mode inference.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-function-forwardRef.expect.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @compilationMode(infer)\nReact.forwardRef(props => {\n  return <div />;\n});\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Memoization\nDESCRIPTION: This snippet shows an optimized version of the component function 'f' using React's compiler runtime. It implements memoization for the 'x' object and the rendered div element to improve performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/lambda-mutated-ref-non-reactive.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction f(a) {\n  const $ = _c(2);\n  let x;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    x = {};\n    $[0] = x;\n  } else {\n    x = $[0];\n  }\n  let t0;\n  if ($[1] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = <div x={x} />;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: f,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: React Component Input Implementation\nDESCRIPTION: Original React component implementation showing key mutation pattern. The component creates a mutable key object used in a div element's key prop, with mutations happening before and after element creation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/mutation-during-jsx-construction.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {identity, mutate, mutateAndReturnNewValue} from 'shared-runtime';\n\nfunction Component(props) {\n  const key = {};\n  // Key is modified by the function, but key itself is not frozen\n  const element = <div key={mutateAndReturnNewValue(key)}>{props.value}</div>;\n  // Key is later mutated here: this mutation must be grouped with the\n  // jsx construction above\n  mutate(key);\n  return element;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: 42}],\n};\n```\n\n----------------------------------------\n\nTITLE: Conditional Subpath Dependency Test Case in React\nDESCRIPTION: This JavaScript code defines a test case with a function `useConditionalSubpath2` that accesses a property `props.a` conditionally and then unconditionally accesses a subproperty `props.a.b`. The purpose is to demonstrate how the React compiler can optimize the dependency tracking to only depend on `props.a` rather than both `props.a` and `props.a.b`. The `FIXTURE_ENTRYPOINT` is used for testing the function.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/subpath-order2.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// When a conditional dependency `props.a` is a subpath of an unconditional\n// dependency `props.a.b`, we can access `props.a` while preserving program\n// semantics (with respect to nullthrows).\n// deps: {`props.a`, `props.a.b`} can further reduce to just `props.a`\n\nimport {identity} from 'shared-runtime';\n\n// ordering of accesses should not matter\nfunction useConditionalSubpath2(props, other) {\n  const x = {};\n  if (identity(other)) {\n    x.a = props.a;\n  }\n  x.b = props.a.b;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useConditionalSubpath2,\n  params: [{a: {b: 3}}, false],\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Component with Global State - Compiled Output\nDESCRIPTION: The compiled version of the React component showing the internal implementation details after compilation. It includes compiler-specific optimizations, memoization logic, and the React runtime utilities for handling effects and state management.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-mutate-global-in-effect-fixpoint.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useEffect, useState } from \"react\";\n\nlet someGlobal = { value: null };\n\nfunction Component() {\n  const $ = _c(5);\n  const [state, setState] = useState(someGlobal);\n\n  let x = someGlobal;\n  while (x == null) {\n    x = someGlobal;\n  }\n\n  const y = x;\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = () => {\n      y.value = \"hello\";\n    };\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  useEffect(t0);\n  let t1;\n  let t2;\n  if ($[1] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = () => {\n      setState(someGlobal.value);\n    };\n    t2 = [someGlobal];\n    $[1] = t1;\n    $[2] = t2;\n  } else {\n    t1 = $[1];\n    t2 = $[2];\n  }\n  useEffect(t1, t2);\n\n  const t3 = String(state);\n  let t4;\n  if ($[3] !== t3) {\n    t4 = <div>{t3}</div>;\n    $[3] = t3;\n    $[4] = t4;\n  } else {\n    t4 = $[4];\n  }\n  return t4;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Mapping Error Codes with codes.json\nDESCRIPTION: JSON file containing error code mappings used by Babel plugin and error decoder page. File is append-only and maintains a static mapping of error IDs to messages.\nSOURCE: https://github.com/facebook/react/blob/main/scripts/error-codes/README.md#2025-04-21_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"error_codes\": [\n    {\n      \"id\": \"error_unique_identifier\",\n      \"message\": \"Original error message\"\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid React Component with setState During Render\nDESCRIPTION: This example demonstrates a React component that incorrectly calls setState (via setX) during render. The component defines a call chain (baz calls bar, which calls foo, which calls setX) and then invokes this chain during render, triggering an infinite loop error.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.unconditional-set-state-nested-function-expressions.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validateNoSetStateInRender\nfunction Component(props) {\n  const [x, setX] = useState(0);\n\n  const foo = () => {\n    setX(1);\n  };\n\n  const bar = () => {\n    foo();\n  };\n\n  const baz = () => {\n    bar();\n  };\n  baz();\n\n  return [x];\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Hook Usage in Nested Functions - React Component\nDESCRIPTION: Example of incorrect React hook implementation where useFoo() hook is called within deeply nested function expressions, violating the Rules of Hooks. Hooks must be called at the top level of a function component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-hook-in-nested-function-expression-object-expression.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @compilationMode(infer)\nfunction Component() {\n  'use memo';\n  const f = () => {\n    const x = {\n      outer() {\n        const g = () => {\n          const y = {\n            inner() {\n              return useFoo();\n            },\n          };\n          return y;\n        };\n      },\n    };\n    return x;\n  };\n}\n```\n\nLANGUAGE: text\nCODE:\n```\n   8 |           const y = {\n   9 |             inner() {\n> 10 |               return useFoo();\n     |                      ^^^^^^ InvalidReact: Hooks must be called at the top level in the body of a function component or custom hook, and may not be called within function expressions. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning). Cannot call Custom within a function component (10:10)\n  11 |             },\n  12 |           };\n  13 |           return y;\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with fbt Internationalization\nDESCRIPTION: This snippet defines a React component that uses fbt for internationalization. It handles pluralization of 'vote' based on count and inserts a parameter for the voting option.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-param-with-leading-whitespace.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport fbt from 'fbt';\nimport {identity} from 'shared-runtime';\n\nfunction Component(props) {\n  return (\n    <span>\n      <fbt desc=\"Title\">\n        <fbt:plural count={identity(props.count)} name=\"count\" showCount=\"yes\">\n          vote\n        </fbt:plural>{' '}\n        for <fbt:param name=\"option\"> {props.option}</fbt:param>\n      </fbt>\n      !\n    </span>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{count: 42, option: 'thing'}],\n  sequentialRenders: [\n    {count: 42, option: 'thing'},\n    {count: 42, option: 'thing'},\n    {count: 1, option: 'other'},\n    {count: 1, option: 'other'},\n    {count: 42, option: 'thing'},\n    {count: 1, option: 'other'},\n    {count: 42, option: 'thing'},\n    {count: 1, option: 'other'},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimizing React Component with Compiler Runtime\nDESCRIPTION: This snippet shows an optimized version of the previous function using React's compiler runtime. It implements the same destructuring logic but with improved performance and memoization techniques.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-assignment.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction foo(a, b, c) {\n  const $ = _c(5);\n  let d;\n  let g;\n  let n;\n  let o;\n  const [t0, t1] = a;\n  d = t0;\n  const [t2] = t1;\n  const { e: t3 } = t2;\n  ({ f: g } = t3);\n  const { l: t4, o: t5 } = b;\n  const { m: t6 } = t4;\n  const [t7] = t6;\n  [n] = t7;\n  o = t5;\n  let t8;\n  if ($[0] !== d || $[1] !== g || $[2] !== n || $[3] !== o) {\n    t8 = { d, g, n, o };\n    $[0] = d;\n    $[1] = g;\n    $[2] = n;\n    $[3] = o;\n    $[4] = t8;\n  } else {\n    t8 = $[4];\n  }\n  return t8;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: React InvalidReact Error Message\nDESCRIPTION: This error message highlights an attempt to access the `current` property of a ref during the render phase of a React component. According to React best practices, refs should be accessed within event handlers or effects to avoid side effects during rendering.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.ref-initialization-arbitrary.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n   6 | component C() {\n   7 |   const r = useRef(DEFAULT_VALUE);\n>  8 |   if (r.current == DEFAULT_VALUE) {\n     |       ^^^^^^^^^ InvalidReact: Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef) (8:8)\n\nInvalidReact: Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef) (9:9)\n   9 |     r.current = 1;\n  10 |   }\n  11 | }\n```\n\n----------------------------------------\n\nTITLE: Compiled JavaScript with React Compiler Runtime\nDESCRIPTION: This code snippet shows the compiled output of the previous hoisting example using React's compiler runtime. The `_c` function (aliased as `c`) from `react/compiler-runtime` is used to manage the memoization and caching of the `foo` function. It demonstrates how React handles hoisting during compilation and optimization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-simple-const-declaration.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n```javascript\nimport { c as _c } from \"react/compiler-runtime\";\nfunction hoisting() {\n  const $ = _c(1);\n  let foo;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    foo = () => bar + baz;\n\n    const bar = 3;\n    const baz = 2;\n    $[0] = foo;\n  } else {\n    foo = $[0];\n  }\n  return foo();\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: hoisting,\n  params: [],\n  isComponent: false,\n};\n\n```\n```\n\n----------------------------------------\n\nTITLE: Invalid Conditional Hook Usage in React Component\nDESCRIPTION: Example of incorrect React Hook implementation where useConditionalHook is called inside a conditional statement. This violates React's Rules of Hooks which require hooks to be called in the same order on every render.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-rules-of-hooks-2aabd222fc6a.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Expected to fail\n\n// Invalid because it's dangerous and might not warn otherwise.\n// This *must* be invalid.\nfunction ComponentWithConditionalHook() {\n  if (cond) {\n    useConditionalHook();\n  }\n}\n```\n\nLANGUAGE: plaintext\nCODE:\n```\n   5 | function ComponentWithConditionalHook() {\n   6 |   if (cond) {\n>  7 |     useConditionalHook();\n     |     ^^^^^^^^^^^^^^^^^^ InvalidReact: Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning) (7:7)\n   8 |   }\n   9 | }\n  10 |\n```\n\n----------------------------------------\n\nTITLE: React Component with Array Destructuring\nDESCRIPTION: Defines a React component `foo` that receives props and uses array destructuring to extract the first two elements into variables x and y. The function returns the sum of x and y. It also exports FIXTURE_ENTRYPOINT, which configures the component for a test environment.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unused-array-rest-element.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(props) {\n  const [x, y] = props.a;\n  return x + y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Complex Destructuring in JavaScript for React Component\nDESCRIPTION: This function demonstrates advanced destructuring patterns in JavaScript, likely used in a React component. It extracts nested values from input objects and returns a new object with selected properties.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-assignment.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(a, b, c) {\n  let d, g, n, o;\n  [\n    d,\n    [\n      {\n        e: {f: g},\n      },\n    ],\n  ] = a;\n  ({\n    l: {\n      m: [[n]],\n    },\n    o,\n  } = b);\n  return {d, g, n, o};\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Invalid React Hooks Usage in Loops\nDESCRIPTION: Demonstrates improper usage of React Hooks inside while loops and conditional statements. This code is intentionally invalid to test React's hook validation rules that require hooks to be called in a consistent order and not within loops or conditions.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-rules-of-hooks-1b9527f967f3.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Expected to fail\n\n// Invalid because it's dangerous and might not warn otherwise.\n// This *must* be invalid.\nfunction useHookInLoops() {\n  while (a) {\n    useHook1();\n    if (b) return;\n    useHook2();\n  }\n  while (c) {\n    useHook3();\n    if (d) return;\n    useHook4();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Reactive Component in React - JavaScript\nDESCRIPTION: The function 'Component' uses arrays to demonstrate how variable reactivity can be interleaved based on their mutations in a React component. Dependencies include a props object with a 'cond' property. The function initializes arrays 'a' and 'b', modifies them based on props, and introduces reactivity by grouping and controlling values. It returns 'x', showing conditional reactivity.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-from-interleaved-reactivity-while.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  // a and b are independent but their mutations are interleaved, so\n  // they get grouped in a reactive scope. this means that a becomes\n  // reactive since it will effectively re-evaluate based on a reactive\n  // input\n  const a = [];\n  const b = [];\n  b.push(props.cond);\n  a.push(null);\n\n  // Downstream consumer of a, which initially seems non-reactive except\n  // that a becomes reactive, per above\n  const c = [a];\n\n  let x;\n  while (c[0][0]) {\n    x = 1;\n  }\n  // The values assigned to `x` are non-reactive, but the value of `x`\n  // depends on the \"control\" value `c[0]` which becomes reactive via\n  // being interleaved with `b`.\n  // Therefore x should be treated as reactive too.\n  return [x];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{cond: true}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Component with FBT Internationalization - Compiled\nDESCRIPTION: Compiled output of the FBT component with optimized rendering and caching logic. Implements plural forms and parameter interpolation with proper memoization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-param-with-trailing-whitespace.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport fbt from \"fbt\";\nimport { identity } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(3);\n  let t0;\n  if ($[0] !== props.count || $[1] !== props.option) {\n    t0 = (\n      <span>\n        {fbt._(\n          { \"*\": \"{count} votes for {option}\", _1: \"1 vote for {option}\" },\n          [\n            fbt._plural(identity(props.count), \"count\"),\n            fbt._param(\n              \"option\",\n\n              props.option,\n            ),\n          ],\n          { hk: \"3Bg20a\" },\n        )}\n        !\n      </span>\n    );\n    $[0] = props.count;\n    $[1] = props.option;\n    $[2] = t0;\n  } else {\n    t0 = $[2];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ count: 42, option: \"thing\" }],\n  sequentialRenders: [\n    { count: 42, option: \"thing\" },\n    { count: 42, option: \"thing\" },\n    { count: 1, option: \"other\" },\n    { count: 1, option: \"other\" },\n    { count: 42, option: \"thing\" },\n    { count: 1, option: \"other\" },\n    { count: 42, option: \"thing\" },\n    { count: 1, option: \"other\" },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic React Component - JavaScript\nDESCRIPTION: This snippet showcases a simple React component function named 'Component' that takes props. It initializes an empty object 'x' and converts it to a number 'y'. The function returns an array containing both 'x' and 'y'. No external dependencies are required. The expected inputs are the component props, and the output is an array.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/globals-Number.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const x = {};\n  const y = Number(x);\n  return [x, y];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining React Functional Component with Props - JavaScript\nDESCRIPTION: This snippet defines a functional React component 'Foo' that takes a 'data' prop and outputs a Stringify component, demonstrating how to manage properties dynamically. It utilizes optional chaining to safely access nested properties in the 'data' object. Dependencies include 'shared-runtime' for the Stringify component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/repro-invariant.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enablePropagateDepsInHIR\nimport {Stringify} from 'shared-runtime';\n\nfunction Foo({data}) {\n  return (\n    <Stringify foo={() => data.a.d} bar={data.a?.b.c} shouldInvokeFns={true} />\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{data: {a: null}}],\n  sequentialRenders: [{data: {a: {b: {c: 4}}}}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining the Custom Hook Function - JavaScript\nDESCRIPTION: This snippet defines a custom React hook called 'useHook' that accepts props and creates two objects 'x' and 'y'. It uses the 'setProperty' function to return an object combining the two. The purpose of the hook is to enable component interaction with passed props.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-method-maybe-alias.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {createHookWrapper, setProperty} from 'shared-runtime';\nfunction useHook(props) {\n  const x = {\n    getX() {\n      return props;\n    },\n  };\n  const y = {\n    getY() {\n      return 'y';\n    },\n  };\n  return setProperty(x, y);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: createHookWrapper(useHook),\n  params: [{value: 0}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Memoization\nDESCRIPTION: This snippet presents the compiler-optimized version of the component. It introduces memoization to avoid unnecessary recalculations and uses a special _c function for caching. The optimized version aims to improve performance while maintaining the same functionality.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-expression-computed-key-non-reactive.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { identity } from \"shared-runtime\";\n\nconst SCALE = 2;\n\nfunction Component(props) {\n  const $ = _c(4);\n  let t0;\n  if ($[0] !== props.value) {\n    t0 = identity([props.value]);\n    $[0] = props.value;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  let t1;\n  if ($[2] !== t0) {\n    t1 = { [SCALE]: t0 };\n    $[2] = t0;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  const context = t1;\n  return context;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ key: \"Sathya\", value: \"Compiler\" }],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with TypeScript\nDESCRIPTION: This snippet defines a React component using TypeScript annotations. It takes a prop 'id' and uses it to create an array, then returns the first element of that array.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-annotations/type-annotation-satisfies-array.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableUseTypeAnnotations\nfunction Component(props: {id: number}) {\n  const x = makeArray(props.id) satisfies number[];\n  const y = x.at(0);\n  return y;\n}\n\nfunction makeArray<T>(x: T): Array<T> {\n  return [x];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{id: 42}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiling React Component with Optimizations in JavaScript\nDESCRIPTION: This snippet demonstrates the compiled version of the React component. It includes compiler runtime imports, constant declarations, and memoization logic for optimized performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-test-return-type-inference.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction component() {\n  const $ = _c(1);\n  const x = foo();\n  const y = foo();\n  if (x > y) {\n  }\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = foo();\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const z_0 = t0;\n  return z_0;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Counter Function with += Operator in JavaScript\nDESCRIPTION: Defines a function 'foo' that initializes a variable to 1, increments it 10 times using the += operator, and returns the final value. The function is exported as part of a fixture entrypoint configuration.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-for.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo() {\n  let x = 1;\n  for (let i = 0; i < 10; i++) {\n    x += 1;\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Refactored React Component with Const Declarations in JavaScript\nDESCRIPTION: This snippet shows a refactored version of the component function. It uses const instead of let for variable declarations, improving code quality and following modern JavaScript best practices.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/logical-expression.expect.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component(props) {\n  const a = props.a || (props.b && props.c && props.d);\n  const b = (props.a && props.b && props.c) || props.d;\n  return a ? b : props.c;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Div Component in React - Javascript\nDESCRIPTION: This snippet defines a simple functional component 'useDiv' that returns a basic div element. It is intended to demonstrate a minimal React component structure without additional functionality.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-functions-hook-with-jsx.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @compilationMode(infer)\nfunction useDiv(props) {\n  return <div />;\n}\n\n```\n\n----------------------------------------\n\nTITLE: React Component Code with arrayPush and Compiler Runtime\nDESCRIPTION: This is the compiled code for the `useFoo` component using the React compiler runtime.  It imports `_c` from `react/compiler-runtime` and `arrayPush` from `shared-runtime`. The function `useFoo` takes an object `t0` as input, extracts properties `a` and `b`, creates an object with property `a`, and pushes the value of `b` onto the keys of this object using `arrayPush`. It exports `FIXTURE_ENTRYPOINT` containing the function and parameters.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/shapes-object-key.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { arrayPush } from \"shared-runtime\";\n\nfunction useFoo(t0) {\n  const $ = _c(2);\n  const { a, b } = t0;\n  let t1;\n  if ($[0] !== a) {\n    t1 = { a };\n    $[0] = a;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  const obj = t1;\n  arrayPush(Object.keys(obj), b);\n  return obj;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ a: 2, b: 3 }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Component with Hook Misuse (JavaScript)\nDESCRIPTION: This snippet showcases an incorrect implementation of a React component where the `useFoo` hook is passed as an argument to the `foo` function instead of being called. This leads to the \"InvalidReact\" error, because React hooks must always be called directly, not referenced as values.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-pass-hook-as-call-arg.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  return foo(useFoo);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Validating Component Naming in JavaScript\nDESCRIPTION: This JavaScript function validates that a capitalized function is treated as a React component. It checks the invocation of `someGlobal.SomeFunc()`, which, if capitalized incorrectly, may raise an error indicating a misuse of component naming conventions. It provides insights into handling JSX rendering appropriately.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.capitalized-method-call.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validateNoCapitalizedCalls\nfunction Component() {\n  const x = someGlobal.SomeFunc();\n\n  return x;\n}\n\n```\n\n----------------------------------------\n\nTITLE: React Component Definition with Truthy Attribute\nDESCRIPTION: This snippet defines a React component that renders a `Stringify` component with a `truthyAttribute`.  The attribute is used without an explicit value, which in JSX defaults to `true`. This demonstrates how JSX handles boolean attributes implicitly.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-attribute-default-to-true.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {Stringify} from 'shared-runtime';\n\nfunction Component() {\n  // https://legacy.reactjs.org/docs/jsx-in-depth.html#props-default-to-true\n  return <Stringify truthyAttribute />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}]\n};\n\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with Nested Functions and Logging\nDESCRIPTION: This snippet defines a React component 'useFoo' that takes a prop 'value' and returns a number. It uses nested functions and includes logging statements. The component is exported as part of a FIXTURE_ENTRYPOINT object.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rename-source-variables-nested-function.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableChangeVariableCodegen\nimport {identity} from 'shared-runtime';\n\nconst $ = 'module_$';\nconst t0 = 'module_t0';\nconst c_0 = 'module_c_0';\nfunction useFoo(props: {value: number}): number {\n  const a = () => {\n    const b = () => {\n      const c = () => {\n        console.log($);\n        console.log(t0);\n        console.log(c_0);\n        return identity(props.value);\n      };\n      return c;\n    };\n    return b;\n  };\n  return a()()();\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{value: 42}],\n};\n```\n\n----------------------------------------\n\nTITLE: Component Fixture Export for Testing\nDESCRIPTION: Export configuration for testing the component with a sample parameter. Defines the component function and test parameters with a name value.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-call-complex-param-value.expect.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ name: \"Sathya\" }],\n};\n```\n\n----------------------------------------\n\nTITLE: Legacy ESLint Configuration for react-compiler Plugin\nDESCRIPTION: Instructions to add the react-compiler plugin to a legacy `.eslintrc` configuration file. It also shows how to set a rule using react-compiler in the rules section.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/eslint-plugin-react-compiler/README.md#2025-04-21_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"plugins\": [\n        \"react-compiler\"\n    ]\n}\n```\n\n----------------------------------------\n\nTITLE: Babel Transform for Error Message Rewriting\nDESCRIPTION: Babel transformation pass that rewrites detailed error messages to compact error IDs for production and minified builds.\nSOURCE: https://github.com/facebook/react/blob/main/scripts/error-codes/README.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n// transform-error-messages.js\nconst transformErrorMessages = (babel) => {\n  // Rewrite error messages to IDs\n}\n```\n\n----------------------------------------\n\nTITLE: Defining and Exporting JavaScript Function with Unusual Loop\nDESCRIPTION: This snippet defines a function 'foo' with a loop that will never execute, and exports a fixture object for testing. The function initializes a variable, contains a non-executing loop, and returns the initialized value.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/constant-propagation-for.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo() {\n  let y = 0;\n  for (const x = 100; x < 10; x) {\n    y = y + 1;\n  }\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Using React and Custom Hooks with Memoization - JavaScript\nDESCRIPTION: This snippet expands on the previous one by importing React runtime features. It demonstrates memoization for optimizing rendering with caching. The 'Component' utilizes the custom hook 'useFreeze' and stores component state within a variable '$' that checks and assigns a cache based on the memoization strategy. The memoization patterns help to avoid unnecessary re-renders unless the dependencies change, improving the performance of the component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hook-call.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction useFreeze() {}\nfunction foo() {}\n\nfunction Component(props) {\n  const $ = _c(3);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = [];\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const x = t0;\n  const y = useFreeze(x);\n  foo(y, x);\n  let t1;\n  if ($[1] !== y) {\n    t1 = (\n      <Component>\n        {x}\n        {y}\n      </Component>\n    );\n    $[1] = y;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  return t1;\n}\n```\n\n----------------------------------------\n\nTITLE: React Component Transformed Output\nDESCRIPTION: Transformed version of the component where the default parameter is extracted into a separate function and parameter handling is made explicit.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/default-param-with-reorderable-callback.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(t0) {\n  const x = t0 === undefined ? _temp : t0;\n  return x;\n}\nfunction _temp() {\n  return [-1, true, 42, \"hello\"];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Incorrect React useRef Access During Render\nDESCRIPTION: This code demonstrates an invalid pattern of accessing a ref's current property during component render. React's rules prohibit accessing ref.current during render as shown in the accompanying error message.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.ref-initialization-nonif.expect.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n//@flow\nimport {useRef} from 'react';\n\ncomponent C() {\n  const r = useRef(null);\n  const guard = r.current == null;\n  if (guard) {\n    r.current = 1;\n  }\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: C,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Lower Context Access\nDESCRIPTION: Transformed version of the App component that uses useContext_withSelector for optimized context access. It includes memoization logic to prevent unnecessary re-renders when context values haven't changed.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/lower-context-selector-simple.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useContext_withSelector } from \"react-compiler-runtime\";\nimport { c as _c } from \"react/compiler-runtime\"; // @lowerContextAccess\nfunction App() {\n  const $ = _c(3);\n  const { foo, bar } = useContext_withSelector(MyContext, _temp);\n  let t0;\n  if ($[0] !== bar || $[1] !== foo) {\n    t0 = <Bar foo={foo} bar={bar} />;\n    $[0] = bar;\n    $[1] = foo;\n    $[2] = t0;\n  } else {\n    t0 = $[2];\n  }\n  return t0;\n}\nfunction _temp(t0) {\n  return [t0.foo, t0.bar];\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring ESLint 8+ with react-compiler plugin\nDESCRIPTION: Configuration instructions for integrating eslint-plugin-react-compiler into ESLint 8+ using flat configuration method. This involves modifying the `eslint.config.mjs` file to include recommended settings.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/eslint-plugin-react-compiler/README.md#2025-04-21_snippet_2\n\nLANGUAGE: diff\nCODE:\n```\n+ import reactCompiler from \"eslint-plugin-react-compiler\"\nimport react from \"eslint-plugin-react\"\n\nexport default [\n    // Your existing config\n    { ...pluginReact.configs.flat.recommended, settings: { react: { version: \"detect\" } } },\n+   reactCompiler.configs.recommended    \n]\n```\n\n----------------------------------------\n\nTITLE: Compiled React Hook with Memoization Optimizations\nDESCRIPTION: The React compiler-transformed version of the useFoo hook with memoization for performance. The compiled code adds a caching mechanism to avoid recalculating values that haven't changed between renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-poisoned/reduce-if-nonexhaustive-poisoned-deps.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { identity } from \"shared-runtime\";\n\nfunction useFoo(t0) {\n  const $ = _c(9);\n  const { input, cond, hasAB } = t0;\n  let t1;\n  let x;\n  if ($[0] !== cond || $[1] !== hasAB || $[2] !== input) {\n    t1 = Symbol.for(\"react.early_return_sentinel\");\n    bb0: {\n      x = [];\n      if (cond) {\n        if (!hasAB) {\n          t1 = null;\n          break bb0;\n        }\n        let t2;\n        if ($[5] !== input.a.b) {\n          t2 = identity(input.a.b);\n          $[5] = input.a.b;\n          $[6] = t2;\n        } else {\n          t2 = $[6];\n        }\n        x.push(t2);\n      } else {\n        let t2;\n        if ($[7] !== input.a.b) {\n          t2 = identity(input.a.b);\n          $[7] = input.a.b;\n          $[8] = t2;\n        } else {\n          t2 = $[8];\n        }\n        x.push(t2);\n      }\n    }\n    $[0] = cond;\n    $[1] = hasAB;\n    $[2] = input;\n    $[3] = t1;\n    $[4] = x;\n  } else {\n    t1 = $[3];\n    x = $[4];\n  }\n  if (t1 !== Symbol.for(\"react.early_return_sentinel\")) {\n    return t1;\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ input: { b: 1 }, cond: true, hasAB: false }],\n  sequentialRenders: [\n    { input: { a: { b: 1 } }, cond: true, hasAB: true },\n    { input: null, cond: true, hasAB: false },\n    // preserve nullthrows\n    { input: { a: { b: undefined } }, cond: true, hasAB: true },\n    { input: { a: undefined }, cond: true, hasAB: true },\n    { input: { a: { b: undefined } }, cond: true, hasAB: true },\n    { input: undefined, cond: true, hasAB: true },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a React Component with Hook and Fixture Testing - JavaScript\nDESCRIPTION: This JavaScript snippet defines a React component that uses a hook from 'shared-runtime' to influence memoization behavior. The Component function creates an instance of the Foo class and assigns a property from its input props. The snippet also exports a FIXTURE_ENTRYPOINT object for testing, providing the Component function and specific parameters to simulate execution and observe outputs. The key elements to focus on include the use of the useHook function to interject processing and influence the outcomes of instance creation and assignment.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/prune-scopes-whose-deps-invalidate-new.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useHook} from 'shared-runtime';\n\nfunction Component(props) {\n  const x = new Foo();\n  useHook(); // intersperse a hook call to prevent memoization of x\n  x.value = props.value;\n\n  const y = {x};\n\n  return {y};\n}\n\nclass Foo {}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: 'sathya'}],\n};\n```\n\n----------------------------------------\n\nTITLE: Error Output from Optional Chaining Usage\nDESCRIPTION: This is the error output showing an unexpected terminal kind error with the optional chaining operator in the logical test block. The error specifically points to the 'value?.y' expression on line 5.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-optional-call-chain-in-logical-expr.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n  3 | function useFoo(props: {value: {x: string; y: string} | null}) {\n  4 |   const value = props.value;\n> 5 |   return useNoAlias(value?.x, value?.y) ?? {};\n    |                               ^^^^^^^^ Todo: Unexpected terminal kind `optional` for logical test block (5:5)\n  6 | }\n  7 |\n  8 | export const FIXTURE_ENTRYPONT = {\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with Memoized Effect - Input Version\nDESCRIPTION: This snippet shows the original implementation of a React component using useEffect with a dependency array. It demonstrates how to use nested arrays as dependencies.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/merged-scopes-are-valid-effect-deps.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validateMemoizedEffectDependencies\n\nimport {useEffect} from 'react';\n\nfunction Component(props) {\n  const y = [[props.value]]; // merged w scope for inner array\n\n  useEffect(() => {\n    console.log(y);\n  }, [y]); // should still be a valid dependency here\n\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: 42}],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Transformed React Component Code\nDESCRIPTION: Transformed version of the component where array destructuring is broken down into explicit variable assignments. Shows how the default value logic is separated into distinct operations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-with-conditional-as-default-value.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const [t0] = props.y;\n  const x = t0 === undefined ? (true ? 1 : 0) : t0;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ y: [] }],\n};\n```\n\n----------------------------------------\n\nTITLE: Initializing JavaScript Objects with Conditional Properties\nDESCRIPTION: This function demonstrates object property assignment based on a conditional parameter. It initializes objects and uses conditional statements to assign properties, showing how aliasing works. Dependencies include a 'mutate' function that modifies the objects. The function takes an argument 'a', initializes 'x', and conditionally assigns 'y' or 'z' before returning 'x'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-property-alias-mutate-inside-if.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nfunction foo(a) {\n  const x = {};\n  if (a) {\n    let y = {};\n    x.y = y;\n    mutate(y); // aliases x & y, but not z\n  } else {\n    let z = {};\n    x.z = z;\n  }\n  return x;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Original Function Implementation\nDESCRIPTION: Original JavaScript function that performs object property mutations through compound assignment operators. Creates three objects and performs chained mutations on their properties.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/chained-assignment-expressions.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo() {\n  const x = {x: 0};\n  const y = {z: 0};\n  const z = {z: 0};\n  x.x += y.y *= 1;\n  z.z += y.y *= x.x &= 3;\n  return z;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Installing and Starting React Application\nDESCRIPTION: Illustrates how to install dependencies and start the development server for the React application. Uses npm scripts to manage the build and run processes. It's essential to have Node.js and npm installed.\nSOURCE: https://github.com/facebook/react/blob/main/fixtures/nesting/README.md#2025-04-21_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\nnpm install\nnpm start\n```\n\n----------------------------------------\n\nTITLE: Input React Component with Fragment Usage\nDESCRIPTION: Original React component implementation using useFragment hook to handle post data with media, comments, and URLs. Demonstrates fragment usage and event handling.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-mixed-scope-declarations-and-locals.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useFragment} from 'shared-runtime';\n\nfunction Component(props) {\n  const post = useFragment(\n    graphql`\n      fragment F on T {\n        id\n      }\n    `,\n    props.post\n  );\n  const allUrls = [];\n  // `media` and `urls` are exported from the scope that will wrap this code,\n  // but `comments` is not (it doesn't need to be memoized, bc the callback\n  // only checks `comments.length`)\n  // because of the scope, the let declaration for media and urls are lifted\n  // out of the scope, and the destructure statement ends up turning into\n  // a reassignment, instead of a const declaration. this means we try to\n  // reassign `comments` when there's no declaration for it.\n  const {media, comments, urls} = post;\n  const onClick = e => {\n    if (!comments.length) {\n      return;\n    }\n    console.log(comments.length);\n  };\n  allUrls.push(...urls);\n  return <Media media={media} onClick={onClick} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Conditional Object Component in React (Input Version)\nDESCRIPTION: A React component that creates an object with the makeObject_Primitives utility and conditionally sets its value property based on props.cond. The component returns an object with either a value of 1 or the provided props.value.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/object-mutated-in-consequent-alternate-both-return.expect.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enablePropagateDepsInHIR\nimport {makeObject_Primitives} from 'shared-runtime';\n\nfunction Component(props) {\n  const object = makeObject_Primitives();\n  if (props.cond) {\n    object.value = 1;\n    return object;\n  } else {\n    object.value = props.value;\n    return object;\n  }\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{cond: false, value: [0, 1, 2]}],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Color Selection Logic in React Hook\nDESCRIPTION: This snippet defines a custom React hook 'useFoo' that selects colors based on global variables 'isSelected' and 'isCurrent'. It loops 6 times, logging the selected color each time. The hook is exported as part of a fixture for testing purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-loop-let-undefined-decl.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// These variables are unknown to useFoo, as they are\n// defined at module scope or implicit globals\nconst isSelected = false;\nconst isCurrent = true;\n\nfunction useFoo() {\n  for (let i = 0; i <= 5; i++) {\n    let color;\n    if (isSelected) {\n      color = isCurrent ? \"#FFCC22\" : \"#FF5050\";\n    } else {\n      color = isCurrent ? \"#CCFF03\" : \"#CCCCCC\";\n    }\n\n    console.log(color);\n  }\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  params: [],\n  fn: useFoo,\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Components with Memoization\nDESCRIPTION: Compiled output showing memoization implementation with render counter instrumentation and conditional compilation based on forget feature flag. Includes caching logic for optimized rendering.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/codegen-instrument-forget-gating-test.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { shouldInstrument, useRenderCounter } from \"react-compiler-runtime\";\nimport { c as _c } from \"react/compiler-runtime\";\nimport { isForgetEnabled_Fixtures } from \"ReactForgetFeatureFlag\"; // @enableEmitInstrumentForget @compilationMode(annotation) @gating\nconst Bar = isForgetEnabled_Fixtures()\n  ? function Bar(props) {\n      \"use forget\";\n      if (DEV && shouldInstrument)\n        useRenderCounter(\"Bar\", \"/codegen-instrument-forget-gating-test.ts\");\n      const $ = _c(2);\n      let t0;\n      if ($[0] !== props.bar) {\n        t0 = <div>{props.bar}</div>;\n        $[0] = props.bar;\n        $[1] = t0;\n      } else {\n        t0 = $[1];\n      }\n      return t0;\n    }\n  : function Bar(props) {\n      \"use forget\";\n      return <div>{props.bar}</div>;\n    };\n\nfunction NoForget(props) {\n  return <Bar>{props.noForget}</Bar>;\n}\nconst Foo = isForgetEnabled_Fixtures()\n  ? function Foo(props) {\n      \"use forget\";\n      if (DEV && shouldInstrument)\n        useRenderCounter(\"Foo\", \"/codegen-instrument-forget-gating-test.ts\");\n      const $ = _c(3);\n      if (props.bar < 0) {\n        return props.children;\n      }\n\n      const t0 = props.bar - 1;\n      let t1;\n      if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n        t1 = <NoForget />;\n        $[0] = t1;\n      } else {\n        t1 = $[0];\n      }\n      let t2;\n      if ($[1] !== t0) {\n        t2 = <Foo bar={t0}>{t1}</Foo>;\n        $[1] = t0;\n        $[2] = t2;\n      } else {\n        t2 = $[2];\n      }\n      return t2;\n    }\n  : function Foo(props) {\n      \"use forget\";\n      if (props.bar < 0) {\n        return props.children;\n      }\n      return (\n        <Foo bar={props.bar - 1}>\n          <NoForget />\n        </Foo>\n      );\n    };\n\nglobal.DEV = true;\nexport const FIXTURE_ENTRYPOINT = {\n  fn: eval(\"Foo\"),\n  params: [{ bar: 2 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Accessing ref.current During Render in React Component\nDESCRIPTION: This code snippet demonstrates an incorrect React pattern - accessing ref.current during component rendering. React restricts this because refs should not be accessed during the render phase as noted by the validation directive.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.validate-mutate-ref-arg-in-render.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validateRefAccessDuringRender:true\nfunction Foo(props, ref) {\n  console.log(ref.current);\n  return <div>{props.bar}</div>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{bar: 'foo'}, {ref: {cuurrent: 1}}],\n  isComponent: true,\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Optimization\nDESCRIPTION: Optimized version of the component with memoization using compiler-runtime. Implements caching mechanism to avoid redundant calculations when props haven't changed.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/align-scopes-iife-return-modified-later-logical.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { getNull } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(3);\n  let t0;\n  let items;\n  if ($[0] !== props.a) {\n    t0 = getNull() ?? [];\n    items = t0;\n\n    items.push(props.a);\n    $[0] = props.a;\n    $[1] = items;\n    $[2] = t0;\n  } else {\n    items = $[1];\n    t0 = $[2];\n  }\n  return items;\n}\n```\n\n----------------------------------------\n\nTITLE: Transformed Function with Renamed Label\nDESCRIPTION: This code snippet shows the transformed version of the original function where the label name has been changed from 'label' to 'bb0'. The function maintains the same logic of breaking out of nested blocks when condition c is true, but uses a different label identifier.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/complex-while.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(a, b, c) {\n  bb0: if (a) {\n    while (b) {\n      if (c) {\n        break bb0;\n      }\n    }\n  }\n  return c;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: React Hook State Management with Compiler Runtime\nDESCRIPTION: This code implements a useFoo function which leverages React compiler-runtime for optimizing component state management. It uses a cache mechanism to reduce redundant calculations. The function processes an input object and conditionally returns a JSX component. Dependencies are similar to the first snippet, focusing on shared-runtime functionalities.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/infer-function-cond-access-local-var.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enablePropagateDepsInHIR\n\nimport { shallowCopy, mutate, Stringify } from \"shared-runtime\";\n\nfunction useFoo(t0) {\n  const $ = _c(5);\n  const { a, shouldReadA } = t0;\n  let local;\n  if ($[0] !== a) {\n    local = shallowCopy(a);\n    mutate(local);\n    $[0] = a;\n    $[1] = local;\n  } else {\n    local = $[1];\n  }\n  let t1;\n  if ($[2] !== local || $[3] !== shouldReadA) {\n    t1 = (\n      <Stringify\n        fn={() => {\n          if (shouldReadA) {\n            return local.b.c;\n          }\n          return null;\n        }}\n        shouldInvokeFns={true}\n      />\n    );\n    $[2] = local;\n    $[3] = shouldReadA;\n    $[4] = t1;\n  } else {\n    t1 = $[4];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ a: null, shouldReadA: true }],\n  sequentialRenders: [\n    { a: null, shouldReadA: true },\n    { a: null, shouldReadA: false },\n    { a: { b: { c: 4 } }, shouldReadA: true },\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Optimizing React Component with Memoization in JavaScript\nDESCRIPTION: This snippet shows an optimized version of the 'useFoo' component using memoization techniques. It uses a custom compiler runtime to cache previous results and avoid unnecessary computations, improving performance for repeated renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-maybe-null-dependency.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { identity } from \"shared-runtime\";\n\n/**\n * Not safe to hoist read of maybeNullObject.value.inner outside of the\n * try-catch block, as that might throw\n */\nfunction useFoo(maybeNullObject) {\n  const $ = _c(4);\n  let y;\n  if ($[0] !== maybeNullObject) {\n    y = [];\n    try {\n      let t0;\n      if ($[2] !== maybeNullObject.value.inner) {\n        t0 = identity(maybeNullObject.value.inner);\n        $[2] = maybeNullObject.value.inner;\n        $[3] = t0;\n      } else {\n        t0 = $[3];\n      }\n      y.push(t0);\n    } catch {\n      y.push(\"null\");\n    }\n    $[0] = maybeNullObject;\n    $[1] = y;\n  } else {\n    y = $[1];\n  }\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [null],\n  sequentialRenders: [null, { value: 2 }, { value: 3 }, null],\n};\n```\n\n----------------------------------------\n\nTITLE: Calling Class Methods in React - JavaScript\nDESCRIPTION: This snippet illustrates a JavaScript class with methods that call other functions. Specifically, it shows how methods `this.useHook()` and `super.useHook()` are called, which are not considered hooks in the React framework. There are no special prerequisites, but it assumes a basic understanding of JavaScript classes and React components.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-dfde14171fcd.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Valid because classes can call functions.\\n// We don\\'t consider these to be hooks.\\nclass C {\\n  m() {\\n    this.useHook();\\n    super.useHook();\\n  }\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Defining Component Function with State Mutation - JavaScript\nDESCRIPTION: This snippet defines a function named 'component' that mutates an object based on inputs 'foo' and 'bar'. It uses shared-runtime for mutation and returns an object containing 'foo'. The dependency on 'shared-runtime' is essential for the mutate function to work correctly. The function expects two parameters and outputs an object.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-fun-alias-captured-mutate-arr-2-iife.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst {mutate} = require('shared-runtime');\n\nfunction component(foo, bar) {\n  let x = {foo};\n  let y = {bar};\n  (function () {\n    let a = [y];\n    let b = x;\n    a.x = b;\n  })();\n  mutate(y);\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: ['foo', 'bar'],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: A React component that creates a context object with a memoized value using the identity function. The component takes props with a value parameter and returns a context object with a key-value pair.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-expression-computed-key-constant-string.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {identity} from 'shared-runtime';\n\nfunction Component(props) {\n  const key = 'KeyName';\n  const context = {\n    [key]: identity([props.value]),\n  };\n  return context;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: 42}],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Memoization in JavaScript\nDESCRIPTION: This snippet shows an optimized version of the 'Foo' component using React's compiler-runtime for memoization. It caches the result of conditional rendering to improve performance in subsequent renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/nested-scopes-begin-same-instr-valueblock.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { identity, mutate } from \"shared-runtime\";\n\nfunction Foo(t0) {\n  const $ = _c(2);\n  const { cond } = t0;\n  let x;\n  if ($[0] !== cond) {\n    x = identity(identity(cond)) ? { a: 2 } : { b: 2 };\n\n    mutate(x);\n    $[0] = cond;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{ cond: false }],\n  sequentialRenders: [\n    { cond: false },\n    { cond: false },\n    { cond: true },\n    { cond: true },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Simplified Function Implementation in React Fixture\nDESCRIPTION: A simplified implementation of the function that directly returns a fixed value of 5. This appears to be the expected result of the more complex sequence point evaluation in the input section.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/expression-with-assignment.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction f() {\n  return 5;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: f,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Input Implementation of useTest Hook\nDESCRIPTION: Original implementation of a custom hook that creates an object with a mutable property and returns an array using makeArray utility.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/codegen-inline-iife-storeprop.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {makeArray, print} from 'shared-runtime';\n\nfunction useTest() {\n  let w = {};\n  return makeArray(\n    (w.x = 42),\n    w.x,\n    (function foo() {\n      w.x = 999;\n      return 2;\n    })(),\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useTest,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining React useFoo Function and Fixture\nDESCRIPTION: This code defines a React function named `useFoo` which takes an object with `input` and `cond` properties. Based on the `cond` parameter, it either skips processing or pushes a value derived from `input.a.b` (using `identity` function) into an array.  The `FIXTURE_ENTRYPOINT` constant defines test scenarios for the `useFoo` function including different input values and conditions.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-unpoisoned/else-branch-scope-unpoisoned.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {identity} from 'shared-runtime';\n\nfunction useFoo({input, cond}) {\n  const x = [];\n  label: {\n    if (cond) {\n      break label;\n    } else {\n      x.push(identity(input.a.b));\n    }\n  }\n  return x[0];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{input: {a: {b: 2}}, cond: false}],\n  sequentialRenders: [\n    {input: null, cond: true},\n    {input: {a: {b: 2}}, cond: false},\n    {input: null, cond: true},\n    // preserve nullthrows\n    {input: {}, cond: false},\n    {input: {a: {b: null}}, cond: false},\n    {input: {a: null}, cond: false},\n    {input: {a: {b: 3}}, cond: false},\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Original React Component with Type Annotations\nDESCRIPTION: Initial implementation of a React component with TypeScript annotations that creates an array from a numeric ID prop and returns its first element. Includes generic array creation helper function.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-annotations/type-annotation-as-array.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableUseTypeAnnotations\nfunction Component(props: {id: number}) {\n  const x = makeArray(props.id) as number[];\n  const y = x.at(0);\n  return y;\n}\n\nfunction makeArray<T>(x: T): Array<T> {\n  return [x];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{id: 42}],\n};\n```\n\n----------------------------------------\n\nTITLE: React Function Implementation (Alternative Syntax)\nDESCRIPTION: Alternative syntax version of the same React function component using double quotes for the 'use no memo' directive. Functionally identical to the previous snippet but with different string delimiter.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/use-no-memo-module-level.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n\"use no memo\";\n\nexport default function foo(x, y) {\n  if (x) {\n    return foo(false, y);\n  }\n  return [y * 10];\n}\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Memoization (Compiled Version)\nDESCRIPTION: This snippet shows the compiled and optimized version of the React component. It uses memoization to cache rendered content and avoid unnecessary re-renders. The component still implements the same conditional rendering logic as the input version.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-propagate-type-of-ternary-nested.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction V0(t0) {\n  const $ = _c(2);\n  const { v1 } = t0;\n  v5(V6.v7({ v8: V9.va }));\n  let t1;\n  if ($[0] !== v1) {\n    t1 = (\n      <ComponentC cd=\"TxqUy\" ce=\"oh`]uc\" cf=\"Bdbo\" c10={!V9.va && v11.v12}>\n        gmhubcw\n        {v1 === V3.V13 ? (\n          <c14\n            c15={\n              \"L^]w\\\\T\\\\qrGmqrlQyrvBgf\\\\inuRdkEqwVPwixiriYGSZmKJf]E]RdT{N[WyVPiEJIbdFzvDohJV[BV`H[[K^xoy[HOGKDqVzUJ^h\"\n            }\n          >\n            iawyneijcgamsfgrrjyvhjrrqvzexxwenxqoknnilmfloafyvnvkqbssqnxnexqvtcpvjysaiovjxyqrorqskfph\n          </c14>\n        ) : v16.v17(\"pyorztRC]EJzVuP^e\") ? (\n          <c14\n            c15={\n              \"CRinMqvmOknWRAKERI]RBzB_LXGKQe{SUpoN[\\\\gL[`bLMOhvFqDVVMNOdY\"\n            }\n          >\n            goprinbjmmjhfserfuqyluxcewpyjihektogc\n          </c14>\n        ) : (\n          <c14 c15={\"H\\\\\\\\GAcTc\\\\lfGMW[yHriCpvW`w]niSIKj\\\\kdgFI\"}>\n            yejarlvudihqdrdgpvahovggdnmgnueedxpbwbkdvvkdhqwrtoiual\n          </c14>\n        )}\n        hflmn\n      </ComponentC>\n    );\n    $[0] = v1;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  const vb = t1;\n  return vb;\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Dependencies After React Changes\nDESCRIPTION: Command to update the SSR fixture dependencies after making changes to React. This step is required whenever the React codebase is modified and rebuilt.\nSOURCE: https://github.com/facebook/react/blob/main/fixtures/ssr/README.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nyarn\n```\n\n----------------------------------------\n\nTITLE: React Component with FBT Translation - Compiled Version\nDESCRIPTION: Compiled and optimized version of the FBT component with caching logic for performance. This version includes memoization using array-based caching to prevent unnecessary re-renders and string conversions.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-param-with-quotes.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport fbt from \"fbt\";\n\nfunction Component(props) {\n  const $ = _c(4);\n  let t0;\n  if ($[0] !== props.name) {\n    t0 = fbt._('Hello {\"user\" name}', [fbt._param('\"user\" name', props.name)], {\n      hk: \"S0vMe\",\n    });\n    $[0] = props.name;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const element = t0;\n  let t1;\n  if ($[2] !== element) {\n    t1 = element.toString();\n    $[2] = element;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ name: \"Jason\" }],\n};\n```\n\n----------------------------------------\n\nTITLE: React Rendering Mutation Error\nDESCRIPTION: An error message indicating that updating an object previously used in JSX rendering is not permitted in React, suggesting moving the mutation before JSX rendering\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-computed-store-to-frozen-value.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n  3 |   // freeze\n  4 |   <div>{x}</div>;\n> 5 |   x[0] = true;\n    |   ^ InvalidReact: Updating a value used previously in JSX is not allowed. Consider moving the mutation before the JSX (5:5)\n  6 |   return x;\n  7 | }\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Compiler Runtime and Memoization\nDESCRIPTION: The compiled version of the Component function with React compiler runtime optimizations. It introduces memoization through the _c function, tracking state changes using an array, and only recalculating values when dependencies change.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/createElement-freeze.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport React from \"react\";\nimport { shallowCopy } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(5);\n  let t0;\n  if ($[0] !== props.width) {\n    t0 = { style: { width: props.width } };\n    $[0] = props.width;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const childProps = t0;\n  let t1;\n  if ($[2] !== childProps) {\n    let t2;\n    if ($[4] === Symbol.for(\"react.memo_cache_sentinel\")) {\n      t2 = [\"hello world\"];\n      $[4] = t2;\n    } else {\n      t2 = $[4];\n    }\n    t1 = React.createElement(\"div\", childProps, t2);\n    $[2] = childProps;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  const element = t1;\n  shallowCopy(childProps);\n  return element;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compilation Error for Fire Event Dependency\nDESCRIPTION: Highlights a compilation error related to improper use of the fire() method and effect dependencies. The error suggests using an array literal for effect dependencies when fire() is used.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/error.invalid-rewrite-deps-no-array-literal.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n  11 |   useEffect(() => {\n  12 |     fire(foo(props));\n> 13 |   }, deps);\n     |      ^^^^ Invariant: Cannot compile `fire`. You must use an array literal for an effect dependency array when that effect uses `fire()` (13:13)\n  14 |\n  15 |   return null;\n  16 | }\n```\n\n----------------------------------------\n\nTITLE: Using Compiler Runtime in React Component (JavaScript)\nDESCRIPTION: This snippet extends the previous component definition by incorporating the react/compiler-runtime for optimized rendering. It utilizes a signal-based state management approach to track state changes more efficiently and return the appropriate value based on the input prop. The code structure facilitates easy testing through the defined FIXTURE_ENTRYPOINT.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-for-init.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  let x;\n  for (const i = props.init; i < 10; ) {\n    if (i === 0) {\n      x = 0;\n      break;\n    } else {\n      x = 1;\n      break;\n    }\n  }\n  let t0;\n  if ($[0] !== x) {\n    t0 = [x];\n    $[0] = x;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  sequentialRenders: [\n    { init: 0 },\n    { init: 0 },\n    { init: 10 },\n    { init: 10 },\n    { init: 0 },\n    { init: 10 },\n    { init: 0 },\n    { init: 10 },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Handling Reactive State in React Component - JavaScript\nDESCRIPTION: This JavaScript code extends the reactive component handling by incorporating the React compiler-runtime. It uses the _c function to manage reactive updates within the component. The function keeps track of reactivity changes and updates the component output accordingly. React compiler runtime is a prerequisite for this snippet. Like the first snippet, it expects a props object as input and returns an array with a boolean value.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-via-mutation-if.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n\n  const x = [];\n  if (props.cond) {\n    x.push(1);\n  }\n\n  let y = false;\n  if (x[0]) {\n    y = true;\n  }\n  let t0;\n  if ($[0] !== y) {\n    t0 = [y];\n    $[0] = y;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  sequentialRenders: [\n    { cond: true },\n    { cond: true },\n    { cond: false },\n    { cond: false },\n    { cond: true },\n    { cond: false },\n    { cond: true },\n    { cond: false },\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: Original implementation of a React component that creates an object with two properties, performs a comparison, and returns a value. Shows basic object property access patterns.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-test-field-load-binary-op.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component() {\n  let x = {u: makeSomePrimitive(), v: makeSomePrimitive()};\n  let u = x.u;\n  let v = x.v;\n  if (u > v) {\n  }\n\n  let y = x.u;\n  let z = x.v;\n  return z;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with Complex Control Flow\nDESCRIPTION: This code snippet defines a React component function that uses labeled statements, if-else conditions, and switch cases to set the value of 'x' based on different props. It handles various edge cases and includes intentional fallthroughs in the switch statement.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/dominator.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let x = 0;\n  label: if (props.a) {\n    x = 1;\n  } else {\n    if (props.b) {\n      x = 2;\n    } else {\n      break label;\n    }\n    x = 3;\n  }\n  label2: switch (props.c) {\n    case 'a': {\n      x = 4;\n      break;\n    }\n    case 'b': {\n      break label2;\n    }\n    case 'c': {\n      x = 5;\n      // intentional fallthrough\n    }\n    default: {\n      x = 6;\n    }\n  }\n  if (props.d) {\n    return null;\n  }\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Conditional React Hook Usage\nDESCRIPTION: Example of incorrect React Hook implementation where useHook() is called inside a conditional statement. This violates React's Rules of Hooks which require hooks to be called in the same order on every render.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-hook-if-consequent.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let x = null;\n  if (props.cond) {\n    x = useHook();\n  }\n  return x;\n}\n```\n\nLANGUAGE: text\nCODE:\n```\n  2 |   let x = null;\n  3 |   if (props.cond) {\n> 4 |     x = useHook();\n    |         ^^^^^^^ InvalidReact: Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning) (4:4)\n  5 |   }\n  6 |   return x;\n  7 | }\n```\n\n----------------------------------------\n\nTITLE: Compiled React Function with Memoization\nDESCRIPTION: Compiler-optimized version of the function that implements caching logic to avoid redundant computations. Uses an array $ to store previous values and their computed results for memoization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/method-call-fn-call.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction foo(a, b, c) {\n  const $ = _c(6);\n  let t0;\n  if ($[0] !== a) {\n    t0 = makeObject(a);\n    $[0] = a;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const x = t0;\n\n  const method = x.method;\n  let t1;\n  if ($[2] !== b || $[3] !== method || $[4] !== x) {\n    t1 = method.call(x, b);\n    $[2] = b;\n    $[3] = method;\n    $[4] = x;\n    $[5] = t1;\n  } else {\n    t1 = $[5];\n  }\n  const y = t1;\n  return y;\n}\n```\n\n----------------------------------------\n\nTITLE: React Component Definition with Shared-Runtime\nDESCRIPTION: This code defines a React component that accepts a prop 'a', creates a function 'x' that mutates a local variable 'z', and then renders a `Stringify` component from `shared-runtime`, passing `x` as the `fn` prop and setting `shouldInvokeFns` to `true`. The `FIXTURE_ENTRYPOINT` exports an object containing the component, initial parameters, and sequential renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-shadow-captured.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {mutate, Stringify} from 'shared-runtime';\nfunction Component({a}) {\n  let z = {a};\n  let x = function () {\n    let z;\n    mutate(z);\n    return z;\n  };\n  return <Stringify fn={x} shouldInvokeFns={true} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{a: 1}],\n  sequentialRenders: [{a: 1}, {a: 1}, {a: 2}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Advanced Component Logic with Compiler Runtime\nDESCRIPTION: This snippet shows a React functional component with more complex handling of memoization and runtime cache. It leverages a utility from 'react/compiler-runtime' to memoize values based on runtime conditions. The component works by checking specific conditions in an internal cache, defaulting values as necessary, and keeping track of state changes to determine return values. The key dependencies are compiler-runtime utilities and React hooks.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/immutable-hooks.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enableAssumeHooksFollowRulesOfReact true\nfunction Component(props) {\n  const $ = _c(3);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = {};\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const x = t0;\n  const y = useFoo(x);\n  bar(x, y);\n  let t1;\n  if ($[1] !== y) {\n    t1 = [x, y];\n    $[1] = y;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  return t1;\n}\n```\n\n----------------------------------------\n\nTITLE: Enhanced Iterator Semantics with Memoization in React using JavaScript\nDESCRIPTION: This snippet extends the previous implementation by including a compiler-runtime cache mechanism, enhancing the memoization process. It optimizes iterator handling by caching React.memo cache sentinels and input states to improve performance. The useFoo function now manages cached state changes to ensure efficient rendering, powered by React and shared-runtime dependencies.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/todo-granular-iterator-semantics.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useIdentity, ValidateMemoization } from \"shared-runtime\";\n\n/**\n * Fixture for granular iterator semantics:\n * 1. ConditionallyMutate the iterator itself, depending on whether the iterator\n *    is a mutable iterator.\n * 2. Capture effect on elements within the iterator.\n */\nfunction Validate({ x, input }) {\n  \"use no memo\";\n  return (\n    <>\n      <ValidateMemoization inputs={[]} output={x[0]} onlyCheckCompiled={true} />\n      <ValidateMemoization\n        inputs={[input]}\n        output={x[1]}\n        onlyCheckCompiled={true}\n      />\n    </>\n  );\n}\nfunction useFoo(input) {\n  \"use memo\";\n  const $ = _c(6);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = [{}];\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const x = Array.from(t0);\n  useIdentity();\n  let t1;\n  if ($[1] !== input) {\n    t1 = [input];\n    $[1] = input;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  x.push(t1);\n  let t2;\n  if ($[3] !== input || $[4] !== x) {\n    t2 = <Validate x={x} input={input} />;\n    $[3] = input;\n    $[4] = x;\n    $[5] = t2;\n  } else {\n    t2 = $[5];\n  }\n  return t2;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [1],\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Component Implementation without Type Annotations in JavaScript\nDESCRIPTION: This snippet shows the implementation of the React component without Flow type annotations. It imports the 'identity' function, defines the Component function, and exports the FIXTURE_ENTRYPOINT for testing purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-annotations/type-annotation-as-number_.flow.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { identity } from \"shared-runtime\";\n\nfunction Component(props) {\n  const x = identity(props.id);\n  const y = (x: number);\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ id: 42 }],\n};\n```\n\n----------------------------------------\n\nTITLE: useCallback Example with Compiler Hints\nDESCRIPTION: This code snippet demonstrates a React component that uses useCallback to memoize a function. The `@validatePreserveExistingMemoizationGuarantees` compiler hint suggests that the compiler should preserve any existing memoization guarantees. The component returns a memoized function that returns an array containing the `propA` prop.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useCallback-with-no-depslist.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees\nimport {useCallback} from 'react';\n\n// Compiler can produce any memoization it finds valid if the\n// source listed no memo deps\nfunction Component({propA}) {\n  // @ts-ignore\n  return useCallback(() => {\n    return [propA];\n  });\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{propA: 2}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Memoization\nDESCRIPTION: This snippet demonstrates the optimized version of the React component using memoization techniques. It imports a compiler runtime function and uses an array to store memoized values, reducing unnecessary computations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/independent.expect.md#2025-04-22_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; /**\n * Should produce 3 scopes:\n *\n * a: inputs=props.a, outputs=a\n *   a = compute(props.a);\n * b: inputs=props.b, outputs=b\n *   b = compute(props.b);\n * return: inputs=a, b outputs=return\n *   return = <Foo a={a} b={b} />\n */\nfunction Component(props) {\n  const $ = _c(7);\n  let t0;\n  if ($[0] !== props.a) {\n    t0 = compute(props.a);\n    $[0] = props.a;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const a = t0;\n  let t1;\n  if ($[2] !== props.b) {\n    t1 = compute(props.b);\n    $[2] = props.b;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  const b = t1;\n  let t2;\n  if ($[4] !== a || $[5] !== b) {\n    t2 = <Foo a={a} b={b} />;\n    $[4] = a;\n    $[5] = b;\n    $[6] = t2;\n  } else {\n    t2 = $[6];\n  }\n  return t2;\n}\n\nfunction compute() {}\nfunction foo() {}\nfunction Foo() {}\n```\n\n----------------------------------------\n\nTITLE: React Component with Potential Prop Mutation\nDESCRIPTION: This React component defines a function that attempts to mutate a variable `x` derived from either `someGlobal` or `props.foo`. The `useEffect` hook is used to indirectly trigger this mutation, violating React's principle of immutability, especially when `x` is derived from props. Mutating props directly or values derived from props is generally discouraged in React.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-mutation-of-possible-props-phi-indirect.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let x = cond ? someGlobal : props.foo;\n  const mutatePhiThatCouldBeProps = () => {\n    x.y = true;\n  };\n  const indirectMutateProps = () => {\n    mutatePhiThatCouldBeProps();\n  };\n  useEffect(() => indirectMutateProps(), []);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Empty React Hook Function Implementation\nDESCRIPTION: A minimal React hook function with no implementation, showcasing a basic function structure without any specific logic or return value.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-4f6c78a14bf7.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction useUnreachable() {}\n```\n\n----------------------------------------\n\nTITLE: React Component with useEffect and useState\nDESCRIPTION: This code defines a React functional component named Foo that uses the useEffect and useState hooks. The useEffect hook updates the state to 2 when the component mounts, and the useState hook initializes the state to 0.  The component renders a Stringify component, passing the state as a prop.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-setstate.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useEffect, useState} from 'react';\nimport {Stringify} from 'shared-runtime';\n\nfunction Foo() {\n  /**\n   * Previously, this lowered to\n   * $1 = LoadContext capture setState\n   * $2 = FunctionExpression deps=$1 context=setState\n   *  [[ at this point, we freeze the `LoadContext setState` instruction, but it will never be referenced again ]]\n   * \n   * Now, this function expression directly references `setState`, which freezes\n   * the source `DeclareContext HoistedConst setState`. Freezing source identifiers\n   * (instead of the one level removed `LoadContext`) is more semantically correct\n   * for everything *other* than hoisted context declarations.\n   * \n   * $2 = Function context=setState\n   */\n  useEffect(() => setState(2), []);\n\n  const [state, setState] = useState(0);\n  return <Stringify state={state} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{}],\n  sequentialRenders: [{}, {}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Input: React Component with Function Definition\nDESCRIPTION: Original implementation of a React component with a nested function that returns an object based on a prop value\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/bug-functiondecl-hoisting.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Foo({value}) {\n  const result = bar();\n  function bar() {\n    return {value};\n  }\n  return <Stringify result={result} fn={bar} shouldInvokeFns={true} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing React Memoization Cache in Component - JavaScript\nDESCRIPTION: This JavaScript snippet extends a React component with an implementation that introduces a memoization cache for improved reactivity using the '_c' function from 'react/compiler-runtime'. It manages an internal reactive state with Symbol for recognizing memo cache sentinel values. Inputs/outputs resemble the basic component, and it's crucial to include 'react/compiler-runtime' as a dependency to utilize the caching mechanism effectively.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-from-interleaved-reactivity-if.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(1);\n\n  const a = [];\n  const b = [];\n  b.push(props.cond);\n  a.push(null);\n\n  const c = [a];\n\n  let x;\n  if (c[0][0]) {\n    x = 1;\n  } else {\n    x = 2;\n  }\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = [x];\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ cond: true }],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Functions and Exporting in JavaScript\nDESCRIPTION: This snippet defines two functions, 'useFoo' and 'Foo'. The 'Foo' function calls 'useFoo' to obtain its name and logs it, returning the name value. An exportable object, 'FIXTURE_ENTRYPOINT', is created to provide access to the 'Foo' function and its parameters.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hook-property-load-local.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction useFoo() {}\n```\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Foo() {\n  let name = useFoo.name;\n  console.log(name);\n  return name;\n}\n```\n\nLANGUAGE: javascript\nCODE:\n```\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Original JavaScript Function with Increment Operations\nDESCRIPTION: Simple function demonstrating pre and post-increment operations on input parameter, returning an array of modified values\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/update-expression-on-function-parameter-2.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(a) {\n  let d = a++;\n  let e = ++a;\n  return [a, d, e];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [2],\n  isComponent: false\n};\n```\n\n----------------------------------------\n\nTITLE: Fixture Entry Point Export\nDESCRIPTION: This code exports a constant named FIXTURE_ENTRYPOINT, which is an object containing the component function, its parameters ('TodoAdd'), and a flag indicating that it's a component ('TodoAdd'). This is likely used for testing and demonstration purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-1.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Original React Component Function\nDESCRIPTION: This snippet defines a React component function 'Foo' that initializes an empty array and returns it. It also exports a FIXTURE_ENTRYPOINT object containing the function and empty props.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/memoize-value-block-value-sequence.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Foo(props) {\n  let x;\n  (x = []), null;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: FBT Component Input Example in React\nDESCRIPTION: Demonstrates the usage of FBT internationalization component in React JSX. Shows how to use fbt:param for dynamic text insertion and handling whitespace rules within FBT components.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-preserve-whitespace-subtree.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport fbt from 'fbt';\n\n/**\n * Note that fbt whitespace rules apply to the entire fbt subtree,\n * not just direct children of fbt elements.\n * (e.g. here, the JSXText children of the span element also use\n * fbt whitespace rules)\n */\n\nfunction Foo(props) {\n  return (\n    <fbt desc={'Dialog to show to user'}>\n      <span key={props.name}>\n        <fbt:param name=\"user name really long description for prettier\">\n          {props.name}\n        </fbt:param>\n        !\n      </span>\n    </fbt>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{name: 'Jason'}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Compiler Runtime\nDESCRIPTION: This snippet shows the compiled version of the React component. It uses the `react/compiler-runtime` to optimize the component's rendering. The compiled code includes memoization and caching of the onClick handler and the JSX elements.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-mutating-ref-property-in-callback-passed-to-jsx.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @validateRefAccessDuringRender\nimport { useRef } from \"react\";\n\nfunction Component() {\n  const $ = _c(2);\n  const ref = useRef(null);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = () => {\n      if (ref.current !== null) {\n        ref.current.value = \"\";\n      }\n    };\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const onClick = t0;\n  let t1;\n  if ($[1] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = (\n      <>\n        <input ref={ref} />\n        <button onClick={onClick} />\n      </>\n    );\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}]\n};\n\n```\n\n----------------------------------------\n\nTITLE: Error Handling for Conditional Hooks in React\nDESCRIPTION: This snippet is an error message indicating that the useFragment hook is being called conditionally within the Component function. It emphasizes that hooks must always be called in the same order regardless of control flow structures, and provides a link to the React documentation for further guidelines.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-conditional-call-aliased-hook-import.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n  4 |   let data;\n  5 |   if (props.cond) {\n> 6 |     data = readFragment();\n    |            ^^^^^^^^^^^^ InvalidReact: Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning) (6:6)\n  7 |   }\n  8 |   return data;\n  9 | }\n\n```\n\n----------------------------------------\n\nTITLE: Error Message for Invalid Capitalized Function Call - JavaScript\nDESCRIPTION: This snippet shows the error output that occurs when the function 'Foo' attempts to call 'Bar'. It explains that capitalized function names should be used only for React components and that the user has options to fix this issue. The snippet highlights key line references for debugging.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.capitalized-function-call-aliased.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n  2 | function Foo() {\n  3 |   let x = Bar;\n> 4 |   x(); // ERROR\n    |   ^^^ InvalidReact: Capitalized functions are reserved for components, which must be invoked with JSX. If this is a component, render it with JSX. Otherwise, ensure that it has no hook calls and rename it to begin with a lowercase letter. Alternatively, if you know for a fact that this function is not a component, you can allowlist it via the compiler config. Bar may be a component. (4:4)\n  5 | }\n  6 |\n\n```\n\n----------------------------------------\n\nTITLE: React Component with Default Arrow Function Parameter (JavaScript)\nDESCRIPTION: This code defines a React component named `Component` using a JavaScript function. It takes two parameters: `x` and `y`. The `y` parameter has a default value, which is an arrow function that returns the value of `x`. The component then simply returns the result of calling the `y` function. The FIXTURE_ENTRYPOINT exports the component function.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.default-param-accesses-local.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(\n  x,\n  y = () => {\n    return x;\n  }\n) {\n  return y();\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiled: FBT Pluralization with Memoization\nDESCRIPTION: The compiled version of the FBT pluralization component, showing how React's compiler transforms the FBT calls. It includes memoization logic to optimize rendering performance and the table structure used for handling pluralization rules.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/bug-fbt-plural-multiple-function-calls.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport fbt from \"fbt\";\n\n/**\n * Similar to error.todo-multiple-fbt-plural\n *\n * Evaluator error:\n *   Found differences in evaluator results\n *   Non-forget (expected):\n *   (kind: ok) <div>1 apple and 2 bananas</div>\n *   Forget:\n *   (kind: ok) <div>1 apples and 2 bananas</div>\n */\n\nfunction useFoo(t0) {\n  const $ = _c(3);\n  const { apples, bananas } = t0;\n  let t1;\n  if ($[0] !== apples || $[1] !== bananas) {\n    t1 = fbt._(\n      {\n        \"*\": {\n          \"*\": \"{number of apples} apples and {number of bananas} bananas\",\n        },\n        _1: { _1: \"{number of apples} apple and {number of bananas} banana\" },\n      },\n      [\n        fbt._plural(apples),\n        fbt._plural(bananas),\n        fbt._param(\"number of apples\", apples),\n        fbt._param(\"number of bananas\", bananas),\n      ],\n      { hk: \"3vKunl\" },\n    );\n    $[0] = apples;\n    $[1] = bananas;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ apples: 1, bananas: 2 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Input Component with Error Handling in JavaScript\nDESCRIPTION: A React component that demonstrates error catching, array manipulation, and input parameter processing. Uses throwInput for testing and handles exceptions by pushing additional data into the caught error.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/try-catch-try-value-modified-in-catch-escaping.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enablePropagateDepsInHIR\nconst {throwInput} = require('shared-runtime');\n\nfunction Component(props) {\n  let x;\n  try {\n    const y = [];\n    y.push(props.y);\n    throwInput(y);\n  } catch (e) {\n    e.push(props.e);\n    x = e;\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{y: 'foo', e: 'bar'}],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with useImperativeHandle and useRef\nDESCRIPTION: This code represents an optimized version of the React component using the React compiler runtime.  It uses `_c` to memoize values. The `useImperativeHandle` hook's callback computes a value based on the component's props and ref values. The component also exports a `FIXTURE_ENTRYPOINT` constant, which configures the component's initial props for testing or demonstration purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useImperativeHandle-ref-mutate.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\n\nimport { useImperativeHandle, useRef } from \"react\";\n\nfunction Component(t0) {\n  const $ = _c(3);\n  const { prop } = t0;\n  const ref1 = useRef(null);\n  const ref2 = useRef(1);\n  let t1;\n  let t2;\n  if ($[0] !== prop) {\n    t1 = () => {\n      const precomputed = prop + ref2.current;\n      return { foo: () => prop + ref2.current + precomputed };\n    };\n\n    t2 = [prop];\n    $[0] = prop;\n    $[1] = t1;\n    $[2] = t2;\n  } else {\n    t1 = $[1];\n    t2 = $[2];\n  }\n  useImperativeHandle(ref1, t1, t2);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ prop: 1 }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Updated Hook Function with Compiler Runtime - JavaScript\nDESCRIPTION: This snippet showcases an updated implementation of the 'useHook' function leveraging the 'react/compiler-runtime'. It encapsulates state management within the helper method and makes use of conditionals to ensure that mutations reflect changes in parameter 'a'. The 'mutate' function is again employed to handle 'b', returning the most current state of 'a'. The 'FIXTURE_ENTRYPOINT' structure remains consistent for testing purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-renamed-ref.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { mutate } from \"shared-runtime\";\n\nfunction useHook(t0) {\n  const $ = _c(2);\n  const { a, b } = t0;\n  let t1;\n  if ($[0] !== a) {\n    t1 = { a };\n    $[0] = a;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  const z = t1;\n\n  const z_0 = { b };\n\n  mutate(z_0);\n  return z;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useHook,\n  params: [{ a: 2, b: 3 }],\n  sequentialRenders: [\n    { a: 2, b: 3 },\n    { a: 2, b: 3 },\n    { a: 2, b: 4 },\n    { a: 3, b: 4 },\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Managing Object State in React - JavaScript\nDESCRIPTION: This snippet illustrates object manipulation within a React component using JavaScript. The function Foo attempts to delete a property in an external object, which raises an InvalidReact error due to prohibited direct manipulation of external variables. React hooks or effects should be used to manage such state changes properly.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.mutate-property-from-global.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nlet wat = {};\n\nfunction Foo() {\n  delete wat.foo;\n  return wat;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining and Exporting a Component in JavaScript\nDESCRIPTION: This snippet demonstrates the creation of a component, its initialization, and export as a fixture entry point. It uses a function to define a component and assigns parameters for its export. The `component` function module provides a mock component structure with a local function invoking a method on the object `t`. The export constant `FIXTURE_ENTRYPOINT` specifies the component as 'TodoAdd'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-decl.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component(a) {\n  let t = {a};\n  function x() {\n    t.foo();\n  }\n  x(t);\n  return t;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Input React Component with FBT Internationalization\nDESCRIPTION: A React component using FBT for internationalization with enumeration and parameter components. The component conditionally renders 'hello' or 'goodbye' based on the props.value, and includes the value as a parameter.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-preserve-jsxtext.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport fbt from 'fbt';\n\nfunction Foo(props) {\n  return (\n    <fbt desc=\"Some text to be translated\">\n      <fbt:enum\n        enum-range={{'0': 'hello', '1': 'goodbye'}}\n        value={props.value ? '0' : '1'}\n      />{' '}\n      <fbt:param name=\"value\">{props.value}</fbt:param>\n      {', '}\n    </fbt>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{value: 1}],\n  sequentialRenders: [{value: 1}, {value: 0}],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with Compiler Runtime Memoization (Output)\nDESCRIPTION: Demonstrates the optimized `Component` function using `react/compiler-runtime`. It uses `_c` to create a cache ($) and checks if the cache is empty. If it is, the component renders and caches the result. Subsequent calls reuse the cached result, improving performance. This snippet relies on `react/compiler-runtime` and assumes `MaybeMutable` and `maybeMutate` are defined elsewhere.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/builtin-jsx-tag-lowered-between-mutations.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const maybeMutable = new MaybeMutable();\n    t0 = <div>{maybeMutate(maybeMutable)}</div>;\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Compiler Runtime in JavaScript\nDESCRIPTION: This JavaScript snippet shows an optimized version of a React component using compiler-runtime optimizations and state management techniques. The 'setValue' function is conditionally initialized based on a memoization sentinel, improving efficiency. It also demonstrates an alternative approach to managing state memoization via caching symbols.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inadvertent-mutability-readonly-lambda.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  const [, setValue] = useState(null);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = (e) => setValue((value_0) => value_0 + e.target.value);\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const onChange = t0;\n\n  useOtherHook();\n  let x;\n  if ($[1] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    x = {};\n    foo(x, onChange);\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  return x;\n}\n\n```\n\n----------------------------------------\n\nTITLE: React Component Definition with Hook and JSX\nDESCRIPTION: This code defines a React component that receives a `value` prop, renders it within nested `div` elements, and includes a `useHook` call. The component also creates an object `o` and assigns the `value` prop to it.  It exports the component as part of a `FIXTURE_ENTRYPOINT` object for testing or rendering.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/prune-scopes-whose-deps-invalidate-jsx.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useHook} from 'shared-runtime';\n\nfunction Component(props) {\n  const o = {};\n  const x = <div>{props.value}</div>; // create within the range of x to group with x\n  useHook(); // intersperse a hook call to prevent memoization of x\n  o.value = props.value;\n\n  const y = <div>{x}</div>;\n\n  return <div>{y}</div>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: 'sathya'}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: The compiled version of the component using React's compiler runtime for optimization. Implements memoization using Symbol.for('react.memo_cache_sentinel') to cache rendered results and avoid unnecessary re-renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/nonreactive-noescaping-dependency-can-inline-into-consuming-scope.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = (\n      <div\n        className={stylex(\n          flags.feature(\"feature-name\") ? styles.featureNameStyle : null,\n        )}\n      />\n    );\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with Object Declaration\nDESCRIPTION: Defines a basic React component function with conditional logic and exports a test fixture object. The fixture includes the component function reference, parameters array, and component identifier.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-args-test-binary-operator.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component(a, b) {\n  if (a > b) {\n    let m = {};\n  }\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Input React Components with Error Handler\nDESCRIPTION: Original React component definitions including an ErrorView component for error handling and a Renderer component with basic structure. Uses shared-runtime's Stringify component for error display.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/multi-arrow-expr-export-gating-test.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @gating\nimport {Stringify} from 'shared-runtime';\n\nconst ErrorView = (error, _retry) => <Stringify error={error}></Stringify>;\n\nexport const Renderer = props => (\n  <div>\n    <span></span>\n    <ErrorView></ErrorView>\n  </div>\n);\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: eval('Renderer'),\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Utility Bar Component for Rendering\nDESCRIPTION: A simple Bar component that renders its children alongside an x prop, demonstrating basic React component composition\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-outlining-simple.expect.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Bar({x, children}) {\n  return (\n    <>\n      {x}\n      {children}\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: Basic React component that destructures and processes props, demonstrating a simple state transformation using an identity function.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructure-object-assignment-to-context-var.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {identity} from 'shared-runtime';\n\nfunction Component(props) {\n  let x;\n  ({x} = props);\n  const foo = () => {\n    x = identity(props.x);\n  };\n  foo();\n  return {x};\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{x: 42}],\n};\n```\n\n----------------------------------------\n\nTITLE: Rendering Component in React with Function Invocation\nDESCRIPTION: This JavaScript snippet defines a React functional component that attempts to render the output of a function called 'notAhookTypedAsHook'. The component returns a JSX element containing the function's invocation result. Dependencies include the React library and a module named 'ReactCompilerTest'. Key input is the invocation of the function 'notAhookTypedAsHook', and output is its returned value inside a div element. The snippet's primary constraint is the expectation for 'notAhookTypedAsHook' to be a hook due to its naming convention, despite it not being one, causing a type configuration error.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-type-provider-nonhook-name-typed-as-hook.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport {notAhookTypedAsHook} from 'ReactCompilerTest';\n\nfunction Component() {\n  return <div>{notAhookTypedAsHook()}</div>;\n}\n```\n\n----------------------------------------\n\nTITLE: Input Implementation of useRelayData Hook\nDESCRIPTION: Original implementation of useRelayData hook that uses useFragment to process query data. The function takes query and idx parameters and returns a string representation of data at the specified index.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/relay-transitive-mixeddata.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useFragment} from 'shared-runtime';\n\n/**\n * React compiler should infer that the returned value is a primitive and avoid\n * memoizing it.\n */\nfunction useRelayData({query, idx}) {\n  'use memo';\n  const data = useFragment('', query);\n  return data.a[idx].toString();\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useRelayData,\n  params: [{query: '', idx: 0}],\n  sequentialRenders: [\n    {query: '', idx: 0},\n    {query: '', idx: 0},\n    {query: '', idx: 1},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining React Test Fixture with Variables and Logic in JavaScript\nDESCRIPTION: A JavaScript function 'foo' with variable declarations and conditional logic, along with a FIXTURE_ENTRYPOINT export for React testing. This fixture defines a function that is not a component and requires no parameters.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-single-if.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo() {\n  let x = 1;\n  let y = 2;\n\n  if (y) {\n    let z = x + y;\n  }\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Hoisting\nDESCRIPTION: This snippet shows the output of the React compiler applied to the `hoisting` function. It uses the `react/compiler-runtime` to manage component memoization and avoid unnecessary re-renders. The compiler transforms the function to use a cache and hoisted variable assignments.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-simple-let-declaration.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction hoisting() {\n  const $ = _c(1);\n  let foo;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    foo = () => bar + baz;\n\n    let bar;\n    bar = 3;\n    let baz;\n    baz = 2;\n    $[0] = foo;\n  } else {\n    foo = $[0];\n  }\n  return foo();\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: hoisting,\n  params: [],\n  isComponent: false,\n};\n\n```\n\n----------------------------------------\n\nTITLE: Implementing React Fixture with Empty Function\nDESCRIPTION: Defines an empty function 'foo' and exports it as a fixture entrypoint. The configuration specifies it's not a React component and has no parameters.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-simple.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo() {}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Initial React Component Function Implementation in JavaScript\nDESCRIPTION: This snippet shows the initial implementation of a React component function. It demonstrates conditional assignment and mutation of variables.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/primitive-alias-mutate.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component(a) {\n  let x = 'foo';\n  if (a) {\n    x = 'bar';\n  } else {\n    x = 'baz';\n  }\n  let y = x;\n  mutate(y);\n  return y;\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering and Memoization in React Component\nDESCRIPTION: This snippet demonstrates how to use memoization to optimize rendering in a React component. With the help of an imported memoization method from 'react/compiler-runtime', it checks for cached values before rendering the child component 'Child'. If a cache hit occurs, it reuses the previously rendered component, otherwise, it renders a new instance. This is encapsulated in 'FIXTURE_ENTRYPOINT' for export.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/quoted-strings-in-jsx-attribute-escaped.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nexport function Component() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = <Child text={'Some \\\\\"text\\\"'} />;\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nfunction Child(props) {\n  return props.text;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining Array Length Manipulation Test in JavaScript for React Compiler\nDESCRIPTION: This snippet defines a function 'useFoo' that creates an array, returns its length, and then sets it to zero. It's designed to test the React compiler's handling of property access and assignment order.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/evaluation-order-mutate-store-after-dependency-load.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n/**\n * Test that we preserve order of evaluation on the following case scope@0\n * ```js\n * // simplified HIR\n * scope@0\n *    ...\n *    $0 = arr.length\n *    $1 = arr.length = 0\n *\n * scope@1 <-- here we should depend on $0 (the value of the property load before the\n *             property store)\n *   [$0, $1]\n * ```\n */\nfunction useFoo(source: Array<number>): [number, number] {\n  const arr = [1, 2, 3, ...source];\n  return [arr.length, (arr.length = 0)];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [[5, 6]],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with compiler runtime and memoization\nDESCRIPTION: This snippet shows a react component, optimized using the react compiler. The component uses the `_c` function from `react/compiler-runtime` to manage memoization. It checks if a memoized value exists and reuses it, otherwise creates a new object using `makeObject_Primitives` and memoizes it for future use. The result of the object will only recompute if the dependencies of the compiler function change. `FIXTURE_ENTRYPOINT` is defined as an exported object.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-maybe-modified-later-dont-preserve-memoization-guarantees.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enablePreserveExistingMemoizationGuarantees:false\nimport { useMemo } from \"react\";\nimport { identity, makeObject_Primitives, mutate } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(2);\n  let t0;\n  let object;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = makeObject_Primitives();\n    object = t0;\n    identity(object);\n    $[0] = object;\n    $[1] = t0;\n  } else {\n    object = $[0];\n    t0 = $[1];\n  }\n  return object;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}]\n};\n\n```\n\n----------------------------------------\n\nTITLE: Invalidating React Hook Invocation\nDESCRIPTION: Demonstrates an incorrect method of calling React hooks inside a try-catch block, which breaks the fundamental rules of hook usage\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.error.rules-of-hooks-e29c874aa913.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction useHook() {\n  try {\n    f();\n    useState();\n  } catch {}\n}\n```\n\n----------------------------------------\n\nTITLE: React Component with useMemo\nDESCRIPTION: This snippet defines a React component `Component` that uses `useMemo` to memoize an object based on the values of `propA` and `propB.x.y`. It imports `useMemo` from 'react' and `identity` from 'shared-runtime'. The component returns a memoized object with `value` (derived from `propB?.x.y`) and `other` (equal to `propA`).\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useMemo-conditional-access-alloc.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees\nimport {useMemo} from 'react';\nimport {identity} from 'shared-runtime';\n\nfunction Component({propA, propB}) {\n  return useMemo(() => {\n    return {\n      value: identity(propB?.x.y),\n      other: propA,\n    };\n  }, [propA, propB.x.y]);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{propA: 2, propB: {x: {y: []}}}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiler-Transformed React Component with Memoization\nDESCRIPTION: The same React component after being processed by the React compiler. It uses the memo cache system to optimize rendering by memoizing the component's state values.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reassign-primitive-in-context.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(1);\n  let x;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    x = 5;\n    const foo = () => {\n      x = {};\n    };\n\n    foo();\n    $[0] = x;\n  } else {\n    x = $[0];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component Definition with Conditional Rendering\nDESCRIPTION: Defines a React functional component `MyApp` that conditionally returns `undefined` (implicitly) based on the value of the `cond` prop. If `props.cond` is truthy, the component returns nothing, otherwise, it would continue execution. This version demonstrates an issue where a variable would be assigned only conditionally.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/early-return.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction MyApp(props) {\n  let res;\n  if (props.cond) {\n    return;\n  } else {\n    res = 1;\n  }\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: MyApp,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n\n```\n\n----------------------------------------\n\nTITLE: Enhanced Function Foo with Memo Cache Handling - JavaScript\nDESCRIPTION: This snippet enhances the previous definition of function 'Foo'. It now includes memoization support using the '_c' function from 'react/compiler-runtime'. Based on a condition, it decides whether to create a new object or use a cached value. It retains the mutation logic if 'CONST_TRUE' is true, and handles exceptions silently. Dependencies include 'CONST_TRUE', 'makeObject_Primitives', and '_c'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/align-scopes-trycatch-nested-overlapping-range.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { CONST_TRUE, makeObject_Primitives } from \"shared-runtime\";\n\nfunction Foo() {\n  const $ = _c(1);\n  try {\n    let thing;\n    if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n      thing = null;\n      if (cond) {\n        thing = makeObject_Primitives();\n      }\n      if (CONST_TRUE) {\n        mutate(thing);\n      }\n      $[0] = thing;\n    } else {\n      thing = $[0];\n    }\n    return thing;\n  } catch {}\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Input React Hook Implementation\nDESCRIPTION: Original implementation of a React hook that returns either an object with getValue method or a number based on a condition. Uses createHookWrapper for testing purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-literal-method-in-ternary-consequent.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {createHookWrapper} from 'shared-runtime';\n\nfunction useHook({isCond, value}) {\n  return isCond\n    ? {\n        getValue() {\n          return value;\n        },\n      }\n    : 42;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: createHookWrapper(useHook),\n  params: [{isCond: true, value: 0}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Function foo\nDESCRIPTION: This snippet defines a function foo which executes a recursive call based on the value of x and returns an array with y multiplied by 10. No external dependencies are specified. The function accepts two parameters: x and y, where x dictates conditional recursion, and it returns an array containing the product of y and 10.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/simple.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nexport default function foo(x, y) {\n  if (x) {\n    return foo(false, y);\n  }\n  return [y * 10];\n}\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: Compiled version of the component with React compiler runtime optimizations. Includes memoization for props.value spreading and maintains the same functionality as the input version.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-in-statement-continue.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  let x;\n  let t0;\n  if ($[0] !== props.value) {\n    t0 = { ...props.value };\n    $[0] = props.value;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const object = t0;\n  for (const y in object) {\n    if (y === \"continue\") {\n      continue;\n    }\n\n    x = object[y];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ value: { a: \"a\", continue: \"skip\", b: \"hello!\" } }],\n  sequentialRenders: [\n    { value: { a: \"a\", continue: \"skip\", b: \"hello!\" } },\n    { value: { a: \"a\", continue: \"skip\", b: \"hello!\" } },\n    { value: { a: \"skip!\", continue: true } },\n    { value: { a: \"a\", continue: \"skip\", b: \"hello!\" } },\n    { value: { a: \"skip!\", continue: true } },\n    { value: { a: \"a\", continue: \"skip\", b: \"hello!\" } },\n    { value: { a: \"skip!\", continue: true } },\n    { value: { a: \"skip!\", continue: true } },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with useInsertionEffect\nDESCRIPTION: This React component `Component` utilizes the `useInsertionEffect` hook to perform side effects. The effect depends on a `data` object, which is newly created on each render and thus cannot be memoized, which triggers a warning from the React Compiler. The `mutate` function is called on the `data` object after the effect is executed.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-useInsertionEffect-dep-not-memoized.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validateMemoizedEffectDependencies\nimport {useInsertionEffect} from 'react';\n\nfunction Component(props) {\n  const data = {};\n  useInsertionEffect(() => {\n    console.log(props.value);\n  }, [data]);\n  mutate(data);\n  return data;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: Optimized version of the component using React's compiler runtime for memoization. Implements caching logic using Symbol.for() checks and a compiler runtime utility.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/function-expression-captures-value-later-frozen-jsx.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(3);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = {};\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const x = t0;\n  let t1;\n  if ($[1] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = (e) => {\n      maybeMutate(x, e.target.value);\n    };\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  const onChange = t1;\n  if (props.cond) {\n  }\n  let t2;\n  if ($[2] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t2 = <Foo value={x} onChange={onChange} />;\n    $[2] = t2;\n  } else {\n    t2 = $[2];\n  }\n  return t2;\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Object References with 'const' in React Component\nDESCRIPTION: This snippet shows object reference assignment using 'const' variable declarations in a React component function. It creates multiple objects with constant references and assigns properties between them before calling a 'mutate' function.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transitive-alias-fields.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component() {\n  const x = {};\n  const p = {};\n  const q = {};\n  const y = {};\n\n  x.y = y;\n  p.y = x.y;\n  q.y = p.y;\n\n  mutate(q);\n}\n```\n\n----------------------------------------\n\nTITLE: Original Function Implementation in JavaScript\nDESCRIPTION: A simple JavaScript function that creates an array and an object, assigns the array to a property of the object, and returns the object. The function is exported as part of a FIXTURE_ENTRYPOINT object.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-property.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo() {\n  const x = [];\n  const y = {};\n  y.x = x;\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component with Inferred Effect Dependencies\nDESCRIPTION: A React component demonstrating how the compiler handles setState as a stable reference in useEffect. This example shows the input code before compilation, where the effect dependency array is intentionally omitted.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/nonreactive-setState.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @inferEffectDependencies\nimport {useEffect, useState} from 'react';\nimport {print} from 'shared-runtime';\n\n/**\n * Special case of `infer-effect-deps/nonreactive-dep`.\n *\n * We know that local `useRef` return values are stable, regardless of\n * inferred memoization.\n */\nfunction NonReactiveSetStateInEffect() {\n  const [_, setState] = useState('initial value');\n  useEffect(() => print(setState));\n}\n```\n\n----------------------------------------\n\nTITLE: Defining and Managing React Component Reactivity - JavaScript\nDESCRIPTION: This snippet defines a React component function that takes props and performs state manipulation to achieve reactive behavior. The component uses arrays to interleave state changes, thereby introducing reactivity by monitoring control values. No external dependencies other than React are required. Inputs include props with a 'cond' property, and outputs are reactive states represented by variable 'x'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-from-interleaved-reactivity-switch.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  // a and b are independent but their mutations are interleaved, so\n  // they get grouped in a reactive scope. this means that a becomes\n  // reactive since it will effectively re-evaluate based on a reactive\n  // input\n  const a = [];\n  const b = [];\n  b.push(props.cond);\n  a.push(null);\n\n  // Downstream consumer of a, which initially seems non-reactive except\n  // that a becomes reactive, per above\n  const c = [a];\n\n  let x;\n  switch (c[0][0]) {\n    case true: {\n      x = 1;\n      break;\n    }\n    default: {\n      x = 2;\n    }\n  }\n  // The values assigned to `x` are non-reactive, but the value of `x`\n  // depends on the \"control\" value `c[0]` which becomes reactive via\n  // being interleaved with `b`.\n  // Therefore x should be treated as reactive too.\n  return [x];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{cond: true}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Default Parameters\nDESCRIPTION: This snippet defines a React component named 'Component' with default parameters. It also exports a FIXTURE_ENTRYPOINT object for testing or demonstration purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/function-param-assignment-pattern.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(x = 'default', y = [{}]) {\n  return [x, y];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Input Hook Function with useState in React\nDESCRIPTION: The original React hook function that uses useState and returns an array containing just the state value. Note that the update function from useState is ignored with an underscore.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-functions-hook-with-hook-call.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @compilationMode(infer)\nfunction useStateValue(props) {\n  const [state, _] = useState(null);\n  return [state];\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: Compiled version of the React component with added memoization logic and transformed FBT calls. Includes symbol-based caching mechanism and early return optimization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-no-value-for-temporary-reactive-scope-with-early-return.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { identity, makeObject_Primitives } from \"shared-runtime\";\nimport fbt from \"fbt\";\n\nfunction Component(props) {\n  const $ = _c(2);\n  let t0;\n  let t1;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = Symbol.for(\"react.early_return_sentinel\");\n    bb0: {\n      const object = makeObject_Primitives();\n      const cond = makeObject_Primitives();\n      if (!cond) {\n        t1 = null;\n        break bb0;\n      }\n\n      t0 = (\n        <div className=\"foo\">\n          {fbt._(\n            \"Lorum ipsum{thing} blah blah blah\",\n            [fbt._param(\"thing\", object.b)],\n            { hk: \"lwmuH\" },\n          )}\n        </div>\n      );\n    }\n    $[0] = t0;\n    $[1] = t1;\n  } else {\n    t0 = $[0];\n    t1 = $[1];\n  }\n  if (t1 !== Symbol.for(\"react.early_return_sentinel\")) {\n    return t1;\n  }\n  return t0;\n}\n```\n\n----------------------------------------\n\nTITLE: Original JavaScript Function with Loop and Conditional Logic\nDESCRIPTION: The input JavaScript function that initializes an empty array, iterates through it, and conditionally assigns a value based on a condition parameter. This represents code before React compiler transformation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-for-of.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(cond) {\n  let items = [];\n  for (const item of items) {\n    let y = 0;\n    if (cond) {\n      y = 1;\n    }\n  }\n  return items;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Validating Conditional Hook Calls in JavaScript\nDESCRIPTION: This snippet defines a function 'useHook' which illustrates incorrect usage of the useState hook by calling it conditionally based on an external variable 'a'. The intended rule is that hooks must always be called at the top level of a React component. This validation is important to maintain the rules set by React to ensure reliable and predictable behavior of hooks.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-rules-of-hooks-c906cace44e9.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Expected to fail\n\n// Invalid because it's dangerous and might not warn otherwise.\n// This *must* be invalid.\nfunction useHook() {\n  if (a) return;\n  useState();\n}\n\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: Shows the original component implementation that creates nested objects with property dependencies on props.a. The component creates scoped objects x and y with properties derived from props.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/merge-nested-scopes-with-same-inputs.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {setProperty} from 'shared-runtime';\n\nfunction Component(props) {\n  // start of scope for y, depend on props.a\n  let y = {};\n\n  // nested scope for x, dependent on props.a\n  const x = {};\n  setProperty(x, props.a);\n  // end of scope for x\n\n  y.a = props.a;\n  y.x = x;\n  // end of scope for y\n\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{a: 42}],\n};\n```\n\n----------------------------------------\n\nTITLE: Building and Testing Release Script - Shell\nDESCRIPTION: This script is responsible for building and testing the React DevTools release. It should be executed in a terminal to ensure everything functions correctly before publishing.\nSOURCE: https://github.com/facebook/react/blob/main/scripts/devtools/README.md#2025-04-21_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\n./build-and-test.js\n```\n\n----------------------------------------\n\nTITLE: Implementing Error Handling in a React Component - JavaScript\nDESCRIPTION: This snippet demonstrates the use of nested try-catch blocks within a React component to manage potential errors when accessing props. It imports an identity function from a shared runtime, applies it to a prop, and handles errors with a fallback rendering and logging mechanism. The snippet requires React and assumes the availability of the identity function. Inputs are component props and outputs are rendered JSX elements or logs. Limitations include the absence of a catch clause handling for the outer try block.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-invalid-jsx-in-catch-in-outer-try-with-finally.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validateNoJSXInTryStatements\nimport {identity} from 'shared-runtime';\n\nfunction Component(props) {\n  let el;\n  try {\n    let value;\n    try {\n      value = identity(props.foo);\n    } catch {\n      el = <div value={value} />;\n    }\n  } finally {\n    console.log(el);\n  }\n  return el;\n}\n\n```\n\n----------------------------------------\n\nTITLE: React Component with Memoization (Code)\nDESCRIPTION: This snippet defines a React component with memoization using `react/compiler-runtime`. It checks if the props have changed since the last render using the `_c` helper. If the props are different, the component re-computes `items` based on the conditional logic, including pushing the `props.a` value, updates the memoized values, and returns the result. Otherwise, it returns the memoized `items` value to avoid re-renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/iife-return-modified-later-phi.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(3);\n  let items;\n  if ($[0] !== props.a || $[1] !== props.cond) {\n    let t0;\n    if (props.cond) {\n      t0 = [];\n    } else {\n      t0 = null;\n    }\n    items = t0;\n\n    items?.push(props.a);\n    $[0] = props.a;\n    $[1] = props.cond;\n    $[2] = items;\n  } else {\n    items = $[2];\n  }\n  return items;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ a: {} }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Input Component Definition with Arrow Function Default\nDESCRIPTION: Original React component definition using an arrow function as a default parameter value for x. Exports a fixture entrypoint for testing purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/default-param-with-empty-callback.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(x = () => {}) {\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Memoization\nDESCRIPTION: This snippet shows the compiled and optimized version of the React component. It implements memoization techniques to improve performance by caching computed values and minimizing re-renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/merge-consecutive-scopes-objects.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useState } from \"react\";\nimport { Stringify } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(11);\n  const [state, setState] = useState(0);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = { component: Stringify, props: { text: \"Counter\" } };\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  let t1;\n  if ($[1] !== state) {\n    t1 = { component: \"span\", props: { children: [state] } };\n    $[1] = state;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  let t2;\n  if ($[3] !== state) {\n    t2 = () => setState(state + 1);\n    $[3] = state;\n    $[4] = t2;\n  } else {\n    t2 = $[4];\n  }\n  let t3;\n  if ($[5] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t3 = [\"increment\"];\n    $[5] = t3;\n  } else {\n    t3 = $[5];\n  }\n  let t4;\n  if ($[6] !== t2) {\n    t4 = {\n      component: \"button\",\n      props: { \"data-testid\": \"button\", onClick: t2, children: t3 },\n    };\n    $[6] = t2;\n    $[7] = t4;\n  } else {\n    t4 = $[7];\n  }\n  let t5;\n  if ($[8] !== t1 || $[9] !== t4) {\n    t5 = [t0, t1, t4];\n    $[8] = t1;\n    $[9] = t4;\n    $[10] = t5;\n  } else {\n    t5 = $[10];\n  }\n  return t5;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: React Error: Invalid React Ref Access During Render\nDESCRIPTION: This error message highlights a critical rule in React: you should not access or modify ref values during the render phase. The provided traceback pinpoints the exact line of code that violates this rule. The error message includes a link to the React documentation to explain why modifying ref values during render is forbidden.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.ref-initialization-linear.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n   6 |   if (r.current == null) {\n   7 |     r.current = 42;\n>  8 |     r.current = 42;\n     |     ^^^^^^^^^ InvalidReact: Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef) (8:8)\n   9 |   }\n  10 | }\n  11 |\n```\n\n----------------------------------------\n\nTITLE: React component using useMemo with invalid argument\nDESCRIPTION: This code defines a React component that uses the useMemo hook. The callback function passed to useMemo incorrectly accepts an argument 'c', which causes an ESLint error because the dependency array is empty. This indicates that the memoized value should only be calculated once, and the callback shouldn't rely on any changing values.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-useMemo-callback-args.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component(a, b) {\n  let x = useMemo(c => a, []);\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing React Component with Nullthrows Behavior in JavaScript\nDESCRIPTION: This snippet defines a React component that utilizes the `props.a` as a core dependency while `props.a.b` is used conditionally. It demonstrates handling of potentially null or undefined properties using optional chaining. The component aggregates values into an array and returns it. Dependencies include an environment capable of executing JavaScript with support for React components.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/conditional-member-expr.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n```javascript\n// To preserve the nullthrows behavior and reactive deps of this code,\n// Forget needs to add `props.a` as a dependency (since `props.a.b` is\n// a conditional dependency, i.e. gated behind control flow)\n\nfunction Component(props) {\n  let x = [];\n  x.push(props.a?.b);\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{a: null}],\n};\n\n```\n```\n\n----------------------------------------\n\nTITLE: Exporting a Constant Object in JavaScript\nDESCRIPTION: This snippet exports a constant object 'FIXTURE_ENTRYPOINT' that contains a reference to the 'foo' function and parameters for usage in other parts of the application as a component entry point.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/while-conditional-continue.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Output: Compiled React Code with Memoization for Lambda Functions\nDESCRIPTION: Compiled version of the React code showing how the compiler optimizes lambda functions through memoization. It uses internal caching to avoid recreating function references when dependencies haven't changed.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/array-map-named-chained-callbacks.expect.md#2025-04-22_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; /**\n * Forked from array-map-simple.js\n *\n * Here, getVal1 has a known callsite in `cb1`, but `cb1` isn't known to be\n * called (it's only passed to array.map). In this case, we should be\n * conservative and assume that all named lambdas are conditionally called.\n */\nfunction useFoo(t0) {\n  const $ = _c(17);\n  const { arr1, arr2 } = t0;\n  let t1;\n  if ($[0] !== arr1[0]) {\n    t1 = () => arr1[0].value;\n    $[0] = arr1[0];\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  const getVal1 = t1;\n  let t2;\n  if ($[2] !== getVal1) {\n    t2 = (e) => getVal1() + e.value;\n    $[2] = getVal1;\n    $[3] = t2;\n  } else {\n    t2 = $[3];\n  }\n  const cb1 = t2;\n  let t3;\n  if ($[4] !== arr1 || $[5] !== cb1) {\n    t3 = arr1.map(cb1);\n    $[4] = arr1;\n    $[5] = cb1;\n    $[6] = t3;\n  } else {\n    t3 = $[6];\n  }\n  const x = t3;\n  let t4;\n  if ($[7] !== arr2) {\n    t4 = () => arr2[0].value;\n    $[7] = arr2;\n    $[8] = t4;\n  } else {\n    t4 = $[8];\n  }\n  const getVal2 = t4;\n  let t5;\n  if ($[9] !== getVal2) {\n    t5 = (e_0) => getVal2() + e_0.value;\n    $[9] = getVal2;\n    $[10] = t5;\n  } else {\n    t5 = $[10];\n  }\n  const cb2 = t5;\n  let t6;\n  if ($[11] !== arr1 || $[12] !== cb2) {\n    t6 = arr1.map(cb2);\n    $[11] = arr1;\n    $[12] = cb2;\n    $[13] = t6;\n  } else {\n    t6 = $[13];\n  }\n  const y = t6;\n  let t7;\n  if ($[14] !== x || $[15] !== y) {\n    t7 = [x, y];\n    $[14] = x;\n    $[15] = y;\n    $[16] = t7;\n  } else {\n    t7 = $[16];\n  }\n  return t7;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ arr1: [], arr2: [] }],\n  sequentialRenders: [\n    { arr1: [], arr2: [] },\n    { arr1: [], arr2: null },\n    { arr1: [{ value: 1 }, { value: 2 }], arr2: [{ value: -1 }] },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Ternary Operator in React Component\nDESCRIPTION: This JavaScript code defines a React component named `ternary` that takes `props` as input. Inside the component, a ternary operator is used to conditionally assign values to the variable `x` based on the value of `props.a`. The component then returns the sum of `x` and `y`. The `FIXTURE_ENTRYPOINT` object exports the component and its configuration for testing or usage elsewhere.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ternary-assignment-expression.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction ternary(props) {\n  let x;\n  const y = props.a ? (x = 1) : (x = 2);\n  return x + y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: ternary,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Original Object Allocation and Mutation Loop\nDESCRIPTION: Shows a function that creates three objects and cyclically swaps their references in a while loop, with mutations occurring between swaps. The function demonstrates a pattern of object allocation and reference manipulation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/alias-while.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(cond) {\n  let a = {};\n  let b = {};\n  let c = {};\n  while (cond) {\n    let z = a;\n    a = b;\n    b = c;\n    c = z;\n    mutate(a, b);\n  }\n  a;\n  b;\n  c;\n  return a;\n}\n\nfunction mutate(x, y) {}\n```\n\n----------------------------------------\n\nTITLE: Invalid Conditional Hook Usage in React Component\nDESCRIPTION: Example of incorrect React hook implementation using optional chaining operator which violates the Rules of Hooks. The code demonstrates a pattern that would cause runtime errors as hooks must be called in a consistent order.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-hook-optionalcall.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component() {\n  const {result} = useConditionalHook?.() ?? {};\n  return result;\n}\n```\n\nLANGUAGE: plaintext\nCODE:\n```\n  1 | function Component() {\n> 2 |   const {result} = useConditionalHook?.() ?? {};\n    |                    ^^^^^^^^^^^^^^^^^^ InvalidReact: Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning) (2:2)\n  3 |   return result;\n  4 | }\n  5 |\n```\n\n----------------------------------------\n\nTITLE: Defining a React Component with Hook and Fixture Testing - JavaScript\nDESCRIPTION: Similar to its previously defined counterpart, this React Component uses the useHook function to influence the instance memory and property assignment. It showcases a consistent structural design to the prior snippet, defining the use of hooks and Export scaffold in a concise JavaScript manner. The FIXTURE_ENTRYPOINT serves as a test scaffold, using similar parameters to reflect the test-oriented design template of the code sample.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/prune-scopes-whose-deps-invalidate-new.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useHook } from \"shared-runtime\";\n\nfunction Component(props) {\n  const x = new Foo();\n  useHook();\n  x.value = props.value;\n\n  const y = { x };\n  return { y };\n}\n\nclass Foo {}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ value: \"sathya\" }],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Output for useFoo Custom Hook\nDESCRIPTION: This snippet shows the React compiler output for the useFoo custom hook. It includes memoization logic using the _c function and optimizes re-renders based on prop changes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/global-types/set-copy-constructor-mutate.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { makeArray, mutate } from \"shared-runtime\";\n\nfunction useFoo(t0) {\n  const $ = _c(6);\n  const { propArr } = t0;\n  let s1;\n  let s2;\n  if ($[0] !== propArr[0]) {\n    s1 = new Set([1, 2, 3]);\n    s1.add(makeArray(propArr[0]));\n\n    s2 = new Set(s1);\n\n    mutate(s2);\n    $[0] = propArr[0];\n    $[1] = s1;\n    $[2] = s2;\n  } else {\n    s1 = $[1];\n    s2 = $[2];\n  }\n  let t1;\n  if ($[3] !== s1 || $[4] !== s2) {\n    t1 = [s1, s2];\n    $[3] = s1;\n    $[4] = s2;\n    $[5] = t1;\n  } else {\n    t1 = $[5];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ propArr: [7, 8, 9] }],\n  sequentialRenders: [\n    { propArr: [7, 8, 9] },\n    { propArr: [7, 8, 9] },\n    { propArr: [7, 8, 10] },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Reactive Component with Compiler Runtime in JavaScript\nDESCRIPTION: This JavaScript snippet implements a Reactive style Component with optional chaining. It includes an import from the 'react/compiler-runtime' which suggests a custom React compiler setup. The function compares and stores component state efficiently, minimizing recalculation. This relies on JavaScript optional chaining and state management in a reactive paradigm.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-member-expression-chain.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // Note that `a?.b.c` is semantically different from `(a?.b).c`\n// We should codegen the correct member expressions\nfunction Component(props) {\n  const $ = _c(3);\n  const x = props?.b.c;\n  const y = props?.b.c.d?.e.f.g?.h;\n  let t0;\n  if ($[0] !== x || $[1] !== y) {\n    t0 = { x, y };\n    $[0] = x;\n    $[1] = y;\n    $[2] = t0;\n  } else {\n    t0 = $[2];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Compiler Error for Invalid Hook Usage\nDESCRIPTION: Error output from the React compiler showing that labeled statements combined with value blocks (conditional, logical, optional chaining) are not supported with hooks.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-useMemo-with-optional.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n  1 | function Component(props) {\n  2 |   return (\n> 3 |     useMemo(() => {\n    |     ^^^^^^^^^^^^^^^\n> 4 |       return [props.value];\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 5 |     }) || []\n    | ^^^^^^^^^^^^^ Todo: Support labeled statements combined with value blocks (conditional, logical, optional chaining, etc) (3:5)\n  6 |   );\n  7 | }\n  8 |\n\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Conditional Refs in JavaScript\nDESCRIPTION: This snippet provides an optimized version, using a caching mechanism for component rendering by utilizing variables such as '$'. It mimics the earlier React component using conditional refs, but improves performance by reducing unnecessary renders through caching previous computations. Dependencies are imported similarly from React libraries. It processes inputs and renders based on cached refs, reducing render overhead.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-ref.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useRef } from \"react\";\nimport { Stringify } from \"shared-runtime\";\n\n/**\n * Fixture showing that Ref types may be reactive.\n * We should always take a dependency on ref values (the outer box) as\n * they may be reactive. Pruning should be done in\n * `pruneNonReactiveDependencies`\n */\nfunction Component(t0) {\n  const $ = _c(4);\n  const { cond } = t0;\n  const ref1 = useRef(1);\n  const ref2 = useRef(2);\n  const ref = cond ? ref1 : ref2;\n  let t1;\n  if ($[0] !== ref) {\n    t1 = () => ref.current;\n    $[0] = ref;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  const cb = t1;\n  let t2;\n  if ($[2] !== cb) {\n    t2 = <Stringify cb={cb} shouldInvokeFns={true} />;\n    $[2] = cb;\n    $[3] = t2;\n  } else {\n    t2 = $[3];\n  }\n  return t2;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ cond: true }],\n  sequentialRenders: [{ cond: true }, { cond: false }],\n};\n```\n\n----------------------------------------\n\nTITLE: Input Functional Component with Shallow Copy and Mutation\nDESCRIPTION: Original implementation of useFoo function demonstrating shallow copying of nested objects and function creation with closure\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/infer-nested-function-uncond-access-local-var.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction useFoo({a}: {a: {b: {c: number}}}) {\n  const local = shallowCopy(a);\n  mutate(local);\n  const fn = () => [() => local.b.c];\n  return <Stringify fn={fn} shouldInvokeFns={true} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Hook and Memoization\nDESCRIPTION: This is the compiled version of the React component `SomeName`. It uses `react/compiler-runtime` and attempts to memoize the rendered fragment using a Symbol as a cache sentinel. The component also calls the custom hook `useSomeHook` and conditionally returns `null` if `anyConditionCanEvenBeFalse` is true.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.bail.rules-of-hooks-6949b255e7eb.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @skip\n// Unsupported input\n\n// Valid because the neither the conditions before or after the hook affect the hook call\n// Failed prior to implementing BigInt because pathsFromStartToEnd and allPathsFromStartToEnd were too big and had rounding errors\nconst useSomeHook = () => {};\n\nconst SomeName = () => {\n  const $ = _c(1);\n  (FILLER ?? FILLER, FILLER) ?? FILLER;\n  (FILLER ?? FILLER, FILLER) ?? FILLER;\n  (FILLER ?? FILLER, FILLER) ?? FILLER;\n  (FILLER ?? FILLER, FILLER) ?? FILLER;\n  (FILLER ?? FILLER, FILLER) ?? FILLER;\n  (FILLER ?? FILLER, FILLER) ?? FILLER;\n  (FILLER ?? FILLER, FILLER) ?? FILLER;\n  (FILLER ?? FILLER, FILLER) ?? FILLER;\n\n  useSomeHook();\n  if (anyConditionCanEvenBeFalse) {\n    return null;\n  }\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = (\n      <React.Fragment>\n        {FILLER ? FILLER : FILLER}\n        {FILLER ? FILLER : FILLER}\n        {FILLER ? FILLER : FILLER}\n        {FILLER ? FILLER : FILLER}\n        {FILLER ? FILLER : FILLER}\n        {FILLER ? FILLER : FILLER}\n        {FILLER ? FILLER : FILLER}\n        {FILLER ? FILLER : FILLER}\n        {FILLER ? FILLER : FILLER}\n        {FILLER ? FILLER : FILLER}\n        {FILLER ? FILLER : FILLER}\n        {FILLER ? FILLER : FILLER}\n        {FILLER ? FILLER : FILLER}\n        {FILLER ? FILLER : FILLER}\n        {FILLER ? FILLER : FILLER}\n        {FILLER ? FILLER : FILLER}\n        {FILLER ? FILLER : FILLER}\n        {FILLER ? FILLER : FILLER}\n        {FILLER ? FILLER : FILLER}\n        {FILLER ? FILLER : FILLER}\n        {FILLER ? FILLER : FILLER}\n        {FILLER ? FILLER : FILLER}\n        {FILLER ? FILLER : FILLER}\n        {FILLER ? FILLER : FILLER}\n        {FILLER ? FILLER : FILLER}\n        {FILLER ? FILLER : FILLER}\n        {FILLER ? FILLER : FILLER}\n        {FILLER ? FILLER : FILLER}\n        {FILLER ? FILLER : FILLER}\n        {FILLER ? FILLER : FILLER}\n        {FILLER ? FILLER : FILLER}\n        {FILLER ? FILLER : FILLER}\n        {FILLER ? FILLER : FILLER}\n        {FILLER ? FILLER : FILLER}\n        {FILLER ? FILLER : FILLER}\n        {FILLER ? FILLER : FILLER}\n        {FILLER ? FILLER : FILLER}\n        {FILLER ? FILLER : FILLER}\n        {FILLER ? FILLER : FILLER}\n        {FILLER ? FILLER : FILLER}\n        {FILLER ? FILLER : FILLER}\n        {FILLER ? FILLER : FILLER}\n      </React.Fragment>\n    );\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n};\n\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Memoization\nDESCRIPTION: This snippet shows an optimized version of the React component using memoization. It uses a compiler-generated array to cache previous prop values and results, improving performance by avoiding unnecessary re-computations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/conditional-break-labeled.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; /**\n * props.b *does* influence `a`\n */\nfunction Component(props) {\n  const $ = _c(5);\n  let a;\n  if (\n    $[0] !== props.a ||\n    $[1] !== props.b ||\n    $[2] !== props.c ||\n    $[3] !== props.d\n  ) {\n    a = [];\n    a.push(props.a);\n    bb0: {\n      if (props.b) {\n        break bb0;\n      }\n\n      a.push(props.c);\n    }\n\n    a.push(props.d);\n    $[0] = props.a;\n    $[1] = props.b;\n    $[2] = props.c;\n    $[3] = props.d;\n    $[4] = a;\n  } else {\n    a = $[4];\n  }\n  return a;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized Compiler Output\nDESCRIPTION: Transformed and optimized version of the component with memoization using an array-based caching mechanism for computed values\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/allow-props-named-like-hooks.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { Stringify } from \"shared-runtime\";\n\nfunction Component(t0) {\n  const $ = _c(8);\n  const { useFeature } = t0;\n  let x;\n  if (useFeature) {\n    const t1 = useFeature + useFeature;\n    let t2;\n    if ($[0] !== t1 || $[1] !== useFeature) {\n      t2 = [t1].push(-useFeature);\n      $[0] = t1;\n      $[1] = useFeature;\n      $[2] = t2;\n    } else {\n      t2 = $[2];\n    }\n    x = t2;\n  }\n\n  const y = useFeature;\n  const z = useFeature.useProperty;\n  let t1;\n  if ($[3] !== useFeature || $[4] !== x || $[5] !== y || $[6] !== z) {\n    t1 = (\n      <Stringify val={useFeature}>\n        {x}\n        {y}\n        {z}\n      </Stringify>\n    );\n    $[3] = useFeature;\n    $[4] = x;\n    $[5] = y;\n    $[6] = z;\n    $[7] = t1;\n  } else {\n    t1 = $[7];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ useFeature: { useProperty: true } }],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: Compiler-transformed version of the component that includes memoization logic using an array of cached values. The code checks for prop changes and reuses cached functions and render results when possible.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/function-expression-prototype-call.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(4);\n  let t0;\n  if ($[0] !== props) {\n    t0 = function () {\n      return <div>{props.name}</div>;\n    };\n    $[0] = props;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const f = t0;\n  let t1;\n  if ($[2] !== f) {\n    t1 = f.call();\n    $[2] = f;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ name: \"Jason\" }],\n};\n```\n\n----------------------------------------\n\nTITLE: Initializing React Component with Memoized Dependency\nDESCRIPTION: Demonstrates a React function component using useMemo with complex dependency inference and mutation. The example highlights potential challenges in automatic memoization optimization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.useMemo-unrelated-mutation-in-depslist.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees\n\nimport {useMemo} from 'react';\n\nfunction useFoo(input1) {\n  const x = {};\n  const y = [input1];\n  const memoized = useMemo(() => {\n    return [y];\n  }, [(mutate(x), y)]);\n\n  return [x, memoized];\n}\n```\n\n----------------------------------------\n\nTITLE: Optimizing React Component with Memoization - JavaScript\nDESCRIPTION: This snippet enhances a React component with memoization to prevent unnecessary re-renders based on prop values. It utilizes the React compiler runtime for caching and early return logic, allowing it to optimize performance. The code checks if input properties have changed and manages state accordingly, providing an expected output from various prop combinations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/early-return-nested-early-return-within-reactive-scope.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(7);\n  let t0;\n  if ($[0] !== props.a || $[1] !== props.b || $[2] !== props.cond) {\n    t0 = Symbol.for(\"react.early_return_sentinel\");\n    bb0: {\n      const x = [];\n      if (props.cond) {\n        x.push(props.a);\n        if (props.b) {\n          let t1;\n          if ($[4] !== props.b) {\n            t1 = [props.b];\n            $[4] = props.b;\n            $[5] = t1;\n          } else {\n            t1 = $[5];\n          }\n          const y = t1;\n          x.push(y);\n          t0 = x;\n          break bb0;\n        }\n\n        t0 = x;\n        break bb0;\n      } else {\n        let t1;\n        if ($[6] === Symbol.for(\"react.memo_cache_sentinel\")) {\n          t1 = foo();\n          $[6] = t1;\n        } else {\n          t1 = $[6];\n        }\n        t0 = t1;\n        break bb0;\n      }\n    }\n    $[0] = props.a;\n    $[1] = props.b;\n    $[2] = props.cond;\n    $[3] = t0;\n  } else {\n    t0 = $[3];\n  }\n  if (t0 !== Symbol.for(\"react.early_return_sentinel\")) {\n    return t0;\n  }\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ cond: true, a: 42, b: 3.14 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Hook useFoo with Memoization\nDESCRIPTION: This code presents the compiled version of the `useFoo` React hook, utilizing React's compiler runtime (`react/compiler-runtime`). It employs memoization techniques using the `_c` function to optimize rendering. The compiled code checks if the input `a` has changed and, if so, re-executes the hook's logic. It also memoizes the callback function `cb` using a similar pattern, storing and reusing the function if the length of `obj_alias.arr` hasn't changed.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/bug-aliased-capture-mutate.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { setPropertyByKey, Stringify } from \"shared-runtime\";\n\nfunction useFoo(t0) {\n  const $ = _c(4);\n  const { a } = t0;\n  let t1;\n  if ($[0] !== a) {\n    const arr = [];\n    const obj = { value: a };\n\n    setPropertyByKey(obj, \"arr\", arr);\n    const obj_alias = obj;\n    let t2;\n    if ($[2] !== obj_alias.arr.length) {\n      t2 = () => obj_alias.arr.length;\n      $[2] = obj_alias.arr.length;\n      $[3] = t2;\n    } else {\n      t2 = $[3];\n    }\n    const cb = t2;\n    for (let i = 0; i < a; i++) {\n      arr.push(i);\n    }\n\n    t1 = <Stringify cb={cb} shouldInvokeFns={true} />;\n    $[0] = a;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ a: 2 }],\n  sequentialRenders: [{ a: 2 }, { a: 3 }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Memoization\nDESCRIPTION: This snippet shows the optimized version of the React component using compiler-specific functions and memoization techniques. It includes caching mechanisms for callbacks and effects.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-global-mutation-in-effect-indirect-usecallback.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @validatePreserveExistingMemoizationGuarantees\nimport { useCallback, useEffect, useState } from \"react\";\n\nlet someGlobal = {};\n\nfunction Component() {\n  const $ = _c(6);\n  const [state, setState] = useState(someGlobal);\n\n  const setGlobal = _temp;\n  let t0;\n  let t1;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = () => {\n      setGlobal();\n    };\n    t1 = [];\n    $[0] = t0;\n    $[1] = t1;\n  } else {\n    t0 = $[0];\n    t1 = $[1];\n  }\n  useEffect(t0, t1);\n  let t2;\n  let t3;\n  if ($[2] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t2 = () => {\n      setState(someGlobal.value);\n    };\n    t3 = [someGlobal];\n    $[2] = t2;\n    $[3] = t3;\n  } else {\n    t2 = $[2];\n    t3 = $[3];\n  }\n  useEffect(t2, t3);\n\n  const t4 = String(state);\n  let t5;\n  if ($[4] !== t4) {\n    t5 = <div>{t4}</div>;\n    $[4] = t4;\n    $[5] = t5;\n  } else {\n    t5 = $[5];\n  }\n  return t5;\n}\nfunction _temp() {\n  someGlobal.value = true;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimizing React Component with Caching\nDESCRIPTION: This snippet presents an optimized version of the React component. It uses a custom compiler runtime for caching, which helps avoid unnecessary computations when props haven't changed.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-try-value-modified-in-catch-escaping.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nconst { throwInput } = require(\"shared-runtime\");\n\nfunction Component(props) {\n  const $ = _c(3);\n  let x;\n  if ($[0] !== props.e || $[1] !== props.y) {\n    try {\n      const y = [];\n      y.push(props.y);\n      throwInput(y);\n    } catch (t0) {\n      const e = t0;\n      e.push(props.e);\n      x = e;\n    }\n    $[0] = props.e;\n    $[1] = props.y;\n    $[2] = x;\n  } else {\n    x = $[2];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ y: \"foo\", e: \"bar\" }],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: A React component 'Foo' that conditionally assigns either an empty array or object based on a boolean condition.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/memoize-value-block-value-conditional.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Foo(props) {\n  let x;\n  true ? (x = []) : (x = {});\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Inferred Effect Dependencies\nDESCRIPTION: The compiled version of the component showing how React's compiler-runtime transforms the code to correctly track the setState dependency. It uses memoization to avoid recreating the effect callback unnecessarily and explicitly adds setState to the dependency array.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/reactive-setState.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @inferEffectDependencies\nimport { useEffect, useState } from \"react\";\nimport { print } from \"shared-runtime\";\n\n/*\n * setState types are not enough to determine to omit from deps. Must also take reactivity into account.\n */\nfunction ReactiveRefInEffect(props) {\n  const $ = _c(2);\n  const [, setState1] = useRef(\"initial value\");\n  const [, setState2] = useRef(\"initial value\");\n  let setState;\n  if (props.foo) {\n    setState = setState1;\n  } else {\n    setState = setState2;\n  }\n  let t0;\n  if ($[0] !== setState) {\n    t0 = () => print(setState);\n    $[0] = setState;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  useEffect(t0, [setState]);\n}\n```\n\n----------------------------------------\n\nTITLE: Optimizing CaptureNotMutate with React Compiler Runtime\nDESCRIPTION: This optimized version of the CaptureNotMutate component uses React's compiler runtime for memoization. It introduces caching mechanisms to avoid unnecessary recalculations and function calls based on prop changes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/lambda-capture-returned-alias.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\n\nfunction CaptureNotMutate(props) {\n  const $ = _c(5);\n  let t0;\n  if ($[0] !== props.x) {\n    t0 = foo(props.x);\n    $[0] = props.x;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const idx = t0;\n  let aliasedElement;\n  if ($[2] !== idx || $[3] !== props.el) {\n    const element = bar(props.el);\n\n    const fn = function () {\n      const arr = { element };\n      return arr[idx];\n    };\n\n    aliasedElement = fn();\n    mutate(aliasedElement);\n    $[2] = idx;\n    $[3] = props.el;\n    $[4] = aliasedElement;\n  } else {\n    aliasedElement = $[4];\n  }\n  return aliasedElement;\n}\n```\n\n----------------------------------------\n\nTITLE: Input React Component Definition\nDESCRIPTION: Initial React component definition showing ErrorView and Renderer components with basic error handling functionality.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/multi-arrow-expr-gating-test.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @gating\nimport {Stringify} from 'shared-runtime';\n\nconst ErrorView = (error, _retry) => <Stringify error={error}></Stringify>;\n\nconst Renderer = props => (\n  <div>\n    <span></span>\n    <ErrorView></ErrorView>\n  </div>\n);\n\nexport default Renderer;\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: eval('Renderer'),\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with FBT Parameter - Compiled\nDESCRIPTION: Compiled version of the React component showing how FBT transforms the JSX syntax. Includes memoization logic using compiler runtime and parameter handling.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbtparam-with-jsx-fragment-value.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport fbt from \"fbt\";\nimport { identity } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== props.text) {\n    t0 = (\n      <Foo\n        value={fbt._(\n          \"{value}%\",\n          [fbt._param(\"value\", <>{identity(props.text)}</>)],\n          { hk: \"10F5Cc\" },\n        )}\n      />\n    );\n    $[0] = props.text;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n```\n\n----------------------------------------\n\nTITLE: Optimized Conditional Rendering in React - JavaScript\nDESCRIPTION: This snippet demonstrates optimized conditional rendering using internal caching mechanisms to prevent unnecessary recomputations in a React component 'Foo'. The snippet imports utilities from 'react/compiler-runtime' and 'shared-runtime' for functions and rendering. It maintains cache status to control when new computations for rendering are necessary, thereby ensuring efficient component updates.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/infer-component-props-non-null.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enablePropagateDepsInHIR\\nimport { identity, Stringify } from \"shared-runtime\";\\n\\nfunction Foo(props) {\\n  const $ = _c(5);\\n  let t0;\\n  if ($[0] !== props.cond || $[1] !== props.value) {\\n    const arr = [];\\n    if (props.cond) {\\n      let t1;\\n      if ($[3] !== props.value) {\\n        t1 = identity(props.value);\\n        $[3] = props.value;\\n        $[4] = t1;\\n      } else {\\n        t1 = $[4];\\n      }\\n      arr.push(t1);\\n    }\\n\\n    t0 = <Stringify arr={arr} />;\\n    $[0] = props.cond;\\n    $[1] = props.value;\\n    $[2] = t0;\\n  } else {\\n    t0 = $[2];\\n  }\\n  return t0;\\n}\\n\\nexport const FIXTURE_ENTRYPOINT = {\\n  fn: Foo,\\n  params: [{ value: 2, cond: true }],\\n};\\n\n```\n\n----------------------------------------\n\nTITLE: React Array Memoization Input Source\nDESCRIPTION: Source code for a React test fixture that validates array memoization using Array.from(). Includes a validation component and a hook that creates and updates an array with memoized values.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-inference-array-from.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useIdentity, ValidateMemoization} from 'shared-runtime';\n\n/**\n * Fixture to assert that we can infer the type and effects of an array created\n * with `Array.from`.\n */\nfunction Validate({x, val1, val2}) {\n  'use no memo';\n  return (\n    <>\n      <ValidateMemoization\n        inputs={[val1]}\n        output={x[0]}\n        onlyCheckCompiled={true}\n      />\n      <ValidateMemoization\n        inputs={[val2]}\n        output={x[1]}\n        onlyCheckCompiled={true}\n      />\n    </>\n  );\n}\nfunction useFoo({val1, val2}) {\n  'use memo';\n  const x = Array.from([]);\n  useIdentity();\n  x.push([val1]);\n  x.push([val2]);\n  return <Validate x={x} val1={val1} val2={val2} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{val1: 1, val2: 2}],\n  params: [\n    {val1: 1, val2: 2},\n    {val1: 1, val2: 2},\n    {val1: 1, val2: 3},\n    {val1: 4, val2: 2},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimizing React Component with Compiler Runtime (JavaScript)\nDESCRIPTION: This snippet demonstrates an optimized React component using 'react/compiler-runtime'. It includes conditional logic checks to memoize computed values and avoid unnecessary re-evaluations. It showcases potential improvements in handling object properties, with 'Stringify' as a dependency, expecting the same inputs as the previous version. The memoization enhances performance but requires managing the cache state.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-functionexpr-conditional-dep.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { Stringify } from \"shared-runtime\";\n\n/**\n * We currently hoist the accessed properties of function expressions,\n * regardless of control flow. This is simply because we wrote support for\n * function expressions before doing a lot of work in PropagateScopeDeps\n * to handle conditionally accessed dependencies.\n *\n * Current evaluator error:\n *  Found differences in evaluator results\n *  Non-forget (expected):\n *  (kind: ok) <div>{\"shouldInvokeFns\":true,\"callback\":{\"kind\":\"Function\",\"result\":null}}</div>\n *  Forget:\n *  (kind: exception) Cannot read properties of null (reading 'prop')\n */\nfunction Component(t0) {\n  const $ = _c(5);\n  const { obj, isObjNull } = t0;\n  let t1;\n  if ($[0] !== isObjNull || $[1] !== obj) {\n    t1 = () => {\n      if (!isObjNull) {\n        return obj.prop;\n      } else {\n        return null;\n      }\n    };\n    $[0] = isObjNull;\n    $[1] = obj;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  const callback = t1;\n  let t2;\n  if ($[3] !== callback) {\n    t2 = <Stringify shouldInvokeFns={true} callback={callback} />;\n    $[3] = callback;\n    $[4] = t2;\n  } else {\n    t2 = $[4];\n  }\n  return t2;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ obj: null, isObjNull: true }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining Function That Calls Another Function - JavaScript\nDESCRIPTION: This snippet defines a JavaScript function that, despite not being a hook, can call another function named 'userFetch'. It highlights a key aspect of JavaScript where functions are first-class citizens and can be invoked based on conditional logic. The snippet serves as an example of valid function usage within the JavaScript programming paradigm.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-485bf041f55f.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Valid because functions can call functions.\nfunction functionThatStartsWithUseButIsntAHook() {\n  if (cond) {\n    userFetch();\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: A React component that demonstrates issues with function reference effect annotations. Uses Array.map and demonstrates mutation effects through array operations. Shows how Read effects on Array.map operands can lead to incorrect behavior.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/mixedreadonly-mutating-map.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {\n  arrayPush,\n  identity,\n  makeArray,\n  Stringify,\n  useFragment,\n} from 'shared-runtime';\n\nfunction Component({extraJsx}) {\n  const x = makeArray();\n  const items = useFragment();\n  const jsx = items.a.map((item, i) => {\n    arrayPush(x, 2);\n    return <Stringify item={item} key={i} />;\n  });\n  const offset = jsx.length;\n  for (let i = 0; i < extraJsx; i++) {\n    jsx.push(<Stringify item={0} key={i + offset} />);\n  }\n  const count = jsx.length;\n  identity(count);\n  return (\n    <>\n      <Stringify x={x} count={count} />\n      {jsx[0]}\n    </>\n  );\n}\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{extraJsx: 0}],\n  sequentialRenders: [{extraJsx: 0}, {extraJsx: 1}],\n};\n```\n\n----------------------------------------\n\nTITLE: Demonstrating value detachment behavior in JavaScript\nDESCRIPTION: Shows how defaultValue updates also affect the value property until value is directly manipulated. After value is set directly, changes to defaultValue no longer affect the value property.\nSOURCE: https://github.com/facebook/react/blob/main/fixtures/dom/src/components/fixtures/text-inputs/README.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nvar input = document.createElement('input')\n// This will turn into 3\ninput.defaultValue = 3\n// This will turn into 5\ninput.defaultValue = 5\n// This will turn into 7\ninput.value = 7\n// This will do nothing\ninput.defaultValue = 1\n```\n\n----------------------------------------\n\nTITLE: Optimized Function with React Compiler Runtime Memoization\nDESCRIPTION: Enhanced version of the function using React's compiler runtime for caching and optimization, with conditional re-computation and state tracking\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-alias-computed-load-3.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction bar(a, b) {\n  const $ = _c(3);\n  let y;\n  if ($[0] !== a || $[1] !== b) {\n    const x = [a, b];\n    y = {};\n    let t;\n    t = {};\n    const f0 = function () {\n      y = x[0][1];\n      t = x[1][0];\n    };\n\n    f0();\n    $[0] = a;\n    $[1] = b;\n    $[2] = y;\n  } else {\n    y = $[2];\n  }\n  return y;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining useFoo React Component with Mutate\nDESCRIPTION: This code defines a React component `useFoo` that takes props as input and conditionally pushes values into an array named `x`. It utilizes a `mutate` function, presumably for state management or side effects. The `FIXTURE_ENTRYPOINT` provides configuration for testing, including initial parameters and sequential renders with different prop values.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-renaming-with-mutation.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {mutate} from 'shared-runtime';\n\nfunction useFoo(props) {\n  let x = [];\n  x.push(props.bar);\n  if (props.cond) {\n    x = {};\n    x = [];\n    x.push(props.foo);\n  }\n  mutate(x);\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{bar: 'bar', foo: 'foo', cond: true}],\n  sequentialRenders: [\n    {bar: 'bar', foo: 'foo', cond: true},\n    {bar: 'bar', foo: 'foo', cond: true},\n    {bar: 'bar', foo: 'foo', cond: false},\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Initializing React Dependency Tracking Function\nDESCRIPTION: A function demonstrating React compiler's ability to track nested object dependencies without order-sensitive access\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/uncond-subpath-order1.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction TestDepsSubpathOrder1(props) {\n  let x = {};\n  x.b = props.a.b;\n  x.a = props.a;\n  x.c = props.a.b.c;\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Counter Function in JavaScript\nDESCRIPTION: The 'useFoo' function encapsulates a counter within a closure. It returns the current count and increments it upon each call. This pattern allows for maintaining state across invocations while providing an avenue for functional programming in JavaScript.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-handle-update-context-identifiers.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction useFoo() {\n  let counter = 2;\n  const fn = () => {\n    return counter++;\n  };\n\n  return fn();\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Effect Handling\nDESCRIPTION: The compiled version of the component with added effect handling logic. Includes caching mechanism for rendered elements and proper tracking of dependencies through the _c compiler runtime.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/mixedreadonly-mutating-map.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport {\n  arrayPush,\n  identity,\n  makeArray,\n  Stringify,\n  useFragment,\n} from \"shared-runtime\";\n\nfunction Component(t0) {\n  const $ = _c(6);\n  const { extraJsx } = t0;\n  const x = makeArray();\n  const items = useFragment();\n\n  const jsx = items.a.map((item, i) => {\n    arrayPush(x, 2);\n    return <Stringify item={item} key={i} />;\n  });\n  const offset = jsx.length;\n  for (let i_0 = 0; i_0 < extraJsx; i_0++) {\n    jsx.push(<Stringify item={0} key={i_0 + offset} />);\n  }\n\n  const count = jsx.length;\n  identity(count);\n  let t1;\n  if ($[0] !== count || $[1] !== x) {\n    t1 = <Stringify x={x} count={count} />;\n    $[0] = count;\n    $[1] = x;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  let t2;\n  if ($[3] !== jsx[0] || $[4] !== t1) {\n    t2 = (\n      <>\n        {t1}\n        {jsx[0]}\n      </>\n    );\n    $[3] = jsx[0];\n    $[4] = t1;\n    $[5] = t2;\n  } else {\n    t2 = $[5];\n  }\n  return t2;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ extraJsx: 0 }],\n  sequentialRenders: [{ extraJsx: 0 }, { extraJsx: 1 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Memoization\nDESCRIPTION: This snippet shows an optimized version of the component using memoization. It imports a compiler runtime function and uses it to cache the component's state, reducing unnecessary recalculations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/delete-computed-property.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(3);\n  let x;\n  if ($[0] !== props.a || $[1] !== props.b) {\n    x = { a: props.a, b: props.b };\n    delete x[\"b\"];\n    $[0] = props.a;\n    $[1] = props.b;\n    $[2] = x;\n  } else {\n    x = $[2];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: JavaScript Error: Unhandled MetaProperty Expression\nDESCRIPTION: This error message indicates that the JavaScript runtime encountered a `MetaProperty` expression (`new.target`) during the lowering of expressions that it cannot handle, specifically when not dealing with `import.meta`. It highlights the line of code where the error occurred: `const nt = new.target;`.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-new-target-meta-property.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n  2 |\n  3 | function foo() {\n> 4 |   const nt = new.target;\n    |              ^^^^^^^^^^ Todo: (BuildHIR::lowerExpression) Handle MetaProperty expressions other than import.meta (4:4)\n  5 |   return <Stringify value={nt} />;\n  6 | }\n  7 |\n\n```\n\n----------------------------------------\n\nTITLE: JavaScript Function with Block-Scoped Variables\nDESCRIPTION: A JavaScript function demonstrating variable scoping with let declarations inside if/else blocks. The function creates variables x and y in the function scope, then declares a variable z in either the if or else block scope, making z inaccessible outside its respective block.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-if-else.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo() {\n  let x = 1;\n  let y = 2;\n\n  if (y) {\n    let z = x + y;\n  } else {\n    let z = x;\n  }\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Handling Errors in JavaScript Execution\nDESCRIPTION: This snippet captures an error related to an update expression inside a lambda function. It indicates that there are issues in handling variables modified as closure references, potentially pointing towards improvements needed in the handling of side effects in functional contexts.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-handle-update-context-identifiers.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n```\n  2 |   let counter = 2;\n  3 |   const fn = () => {\n> 4 |     return counter++;\n    |            ^^^^^^^^^ Todo: (BuildHIR::lowerExpression) Handle UpdateExpression to variables captured within lambdas. (4:4)\n  5 |   };\n  6 |\n  7 |   return fn();\n```\n```\n\n----------------------------------------\n\nTITLE: Processing Component Props in JavaScript\nDESCRIPTION: This JavaScript snippet defines a functional component that processes its props and manages intermediate states within arrays. The function constructs arrays based on input properties {a, b, c} and performs mutations on them to dictate a specific output structure. It illustrates basic usage of arrays and the modification of values based on the input props. No external dependencies are required, but understanding of JavaScript array operations is necessary.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-access-assignment.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component({a, b, c}) {\n  const x = [a];\n  const y = [null, b];\n  const z = [[], [], [c]];\n  x[0] = y[1];\n  z[0][0] = x[0];\n  return [x, z];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{a: 1, b: 20, c: 300}],\n  sequentialRenders: [\n    {a: 2, b: 20, c: 300},\n    {a: 3, b: 20, c: 300},\n    {a: 3, b: 21, c: 300},\n    {a: 3, b: 22, c: 300},\n    {a: 3, b: 22, c: 301},\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Hook with useCallback in React\nDESCRIPTION: This snippet defines a custom React hook, useHook, that memoizes a function using useCallback. It checks a condition based on the props and mutates an object if the condition is met, returning a specific value from the props. Dependencies for memoization are specified in the useCallback hook to optimize re-renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.hoist-useCallback-infer-conditional-value-block.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees\nimport {useCallback} from 'react';\nimport {identity, mutate} from 'shared-runtime';\n\nfunction useHook(propA, propB) {\n  return useCallback(() => {\n    const x = {};\n    if (identity(null) ?? propA.a) {\n      mutate(x);\n      return {\n        value: propB.x.y,\n      };\n    }\n  }, [propA.a, propB.x.y]);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useHook,\n  params: [{a: 1}, {x: {y: 3}}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Rest Parameters\nDESCRIPTION: This snippet defines a simple React component that takes a 'foo' parameter and rest parameters. It returns an array containing 'foo' and the rest parameters. An export constant FIXTURE_ENTRYPOINT is also defined for testing purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rest-param-with-identifier.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(foo, ...bar) {\n  return [foo, bar];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: ['foo', 'bar', 'baz'],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component Definition with useHook\nDESCRIPTION: This React component utilizes the `useHook` function from the `shared-runtime` module.  The hook call is intentionally interspersed within the component's logic to prevent memoization of the 'x' variable. The component accepts 'props' as input, specifically expecting a 'value' property, and returns a nested array containing this value.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/prune-scopes-whose-deps-invalidate-array.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useHook} from 'shared-runtime';\n\nfunction Component(props) {\n  const x = [];\n  useHook(); // intersperse a hook call to prevent memoization of x\n  x.push(props.value);\n\n  const y = [x];\n\n  return [y];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: 'sathya'}],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component Functionality in JavaScript\nDESCRIPTION: This snippet demonstrates the creation of a React component function called 'Foo' that utilizes the 'useRef' hook to access a mutable reference. It takes an object argument, extracts property 'a', and combines it with the current ref value to pass to the 'VideoList' component. It highlights the use of hooks for component state management.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ref-current-not-added-to-dep-2.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validateRefAccessDuringRender:false\nfunction Foo({a}) {\n  const ref = useRef();\n  const x = {a, val: ref.current};\n\n  return <VideoList videos={x} />;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with Array Iteration\nDESCRIPTION: This snippet defines a React component that creates an array of objects, iterates over them, and renders their JSON representations. It uses utility functions for object creation and mutation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-of-mutate.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {makeObject_Primitives, mutateAndReturn, toJSON} from 'shared-runtime';\n\nfunction Component(_props) {\n  const collection = [makeObject_Primitives()];\n  const results = [];\n  for (const item of collection) {\n    results.push(<div key={toJSON(item)}>{toJSON(mutateAndReturn(item))}</div>);\n  }\n  return <div>{results}</div>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  isComponent: true,\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Dependency Tracking\nDESCRIPTION: This is the compiled version of the `Foo` component, utilizing `react/compiler-runtime` for optimized rendering. It uses a dependency tracking array `$` to store previous prop values and the rendered result. This allows the component to skip re-renders if the props haven't changed, improving performance. The compiled code mirrors the logic of the original component, conditionally accessing the nested property and rendering the result with `Stringify`.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/infer-objectmethod-cond-access.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enablePropagateDepsInHIR\nimport { Stringify } from \"shared-runtime\";\n\nfunction Foo(t0) {\n  const $ = _c(3);\n  const { a, shouldReadA } = t0;\n  let t1;\n  if ($[0] !== a || $[1] !== shouldReadA) {\n    t1 = (\n      <Stringify\n        objectMethod={{\n          method() {\n            if (shouldReadA) {\n              return a.b.c;\n            }\n            return null;\n          },\n        }}\n        shouldInvokeFns={true}\n      />\n    );\n    $[0] = a;\n    $[1] = shouldReadA;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{ a: null, shouldReadA: true }],\n  sequentialRenders: [\n    { a: null, shouldReadA: true },\n    { a: null, shouldReadA: false },\n    { a: { b: { c: 4 } }, shouldReadA: true },\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining Component Props - TypeScript\nDESCRIPTION: This snippet defines the props interface for a functional component in TypeScript. It allows for optional props and ensures type safety while accessing component properties.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/non-null-assertion.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface ComponentProps {\n  name?: string;\n}\n```\n\n----------------------------------------\n\nTITLE: React Compiler Runtime Memoized Function\nDESCRIPTION: Transformed version of the original function using React compiler runtime, introducing memoization and cache management with symbol-based sentinel check.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-property-mutate-alias.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction foo() {\n  const $ = _c(1);\n  let y;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const a = {};\n    y = a;\n    const x = [];\n\n    y.x = x;\n\n    mutate(a);\n    $[0] = y;\n  } else {\n    y = $[0];\n  }\n  return y;\n}\n```\n\n----------------------------------------\n\nTITLE: Optimized React Code After Constant Propagation\nDESCRIPTION: The optimized output code shows the result of constant propagation where 'x' has been completely removed and its final value (4) is directly returned. The code demonstrates proper handling of the scoping bug.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/constant-prop-across-objectmethod-def.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { identity } from \"shared-runtime\";\n\n// repro for context identifier scoping bug, in which x was\n// inferred as a context variable.\n\nfunction Component() {\n  const obj = { method() {} };\n\n  identity(obj);\n  return 4;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: The transformed code after React's compiler processing, implementing memoization with Symbol.for(\"react.memo_cache_sentinel\") to optimize rendering. The compiler adds runtime helpers to manage component state and caching of function references.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-mutating-ref-in-callback-passed-to-jsx-indirect.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @validateRefAccessDuringRender\nimport { useRef } from \"react\";\n\nfunction Component() {\n  const $ = _c(2);\n  const ref = useRef(null);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const setRef = () => {\n      if (ref.current !== null) {\n        ref.current = \"\";\n      }\n    };\n\n    t0 = () => {\n      setRef();\n    };\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const onClick = t0;\n  let t1;\n  if ($[1] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = (\n      <>\n        <input ref={ref} />\n        <button onClick={onClick} />\n      </>\n    );\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing a Component with Memoization in React\nDESCRIPTION: This snippet implements a React component 'Component' that leverages a custom renderer for optimization using '_c' from 'react/compiler-runtime'. It optimizes rendering based on the props and internal state, which helps to avoid unnecessary updates.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-outlining-separate-nested.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enableJsxOutlining\nfunction Component(t0) {\n  const $ = _c(7);\n  const { arr } = t0;\n  const x = useX();\n  let t1;\n  if ($[0] !== arr || $[1] !== x) {\n    let t2;\n    if ($[3] !== x) {\n      t2 = (i, id) => {\n        const T0 = _temp;\n        return <T0 i={i} j={i} k={i} key={id} x={x} />;\n      };\n      $[3] = x;\n      $[4] = t2;\n    } else {\n      t2 = $[4];\n    }\n    t1 = arr.map(t2);\n    $[0] = arr;\n    $[1] = x;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  let t2;\n  if ($[5] !== t1) {\n    t2 = <>{t1}</>;\n    $[5] = t1;\n    $[6] = t2;\n  } else {\n    t2 = $[6];\n  }\n  return t2;\n}\nfunction _temp(t0) {\n  const $ = _c(11);\n  const { i: i, j: j, k: k, x: x } = t0;\n  let t1;\n  if ($[0] !== i) {\n    t1 = <Baz i={i} />;\n    $[0] = i;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  let t2;\n  if ($[2] !== j) {\n    t2 = <Joe j={j} />;\n    $[2] = j;\n    $[3] = t2;\n  } else {\n    t2 = $[3];\n  }\n  let t3;\n  if ($[4] !== k) {\n    t3 = <Foo k={k} />;\n    $[4] = k;\n    $[5] = t3;\n  } else {\n    t3 = $[5];\n  }\n  let t4;\n  if ($[6] !== t1 || $[7] !== t2 || $[8] !== t3 || $[9] !== x) {\n    t4 = (\n      <Bar x={x}>\n        {t1}\n        {t2}\n        {t3}\n      </Bar>\n    );\n    $[6] = t1;\n    $[7] = t2;\n    $[8] = t3;\n    $[9] = x;\n    $[10] = t4;\n  } else {\n    t4 = $[10];\n  }\n  return t4;\n}\n\nfunction Bar(t0) {\n  const $ = _c(3);\n  const { x, children } = t0;\n  let t1;\n  if ($[0] !== children || $[1] !== x) {\n    t1 = (\n      <>\n        {x}\n        {children}\n      </>\n    );\n    $[0] = children;\n    $[1] = x;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  return t1;\n}\n\nfunction Baz(t0) {\n  const { i } = t0;\n  return i;\n}\n\nfunction Joe(t0) {\n  const { j } = t0;\n  return j;\n}\n\nfunction Foo(t0) {\n  const { k } = t0;\n  return k;\n}\n\nfunction useX() {\n  return \"x\";\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ arr: [\"foo\", \"bar\"] }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Publishing Release Script - Shell\nDESCRIPTION: This script publishes the React DevTools release to NPM. It needs to be executed in a terminal and includes additional instructions for uploading to browser extension stores.\nSOURCE: https://github.com/facebook/react/blob/main/scripts/devtools/README.md#2025-04-21_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\n./publish-release.js\n```\n\n----------------------------------------\n\nTITLE: Fixture Entrypoint Configuration\nDESCRIPTION: An exported constant that defines a fixture configuration for the foo function, specifying the function reference, parameters, and component association for testing or configuration purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-nested-partial-phi.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\"\n};\n```\n\n----------------------------------------\n\nTITLE: Analyzing JavaScript Hook Usage in React\nDESCRIPTION: This code snippet demonstrates the improper usage of the useState hook within an anonymous class in JavaScript. It highlights a scenario where the snippet passes certain tests even though it theoretically should not. The snippet does not provide any specific input or output as it serves more as a structural example.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.invalid.invalid-rules-of-hooks-2c51251df67a.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @skip\n// Passed but should have failed\n\n(class {\n  useHook() {\n    useState();\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Enhanced StoreLandingUnseenGiftModalContainer with React Runtime\nDESCRIPTION: This snippet enhances the StoreLandingUnseenGiftModalContainer by integrating it with React's compiler-runtime for memoization. It checks if the input parameter 'a' has changed since the last render, and utilizes caching for performance improvement. It returns the status of the gift using the gifts ID.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-skip-computed-path.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction StoreLandingUnseenGiftModalContainer(a) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== a) {\n    const giftsSeen = { a };\n    t0 = ((gift) => (gift.id ? giftsSeen[gift.id] : false))();\n    $[0] = a;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: StoreLandingUnseenGiftModalContainer,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring Jest Timers for Testing\nDESCRIPTION: Sets up Jest timer mocking and restoration for consistent test environments. Uses useFakeTimers() to simulate timer behavior and useRealTimers() to reset to standard timer implementation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.bail.rules-of-hooks-279ac76f53af.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\njest.useFakeTimers();\nbeforeEach(() => {\n  jest.useRealTimers();\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing a conditional function with React test fixture (Final version)\nDESCRIPTION: The revised implementation of the foo function that uses 'const' instead of 'let' for the y variable. This demonstrates proper variable declaration practices with immutable values.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-phi-primitive.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(a, b) {\n  let x;\n  if (a) {\n    x = 1;\n  } else {\n    x = 2;\n  }\n\n  const y = x;\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [true, false],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Reactive Components in React - JavaScript\nDESCRIPTION: This JavaScript snippet defines a component that conditionally mutates reactive values. The component function applies conditional logic on props to control the reactivity of variables x and y, ultimately rendering a reactive output. No additional dependencies are required aside from React itself. Expected input is a props object, and the output is an array containing a boolean value. The snippet controls reactivity based on the component's sequential renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-via-mutation-if.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  // x is mutated conditionally based on a reactive value,\n  // so it needs to be considered reactive\n  let x = [];\n  if (props.cond) {\n    x.push(1);\n  }\n  // Since x is reactive, y is now reactively controlled too:\n  let y = false;\n  if (x[0]) {\n    y = true;\n  }\n  // Thus this value should be reactive on `y`:\n  return [y];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  sequentialRenders: [\n    {cond: true},\n    {cond: true},\n    {cond: false},\n    {cond: false},\n    {cond: true},\n    {cond: false},\n    {cond: true},\n    {cond: false},\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Implementing React Fixture with Function Implementation\nDESCRIPTION: Defines a simple function 'foo' with variable assignments and exports it as a fixture entrypoint. The configuration specifies it's not a React component and has no parameters.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-simple.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo() {\n  let x = 1;\n  let y = 2;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Validating Ref Access During Render in React JavaScript\nDESCRIPTION: This JavaScript snippet demonstrates an attempt to access the 'current' property of a ref during rendering in a React functional component. The code shows how the 'useRef' hook is incorrectly used to update the 'inner' property during render, which leads to an 'InvalidReact' error. This access is prohibited because ref values should only be modified in lifecycle methods or effects to ensure stability and predictability of component renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-set-and-read-ref-nested-property-during-render.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\n// @validateRefAccessDuringRender\nfunction Component(props) {\n  const ref = useRef({inner: null});\n  ref.current.inner = props.value;\n  return ref.current.inner;\n}\n```\n\n----------------------------------------\n\nTITLE: React Component with useState Hook (Code)\nDESCRIPTION: This React component uses the useState hook to initialize a state variable 'x' with the initial value of 1. The component is designed to return this initial value of 'x'.  The `setX` function from the useState hook is intentionally unused in this version.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hooks-with-React-namespace.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component() {\n  const [x] = React.useState(1);\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization Implementation\nDESCRIPTION: This snippet shows the compiled version of the React component using React's compiler runtime. It implements the memoization strategies described in the input component, using a cache array and conditional checks to avoid unnecessary recalculations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/escape-analysis-non-escaping-interleaved-allocating-nested-dependency.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(7);\n  let t0;\n  if ($[0] !== props.a) {\n    t0 = [props.a];\n    $[0] = props.a;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const a = t0;\n  let t1;\n  if ($[2] !== a) {\n    t1 = [a];\n    $[2] = a;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  const b = t1;\n  let c;\n  if ($[4] !== b || $[5] !== props.b) {\n    c = [];\n    const d = {};\n    d.b = b;\n    c.push(props.b);\n    $[4] = b;\n    $[5] = props.b;\n    $[6] = c;\n  } else {\n    c = $[6];\n  }\n  return c;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Compiler Runtime Fixture\nDESCRIPTION: React compiler-transformed version of the component with explicit memoization and early return handling using runtime cache and sentinels\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/early-return-no-declarations-reassignments-dependencies.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { makeArray } from \"shared-runtime\";\n\nlet ENABLE_FEATURE = false;\n\nfunction Component(props) {\n  const $ = _c(3);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = Symbol.for(\"react.early_return_sentinel\");\n    bb0: {\n      const x = [];\n      if (ENABLE_FEATURE) {\n        x.push(42);\n        t0 = x;\n        break bb0;\n      } else {\n        console.log(\"fallthrough\");\n      }\n    }\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  if (t0 !== Symbol.for(\"react.early_return_sentinel\")) {\n    return t0;\n  }\n  let t1;\n  if ($[1] !== props.a) {\n    t1 = makeArray(props.a);\n    $[1] = props.a;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  return t1;\n}\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Memoization Using React Compiler Runtime\nDESCRIPTION: The same component after being processed by the React compiler, implementing memoization to avoid redundant computations and renders. Uses an imported runtime helper _c to manage a cache array of previous values and dependencies.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/interdependent.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; /**\n * Should produce 1 scope:\n *\n * return: inputs=props.a & props.b; outputs=return\n *   const a = compute(props.a);\n *   const b = compute(props.b);\n *   foo(a, b);\n *   return = <Foo a={a} b={b} />\n */\nfunction Component(props) {\n  const $ = _c(7);\n  let a;\n  let b;\n  if ($[0] !== props.a || $[1] !== props.b) {\n    a = compute(props.a);\n    b = compute(props.b);\n    foo(a, b);\n    $[0] = props.a;\n    $[1] = props.b;\n    $[2] = a;\n    $[3] = b;\n  } else {\n    a = $[2];\n    b = $[3];\n  }\n  let t0;\n  if ($[4] !== a || $[5] !== b) {\n    t0 = <Foo a={a} b={b} />;\n    $[4] = a;\n    $[5] = b;\n    $[6] = t0;\n  } else {\n    t0 = $[6];\n  }\n  return t0;\n}\n\nfunction compute() {}\nfunction foo() {}\nfunction Foo() {}\n```\n\n----------------------------------------\n\nTITLE: Compiled React Components with Forget Optimization\nDESCRIPTION: Compiled version of the components with React Forget optimization feature. Includes memoization logic and conditional rendering based on the isForgetEnabled_Fixtures flag. Demonstrates advanced compilation techniques for performance optimization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/multi-arrow-expr-export-gating-test.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { isForgetEnabled_Fixtures } from \"ReactForgetFeatureFlag\"; // @gating\nimport { Stringify } from \"shared-runtime\";\n\nconst ErrorView = isForgetEnabled_Fixtures()\n  ? (error, _retry) => {\n      const $ = _c(2);\n      let t0;\n      if ($[0] !== error) {\n        t0 = <Stringify error={error} />;\n        $[0] = error;\n        $[1] = t0;\n      } else {\n        t0 = $[1];\n      }\n      return t0;\n    }\n  : (error, _retry) => <Stringify error={error}></Stringify>;\n\nexport const Renderer = isForgetEnabled_Fixtures()\n  ? (props) => {\n      const $ = _c(1);\n      let t0;\n      if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n        t0 = (\n          <div>\n            <span />\n            <ErrorView />\n          </div>\n        );\n        $[0] = t0;\n      } else {\n        t0 = $[0];\n      }\n      return t0;\n    }\n  : (props) => (\n      <div>\n        <span></span>\n        <ErrorView></ErrorView>\n      </div>\n    );\nexport const FIXTURE_ENTRYPOINT = {\n  fn: eval(\"Renderer\"),\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Validating Ref Access During Component Render - React - JavaScript\nDESCRIPTION: This code snippet defines a functional React component that attempts to access a ref's current value during the render phase, which leads to a runtime error. The component expects a `ref` prop and attempts to display its current value inside a div. However, accessing `ref.current` during render violates React rules, causing an error that emphasizes this limitation. The expected inputs are a valid React ref object, while the output should ideally be the contained value in the UI, but an error occurs instead.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-read-ref-prop-in-render-destructure.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validateRefAccessDuringRender @compilationMode(infer)\nfunction Component({ref}) {\n  const value = ref.current;\n  return <div>{value}</div>;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Processing Items Asynchronously in React Component\nDESCRIPTION: This asynchronous function 'Component' takes a prop 'items', iterates over it using 'for await' to accommodate asynchronous data, and pushes each item to an array 'x', which is then returned. The function demonstrates handling asynchronous iterable objects.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-for-await-loops.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nasync function Component({items}) {\n  const x = [];\n  for await (const item of items) {\n    x.push(item);\n  }\n  return x;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Test Fixture for Sequential Rendering Scenarios\nDESCRIPTION: Defines a test fixture with multiple input scenarios to validate the behavior of useFoo function under different array conditions\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/array-map-simple.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ arr1: [], arr2: [] }],\n  sequentialRenders: [\n    { arr1: [], arr2: [] },\n    { arr1: [], arr2: null },\n    { arr1: [{ value: 1 }, { value: 2 }], arr2: [{ value: -1 }] },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: React Compiler Error Message\nDESCRIPTION: An error message from React Compiler showing that it skipped optimizing the component because it couldn't preserve the existing manual memoization. The error points to line 18 where useMemo is used to memoize a potentially mutable value.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-repro-missed-memoization-from-capture-in-invoked-function-inferred-as-mutation.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n  16 |   // We infer that getIsEnabled returns a mutable value, such that\n  17 |   // isEnabled is mutable\n> 18 |   const isEnabled = useMemo(() => getIsEnabled(), [getIsEnabled]);\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ CannotPreserveMemoization: React Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. This value was memoized in source but not in compilation output. (18:18)\n  19 |\n  20 |   // We then infer getLoggingData as capturing that mutable value,\n  21 |   // so any calls to this function are then inferred as extending\n```\n\n----------------------------------------\n\nTITLE: Compiled React Memo Code with Feature Flag\nDESCRIPTION: Compiled version with React compiler runtime and feature flag integration, including memo cache sentinel logic\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/invalid-fnexpr-reference.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { isForgetEnabled_Fixtures } from \"ReactForgetFeatureFlag\"; // @gating\nimport * as React from \"react\";\n\nlet Foo;\nconst MemoFoo = React.memo(Foo);\nFoo = isForgetEnabled_Fixtures()\n  ? () => {\n      const $ = _c(1);\n      let t0;\n      if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n        t0 = <div>hello world!</div>;\n        $[0] = t0;\n      } else {\n        t0 = $[0];\n      }\n      return t0;\n    }\n  : () => <div>hello world!</div>;\n\n/**\n * Evaluate this fixture module to assert that compiler + original have the same\n * runtime error message.\n */\nexport const FIXTURE_ENTRYPOINT = {\n  fn: isForgetEnabled_Fixtures() ? () => {} : () => {},\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Managing Component Props - JavaScript\nDESCRIPTION: This code snippet is a JavaScript function named 'Component' that processes properties ('props') to generate and return an array of values based on conditional checks. The snippet shows how to use fallback values and conditionally alter state based on the presence of specific props. It is structured for intelligible state transitions, ideal for components in a React-like framework.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-cascading-eliminated-phis.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nfunction Component(props) {\n  let x = 0;\n  const values = [];\n  const y = props.a || props.b;\n  values.push(y);\n  if (props.c) {\n    x = 1;\n  }\n  values.push(x);\n  if (props.d) {\n    x = 2;\n  }\n  values.push(x);\n  return values;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{a: 0, b: 1, c: true, d: true}],\n  sequentialRenders: [\n    {a: 0, b: 1, c: true, d: true},\n    {a: 4, b: 1, c: true, d: true},\n    {a: 4, b: 1, c: false, d: true},\n    {a: 4, b: 1, c: false, d: false},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with useNoAlias and Caching - JavaScript\nDESCRIPTION: In this code snippet, a React component is optimized with internal caching using the '_c' function from 'react/compiler-runtime'. The component tracks several state variables to avoid unnecessary computations and updates. It empowers the 'useNoAlias' function for efficient runtime behavior based on 'props.a'. Dependencies include 'react/compiler-runtime' and 'shared-runtime', and it requires understanding of React's reconciliation and caching mechanism.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hook-noAlias.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useNoAlias } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(5);\n  let t0;\n  if ($[0] !== props.a) {\n    t0 = { a: props.a };\n    $[0] = props.a;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const item = t0;\n  const x = useNoAlias(item, () => {\n    console.log(props);\n  }, [props.a]);\n  let t1;\n  if ($[2] !== item || $[3] !== x) {\n    t1 = [x, item];\n    $[2] = item;\n    $[3] = x;\n    $[4] = t1;\n  } else {\n    t1 = $[4];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ a: { id: 42 } }],\n  isComponent: true,\n};\n\n```\n\n----------------------------------------\n\nTITLE: Using React Compiler Runtime and Hoisting in JavaScript\nDESCRIPTION: This snippet showcases a more complex implementation of the hoisting function using React's compiler runtime. It demonstrates a memoization pattern to cache results and appropriately handles variable scopes for `foo`, `bar`, and `baz`. It uses the compiler runtime to manage reactivity and state more directly, ensuring correct behavior in a React application.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-nested-let-declaration.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction hoisting() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const qux = () => {\n      let result;\n\n      result = foo();\n      return result;\n    };\n\n    let foo;\n    foo = () => bar + baz;\n\n    let bar;\n    bar = 3;\n    const baz = 2;\n    t0 = qux();\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: hoisting,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with FBT Optimization\nDESCRIPTION: This snippet shows the compiled and optimized version of the React component using FBT. It includes memoization for performance improvement and demonstrates how FBT transforms the internationalized strings into an optimized format for runtime execution.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-single-space-btw-param-and-text.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport fbt from \"fbt\";\n\nconst _ = fbt;\nfunction Component(t0) {\n  const $ = _c(2);\n  const { value } = t0;\n  let t1;\n  if ($[0] !== value) {\n    t1 = fbt._(\n      \"Before text {paramName} after text\",\n      [fbt._param(\"paramName\", value)],\n      { hk: \"26pxNm\" },\n    );\n    $[0] = value;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ value: \"hello world\" }],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Fixture Function in React JavaScript\nDESCRIPTION: This snippet imports a constant from a shared runtime and defines a function that constructs an array using this constant and provided properties. The function is then exported as a part of a fixture entry point to be used in React components. The main dependencies are 'shared-runtime' and knowledge of function export in ES6.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/holey-array-expr.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {CONST_STRING0} from 'shared-runtime';\n\nfunction t(props) {\n  let x = [, CONST_STRING0, props];\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: t,\n  params: [{a: 1, b: 2}],\n  isComponent: false,\n};\n\n```\n\n----------------------------------------\n\nTITLE: Optimized Component Calculation with React (JavaScript)\nDESCRIPTION: This optimized version of the React component employs memoization to store previously computed results, reducing repetitive calculations. It utilizes react/compiler-runtime for optimization. Input outputs remain similar to the basic version and the optimizations ensure fewer recalculations by caching previous parameter states.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/primitive-reassigned-loop-force-scopes-enabled.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { c as _c } from \\\"react/compiler-runtime\\\"; // @enableForest\\nfunction Component(t0) {\\n  const $ = _c(5);\\n  const { base, start, increment, test } = t0;\\n  let value;\\n  if ($[0] !== base || $[1] !== increment || $[2] !== start || $[3] !== test) {\\n    value = base;\\n    for (let i = start; i < test; i = i + increment, i) {\\n      value = value + i;\\n    }\\n    $[0] = base;\\n    $[1] = increment;\\n    $[2] = start;\\n    $[3] = test;\\n    $[4] = value;\\n  } else {\\n    value = $[4];\\n  }\\n  return <div>{value}</div>;\\n}\\n\\nexport const FIXTURE_ENTRYPOINT = {\\n  fn: Component,\\n  params: [{ base: 0, start: 0, test: 10, increment: 1 }],\\n  sequentialRenders: [\\n    { base: 0, start: 1, test: 10, increment: 1 },\\n    { base: 0, start: 0, test: 10, increment: 2 },\\n    { base: 2, start: 0, test: 10, increment: 2 },\\n    { base: 0, start: 0, test: 11, increment: 2 },\\n  ],\\n};\\n\n```\n\n----------------------------------------\n\nTITLE: Using Fire in React Component with JavaScript\nDESCRIPTION: The snippet shows how to use the fire function in a React component, showcasing dependencies such as React and its hooks. The snippet attempts to call fire with a callback and again within a useCallback hook. The primary parameter is props, which is used within the foo function to log values and is passed to fire. The limitation here is the incorrect usage of fire outside proper lifecycle management, highlighted by an error.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/error.invalid-outside-effect.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\n// @enableFire\nimport {fire, useCallback} from 'react';\n\nfunction Component({props, bar}) {\n  const foo = () => {\n    console.log(props);\n  };\n  fire(foo(props));\n\n  useCallback(() => {\n    fire(foo(props));\n  }, [foo, props]);\n\n  return null;\n}\n\n```\n\n----------------------------------------\n\nTITLE: React Component with Nested Factorial Function\nDESCRIPTION: This code defines a React component `Foo` that calculates the factorial of a fixed value (3) using nested functions `outer` and `fact`. The `outer` function takes a value and calls the `fact` function to compute its factorial.  The component returns the result of the factorial calculation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-recursive-call-within-lambda.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Foo({}) {\n  const outer = val => {\n    const fact = x => {\n      if (x <= 0) {\n        return 1;\n      }\n      return x * fact(x - 1);\n    };\n    return fact(val);\n  };\n  return outer(3);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{}]\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiled JavaScript Function\nDESCRIPTION: This is the compiled version of the `foo` function, optimized using React's compiler. It uses `_c` from `react/compiler-runtime` to memoize the function's result based on the input `a`. It checks if the input `a` has changed, and if so, executes the original logic. Otherwise, it reuses the previously computed value.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-property-alias-alias-mutate-if.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\\nfunction foo(a) {\\n  const $ = _c(2);\\n  let x;\\n  if ($[0] !== a) {\\n    const b = {};\\n    x = b;\\n    if (a) {\\n      const y = {};\\n      x.y = y;\\n    } else {\\n      const z = {};\\n      x.z = z;\\n    }\\n\\n    mutate(b);\\n    $[0] = a;\\n    $[1] = x;\\n  } else {\\n    x = $[1];\\n  }\\n  return x;\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Initializing React Component with Incorrect useEffect\nDESCRIPTION: A React functional component using useEffect with an invalid dependency handling approach, which causes a compilation error\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/bailout-retry/error.use-no-memo.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @inferEffectDependencies @panicThreshold(none)\nimport {useEffect} from 'react';\n\nfunction Component({propVal}) {\n  'use no memo';\n  useEffect(() => [propVal]);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with Invalid State Update\nDESCRIPTION: This snippet defines a React functional component using the useState hook. It includes a loop that processes props and an invalid state update that occurs unconditionally during render, which can cause an infinite loop.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.unconditional-set-state-in-render-with-loop-throw.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validateNoSetStateInRender\nfunction Component(props) {\n  const [state, setState] = useState(false);\n  for (const _ of props) {\n    if (props.cond) {\n      break;\n    } else {\n      throw new Error('bye!');\n    }\n  }\n  setState(true);\n  return state;\n}\n```\n\n----------------------------------------\n\nTITLE: Using Custom Hook with State Management in JavaScript\nDESCRIPTION: This snippet defines a custom React hook that takes an object with a value, mutates it using shared runtime methods, and returns an object with a method to get the current value. It leverages the 'mutateAndReturn' function to manage state changes and stores the value in an internal state.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-method-shorthand-mutated-after.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {createHookWrapper, mutate, mutateAndReturn} from 'shared-runtime';\nfunction useHook({value}) {\n  const x = mutateAndReturn({value});\n  const obj = {\n    getValue() {\n      return x;\n    },\n  };\n  mutate(obj);\n  return obj;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: createHookWrapper(useHook),\n  params: [{value: 0}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: The optimized version of the component after React compiler processing. It implements memoization using an array to track input and output values, preventing unnecessary recomputation when props haven't changed.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/interdependent-across-if.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction compute() {}\nfunction foo() {}\nfunction Foo() {}\n\n/**\n * Should produce 1 scope:\n *\n * return: inputs=props.a & props.b & props.c; outputs=return\n *   const a = compute(props.a);\n *   const b = compute(props.b);\n *   if (props.c)\n *     foo(a, b);\n *   return = <Foo a={a} b={b} />\n */\nfunction Component(props) {\n  const $ = _c(8);\n  let a;\n  let b;\n  if ($[0] !== props.a || $[1] !== props.b || $[2] !== props.c) {\n    a = compute(props.a);\n    b = compute(props.b);\n    if (props.c) {\n      foo(a, b);\n    }\n    $[0] = props.a;\n    $[1] = props.b;\n    $[2] = props.c;\n    $[3] = a;\n    $[4] = b;\n  } else {\n    a = $[3];\n    b = $[4];\n  }\n  let t0;\n  if ($[5] !== a || $[6] !== b) {\n    t0 = <Foo a={a} b={b} />;\n    $[5] = a;\n    $[6] = b;\n    $[7] = t0;\n  } else {\n    t0 = $[7];\n  }\n  return t0;\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Optimized useState in JavaScript\nDESCRIPTION: This snippet shows the compiled version of the React component. It uses an optimized version of useState, employing a caching mechanism to avoid unnecessary re-renders. The component structure and FIXTURE_ENTRYPOINT export remain the same.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-duplicate-import-specifier.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport type { SetStateAction, Dispatch } from \"react\";\nimport { useState } from \"react\";\n\nfunction Component(_props) {\n  const $ = _c(2);\n  const [x] = useState(0);\n  let t0;\n  if ($[0] !== x) {\n    t0 = { x };\n    $[0] = x;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with FBT Internationalization Markup\nDESCRIPTION: Original React component that uses the FBT internationalization library to create a text string with a parameter insertion. The component accepts a value prop that gets inserted between 'Before text' and 'After text'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-no-whitespace-btw-text-and-param.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport fbt from 'fbt';\n\nconst _ = fbt;\nfunction Component({value}: {value: string}) {\n  return (\n    <fbt desc=\"descdesc\">\n      Before text<fbt:param name=\"paramName\">{value}</fbt:param>After text\n    </fbt>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: 'hello world'}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Foo Component and Rendering JSX - React - JavaScript\nDESCRIPTION: This snippet demonstrates the definition of a functional component 'Foo' in React. It uses destructuring to extract values from an array and an object, rendering these values in a div. The component does not take any parameters and relies on React's implicit state management.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoist-destruct.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n//@flow\ncomponent Foo() {\n  function foo() {\n    return (\n      <div>\n        {a} {z} {y}\n      </div>\n    );\n  }\n  const [a, {x: z, y = 10}] = [1, {x: 2}];\n  return foo();\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Incorrect useMemo Hook Usage in React Component\nDESCRIPTION: A React component function that tries to use the useMemo hook with a logical OR fallback pattern. This pattern is not supported by React's compiler, as hooks must be called unconditionally at the top level.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-useMemo-with-optional.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  return (\n    useMemo(() => {\n      return [props.value];\n    }) || []\n  );\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Hoisted Function - JavaScript\nDESCRIPTION: This snippet defines a React component 'Component' that attempts to render a nested function 'Foo'. The nested function is hoisted, which makes it available before its declaration in the code, but it remains unreachable from a control-flow standpoint. It highlights JavaScript's hoisting behavior in the context of function declarations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-hoisted-function-in-unreachable-code.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @compilationMode(infer)\nfunction Component() {\n  return <Foo />;\n\n  // This is unreachable from a control-flow perspective, but it gets hoisted\n  function Foo() {}\n}\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Hook with Explicit Memoization Logic\nDESCRIPTION: Shows the compiled version of the useMakeCallback hook with React compiler transformations. The compiler adds explicit memoization logic using an array for caching dependencies and the callback function, reusing the cached version when dependencies haven't changed.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/assume-invoked/return-function.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { createHookWrapper } from \"shared-runtime\";\n\n/**\n * Assume that directly returned functions are invoked and that their property\n * loads are hoistable.\n */\nfunction useMakeCallback(t0) {\n  const $ = _c(3);\n  const { obj, setState } = t0;\n  let t1;\n  if ($[0] !== obj.value || $[1] !== setState) {\n    t1 = () => setState(obj.value);\n    $[0] = obj.value;\n    $[1] = setState;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  return t1;\n}\n\nconst setState = (arg: number) => {\n  \"use no memo\";\n  return arg;\n};\nexport const FIXTURE_ENTRYPOINT = {\n  fn: createHookWrapper(useMakeCallback),\n  params: [{ obj: { value: 1 }, setState }],\n  sequentialRenders: [\n    { obj: { value: 1 }, setState },\n    { obj: { value: 2 }, setState },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: Compiled version of the React component with added memoization logic using the _c compiler runtime. Implements caching for computed values to optimize performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-annotations/type-annotation-var-array_.flow.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { identity } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(4);\n  let t0;\n  if ($[0] !== props.id) {\n    t0 = makeArray(props.id);\n    $[0] = props.id;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const x = t0;\n  let t1;\n  if ($[2] !== x) {\n    t1 = x.at(0);\n    $[2] = x;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  const y = t1;\n  return y;\n}\n\nfunction makeArray(x) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== x) {\n    t0 = [x];\n    $[0] = x;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ id: 42 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Invalid React Mutation Error\nDESCRIPTION: This error message indicates that a value used previously in JSX is being updated, which is not allowed in React due to immutability principles. The error highlights the line of code where the mutation occurs (in this case, `delete x[y]`).  The suggestion is to move the mutation before the JSX element.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-delete-computed-property-of-frozen-value.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n  3 |   // freeze\n  4 |   <div>{x}</div>;\n> 5 |   delete x[y];\n    |          ^ InvalidReact: Updating a value used previously in JSX is not allowed. Consider moving the mutation before the JSX (5:5)\n  6 |   return x;\n  7 | }\n  8 |\n```\n\n----------------------------------------\n\nTITLE: Original React Component with Memoization Comments\nDESCRIPTION: This is the input React component with comments explaining the memoization strategy. It demonstrates how primitives and objects are handled differently with regard to memoization needs.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/escape-analysis-non-escaping-interleaved-primitive-dependency.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  // a does not need to be memoized ever, even though it's a\n  // dependency of c, which exists in a scope that has a memoized\n  // output. it doesn't need to be memoized bc the value is a primitive type.\n  const a = props.a + props.b;\n\n  // b and c are interleaved and grouped into a single scope,\n  // but they are independent values. c does not escape, but\n  // we need to ensure that a is memoized or else b will invalidate\n  // on every render since a is a dependency.\n  const b = [];\n  const c = {};\n  c.a = a;\n  b.push(props.c);\n\n  return b;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Simplified React Test Fixture\nDESCRIPTION: Provides a simplified version of the test fixture function that directly adds 1 to the input parameter. Exports the same fixture entrypoint configuration structure.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unconditional-break-label.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(a) {\n  return a + 1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Demonstrating JavaScript Hoisting\nDESCRIPTION: This code snippet defines a function that showcases JavaScript's hoisting behavior, particularly how functions access variables from the outer scope. It includes a function 'hoisting' that calls a nested function 'foo', which in turn calls another nested function 'bar', demonstrating access to 'bar' despite its declaration being below its usage. The expected output is '1' when 'foo' is invoked.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-simple-function-expression.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction hoisting() {\n  const foo = () => {\n    return bar();\n  };\n  const bar = () => {\n    return 1;\n  };\n\n  return foo(); // OK: bar's value is only accessed outside of its TDZ\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: hoisting,\n  params: [],\n  isComponent: false,\n};\n\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: A React component that manages state using useState hook and handles input changes. The component demonstrates variable shadowing in the onChange handler.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/nested-function-shadowed-identifiers.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const [x, setX] = useState(null);\n\n  const onChange = e => {\n    let x = null; // intentionally shadow the original x\n    setX(currentX => currentX + x); // intentionally refer to shadowed x\n  };\n\n  return <input value={x} onChange={onChange} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Declaring React Components with JSX in JavaScript\nDESCRIPTION: This snippet defines a set of React components using JSX syntax, built to render elements based on an array input. Dependencies include React and a mock \\'useX\\' hook providing a constant string. The main component \\'Component\\' maps over an array \\'arr\\' passed as a prop, embedding JSX elements \\'Bar\\', \\'Baz\\', and \\'Foo\\'. Expected input is a component render with props containing an \\'arr\\'. Outputs are React element trees based on 'arr'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-outlining-with-non-jsx-children.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableJsxOutlining\nfunction Component({arr}) {\n  const x = useX();\n  return (\n    <>\n      {arr.map((i, id) => {\n        return (\n          <Bar key={id} x={x}>\n            <Baz i={i}>Test</Baz>\n            <Foo k={i} />\n          </Bar>\n        );\n      })}\n    </>\n  );\n}\n\nfunction Bar({x, children}) {\n  return (\n    <>\n      {x}\n      {children}\n    </>\n  );\n}\n\nfunction Baz({i, children}) {\n  return (\n    <>\n      {i}\n      {children}\n    </>\n  );\n}\n\nfunction Foo({k}) {\n  return k;\n}\n\nfunction useX() {\n  return 'x';\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{arr: ['foo', 'bar']}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: This snippet shows the compiled version of the React component. It utilizes the '_c' function from 'react/compiler-runtime' for memoization. It checks if the prop 'a' has changed, and if so, re-executes the logic, updating a cache. Otherwise, it retrieves the previously computed value from the cache, optimizing for performance and avoiding unnecessary re-renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-alias-mutate.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { mutate } from \"shared-runtime\";\nfunction Component(t0) {\n  const $ = _c(2);\n  const { a } = t0;\n  let y;\n  if ($[0] !== a) {\n    const x = { a };\n    y = {};\n    const f0 = function () {\n      y.x = x;\n    };\n\n    f0();\n    mutate(y);\n    $[0] = a;\n    $[1] = y;\n  } else {\n    y = $[1];\n  }\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ a: 2 }],\n  sequentialRenders: [{ a: 2 }, { a: 2 }, { a: 3 }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Using Compiler Runtime in useFoo Hook\nDESCRIPTION: This snippet demonstrates another implementation of the useFoo hook using the React compiler runtime for internal state management. It checks incoming parameters for changes and utilizes a sentinel symbol to manage early return states.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-poisoned/return-in-scope.expect.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction useFoo(t0) {\n  const $ = _c(4);\n  const { obj, objIsNull } = t0;\n  let t1;\n  let x;\n  if ($[0] !== obj || $[1] !== objIsNull) {\n    t1 = Symbol.for(\"react.early_return_sentinel\");\n    bb0: {\n      x = [];\n      if (objIsNull) {\n        t1 = undefined;\n        break bb0;\n      }\n\n      x.push(obj.b);\n    }\n    $[0] = obj;\n    $[1] = objIsNull;\n    $[2] = t1;\n    $[3] = x;\n  } else {\n    t1 = $[2];\n    x = $[3];\n  }\n  if (t1 !== Symbol.for(\"react.early_return_sentinel\")) {\n    return t1;\n  }\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Object Property Manipulation with Dynamic Keys in JavaScript\nDESCRIPTION: Function that creates a new object using spread operator, then assigns properties using dynamic keys. Used in combination with a test fixture export for a TodoAdd component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-computed-access-assignment.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(a, b, c) {\n  const x = {...a};\n  x[b] = c[b];\n  x[1 + 2] = c[b * 4];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Complex Logic (Simplified)\nDESCRIPTION: This code defines a React functional component named `MyComponent` with complex conditional statements and hooks. It aims to illustrate scenarios that can be computationally expensive to analyze, potentially related to memoization or other performance optimizations. The conditional logic and hooks contribute to the component's overall complexity.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-c1e8c7f4c191.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// Is valid but hard to compute by brute-forcing\nfunction MyComponent() {\n  if (c) {\n  }\n  if (c) {\n  }\n  if (c) {\n  }\n  if (c) {\n  }\n  if (c) {\n  }\n  if (c) {\n  }\n  if (c) {\n  }\n  if (c) {\n  }\n  if (c) {\n  }\n  if (c) {\n  }\n  if (c) {\n  }\n  if (c) {\n  }\n  if (c) {\n  }\n  if (c) {\n  }\n  if (c) {\n  }\n  if (c) {\n  }\n  if (c) {\n  }\n  if (c) {\n  }\n  if (c) {\n  }\n  if (c) {\n  }\n  if (c) {\n  }\n  if (c) {\n  }\n  if (c) {\n  }\n  if (c) {\n  }\n  if (c) {\n  }\n  if (c) {\n  }\n  if (c) {\n  }\n  if (c) {\n  }\n  if (c) {\n  }\n  if (c) {\n  }\n  if (c) {\n  }\n  if (c) {\n  }\n  if (c) {\n  }\n  if (c) {\n  }\n  if (c) {\n  }\n  if (c) {\n  }\n\n  useHook();\n  useHook();\n  useHook();\n  useHook();\n  useHook();\n  useHook();\n  useHook();\n  useHook();\n  useHook();\n  useHook();\n}\n\n```\n\n----------------------------------------\n\nTITLE: Transformed React Component\nDESCRIPTION: This snippet represents the transformed version of the `Component` after possible optimization. The `useMemo` hook has been removed, directly assigning `props.value` to a local variable `t0` and then assigning `t0` to `x` before returning it. The `FIXTURE_ENTRYPOINT` remains the same, defining test configurations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-labeled-statement-unconditional-return.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let t0;\n\n  t0 = props.value;\n  const x = t0;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiled JavaScript Function with Memoization\nDESCRIPTION: This snippet shows the compiled version of the `foo` function using `react/compiler-runtime`. It utilizes `_c(1)` to memoize the result of the function. If the memoized value is not available (first execution), it creates the data structure as in the original function. Subsequent calls will directly return the memoized value from the cache, thus avoiding redundant calculations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-scope-grouping.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction foo() {\n  const $ = _c(1);\n  let x;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    x = {};\n    const y = [];\n    const z = {};\n    y.push(z);\n    x.y = y;\n    $[0] = x;\n  } else {\n    x = $[0];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [],\n  isComponent: false,\n};\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Reactive State Management in a React Component\nDESCRIPTION: This snippet enhances the previous component by incorporating a reactive state management approach using `react/compiler-runtime`. It rerenders the component based on the condition of `$[0]` and updates it accordingly. The logic within the loop remains similar, but now includes state validation and updates for reactive usage, allowing the output array `t0` to either hold the new value of `x` or the previous state depending on the condition.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-do-while-test.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  let x;\n  let i = 0;\n  do {\n    if (i > 10) {\n      x = 10;\n    } else {\n      x = 1;\n    }\n\n    i++;\n  } while (i < props.test);\n  let t0;\n  if ($[0] !== x) {\n    t0 = [x];\n    $[0] = x;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  sequentialRenders: [\n    { test: 12 },\n    { test: 12 },\n    { test: 1 },\n    { test: 1 },\n    { test: 12 },\n    { test: 1 },\n    { test: 12 },\n    { test: 1 },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Problematic React Component Implementation\nDESCRIPTION: Modified version of the component with an infinite loop bug due to improper loop variable declaration (const) and missing increment. This appears to be a test case for detecting problematic implementations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-return.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  for (const i = 0; 0 < props.count; ) {\n    return;\n  }\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a function with conditional logic in Javascript\nDESCRIPTION: This code snippet defines a Javascript function named `foo` that takes four arguments and uses nested `if` statements to assign a value to `x` based on these arguments. The function is structured to intentionally avoid a phi node and create two distinct phis.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-sibling-phis.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(a, b, c, d) {\n  let x = 0;\n  if (true) {\n    if (true) {\n      x = a;\n    } else {\n      x = b;\n    }    \n  } else {\n    if (true) {\n      x = c;\n    } else {\n      x = d;\n    }\n  }\n  // note: intentionally no phi here so that there are two distinct phis above\n}\n```\n\n----------------------------------------\n\nTITLE: Error Message for Invalid React Component Implementation\nDESCRIPTION: This error message is generated when analyzing the React component. It points out the specific line where setState is called unconditionally during render, which would trigger an infinite loop. The error provides a link to the React documentation for further information.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.unconditional-set-state-in-render-after-loop.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n  4 |   for (const _ of props) {\n  5 |   }\n> 6 |   setState(true);\n    |   ^^^^^^^^ InvalidReact: This is an unconditional set state during render, which will trigger an infinite loop. (https://react.dev/reference/react/useState) (6:6)\n  7 |   return state;\n  8 | }\n  9 |\n```\n\n----------------------------------------\n\nTITLE: Input Example of React useEffect with Pruned Non-Reactive Values\nDESCRIPTION: Example React component demonstrating a scenario where semantically non-reactive values have pruned scopes due to interleaving hook calls. The code shows how the React compiler needs to handle effect dependencies for such cases.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/pruned-nonreactive-obj.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @inferEffectDependencies\nimport {useIdentity, mutate, makeObject} from 'shared-runtime';\nimport {useEffect} from 'react';\n\n/**\n * When a semantically non-reactive value has a pruned scope (i.e. the object\n * identity becomes reactive, but the underlying value it represents should be\n * constant), the compiler can choose to either\n * - add it as a dependency (and rerun the effect)\n * - not add it as a dependency\n *\n * We keep semantically non-reactive values in both memo block and effect\n * dependency arrays to avoid versioning invariants e.g. `x !== y.aliasedX`.\n * ```js\n * function Component() {\n *   // obj is semantically non-reactive, but its memo scope is pruned due to\n *   // the interleaving hook call\n *   const obj = {};\n *   useHook();\n *   write(obj);\n *\n *   const ref = useRef();\n *\n *   // this effect needs to be rerun when obj's referential identity changes,\n *   // because it might alias obj to a useRef / mutable store.\n *   useEffect(() => ref.current = obj, ???);\n *\n *   // in a custom hook (or child component), the user might expect versioning\n *   // invariants to hold\n *   useHook(ref, obj);\n * }\n *\n * // defined elsewhere\n * function useHook(someRef, obj) {\n *   useEffect(\n *     () => assert(someRef.current === obj),\n *     [someRef, obj]\n *   );\n * }\n * ```\n */\nfunction PrunedNonReactive() {\n  const obj = makeObject();\n  useIdentity(null);\n  mutate(obj);\n\n  useEffect(() => print(obj.value));\n}\n```\n\n----------------------------------------\n\nTITLE: React Component Fixture Entrypoint\nDESCRIPTION: Defines a test fixture for the Component with predefined parameters, used for testing or evaluation purposes\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unmemoized-nonreactive-dependency-is-pruned-as-dependency.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ value: 42 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled Hook Implementation\nDESCRIPTION: Compiled version of the hook using React compiler runtime with memoization. Uses an array $ for storing previous end value and result, implementing a caching mechanism for optimization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unlabeled-break-within-label-loop.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction useHook(end) {\n  const $ = _c(2);\n  let log;\n  if ($[0] !== end) {\n    log = [];\n    for (let i = 0; i < end + 1; i++) {\n      log.push(`${i} @A`);\n      if (i === end) {\n        break;\n      }\n\n      log.push(`${i} @B`);\n\n      log.push(`${i} @C`);\n    }\n    $[0] = end;\n    $[1] = log;\n  } else {\n    log = $[1];\n  }\n  return log;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useHook,\n  params: [1],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining useFoo with Basic Input Handling in JavaScript\nDESCRIPTION: The first implementation of the useFoo function processes input properties based on the hasAB and returnNull flags. It returns an array constructed from the identity of input.a or null based on the conditions. Dependencies include 'shared-runtime' for identity function.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-unpoisoned/reduce-if-exhaustive-nonpoisoned-deps.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {identity} from 'shared-runtime';\n\nfunction useFoo({input, hasAB, returnNull}) {\n  const x = [];\n  if (!hasAB) {\n    x.push(identity(input.a));\n    if (!returnNull) {\n      return null;\n    }\n  } else {\n    x.push(identity(input.a.b));\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{input: {b: 1}, hasAB: false, returnNull: false}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Function with Memoization\nDESCRIPTION: Compiler-transformed version that adds caching using a closure array ($), implements early returns using symbols, and preserves mutation semantics. Includes block-level scoping and conditional value tracking.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/align-scope-starts-within-cond.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { mutate } from \"shared-runtime\";\n\n/**\n * Similar fixture to `align-scopes-nested-block-structure`, but\n * a simpler case.\n */\nfunction useFoo(cond) {\n  const $ = _c(3);\n  let s;\n  let t0;\n  if ($[0] !== cond) {\n    t0 = Symbol.for(\"react.early_return_sentinel\");\n    bb0: {\n      if (cond) {\n        s = {};\n      } else {\n        t0 = null;\n        break bb0;\n      }\n\n      mutate(s);\n    }\n    $[0] = cond;\n    $[1] = t0;\n    $[2] = s;\n  } else {\n    t0 = $[1];\n    s = $[2];\n  }\n  if (t0 !== Symbol.for(\"react.early_return_sentinel\")) {\n    return t0;\n  }\n  return s;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [true],\n};\n```\n\n----------------------------------------\n\nTITLE: React useCallback Input\nDESCRIPTION: This code snippet demonstrates a React component named 'Foo' that uses the useCallback hook. The component initializes a variable 'x', pushes a prop into it, reassigns 'x' to a new array created by 'makeArray', and then defines a useCallback hook that returns an array containing 'x'. The useCallback dependency array includes 'x'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useCallback-captures-reassigned-context.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees\n\nimport {useCallback} from 'react';\nimport {makeArray} from 'shared-runtime';\n\n// This case is fine, as all reassignments happen before the useCallback\nfunction Foo(props) {\n  let x = [];\n  x.push(props);\n  x = makeArray();\n\n  const cb = useCallback(() => [x], [x]);\n\n  return cb;\n}\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{}]\n};\n```\n\n----------------------------------------\n\nTITLE: React Component Definition and Export\nDESCRIPTION: This code defines a functional React component named `Component` that accepts `props` as input. The component returns an object containing `props` passed into a function `f`. The result is assigned to the `foo` property. The component and its default parameters are exported as `FIXTURE_ENTRYPOINT`.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-no-component-obj-return.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @compilationMode(infer)\nfunction Component(props) {\n  const ignore = <foo />;\n  return { foo: f(props) };\n}\n\nfunction f(props) {\n  return props;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}]\n};\n\n```\n\n----------------------------------------\n\nTITLE: Using React Compiler Test Hook in JavaScript\nDESCRIPTION: This snippet demonstrates how to import and use a specific hook from the ReactCompilerTest library within a functional React component. It exhibits an invalid type configuration for the intended hook usage, highlighting a mismatch between expected and actual types.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-type-provider-hook-name-not-typed-as-hook-namespace.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport ReactCompilerTest from 'ReactCompilerTest';\n\nfunction Component() {\n  return ReactCompilerTest.useHookNotTypedAsHook();\n}\n\n```\n\nLANGUAGE: javascript\nCODE:\n```\n```\n  2 |\n  3 | function Component() {\n> 4 |   return ReactCompilerTest.useHookNotTypedAsHook();\n    |          ^^^^^^^^^^^^^^^^^ InvalidConfig: Invalid type configuration for module. Expected type for object property 'useHookNotTypedAsHook' from module 'ReactCompilerTest' to be a hook based on the property name (4:4)\n  5 | }\n  6 |\n```\n\n----------------------------------------\n\nTITLE: Managing Array Mutations with shared-runtime in JavaScript\nDESCRIPTION: This snippet uses shared-runtime to demonstrate how the concat method captures values from one array into another. The Foo function shows potential impacts of mutating the resulting array, which may affect the original array. The dependency includes the shared-runtime library, and it showcases how later mutations of the resulting array may write to values within the original array.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-concat-should-capture.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {mutate} from 'shared-runtime';\n\n/**\n * Fixture showing why `concat` needs to capture both the callee and rest args.\n * Here, observe that arr1's values are captured into arr2.\n *  - Later mutations of arr2 may write to values within arr1.\n *  - Observe that it's technically valid to separately memoize the array arr1\n *    itself.\n */\nfunction Foo({inputNum}) {\n  const arr1: Array<number | object> = [{a: 1}, {}];\n  const arr2 = arr1.concat([1, inputNum]);\n  mutate(arr2[0]);\n  return arr2;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{inputNum: 2}],\n  sequentialRenders: [{inputNum: 2}, {inputNum: 3}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Component Logic in JavaScript\nDESCRIPTION: This snippet defines a React functional component that creates two objects using a hypothetical 'makeObject' function and evaluates a conditional expression to determine which property to use based on the objects and props. It demonstrates how to manage dependencies on prop values using logical operators.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unused-logical-assigned-to-variable.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  // unused!\n  const obj = makeObject();\n  const obj2 = makeObject();\n  const _ = (obj.a ?? obj2.b) || props.c;\n  return null;\n}\n\n```\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const obj = makeObject();\n  const obj2 = makeObject();\n  (obj.a ?? obj2.b) || props.c;\n  return null;\n}\n\n```\n\n----------------------------------------\n\nTITLE: React Component with useMemo Implementation\nDESCRIPTION: Original React component implementation using useMemo hooks to memoize values and arrays. Shows pattern for memoizing individual items and collections with dependencies.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-provider-store-capture.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useMemo} from 'react';\nimport {typedArrayPush, ValidateMemoization} from 'shared-runtime';\n\nexport function Component({a, b}) {\n  const item1 = useMemo(() => ({a}), [a]);\n  const item2 = useMemo(() => ({b}), [b]);\n  const items = useMemo(() => {\n    const items = [];\n    typedArrayPush(items, item1);\n    typedArrayPush(items, item2);\n    return items;\n  }, [item1, item2]);\n\n  return (\n    <>\n      <ValidateMemoization inputs={[a]} output={items[0]} />\n      <ValidateMemoization inputs={[b]} output={items[1]} />\n      <ValidateMemoization inputs={[a, b]} output={items} />\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Chaining Frontend API Methods\nDESCRIPTION: Example showing how to chain Frontend API methods for convenience in initializing DevTools UI.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools-core/README.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst DevtoolsUI = require(\"react-devtools-core/standalone\");\nDevtoolsUI.setContentDOMNode(element).startServer();\n```\n\n----------------------------------------\n\nTITLE: Defining Native Log Function with Compiler Runtime\nDESCRIPTION: This snippet defines the 'getNativeLogFunction' utilizing the React compiler-runtime. It is similar to the previous function but adds optimizations to address performance, while managing logging behaviors for different input scenarios.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capture-param-mutate.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction getNativeLogFunction(level) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== level) {\n    t0 = function () {\n      let str;\n      if (arguments.length === 1 && typeof arguments[0] === \"string\") {\n        str = arguments[0];\n      } else {\n        str = Array.prototype.map.call(arguments, _temp).join(\", \");\n      }\n\n      const firstArg = arguments[0];\n      let logLevel = level;\n      if (\n        typeof firstArg === \"string\" &&\n        firstArg.slice(0, 9) === \"Warning: \" &&\n        logLevel >= LOG_LEVELS.error\n      ) {\n        logLevel = LOG_LEVELS.warn;\n      }\n      if (global.__inspectorLog) {\n        global.__inspectorLog(\n          INSPECTOR_LEVELS[logLevel],\n          str,\n          [].slice.call(arguments),\n          INSPECTOR_FRAMES_TO_SKIP,\n        );\n      }\n      if (groupStack.length) {\n        str = groupFormat(\"\", str);\n      }\n\n      global.nativeLoggingHook(str, logLevel);\n    };\n    $[0] = level;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\nfunction _temp(arg) {\n  return inspect(arg, { depth: 10 });\n}\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component (useCallback Replacement)\nDESCRIPTION: This code represents the compiled version of the React component Foo, where the useCallback hook has been replaced with a more efficient mechanism. Instead of useCallback, it utilizes a compiler runtime helper (_c) to cache the function (t0). The function is only recreated when the router location changes, mirroring the behavior of useCallback but optimized by the compiler.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-member-expr-arguments.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Foo(props) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== props.router.location) {\n    t0 = (reason) => {\n      log(props.router.location);\n    };\n    $[0] = props.router.location;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const onFoo = t0;\n  return onFoo;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: This code shows the compiled version of the React component, utilizing `react/compiler-runtime` for memoization. It introduces variables and conditional logic to cache and reuse values based on prop changes and previous computations. The component uses a mutable array `$` to store intermediate values for memoization, improving performance by avoiding unnecessary recalculations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/bug-object-expression-computed-key-modified-during-after-construction-hoisted-sequence-expr.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { identity, mutate } from \"shared-runtime\";\n\n/**\n * Bug: copy of error.todo-object-expression-computed-key-modified-during-after-construction-sequence-expr\n * with the mutation hoisted to a named variable instead of being directly\n * inlined into the Object key.\n *\n * Found differences in evaluator results\n *   Non-forget (expected):\n *   (kind: ok) [{\"[object Object]\":[42]},{\"wat0\":\"joe\",\"wat1\":\"joe\"}]\n *   [{\"[object Object]\":[42]},{\"wat0\":\"joe\",\"wat1\":\"joe\"}]\n *   Forget:\n *   (kind: ok) [{\"[object Object]\":[42]},{\"wat0\":\"joe\",\"wat1\":\"joe\"}]\n *   [{\"[object Object]\":[42]},{\"wat0\":\"joe\",\"wat1\":\"joe\",\"wat2\":\"joe\"}]\n */\nfunction Component(props) {\n  const $ = _c(8);\n  let key;\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    key = {};\n    t0 = (mutate(key), key);\n    $[0] = key;\n    $[1] = t0;\n  } else {\n    key = $[0];\n    t0 = $[1];\n  }\n  const tmp = t0;\n  let t1;\n  if ($[2] !== props.value) {\n    t1 = identity([props.value]);\n    $[2] = props.value;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  let t2;\n  if ($[4] !== t1) {\n    t2 = { [tmp]: t1 };\n    $[4] = t1;\n    $[5] = t2;\n  } else {\n    t2 = $[5];\n  }\n  const context = t2;\n\n  mutate(key);\n  let t3;\n  if ($[6] !== context) {\n    t3 = [context, key];\n    $[6] = context;\n    $[7] = t3;\n  } else {\n    t3 = $[7];\n  }\n  return t3;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ value: 42 }],\n  sequentialRenders: [{ value: 42 }, { value: 42 }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Compiler Runtime in JavaScript\nDESCRIPTION: This snippet shows the compiled and optimized version of the React component using the React compiler runtime. It includes memoization techniques to avoid unnecessary re-renders and optimizes the rendering of the Stringify component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/global-types/repro-array-filter-capture-mutate-bug.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { mutateAndReturn, Stringify, useIdentity } from \"shared-runtime\";\n\n/**\n * Repro for bug with `mutableOnlyIfOperandsAreMutable` flag\n * Found differences in evaluator results\n  * Non-forget (expected):\n  * (kind: ok)\n  * <div>{\"children\":[{\"value\":\"foo\",\"wat0\":\"joe\"},{\"value\":5,\"wat0\":\"joe\"}]}</div>\n  * <div>{\"children\":[{\"value\":\"foo\",\"wat0\":\"joe\"},{\"value\":6,\"wat0\":\"joe\"}]}</div>\n  * <div>{\"children\":[{\"value\":\"foo\",\"wat0\":\"joe\"},{\"value\":6,\"wat0\":\"joe\"}]}</div>\n  * Forget:\n  * (kind: ok)\n  * <div>{\"children\":[{\"value\":\"foo\",\"wat0\":\"joe\"},{\"value\":5,\"wat0\":\"joe\"}]}</div>\n  * <div>{\"children\":[{\"value\":\"foo\",\"wat0\":\"joe\",\"wat1\":\"joe\"},{\"value\":6,\"wat0\":\"joe\"}]}</div>\n  * <div>{\"children\":[{\"value\":\"foo\",\"wat0\":\"joe\",\"wat1\":\"joe\"},{\"value\":6,\"wat0\":\"joe\"}]}</div>\n\n */\nfunction Component(t0) {\n  const $ = _c(7);\n  const { value } = t0;\n  const arr = [{ value: \"foo\" }, { value: \"bar\" }, { value }];\n  useIdentity(null);\n  const derived = arr.filter(mutateAndReturn);\n  let t1;\n  if ($[0] !== derived) {\n    t1 = derived.at(0);\n    $[0] = derived;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  let t2;\n  if ($[2] !== derived) {\n    t2 = derived.at(-1);\n    $[2] = derived;\n    $[3] = t2;\n  } else {\n    t2 = $[3];\n  }\n  let t3;\n  if ($[4] !== t1 || $[5] !== t2) {\n    t3 = (\n      <Stringify>\n        {t1}\n        {t2}\n      </Stringify>\n    );\n    $[4] = t1;\n    $[5] = t2;\n    $[6] = t3;\n  } else {\n    t3 = $[6];\n  }\n  return t3;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ value: 5 }],\n  sequentialRenders: [{ value: 5 }, { value: 6 }, { value: 6 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Transformed React Hook with Compiler-Managed Memoization\nDESCRIPTION: This snippet shows the transformed version of the `useFoo` hook, likely produced by a React compiler. It manages memoization using a cache (`_c`) and checks for a sentinel value (`Symbol.for(\"react.memo_cache_sentinel\")`) to determine if the array and the derived function need to be recomputed. The `FIXTURE_ENTRYPOINT` remains the same, exporting the hook for use.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useCallback-infer-read-dep.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @validatePreserveExistingMemoizationGuarantees\nimport { useCallback } from \"react\";\nimport { sum } from \"shared-runtime\";\n\nfunction useFoo() {\n  const $ = _c(2);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = [1, 2, 3];\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const val = t0;\n  let t1;\n  if ($[1] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = () => sum(...val);\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Type Alias Parameter Annotation Transformed Output\nDESCRIPTION: Transformed JavaScript code after TypeScript compilation. Shows how the type annotations are removed and the arrow function is converted to a regular function declaration.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-alias-used-as-annotation.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableAssumeHooksFollowRulesOfReact @enableTransitivelyFreezeFunctionExpressions\ntype Bar = string;\nfunction TypeAliasUsedAsParamAnnotation() {\n  const fun = _temp;\n\n  fun(\"hello, world\");\n}\nfunction _temp(f) {\n  console.log(f);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: TypeAliasUsedAsParamAnnotation,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Stringify in JavaScript\nDESCRIPTION: This snippet defines a React component that uses the Stringify function. It includes a callback function and passes props to the Stringify component. The FIXTURE_ENTRYPOINT is also defined for testing purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/component-inner-function-with-many-args.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {Stringify} from 'shared-runtime';\nfunction Component(props) {\n  const cb = (x, y, z) => x + y + z;\n\n  return <Stringify cb={cb} id={props.id} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{id: 0}],\n};\n```\n\n----------------------------------------\n\nTITLE: Stopping Stream Flow in React\nDESCRIPTION: Method to pause or end the writing of serialized output for a request. Supports streaming backpressure implementation and can be resumed with startFlowing.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-server/README.md#2025-04-21_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nstopFlowing(request: Request): void\n```\n\n----------------------------------------\n\nTITLE: Simplified React Component Implementation\nDESCRIPTION: Shows a minimalist version of the component function with empty conditional block and exports the same fixture structure. Used to demonstrate basic component structure without implementation details.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-args-test-binary-operator.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component(a, b) {\n  if (a > b) {\n  }\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component Implementation\nDESCRIPTION: Compiled version of the React component showing how memoization is implemented at runtime. Uses the compiler-runtime to manage cached values and dependencies tracking.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reordering-across-blocks.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { Stringify } from \"shared-runtime\";\n\nfunction Component(t0) {\n  const $ = _c(9);\n  const { config } = t0;\n  let t1;\n  let t2;\n  if ($[0] !== config) {\n    t2 = (event) => {\n      config?.onA?.(event);\n    };\n    $[0] = config;\n    $[1] = t2;\n  } else {\n    t2 = $[1];\n  }\n  const a = t2;\n  let t3;\n  if ($[2] !== config) {\n    t3 = (event_0) => {\n      config?.onB?.(event_0);\n    };\n    $[2] = config;\n    $[3] = t3;\n  } else {\n    t3 = $[3];\n  }\n  const b = t3;\n  let t4;\n  if ($[4] !== a || $[5] !== b) {\n    t4 = { b, a };\n    $[4] = a;\n    $[5] = b;\n    $[6] = t4;\n  } else {\n    t4 = $[6];\n  }\n  t1 = t4;\n  const object = t1;\n  let t5;\n  if ($[7] !== object) {\n    t5 = <Stringify value={object} />;\n    $[7] = object;\n    $[8] = t5;\n  } else {\n    t5 = $[8];\n  }\n  return t5;\n}\n```\n\n----------------------------------------\n\nTITLE: Transformed React Component with useFire\nDESCRIPTION: This code presents the transformed version of the React component using the `useFire` hook and compiler-runtime. The compiler has replaced the direct `fire` call with a `useFire` hook and a conditional update to trigger the effect only when necessary, optimizing performance by memoizing the handler.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/rewrite-deps.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c, useFire } from \"react/compiler-runtime\"; // @enableFire\nimport { fire } from \"react\";\n\nfunction Component(props) {\n  const $ = _c(4);\n  const foo = _temp;\n  const t0 = useFire(foo);\n  let t1;\n  let t2;\n  if ($[0] !== props || $[1] !== t0) {\n    t1 = () => {\n      t0(props);\n    };\n    t2 = [t0, props];\n    $[0] = props;\n    $[1] = t0;\n    $[2] = t1;\n    $[3] = t2;\n  } else {\n    t1 = $[2];\n    t2 = $[3];\n  }\n  useEffect(t1, t2);\n  return null;\n}\nfunction _temp(props_0) {\n  console.log(props_0);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Original React Component with Mutable Object in JSX\nDESCRIPTION: A React hook function that demonstrates how a mutable object is created, potentially mutated, and then captured in a JSX expression. The example explores a complex edge case of scope management when JSX references values across different scopes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/mutation-within-jsx.expect.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {\n  Stringify,\n  makeObject_Primitives,\n  mutateAndReturn,\n} from 'shared-runtime';\n\n/**\n * In this example, the `<Stringify ... />` JSX block mutates then captures obj.\n * As JSX expressions freeze their values, we know that `obj` and `myDiv` cannot\n * be mutated past this.\n * This set of mutable range + scopes is an edge case because the JSX expression\n * references values in two scopes.\n * - (freeze) the result of `mutateAndReturn`\n *   this is a mutable value with a mutable range starting at `makeObject()`\n * - (mutate) the lvalue storing the result of `<Stringify .../>`\n *   this is a immutable value and so gets assigned a different scope\n *\n * obj@0 = makeObj();                         scope@0\n * if (cond) {                               |\n *   $1@0 = mutate(obj@0);                   |\n *   myDiv@1 = JSX $1@0          <- scope@1  |\n * }                                         \n *\n * Coincidentally, the range of `obj` is extended by alignScopesToBlocks to *past*\n * the end of the JSX instruction. As we currently alias identifier mutableRanges to\n * scope ranges, this `freeze` reference is perceived as occurring during the mutable\n * range of `obj` (even though it is after the last mutating reference).\n *\n * This case is technically safe as `myDiv` correctly takes `obj` as a dependency. As\n * a result, developers can never observe myDiv can aliasing a different value generation\n * than `obj` (e.g. the invariant `myDiv.props.value === obj` always holds).\n */\nfunction useFoo({data}) {\n  let obj = null;\n  let myDiv = null;\n  if (data.cond) {\n    obj = makeObject_Primitives();\n    if (data.cond1) {\n      myDiv = <Stringify value={mutateAndReturn(obj)} />;\n    }\n  }\n  return myDiv;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{data: {cond: true, cond1: true}}],\n  sequentialRenders: [\n    {data: {cond: true, cond1: true}},\n    {data: {cond: true, cond1: true}},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Reordering Children Operation in React DevTools\nDESCRIPTION: Example showing the operation payload for reordering children of a component. It includes the operation type, parent fiber id, count of children, and the ordered list of child fiber ids.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/OVERVIEW.md#2025-04-21_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\n[\n  3,  // re-order operation\n  15, // fiber id\n  2,  // number of children\n  35, // first child id\n  21, // second child id\n]\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization in JavaScript\nDESCRIPTION: This snippet shows the compiled version of the Component using React's compiler runtime. It includes memoization logic to optimize performance by caching the result of the default parameter check.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/default-param-array-with-unary.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(t0) {\n  const $ = _c(2);\n  let t1;\n  if ($[0] !== t0) {\n    t1 = t0 === undefined ? [-1, 1] : t0;\n    $[0] = t0;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  const x = t1;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing a React Hook with Conditionals\nDESCRIPTION: The snippet imports constants and a component from a shared runtime. It defines a React hook that uses these constants to dynamically compute a value. If the 'cond' parameter is true, a constant is added to an initial value, which is then limited to a maximum of 100. It returns a JSX element of type 'Stringify' with a function and a boolean flag as props. Dependencies include 'shared-runtime', and the function expects an object with a 'cond' property. It returns a JSX component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-reassigned-twice-let-declaration.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {CONST_NUMBER0, CONST_NUMBER1, Stringify} from 'shared-runtime';\n\nfunction useHook({cond}) {\n  'use memo';\n  const getX = () => x;\n\n  let x = CONST_NUMBER0;\n  if (cond) {\n    x += CONST_NUMBER1;\n    x = Math.min(x, 100);\n  }\n  return <Stringify getX={getX} shouldInvokeFns={true} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useHook,\n  params: [{cond: true}],\n  sequentialRenders: [{cond: true}, {cond: true}, {cond: false}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Original React Components with Forget Directive\nDESCRIPTION: Original React component definitions using the 'use forget' directive. Includes Bar and Foo components with forget functionality, and a NoForget component without it. Also includes a fixture entrypoint for testing.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/gating-test-export-function.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @gating @compilationMode(annotation)\nexport function Bar(props) {\n  'use forget';\n  return <div>{props.bar}</div>;\n}\n\nexport function NoForget(props) {\n  return <Bar>{props.noForget}</Bar>;\n}\n\nexport function Foo(props) {\n  'use forget';\n  return <Foo>{props.bar}</Foo>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: eval('Bar'),\n  params: [{bar: 2}],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with State Management in JavaScript\nDESCRIPTION: This snippet implements a more complex version of the Component function using internal mutable state via the _c function from 'react/compiler-runtime'. It checks for changes in props and stores previous values to optimize re-rendering and maintain local state, showcasing advanced React component handling.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/temporary-accessed-outside-scope.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(6);\n  let t0;\n  let t1;\n  if ($[0] !== props) {\n    const maybeMutable = new MaybeMutable();\n    const x = props;\n    t0 = x;\n    t1 = maybeMutate(maybeMutable);\n    $[0] = props;\n    $[1] = t0;\n    $[2] = t1;\n  } else {\n    t0 = $[1];\n    t1 = $[2];\n  }\n  let t2;\n  if ($[3] !== t0 || $[4] !== t1) {\n    t2 = [t0, t1];\n    $[3] = t0;\n    $[4] = t1;\n    $[5] = t2;\n  } else {\n    t2 = $[5];\n  }\n  return t2;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Exporting Fixture Entry Point - JavaScript\nDESCRIPTION: This snippet exports a constant 'FIXTURE_ENTRYPOINT' which is an object containing the component function, an array of parameters, and an indication of the component's name. This structure is likely intended for use in tests or examples where the component needs to be instantiated with specific parameters.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unused-conditional.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component Output\nDESCRIPTION: Compiled version of the component with React compiler runtime optimizations. Implements caching mechanism using the _c compiler helper to avoid recreating objects on each render when inputs haven't changed.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructure-capture-global.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nlet someGlobal = {};\nfunction component(a) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== a) {\n    t0 = { a, someGlobal };\n    $[0] = a;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const x = t0;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: [\"value 1\"],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: React Error for Invalid Ref Access\nDESCRIPTION: The error message shown when React detects a ref.current access during component render. The error points to line 6 where the ref value is read and explains that ref values may not be accessed during render.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.ref-initialization-nonif.expect.md#2025-04-22_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n  4 | component C() {\n  5 |   const r = useRef(null);\n> 6 |   const guard = r.current == null;\n    |                 ^^^^^^^^^^^^^^^^^ InvalidReact: Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef) (6:6)\n\nInvalidReact: Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef). Cannot access ref value `guard` (7:7)\n  7 |   if (guard) {\n  8 |     r.current = 1;\n  9 |   }\n```\n\n----------------------------------------\n\nTITLE: Initializing React Component with useReducer\nDESCRIPTION: Demonstrates incorrect usage of useReducer hook by attempting to directly mutate state, which is an anti-pattern in React\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.modify-useReducer-state.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useReducer} from 'react';\n\nfunction Foo() {\n  let [state, setState] = useReducer({foo: 1});\n  state.foo = 1;\n  return state;\n}\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Compiler Runtime\nDESCRIPTION: Optimized version of the component using React compiler runtime for memoization. Implements value caching to prevent unnecessary array creation and push operations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/debugger-memoized.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  let x;\n  if ($[0] !== props.value) {\n    x = [];\n    debugger;\n\n    x.push(props.value);\n    $[0] = props.value;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Initializing React Component with Problematic Variable Reassignment\nDESCRIPTION: Demonstrates a React component with potential state management issues by directly reassigning variables instead of using React state hooks. The code triggers a lint warning about inconsistent behavior during renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.mutable-range-shared-inner-outer-function.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableAssumeHooksFollowRulesOfReact @enableTransitivelyFreezeFunctionExpressions\nlet cond = true;\nfunction Component(props) {\n  let a;\n  let b;\n  const f = () => {\n    if (cond) {\n      a = {};\n      b = [];\n    } else {\n      a = {};\n      b = [];\n    }\n    a.property = true;\n    b.push(false);\n  };\n  return <div onClick={f()} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining useFoo Component and Fixture (Input)\nDESCRIPTION: This code defines a React component called `useFoo` which conditionally mutates an array based on the provided props (`bar`, `foo`, `cond`). The `FIXTURE_ENTRYPOINT` object configures the component for testing with specific initial parameters and sequential renders. The `mutate` function is used which is likely part of a shared runtime for state management or triggering updates.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/ssa-renaming-via-destructuring-with-mutation.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enablePropagateDepsInHIR\nimport {mutate} from 'shared-runtime';\n\nfunction useFoo(props) {\n  let {x} = {x: []};\n  x.push(props.bar);\n  if (props.cond) {\n    ({x} = {x: {}});\n    ({x} = {x: []});\n    x.push(props.foo);\n  }\n  mutate(x);\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{bar: 'bar', foo: 'foo', cond: true}],\n  sequentialRenders: [\n    {bar: 'bar', foo: 'foo', cond: true},\n    {bar: 'bar', foo: 'foo', cond: true},\n    {bar: 'bar', foo: 'foo', cond: false},\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Using useMemo for Memoization in React\nDESCRIPTION: This snippet illustrates how to use the useMemo hook in a React functional component to memoize the derived value from props. The component takes 'propA' as a parameter and uses useMemo to compute a value that depends on 'propA.x'. This ensures that the computed value is recalculated only when 'propA.x' changes, thereby optimizing performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.useMemo-property-call-chained-object.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees\nimport {useMemo} from 'react';\n\nfunction Component({propA}) {\n  return useMemo(() => {\n    return {\n      value: propA.x().y,\n    };\n  }, [propA.x]);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Original JavaScript Function Definition\nDESCRIPTION: This snippet defines a JavaScript function `foo` that creates an object `x`, an array `y`, and an object `z`. It then pushes `z` into `y` and assigns `y` to `x.y`. Finally, it returns `x`. This represents a simple data structure creation and manipulation logic.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-scope-grouping.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo() {\n  let x = {};\n  let y = [];\n  let z = {};\n  y.push(z);\n  x.y = y;\n\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [],\n  isComponent: false,\n};\n\n```\n\n----------------------------------------\n\nTITLE: Optimizing React Component with Compiler Runtime in JavaScript\nDESCRIPTION: This snippet shows an optimized version of the React component using the React compiler runtime. It implements memoization to avoid unnecessary recalculations and object creations, potentially improving performance in React applications.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-variable-in-nested-function.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction component(a) {\n  const $ = _c(4);\n  let t0;\n  if ($[0] !== a) {\n    t0 = { a };\n    $[0] = a;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const z = t0;\n  let t1;\n  if ($[2] !== z) {\n    t1 = function () {\n      (function () {\n        console.log(z);\n      })();\n    };\n    $[2] = z;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  const x = t1;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component Implementation\nDESCRIPTION: This snippet shows an optimized version of the Component, likely generated by a React compiler. It uses memoization techniques to minimize re-renders and improve performance, while maintaining the same functionality as the original component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-provider-store-capture-namespace-import.expect.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useMemo } from \"react\";\nimport * as SharedRuntime from \"shared-runtime\";\n\nexport function Component(t0) {\n  const $ = _c(27);\n  const { a, b } = t0;\n  let t1;\n  let t2;\n  if ($[0] !== a) {\n    t2 = { a };\n    $[0] = a;\n    $[1] = t2;\n  } else {\n    t2 = $[1];\n  }\n  t1 = t2;\n  const item1 = t1;\n  let t3;\n  let t4;\n  if ($[2] !== b) {\n    t4 = { b };\n    $[2] = b;\n    $[3] = t4;\n  } else {\n    t4 = $[3];\n  }\n  t3 = t4;\n  const item2 = t3;\n  let t5;\n  let items;\n  if ($[4] !== item1 || $[5] !== item2) {\n    items = [];\n    SharedRuntime.typedArrayPush(items, item1);\n    SharedRuntime.typedArrayPush(items, item2);\n    $[4] = item1;\n    $[5] = item2;\n    $[6] = items;\n  } else {\n    items = $[6];\n  }\n  t5 = items;\n  const items_0 = t5;\n  let t6;\n  if ($[7] !== a) {\n    t6 = [a];\n    $[7] = a;\n    $[8] = t6;\n  } else {\n    t6 = $[8];\n  }\n  let t7;\n  if ($[9] !== items_0[0] || $[10] !== t6) {\n    t7 = <SharedRuntime.ValidateMemoization inputs={t6} output={items_0[0]} />;\n    $[9] = items_0[0];\n    $[10] = t6;\n    $[11] = t7;\n  } else {\n    t7 = $[11];\n  }\n  let t8;\n  if ($[12] !== b) {\n    t8 = [b];\n    $[12] = b;\n    $[13] = t8;\n  } else {\n    t8 = $[13];\n  }\n  let t9;\n  if ($[14] !== items_0[1] || $[15] !== t8) {\n    t9 = <SharedRuntime.ValidateMemoization inputs={t8} output={items_0[1]} />;\n    $[14] = items_0[1];\n    $[15] = t8;\n    $[16] = t9;\n  } else {\n    t9 = $[16];\n  }\n  let t10;\n  if ($[17] !== a || $[18] !== b) {\n    t10 = [a, b];\n    $[17] = a;\n    $[18] = b;\n    $[19] = t10;\n  } else {\n    t10 = $[19];\n  }\n  let t11;\n  if ($[20] !== items_0 || $[21] !== t10) {\n    t11 = <SharedRuntime.ValidateMemoization inputs={t10} output={items_0} />;\n    $[20] = items_0;\n    $[21] = t10;\n    $[22] = t11;\n  } else {\n    t11 = $[22];\n  }\n  let t12;\n  if ($[23] !== t11 || $[24] !== t7 || $[25] !== t9) {\n    t12 = (\n      <>\n        {t7}\n        {t9}\n        {t11}\n      </>\n    );\n    $[23] = t11;\n    $[24] = t7;\n    $[25] = t9;\n    $[26] = t12;\n  } else {\n    t12 = $[26];\n  }\n  return t12;\n}\n```\n\n----------------------------------------\n\nTITLE: Optimized React Hook Implementation with Compiler-Generated Code\nDESCRIPTION: This snippet shows an optimized version of the 'useFoo' hook, likely generated by a React compiler. It includes additional logic for memoization and dependency tracking, improving performance by minimizing unnecessary re-renders and calculations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useMemo-in-other-reactive-block.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @validatePreserveExistingMemoizationGuarantees\nimport { useMemo, useState } from \"react\";\nimport { arrayPush } from \"shared-runtime\";\n\n// useMemo-produced values can exist in nested reactive blocks, as long\n// as their reactive dependencies are a subset of depslist from source\nfunction useFoo(minWidth, otherProp) {\n  const $ = _c(6);\n  const [width] = useState(1);\n  let t0;\n  if ($[0] !== minWidth || $[1] !== otherProp || $[2] !== width) {\n    const x = [];\n    let t1;\n\n    const t2 = Math.max(minWidth, width);\n    let t3;\n    if ($[4] !== t2) {\n      t3 = { width: t2 };\n      $[4] = t2;\n      $[5] = t3;\n    } else {\n      t3 = $[5];\n    }\n    t1 = t3;\n    const style = t1;\n\n    arrayPush(x, otherProp);\n    t0 = [style, x];\n    $[0] = minWidth;\n    $[1] = otherProp;\n    $[2] = width;\n    $[3] = t0;\n  } else {\n    t0 = $[3];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [2, \"other\"],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with try/catch\nDESCRIPTION: This React component attempts to access `props.cond` and `props.foo` within a try/catch block. The intention is to catch any errors that might occur during property access. The error message indicates an unsupported feature.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-logical-expression-within-try-catch.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let result;\n  try {\n    result = props.cond && props.foo;\n  } catch (e) {\n    console.log(e);\n  }\n  return result;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Output: Compiled React Hook with Dependency Tracking\nDESCRIPTION: The compiled version of the React hook that implements efficient dependency tracking. It uses the React compiler-runtime to track dependencies and memorize results based on props.a and cond values, avoiding unnecessary recalculations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/superpath-order2.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // When an unconditional dependency `props.a` is the subpath of a conditional\n// dependency `props.a.b`, we can safely overestimate and only track `props.a`\n// as a dependency\n\nimport { identity } from \"shared-runtime\";\n\n// ordering of accesses should not matter\nfunction useConditionalSuperpath2(t0) {\n  const $ = _c(3);\n  const { props, cond } = t0;\n  let x;\n  if ($[0] !== cond || $[1] !== props.a) {\n    x = {};\n    if (identity(cond)) {\n      x.b = props.a.b;\n    }\n\n    x.a = props.a;\n    $[0] = cond;\n    $[1] = props.a;\n    $[2] = x;\n  } else {\n    x = $[2];\n  }\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Cache Implementation\nDESCRIPTION: The compiled version of the React component that implements caching logic using Symbol.for('react.memo_cache_sentinel'). It includes memoization of computation results and prop comparison for optimization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/phi-type-inference-array-push.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enablePropagateDepsInHIR\nfunction Component(props) {\n  const $ = _c(4);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = {};\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const x = t0;\n  let t1;\n  if ($[1] !== props.cond || $[2] !== props.value) {\n    let y;\n    if (props.cond) {\n      y = [props.value];\n    } else {\n      y = [];\n    }\n\n    y.push(x);\n\n    t1 = [x, y];\n    $[1] = props.cond;\n    $[2] = props.value;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ cond: true, value: 42 }],\n  sequentialRenders: [\n    { cond: true, value: 3.14 },\n    { cond: false, value: 3.14 },\n    { cond: true, value: 42 },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with FBT Internationalization\nDESCRIPTION: This snippet defines a React component that uses FBT for internationalization. It handles plural forms and conditional rendering based on props.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-unmerged-fbt-call-merge-overlapping-reactive-scopes.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport fbt from 'fbt';\nimport {Stringify} from 'shared-runtime';\n\nfunction Component(props) {\n  const label = fbt(\n    fbt.plural('bar', props.value.length, {\n      many: 'bars',\n      showCount: 'yes',\n    }),\n    'The label text'\n  );\n  return props.cond ? (\n    <Stringify\n      description={<fbt desc=\"Some text\">Text here</fbt>}\n      label={label.toString()}\n    />\n  ) : null;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{cond: true, value: [0, 1, 2]}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining and Invoking Functions with Closures in JavaScript\nDESCRIPTION: This snippet defines a function 'foo' that utilizes closures by creating inner functions 'fn1' and 'fn2'. It demonstrates variable reassignment within these closures but raises concerns regarding React's rendering behavior when variables are reassigned post-render. The key parameters include 'x', which is being reassigned across closures, potentially leading to inconsistencies in state management. The expected output is an array containing results from invoking 'fn1' and the value of 'copy2'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.context-variable-only-chained-assign.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {identity, invoke} from 'shared-runtime';\n\nfunction foo() {\n  let x = 2;\n  const fn1 = () => {\n    const copy1 = (x = 3);\n    return identity(copy1);\n  };\n  const fn2 = () => {\n    const copy2 = (x = 4);\n    return [invoke(fn1), copy2, identity(copy2)];\n  };\n  return invoke(fn2);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Managing Reactivity in React Component\nDESCRIPTION: Defines a React component function that manages two independent states 'a' and 'b,' which become interdependently reactive due to interleaved operations. It demonstrates the control flow logic to manage dependencies reactively, returning a reactive array based on the provided prop. Importantly, 'x' is treated reactively as it indirectly depends on the reactive 'c'. There are no external dependencies beyond standard JavaScript and React environment. Inputs and outputs revolve around a props object and a returned array.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-from-interleaved-reactivity-for-init.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  // a and b are independent but their mutations are interleaved, so\n  // they get grouped in a reactive scope. this means that a becomes\n  // reactive since it will effectively re-evaluate based on a reactive\n  // input\n  const a = [];\n  const b = [];\n  b.push(props.cond);\n  a.push(0);\n\n  // Downstream consumer of a, which initially seems non-reactive except\n  // that a becomes reactive, per above\n  const c = [a];\n\n  let x;\n  for (let i = c[0][0]; i < 10; i++) {\n    x = 1;\n  }\n  // The values assigned to `x` are non-reactive, but the value of `x`\n  // depends on the \"control\" value `c[0]` which becomes reactive via\n  // being interleaved with `b`.\n  // Therefore x should be treated as reactive too.\n  return [x];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{cond: true}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Original React Component with Destructuring\nDESCRIPTION: A React component that demonstrates nested object destructuring with default values from props. The component extracts a nested 'y' value with a default fallback.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-object-default.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const {x: {y} = {y: 'default'}} = props.y;\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Defining React Hook Test Input\nDESCRIPTION: Original hook implementation showing the input pattern for creating a test fixture. Uses createHookWrapper to wrap a custom hook that processes a value parameter and returns one of two constant strings.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-literal-method-in-ternary-test.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {createHookWrapper, CONST_STRING0, CONST_STRING1} from 'shared-runtime';\n\nfunction useHook({value}) {\n  return {\n    getValue() {\n      return identity(value);\n    },\n  }\n    ? CONST_STRING0\n    : CONST_STRING1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: createHookWrapper(useHook),\n  params: [{value: 0}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Original React Component in JavaScript\nDESCRIPTION: This snippet defines a simple React component that destructures a property from its input and returns an object. It also exports a FIXTURE_ENTRYPOINT object for testing purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-object-pattern.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component(t) {\n  let {a} = t;\n  let y = {a};\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: [{a: 42}],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: Initial implementation of a React component with an inline arrow function and variable reassignment. The component invokes a function that returns an object and modifies a local variable.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/constant-prop-colliding-identifier.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {invoke} from 'shared-runtime';\n\nfunction Component() {\n  let x = 2;\n  const fn = () => {\n    return {x: 'value'};\n  };\n  invoke(fn);\n  x = 3;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Initializing Global Variable and React Component\nDESCRIPTION: Defines a global variable and a React component that modifies and renders the global state. Uses compilation mode inference and no panic threshold.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/should-bailout-without-compilation-infer-mode.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nlet someGlobal = 'joe';\n\nfunction Component() {\n  someGlobal = 'wat';\n  return <div>{someGlobal}</div>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Using useRef Hook in React\nDESCRIPTION: This snippet demonstrates the implementation of a custom hook that attempts to set a ref value during the render phase in React. It highlights the error produced when accessing the `current` property of a ref. The main dependency for this code is React itself, specifically the useRef hook.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-write-but-dont-read-ref-in-render.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validateRefAccessDuringRender\nfunction useHook({value}) {\n  const ref = useRef(null);\n  // Writing to a ref in render is against the rules:\n  ref.current = value;\n  // returning a ref is allowed, so this alone doesn't trigger an error:\n  return ref;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining React Functional Component - JavaScript\nDESCRIPTION: This code snippet defines a React functional component named 'Component'. It attempts to mutate an array 'x' after it has already been rendered in the JSX, which triggers a React error due to improper state management practices. The snippet serves as an example of a common mistake where state updates are attempted after JSX rendering.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-mutate-after-freeze.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let x = [];\n\n  let _ = <Component x={x} />;\n\n  // x is Frozen at this point\n  x.push(props.p2);\n\n  return <div>{_}</div>;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Define and Export JavaScript Function\nDESCRIPTION: This code defines a JavaScript function `foo` that takes two arguments, `a` and `b`. It initializes an array `x`, and if `a` is truthy, it reassigns `x` to the value `1`. Finally, it assigns `x` to `y` and returns `y`. The function is then exported as part of the `FIXTURE_ENTRYPOINT` object, which includes information about its parameters and its use as a component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-non-empty-initializer.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(a, b) {\n  let x = [];\n  if (a) {\n    x = 1;\n  }\n\n  let y = x;\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n\n```\n\n----------------------------------------\n\nTITLE: Invalid React Hook Implementation with Side Effects\nDESCRIPTION: An example of incorrect React hook implementation that modifies state outside component scope. The hook violates React's rule about pure components by reassigning an external variable, which should instead be managed with useState.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.update-global-should-bailout.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nlet renderCount = 0;\nfunction useFoo() {\n  renderCount += 1;\n  return renderCount;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Original Function with Complex Destructuring\nDESCRIPTION: Original JavaScript function implementing complex nested destructuring patterns on input parameters with spread operators.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(a, b, c) {\n  const [\n    d,\n    [\n      {\n        e: {f},\n        ...g\n      },\n    ],\n    ...h\n  ] = a;\n  const {\n    l: {\n      m: [[n], ...o],\n    },\n    p,\n  } = b;\n  return [d, f, g, h, n, o, p];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a React Functional Component Using useState - JavaScript\nDESCRIPTION: This code defines a functional component 'Component' that attempts to use the useState Hook incorrectly. It initializes a state variable but assigns the Hook reference itself instead of calling it. The expected output is the first element of the state array, but this will trigger an error due to improper Hook usage.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-assign-hook-to-local.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const x = useState;\n  const state = x(null);\n  return state[0];\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Memo Cache in React Effect Hooks - JavaScript\nDESCRIPTION: This snippet extends NonReactiveDepInEffect to incorporate memoization. It checks if certain cached values are marked with a sentinel to determine whether to create a new object or use a cached one. The React useEffect and SharedRuntime hooks are used to manage side-effects based on these checks. Dependencies on 'react/compiler-runtime' and 'shared-runtime' are necessary.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/import-namespace-useEffect.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @inferEffectDependencies\nimport * as React from \"react\";\nimport * as SharedRuntime from \"shared-runtime\";\n\nfunction NonReactiveDepInEffect() {\n  const $ = _c(4);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = makeObject_Primitives();\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const obj = t0;\n  let t1;\n  if ($[1] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = () => print(obj);\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  React.useEffect(t1, [obj]);\n  let t2;\n  let t3;\n  if ($[2] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t2 = () => print(obj);\n    t3 = [obj];\n    $[2] = t2;\n    $[3] = t3;\n  } else {\n    t2 = $[2];\n    t3 = $[3];\n  }\n  SharedRuntime.useSpecialEffect(t2, t3, [obj]);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Original Component Function Definition in React\nDESCRIPTION: A React component function that returns a closure which logs either an argument or a prop value. The returned function captures the props reference to access props.str when no arguments are provided.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reassigned-phi-in-returned-function-expression.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  return () => {\n    let str;\n    if (arguments.length) {\n      str = arguments[0];\n    } else {\n      str = props.str;\n    }\n    global.log(str);\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing React Function Component with Invoke Utility in JavaScript\nDESCRIPTION: This code snippet defines a React function component 'useFoo' that uses an 'invoke' utility from a shared runtime. It creates an empty object, passes it to the 'invoke' function, and logs the result. The component is then exported as part of a fixture entrypoint object.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/lambda-return-expression.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {invoke} from 'shared-runtime';\n\nfunction useFoo() {\n  const x = {};\n  const result = invoke(() => x);\n  console.log(result);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [],\n  isComponent: false,\n};\n```\n\nLANGUAGE: javascript\nCODE:\n```\nimport { invoke } from \"shared-runtime\";\n\nfunction useFoo() {\n  const x = {};\n  const result = invoke(() => x);\n  console.log(result);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Basic React Component - JavaScript\nDESCRIPTION: This snippet defines a basic React functional component that accepts props, creates an object, converts it to a string, and returns both the object and the string. It serves as a simple demonstration of React component structure.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/globals-String.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const x = {};\n  const y = String(x);\n  return [x, y];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: A React component that conditionally creates an array based on props and demonstrates memoization patterns. The component uses a special compiler directive @enablePropagateDepsInHIR for dependency propagation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/phi-type-inference-array-push.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enablePropagateDepsInHIR\nfunction Component(props) {\n  const x = {};\n  let y;\n  if (props.cond) {\n    y = [props.value];\n  } else {\n    y = [];\n  }\n  // This should be inferred as `<store> y` s.t. `x` can still\n  // be independently memoized. *But* this also must properly\n  // extend the mutable range of the array literals in the\n  // if/else branches\n  y.push(x);\n\n  return [x, y];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{cond: true, value: 42}],\n  sequentialRenders: [\n    {cond: true, value: 3.14},\n    {cond: false, value: 3.14},\n    {cond: true, value: 42},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Using useRef with useCallback in React Component\nDESCRIPTION: This code demonstrates a React component that incorrectly mutates a ref's current value during render. It shows how useRef and useCallback interact, and why modifying a ref during render violates React's rules.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-useCallback-set-ref-nested-property-ref-modified-later-preserve-memoization.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enablePreserveExistingMemoizationGuarantees @validateRefAccessDuringRender\nimport {useCallback, useRef} from 'react';\n\nfunction Component(props) {\n  const ref = useRef({inner: null});\n\n  const onChange = useCallback(event => {\n    // The ref should still be mutable here even though function deps are frozen in\n    // @enablePreserveExistingMemoizationGuarantees mode\n    ref.current.inner = event.target.value;\n  });\n\n  // The ref is modified later, extending its range and preventing memoization of onChange\n  ref.current.inner = null;\n\n  return <input onChange={onChange} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: React Compiler Runtime Transformed Function\nDESCRIPTION: Compiler-generated version of the function with added memoization using _c runtime helper, tracking changes and optimizing return value\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/update-expression-on-function-parameter-2.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(a) {\n  const $ = _c(4);\n  const d = a++;\n  const e = ++a;\n  let t0;\n  if ($[0] !== a || $[1] !== d || $[2] !== e) {\n    t0 = [a, d, e];\n    $[0] = a;\n    $[1] = d;\n    $[2] = e;\n    $[3] = t0;\n  } else {\n    t0 = $[3];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [2],\n  isComponent: false\n};\n```\n\n----------------------------------------\n\nTITLE: Running Fizz Fixtures in Production Mode\nDESCRIPTION: Command to start Fizz Fixtures in production mode, which pre-builds all static resources and starts a server-side rendering HTTP server without hot reloading.\nSOURCE: https://github.com/facebook/react/blob/main/fixtures/fizz/README.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nyarn start:prod\n```\n\n----------------------------------------\n\nTITLE: Running the Test Shell\nDESCRIPTION: Launch the test shell to see changes reflected in the DevTools test app.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/CONTRIBUTING.md#2025-04-21_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\ncd <react-repo>\ncd packages/react-devtools-shell\nyarn start\n```\n\n----------------------------------------\n\nTITLE: Compiled Output with React Memoization\nDESCRIPTION: Compiled version of the useTest hook showing React's memoization implementation using Symbol.for('react.memo_cache_sentinel') and compiler runtime utilities.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/codegen-inline-iife-storeprop.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { makeArray, print } from \"shared-runtime\";\n\nfunction useTest() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const w = {};\n\n    const t1 = (w.x = 42);\n    const t2 = w.x;\n    let t3;\n\n    w.x = 999;\n    t3 = 2;\n    t0 = makeArray(t1, t2, t3);\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useTest,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimizing React Component with Compiler Runtime in JavaScript\nDESCRIPTION: This snippet provides an optimized version of a React component using `react/compiler-runtime`. It maintains state for the `Foo` element using an array to cache element type changes, improving rendering performance. Dependencies include `shared-runtime` and `react/compiler-runtime`, which should be pre-installed. The function is exported with its parameters encapsulated in `FIXTURE_ENTRYPOINT`.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-reactive-local-variable-member-expr.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport * as sharedRuntime from \"shared-runtime\";\n\nfunction Component(t0) {\n  const $ = _c(2);\n  const { something } = t0;\n  const Foo = something.StaticText1;\n  let t1;\n  if ($[0] !== Foo) {\n    t1 = () => <Foo />;\n    $[0] = Foo;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ something: sharedRuntime }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Optimized Counter Function in JavaScript\nDESCRIPTION: An optimized version of the counter function that removes the unnecessary x variable. The function increments only the y variable until reaching the maximum value specified in props, then returns y.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/dce-loop.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(props) {\n  let y = 0;\n  while (y < props.max) {\n    y++;\n  }\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [{ max: 10 }],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: React Component Definition\nDESCRIPTION: This code defines a React functional component named `foo`. The component takes `props` as input, initializes a variable `x` to 0, and enters a while loop that continues as long as `x` is greater than `props.min` and less than `props.max`. Inside the loop, `x` is multiplied by 2. Finally, the component returns the final value of `x`.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/while-logical.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(props) {\n  let x = 0;\n  while (x > props.min && x < props.max) {\n    x *= 2;\n  }\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Input React Function Component Definition\nDESCRIPTION: Original React component code showing nested function declarations with default parameters and closures. The code creates a function that returns nested functions with default parameter values.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/deeply-nested-function-expressions-with-params.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Foo() {\n  return (function t() {\n    let x = {};\n    let y = {};\n    return function a(x = () => {}) {\n      return (function b(y = []) {\n        return [x, y];\n      })();\n    };\n  })();\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining and Exporting a React Component with Sequenced Properties in JavaScript\nDESCRIPTION: This code snippet defines a React function component named 'Component' that processes properties and stores calculated values based on conditions involving those properties. It exports an object 'FIXTURE_ENTRYPOINT' that associates the component with a set of parameters and predefined render sequences for testing purposes. Dependencies include basic JavaScript syntax and React environment setup.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/ssa-cascading-eliminated-phis.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enablePropagateDepsInHIR\nfunction Component(props) {\n  let x = 0;\n  const values = [];\n  const y = props.a || props.b;\n  values.push(y);\n  if (props.c) {\n    x = 1;\n  }\n  values.push(x);\n  if (props.d) {\n    x = 2;\n  }\n  values.push(x);\n  return values;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{a: 0, b: 1, c: true, d: true}],\n  sequentialRenders: [\n    {a: 0, b: 1, c: true, d: true},\n    {a: 4, b: 1, c: true, d: true},\n    {a: 4, b: 1, c: false, d: true},\n    {a: 4, b: 1, c: false, d: false},\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Initializing React Component with useIdentity Hook\nDESCRIPTION: Creates an array using makeArray function and attempts to spread its values into useIdentity hook. Contains a potential error related to spread syntax support.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-hook-call-spreads-mutable-iterator.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useIdentity} from 'shared-runtime';\n\nfunction Component() {\n  const items = makeArray(0, 1, 2, null, 4, false, 6);\n  return useIdentity(...items.values());\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  sequentialRenders: [{}, {}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Enhanced Input Handler with State Management in JavaScript\nDESCRIPTION: This snippet defines an enhanced version of the React component that utilizes a runtime helper from the 'react/compiler-runtime' module. It manages input state and checks conditions before pushing the input to an array, thereby returning the appropriate value based on the state.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactivity-via-aliased-mutation-array.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== props.input) {\n    const x = [];\n    const y = x;\n    y.push(props.input);\n\n    t0 = [x[0]];\n    $[0] = props.input;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  sequentialRenders: [\n    { input: 42 },\n    { input: 42 },\n    { input: \"sathya\" },\n    { input: \"sathya\" },\n    { input: 42 },\n    { input: \"sathya\" },\n    { input: 42 },\n    { input: \"sathya\" },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Error Message for Async useMemo\nDESCRIPTION: This section captures the error message that arises when trying to use an async function inside the useMemo hook in React. It specifies the line number and the reason for the error, aiding in debugging.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-ReactUseMemo-async-callback.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n  1 | function component(a, b) {\n> 2 |   let x = React.useMemo(async () => {\n    |                         ^^^^^^^^^^^^^\n> 3 |     await a;\n    | ^^^^^^^^^^^^\n> 4 |   }, []);\n    | ^^^^ InvalidReact: useMemo callbacks may not be async or generator functions (2:4)\n  5 |   return x;\n  6 | }\n  7 |\n```\n\n----------------------------------------\n\nTITLE: Setting react-compiler Rule in ESLint\nDESCRIPTION: Example configuration for setting the react-compiler rule to error in the rules section. Aids in surfacing errors identified by the React compiler.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/eslint-plugin-react-compiler/README.md#2025-04-21_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"rules\": {\n        \"react-compiler/react-compiler\": \"error\"\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: The compiled version of the component with React compiler optimizations, including memoization using Symbol.for('react.memo_cache_sentinel'). Maintains the same functionality as the original component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-provider-tagged-template-expression.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { graphql } from \"shared-runtime\";\n\nexport function Component(t0) {\n  const $ = _c(1);\n  const fragment = graphql`\n    fragment Foo on User {\n      name\n    }\n  `;\n  let t1;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = <div>{fragment}</div>;\n    $[0] = t1;\n  } else {\n    t1 = $[0];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ a: 0, b: 0 }],\n  sequentialRenders: [\n    { a: 0, b: 0 },\n    { a: 1, b: 0 },\n    { a: 1, b: 1 },\n    { a: 1, b: 2 },\n    { a: 2, b: 2 },\n    { a: 3, b: 2 },\n    { a: 0, b: 0 },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: Basic React component that creates an array and pushes a prop value into it. Contains a debugger statement and exports a fixture configuration.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/debugger-memoized.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const x = [];\n  debugger;\n  x.push(props.value);\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: React Error: Invalid Variable Modification\nDESCRIPTION: This error message indicates that the code attempts to modify `window.href` directly within the component's function body. React recommends using effect hooks for side effects to manage component lifecycle and avoid direct DOM manipulation. The error highlights the specific line where the invalid modification occurs.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.object-capture-global-mutation.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n  1 | function Foo() {\n  2 |   const x = () => {\n> 3 |     window.href = 'foo';\n    |     ^^^^^^ InvalidReact: Writing to a variable defined outside a component or hook is not allowed. Consider using an effect (3:3)\n  4 |   };\n  5 |   const y = {x};\n  6 |   return <Bar y={y} />;\n\n```\n\n----------------------------------------\n\nTITLE: Invalid React Hook Call in Callback Function\nDESCRIPTION: This code snippet illustrates an invalid React hook usage by calling `useHookInsideCallback` within a callback function passed to `useEffect`. This violates the Rules of Hooks, which state that hooks must be called at the top level of a function component or custom hook, not within function expressions or callbacks. The expected output is a runtime error indicating the violation of hook rules.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid.invalid-rules-of-hooks-0de1224ce64b.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Invalid because it's a common misunderstanding.\n// We *could* make it valid but the runtime error could be confusing.\nfunction createComponent() {\n  return function ComponentWithHookInsideCallback() {\n    useEffect(() => {\n      useHookInsideCallback();\n    });\n  };\n}\n\n```\n\n----------------------------------------\n\nTITLE: Invalid React Hook Usage Example\nDESCRIPTION: Example showing incorrect implementation of React Hooks where useState is called after conditional statements, violating the Rules of Hooks. This code is intentionally written to demonstrate the error case.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-rules-of-hooks-9718e30b856c.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Expected to fail\n\n// Invalid because it's dangerous and might not warn otherwise.\n// This *must* be invalid.\nfunction useHook() {\n  if (a) return;\n  if (b) {\n    console.log('true');\n  } else {\n    console.log('false');\n  }\n  useState();\n}\n```\n\nLANGUAGE: plaintext\nCODE:\n```\n  10 |     console.log('false');\n  11 |   }\n> 12 |   useState();\n     |   ^^^^^^^^ InvalidReact: Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning) (12:12)\n  13 | }\n  14 |\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: This is the compiled version of the React component, showcasing how React Compiler handles the `Array.from` transformation and memoizes intermediate values. The code uses the `_c` function from `react/compiler-runtime` for memoization. The `_temp` function is the callback passed to Array.from. Dependencies: `_c` from `react/compiler-runtime`, `useIdentity`, `Stringify` from `shared-runtime`.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-from-arg1-captures-arg0.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useIdentity, Stringify } from \"shared-runtime\";\n\n/**\n * TODO: Note that this `Array.from` is inferred to be mutating its first\n * argument. This is because React Compiler's typing system does not yet support\n * annotating a function with a set of argument match cases + distinct\n * definitions (polymorphism).\n *\n * In this case, we should be able to infer that the `Array.from` call is\n * not mutating its 0th argument.\n * The 0th argument should be typed as having `effect:Mutate` only when\n * (1) it might be a mutable iterable or\n * (2) the 1st argument might mutate its callee\n */\nfunction Component(t0) {\n  const $ = _c(10);\n  const { value } = t0;\n  let t1;\n  let t2;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = { value: \"foo\" };\n    t2 = { value: \"bar\" };\n    $[0] = t1;\n    $[1] = t2;\n  } else {\n    t1 = $[0];\n    t2 = $[1];\n  }\n  let t3;\n  if ($[2] !== value) {\n    t3 = [t1, t2, { value }];\n    $[2] = value;\n    $[3] = t3;\n  } else {\n    t3 = $[3];\n  }\n  const arr = t3;\n  useIdentity();\n  let t4;\n  if ($[4] !== arr) {\n    t4 = Array.from(arr, _temp);\n    $[4] = arr;\n    $[5] = t4;\n  } else {\n    t4 = $[5];\n  }\n  const derived = t4;\n  let t5;\n  if ($[6] !== derived) {\n    t5 = derived.at(-1);\n    $[6] = derived;\n    $[7] = t5;\n  } else {\n    t5 = $[7];\n  }\n  let t6;\n  if ($[8] !== t5) {\n    t6 = <Stringify>{t5}</Stringify>;\n    $[8] = t5;\n    $[9] = t6;\n  } else {\n    t6 = $[9];\n  }\n  return t6;\n}\nfunction _temp(x, idx) {\n  return { ...x, id: idx };\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ value: 5 }],\n  sequentialRenders: [{ value: 5 }, { value: 6 }, { value: 6 }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining and Exporting a React Component - JavaScript\nDESCRIPTION: This snippet defines a React functional component with an embedded function for rendering. It includes an exported object for the entry point with a function and parameter specification. The component uses an inner function to return a constant value as part of the rendering process. No external dependencies are required.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-within-lambda.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component({}) {\n  const outer = () => {\n    const inner = () => {\n      return x;\n    };\n    const x = 3;\n    return inner();\n  };\n  return <div>{outer()}</div>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimizing a React Hook with Compiler Runtime\nDESCRIPTION: This variant of the function useFoo incorporates use of React's compiler runtime for optimization. It stores the previous state and compares it to minimize unnecessary re-calculations. The function takes an object and a null indicator boolean and returns an array, caching results using compiler hooks.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-poisoned/loop-break-in-scope.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction useFoo(t0) {\n  const $ = _c(3);\n  const { obj, objIsNull } = t0;\n  let x;\n  if ($[0] !== obj || $[1] !== objIsNull) {\n    x = [];\n    for (let i = 0; i < 5; i++) {\n      if (objIsNull) {\n        continue;\n      }\n\n      x.push(obj.a);\n    }\n    $[0] = obj;\n    $[1] = objIsNull;\n    $[2] = x;\n  } else {\n    x = $[2];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ obj: null, objIsNull: true }],\n  sequentialRenders: [\n    { obj: null, objIsNull: true },\n    { obj: { a: 2 }, objIsNull: false },\n    // check we preserve nullthrows\n    { obj: { a: undefined }, objIsNull: false },\n    { obj: undefined, objIsNull: false },\n    { obj: { a: undefined }, objIsNull: false },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: React Lint Error for Variable Reassignment\nDESCRIPTION: An error message highlighting the React best practice of avoiding direct variable reassignment after render, recommending the use of state management instead.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-reassign-local-in-hook-return-value.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n  2 |   let x = 0;\n  3 |   return value => {\n> 4 |     x = value;\n    |     ^ InvalidReact: Reassigning a variable after render has completed can cause inconsistent behavior on subsequent renders. Consider using state instead. Variable `x` cannot be reassigned after render (4:4)\n  5 |   };\n  6 | }\n```\n\n----------------------------------------\n\nTITLE: Optimized React Implementation Without useMemo\nDESCRIPTION: Optimized version that removes the useMemo hook and directly calculates the minimum value. This implementation shows the transformed code after optimization, maintaining the same functionality but with simpler execution.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useMemo-infer-nonallocating.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees\n\nimport { useMemo } from \"react\";\n\n// It's correct to infer a useMemo value is non-allocating\n// and not provide it with a reactive scope\nfunction useFoo(num1, num2) {\n  let t0;\n  t0 = Math.min(num1, num2);\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [2, 3],\n};\n```\n\n----------------------------------------\n\nTITLE: Input Function with Array Manipulation\nDESCRIPTION: Initial implementation of a function creating an object with a nested array, demonstrating basic object and array manipulation\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-property-call.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo() {\n  const x = [];\n  const y = {x: x};\n  y.x.push([]);\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Initializing React Component with Unresolved Effect Dependencies\nDESCRIPTION: Demonstrates a React component using useEffect with a function that references external variable, causing dependency inference failure\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/bailout-retry/error.non-inlined-effect-fn.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @inferEffectDependencies @panicThreshold(none)\nimport {useEffect} from 'react';\n\nfunction Component({foo}) {\n  function f() {\n    console.log(foo);\n  }\n\n  // No inferred dep array, the argument is not a lambda\n  useEffect(f);\n}\n```\n\n----------------------------------------\n\nTITLE: React Compiler Dependency Inference Error\nDESCRIPTION: Error message indicating that the React Compiler cannot infer effect dependencies, which will break the build\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/bailout-retry/error.use-no-memo.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n  4 | function Component({propVal}) {\n  5 |   'use no memo';\n> 6 |   useEffect(() => [propVal]);\n    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ InvalidReact: [InferEffectDependencies] React Compiler is unable to infer dependencies of this effect. This will break your build! To resolve, either pass your own dependency array or fix reported compiler bailout diagnostics. (6:6)\n  7 | }\n  8 |\n```\n\n----------------------------------------\n\nTITLE: Implementing a Simple Logging Hook in JavaScript\nDESCRIPTION: This snippet defines a simple 'useHook' function that generates a logging array while looping from 0 to 'end'. It demonstrates the use of nested blocks for conditional breaks and logging at different stages of the loop.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/labeled-break-within-label-loop.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction useHook(end) {\n  const log = [];\n  for (let i = 0; i < end + 1; i++) {\n    log.push(`${i} @A`);\n    bb0: {\n      if (i === end) {\n        break bb0;\n      }\n      log.push(`${i} @B`);\n    }\n    log.push(`${i} @C`);\n  }\n  return log;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useHook,\n  params: [1],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with Global Variable Reassignment\nDESCRIPTION: This JavaScript code defines a React component `Component` that attempts to reassign values to variables (`someUnknownGlobal`, `moduleLocal`) that are assumed to be defined outside of the component's scope (either globally or in the module). React components should be pure functions and free of side effects. This is enforced by linting rules in modern React projects.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.reassignment-to-global-indirect.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component() {\n  const foo = () => {\n    // Cannot assign to globals\n    someUnknownGlobal = true;\n    moduleLocal = true;\n  };\n  foo();\n}\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Stringify and Identity Functions\nDESCRIPTION: This snippet defines a React component that uses the Stringify component and an identity function. It also exports a FIXTURE_ENTRYPOINT object for testing purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/constant-propagation-into-function-expressions.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {Stringify, identity} from 'shared-runtime';\n\nfunction Component(props) {\n  const x = 42;\n  const onEvent = () => {\n    return identity(x);\n  };\n  return <Stringify onEvent={onEvent} shouldInvokeFns={true} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n  sequentialRenders: [{}, {}],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component with Spread Operator\nDESCRIPTION: A React component that calls a method with spread arguments. The component calls a method on the 'foo' object using the method name from props and spreads array arguments with a null value in between.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/computed-call-spread.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const x = foo[props.method](...props.a, null, ...props.b);\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing React Hook with Invalid Variable Reassignment\nDESCRIPTION: Demonstrates an incorrect hook implementation that attempts to destructure and reassign props, which violates React's component purity rules. The code triggers an error recommending the use of useState for managing component state.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-destructure-assignment-to-global.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction useFoo(props) {\n  [x] = props;\n  return {x};\n}\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: A React component that creates an array of primitive objects and modifies the last item's 'a' property. Includes a test fixture for sequential renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-of-capture-item-of-local-collection-mutate-later-value-initially-null.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {makeObject_Primitives} from 'shared-runtime';\n\nfunction Component(props) {\n  let lastItem = null;\n  const items = [makeObject_Primitives(), makeObject_Primitives()];\n  for (const x of items) {\n    lastItem = x;\n  }\n  if (lastItem != null) {\n    lastItem.a += 1;\n  }\n  return items;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n  sequentialRenders: [{}, {}, {}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a Function and Exporting an Object in JavaScript\nDESCRIPTION: This snippet defines a function `foo` which adds two elements from a props array and exports an object `FIXTURE_ENTRYPOINT` containing a reference to the function and component parameters. The function uses destructuring to extract values from `props.a`.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unused-array-middle-element.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(props) {\n  const [x, unused, y] = props.a;\n  return x + y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Counter Function with Two Variables in JavaScript\nDESCRIPTION: A function that increments two variables in a while loop until reaching a maximum value specified in props. The function returns the final value of the y variable. This is the original implementation with both x and y variables.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/dce-loop.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(props) {\n  let x = 0;\n  let y = 0;\n  while (y < props.max) {\n    x++;\n    y++;\n  }\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [{max: 10}],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a React Component with Conditional Logic and Array Manipulation\nDESCRIPTION: A React component that conditionally creates an array based on props and manipulates it. It demonstrates a pattern where an object is created and later pushed into a conditionally created array, then both are returned.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/phi-type-inference-array-push.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const x = {};\n  let y;\n  if (props.cond) {\n    y = [props.value];\n  } else {\n    y = [];\n  }\n  // This should be inferred as `<store> y` s.t. `x` can still\n  // be independently memoized. *But* this also must properly\n  // extend the mutable range of the array literals in the\n  // if/else branches\n  y.push(x);\n\n  return [x, y];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{cond: true, value: 42}],\n  sequentialRenders: [\n    {cond: true, value: 3.14},\n    {cond: false, value: 3.14},\n    {cond: true, value: 42},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with Local Reassignment\nDESCRIPTION: This React component defines a local variable `local` and a function `reassignLocal` that attempts to reassign its value. The `onMount` function calls `reassignLocal` and then checks if `local` has been updated. The `useEffect` hook triggers `onMount` on component mount. The component is designed to highlight issues when reassigning local variables inside functions escaping the render scope, revealing inconsistent behavior based on whether the React Compiler is enabled.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-reassign-local-variable-in-effect.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useEffect} from 'react';\n\nfunction Component() {\n  let local;\n\n  const reassignLocal = newValue => {\n    local = newValue;\n  };\n\n  const onMount = newValue => {\n    reassignLocal('hello');\n\n    if (local === newValue) {\n      // Without React Compiler, `reassignLocal` is freshly created\n      // on each render, capturing a binding to the latest `local`,\n      // such that invoking reassignLocal will reassign the same\n      // binding that we are observing in the if condition, and\n      // we reach this branch\n      console.log('`local` was updated!');\n    } else {\n      // With React Compiler enabled, `reassignLocal` is only created\n      // once, capturing a binding to `local` in that render pass.\n      // Therefore, calling `reassignLocal` will reassign the wrong\n      // version of `local`, and not update the binding we are checking\n      // in the if condition.\n      //\n      // To protect against this, we disallow reassigning locals from\n      // functions that escape\n      throw new Error('`local` not updated!');\n    }\n  };\n\n  useEffect(() => {\n    onMount();\n  }, [onMount]);\n\n  return 'ok';\n}\n\n```\n\n----------------------------------------\n\nTITLE: Compiler-Optimized React Component\nDESCRIPTION: Compiler-transformed version of the component with caching logic added. Uses a cache array ($) to store and compare values, preventing unnecessary recalculations and array creations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-same-property-identifier-names.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { identity } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(5);\n  const { x: t0, sameName: renamed } = props;\n  const { destructured } = t0;\n  let t1;\n  if ($[0] !== destructured) {\n    t1 = identity(destructured);\n    $[0] = destructured;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  const sameName = t1;\n  let t2;\n  if ($[2] !== renamed || $[3] !== sameName) {\n    t2 = [sameName, renamed];\n    $[2] = renamed;\n    $[3] = sameName;\n    $[4] = t2;\n  } else {\n    t2 = $[4];\n  }\n  return t2;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ x: { destructured: 0 }, sameName: 2 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining and Mutating a React Component - JavaScript\nDESCRIPTION: This snippet defines a React component that utilizes external 'mutate' functionality. It demonstrates state mutation based on props 'foo' and 'bar', dynamically adjusting component rendering. Prerequisites include the 'shared-runtime' library. Parameters include input properties 'foo' and 'bar'. Expected output changes dynamically as these parameters alter.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-alias-captured-mutate-arr.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport {mutate} from 'shared-runtime';\nfunction Component({foo, bar}) {\n  let x = {foo};\n  let y = {bar};\n  const f0 = function () {\n    let a = [y];\n    let b = x;\n    a.x = b;\n  };\n  f0();\n  mutate(y);\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{foo: 2, bar: 3}],\n  sequentialRenders: [\n    {foo: 2, bar: 3},\n    {foo: 2, bar: 3},\n    {foo: 2, bar: 4},\n    {foo: 3, bar: 4},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Using React Compiler Runtime in Component\nDESCRIPTION: This code uses a customized React setup with the \"react/compiler-runtime\" package for component creation. It manipulates component render state to handle memoized values and dependencies more efficiently. Prerequisites include a setup with the react/compiler-runtime and familiarity with its concepts. It takes initial component configurations and outputs a component that conditionally renders based on state changes. There are constraints regarding react memoization strategies and their interactions.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-ref-access-in-unused-callback-nested.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @validateRefAccessDuringRender\nimport { useEffect, useRef, useState } from \"react\";\n\nfunction Component() {\n  const $ = _c(5);\n  const ref = useRef(null);\n  const [state, setState] = useState(false);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = [];\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  useEffect(_temp, t0);\n  let t1;\n  let t2;\n  if ($[1] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = () => {\n      setState(true);\n    };\n    t2 = [];\n    $[1] = t1;\n    $[2] = t2;\n  } else {\n    t1 = $[1];\n    t2 = $[2];\n  }\n  useEffect(t1, t2);\n\n  const t3 = String(state);\n  let t4;\n  if ($[3] !== t3) {\n    t4 = <Child key={t3} ref={ref} />;\n    $[3] = t3;\n    $[4] = t4;\n  } else {\n    t4 = $[4];\n  }\n  return t4;\n}\nfunction _temp() {}\n\nfunction Child(t0) {\n  const { ref } = t0;\n  return ref.current;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Test Configuration for React Hook\nDESCRIPTION: Defines the test configuration for the React hook, specifying initial parameters and a series of sequential renders with different prop values to verify behavior with null, undefined, and valid object values.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/superpath-order2.expect.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useConditionalSuperpath2,\n  params: [{ props: { a: null }, cond: false }],\n  sequentialRenders: [\n    { props: { a: null }, cond: false },\n    { props: { a: {} }, cond: true },\n    { props: { a: { b: 3 } }, cond: true },\n    { props: {}, cond: false },\n    // test that we preserve nullthrows\n    { props: { a: { b: undefined } }, cond: true },\n    { props: { a: undefined }, cond: true },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining and Invoking Functions in JavaScript\nDESCRIPTION: This snippet shows how to define a normal function that can call another function. It demonstrates the concept of function invocation within other functions, which is a fundamental aspect of JavaScript programming.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-347b0dae66f1.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Valid because functions can call functions.\nfunction normalFunctionWithNormalFunction() {\n  doSomething();\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining Conditional Component Logic - JavaScript\nDESCRIPTION: This snippet defines a simple React component that returns an array based on props. It utilizes basic conditional checks to push values into an array and handles cases where props are not provided. The expected input is an object with boolean and numerical properties, leading to an array output.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/early-return-nested-early-return-within-reactive-scope.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let x = [];\n  if (props.cond) {\n    x.push(props.a);\n    if (props.b) {\n      const y = [props.b];\n      x.push(y);\n      // oops no memo!\n      return x;\n    }\n    // oops no memo!\n    return x;\n  } else {\n    return foo();\n  }\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{cond: true, a: 42, b: 3.14}],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Memoization\nDESCRIPTION: Compiled and optimized version of the component that implements memoization using a cache array ($). Prevents unnecessary recreations of the context object when props haven't changed.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-expression-computed-member.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { identity, mutate, mutateAndReturn } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(2);\n  let context;\n  if ($[0] !== props.value) {\n    const key = { a: \"key\" };\n    context = { [key.a]: identity([props.value]) };\n\n    mutate(key);\n    $[0] = props.value;\n    $[1] = context;\n  } else {\n    context = $[1];\n  }\n  return context;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ value: 42 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Memoization\nDESCRIPTION: This snippet shows an optimized version of the React component, likely produced by a compiler. It includes memoization techniques to improve performance and efficiency in handling state and effects.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-global-reassignment-in-effect-indirect.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useEffect, useState } from \"react\";\n\nlet someGlobal = false;\n\nfunction Component() {\n  const $ = _c(6);\n  const [state, setState] = useState(someGlobal);\n\n  const setGlobal = _temp;\n  let t0;\n  let t1;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = () => {\n      setGlobal();\n    };\n    t1 = [];\n    $[0] = t0;\n    $[1] = t1;\n  } else {\n    t0 = $[0];\n    t1 = $[1];\n  }\n  useEffect(t0, t1);\n  let t2;\n  let t3;\n  if ($[2] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t2 = () => {\n      setState(someGlobal);\n    };\n    t3 = [someGlobal];\n    $[2] = t2;\n    $[3] = t3;\n  } else {\n    t2 = $[2];\n    t3 = $[3];\n  }\n  useEffect(t2, t3);\n\n  const t4 = String(state);\n  let t5;\n  if ($[4] !== t4) {\n    t5 = <div>{t4}</div>;\n    $[4] = t4;\n    $[5] = t5;\n  } else {\n    t5 = $[5];\n  }\n  return t5;\n}\nfunction _temp() {\n  someGlobal = true;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Creating Invalid Component Tag Test in React\nDESCRIPTION: This code creates a test fixture that demonstrates warning differences between regular React and Forget mode when using an incorrectly cased component tag. It intentionally uses a lowercase 'invalidtag' element to trigger specific warning messages about component casing.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/invalid-jsx-lowercase-localvar.expect.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {Throw} from 'shared-runtime';\n\n/**\n * Note: this is disabled in the evaluator due to different devmode errors.\n * Found differences in evaluator results\n *  Non-forget (expected):\n *  (kind: ok) <invalidtag val=\"[object Object]\"></invalidtag>\n *  logs: ['Warning: <%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.%s','invalidTag']\n *\n *  Forget:\n *  (kind: ok) <invalidtag val=\"[object Object]\"></invalidtag>\n *  logs: [\n *   'Warning: <%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.%s','invalidTag',\n *   'Warning: The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.%s','invalidTag',\n *  ]\n */\nfunction useFoo() {\n  const invalidTag = Throw;\n  /**\n   * Need to be careful to not parse `invalidTag` as a localVar (i.e. render\n   * Throw). Note that the jsx transform turns this into a string tag:\n   * `jsx(\"invalidTag\"...\n   */\n  return <invalidTag val={{val: 2}} />;\n}\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiler-Optimized React Component Implementation\nDESCRIPTION: The React compiler's optimized version of the component that uses caching to prevent unnecessary re-renders. It extracts the map callback to a separate function and uses the compiler-runtime to track dependencies and memoize intermediate values.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/outlined-destructured-params.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { Stringify } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(4);\n  let t0;\n  if ($[0] !== props.items) {\n    t0 = props.items.map(_temp);\n    $[0] = props.items;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  let t1;\n  if ($[2] !== t0) {\n    t1 = <>{t0}</>;\n    $[2] = t0;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  return t1;\n}\nfunction _temp(t0) {\n  const { id, name } = t0;\n  return <Stringify key={id} name={name} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ items: [{ id: 1, name: \"one\" }] }],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: React component using hooks and custom classes to display a timestamp label. Includes a useServerTime hook and Highlight class for rendering.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-independently-memoized-property-load-for-method-call.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @flow @enableAssumeHooksFollowRulesOfReact\nfunction Component({label, highlightedItem}) {\n  const serverTime = useServerTime();\n  const highlight = new Highlight(highlightedItem);\n\n  const time = serverTime.get();\n  // subtle bit here: the binary expression infers the result of the call\n  // as a primitive and not needing memoization. the logical is necessary\n  // because without it there are no intermediate scopes which observe\n  // the result of the binary expression, so its memoization can be pruned\n  const timestampLabel = time / 1000 || label;\n\n  return (\n    <>\n      {highlight.render()}\n      {timestampLabel}\n    </>\n  );\n}\n\nfunction useServerTime() {\n  'use no forget';\n\n  return {\n    get() {\n      return 42000; // would be a constant value from the server\n    },\n  };\n}\n\nclass Highlight {\n  constructor(value) {\n    this.value = value;\n  }\n\n  render() {\n    return this.value;\n  }\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{label: '<unused>', highlightedItem: 'Seconds passed: '}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Inferred Effect Dependencies\nDESCRIPTION: The compiled version of the component after transformation. The arrow function has been outlined to a separate named function '_temp', and an empty dependencies array has been inferred. This demonstrates how React's dependency inference handles outlined functions.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/outlined-function.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// @inferEffectDependencies\nimport { useEffect } from \"react\";\nimport { print } from \"shared-runtime\";\n/**\n * This compiled output is technically incorrect but this is currently the same\n * case as a bailout (an effect that overfires).\n *\n * To ensure an empty deps array is passed, we need special case\n * `InferEffectDependencies` for outlined functions (likely easier) or run it\n * before OutlineFunctions\n */\nfunction OutlinedFunctionInEffect() {\n  useEffect(_temp, []);\n}\nfunction _temp() {\n  return print(\"hello world!\");\n}\n```\n\n----------------------------------------\n\nTITLE: React Component Definition\nDESCRIPTION: This snippet defines a React component `VideoTab` that uses `useRef` to create a ref. It then defines a function `x` that accesses the `current` property of the ref within a `console.log` statement. This function is then passed as the `videos` prop to a `VideoList` component. The `@validateRefAccessDuringRender false` comment indicates that ref access during render is disabled.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ref-current-field-not-added-to-dep.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validateRefAccessDuringRender false\nfunction VideoTab() {\n  const ref = useRef();\n  let x = () => {\n    console.log(ref.current.x);\n  };\n\n  return <VideoList videos={x} />;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Components with Instrumentation and Memoization\nDESCRIPTION: Compiled output with instrumentation and optimization features added. The compiler adds render counters for development mode and implements a memoization strategy using Symbol tokens to avoid redundant rendering. Components maintain the same functionality but with optimized performance characteristics.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/conflict-codegen-instrument-forget.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport {\n  shouldInstrument as _shouldInstrument3,\n  useRenderCounter,\n} from \"react-compiler-runtime\";\nimport { c as _c } from \"react/compiler-runtime\"; // @enableEmitInstrumentForget @compilationMode(annotation)\n\nimport { identity } from \"shared-runtime\";\n\nfunction Bar(props) {\n  \"use forget\";\n  if (DEV && _shouldInstrument3)\n    useRenderCounter(\"Bar\", \"/conflict-codegen-instrument-forget.ts\");\n  const $ = _c(4);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = identity(null);\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const shouldInstrument = t0;\n  let t1;\n  if ($[1] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = identity(null);\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  const _shouldInstrument = t1;\n  let t2;\n  if ($[2] !== props.bar) {\n    t2 = (\n      <div style={shouldInstrument} other={_shouldInstrument}>\n        {props.bar}\n      </div>\n    );\n    $[2] = props.bar;\n    $[3] = t2;\n  } else {\n    t2 = $[3];\n  }\n  return t2;\n}\n\nfunction Foo(props) {\n  \"use forget\";\n  if (DEV && _shouldInstrument3)\n    useRenderCounter(\"Foo\", \"/conflict-codegen-instrument-forget.ts\");\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== props.bar) {\n    t0 = <Foo>{props.bar}</Foo>;\n    $[0] = props.bar;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n```\n\n----------------------------------------\n\nTITLE: React Component with Memoization and Array Handling\nDESCRIPTION: This snippet illustrates the implementation of the 'Component' function with additional usage of memoization through 'react/compiler-runtime'. It uses 'makeArray' to generate values, processes them to compute a sum, and utilizes a memoization cache to optimize performance. The snippet highlights dependencies on both 'react/compiler-runtime' and 'shared-runtime'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reassign-in-while-loop-condition.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { makeArray } from \"shared-runtime\";\n\n// @flow\nfunction Component() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const items = makeArray(0, 1, 2);\n    let item;\n    let sum = 0;\n    while ((item = items.pop())) {\n      sum = sum + item;\n    }\n\n    t0 = [items, sum];\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Compiler Output for Object Destructuring in JavaScript\nDESCRIPTION: This snippet shows the optimized version of the 'foo' function after React compiler processing. It introduces memoization and uses React's compiler runtime for performance improvements.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructure-string-literal-property-key.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction foo() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = { data: 1 };\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const { data: t } = t0;\n  return t;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Running react-devtools with NPX\nDESCRIPTION: Command for running react-devtools using NPX without requiring global installation. NPX allows execution of npm package binaries without installation.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/README.md#2025-04-21_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nnpx react-devtools\n```\n\n----------------------------------------\n\nTITLE: Exporting a Function Configuration Object\nDESCRIPTION: This code exports a constant named `FIXTURE_ENTRYPOINT`, which is an object. This object contains metadata about the function `foo`, including the function itself (`fn`), an array of parameter names (`params`), and a flag indicating that it's a component (`isComponent`). This configuration allows the function to be easily integrated and tested within a React environment.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/simple-scope.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a Function and Exporting with Const in JavaScript\nDESCRIPTION: Similar to the previous snippet, this one defines the same function 'foo', but this time it uses 'const' for the array declarations. It also exports the same constant object with the function reference and metadata, showcasing a small variation in variable declaration style.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/overlapping-scopes-shadowed.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(a, b) {\\n  const x = [];\\n  const y = [];\\n  y.push(b);\\n  x.push(a);\\n}\\n\\nexport const FIXTURE_ENTRYPOINT = {\\n  fn: foo,\\n  params: [\"TodoAdd\"],\\n  isComponent: \"TodoAdd\",\\n};\\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Component in JavaScript\nDESCRIPTION: This snippet defines a React component function that creates an object and assigns properties using a function call. It highlights basic React component initialization. makeObject() is assumed to generate necessary object attributes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/call-args-destructuring-assignment.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let x = makeObject();\n  x.foo(([x] = makeObject()));\n  return x;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing a JavaScript Function with a Loop Increment Bug\nDESCRIPTION: A JavaScript function 'foo' containing a while loop with a potential infinite loop bug. The loop condition checks if x < 10, but inside the loop, the increment operation (x + 1) doesn't actually modify x since the result isn't assigned back to x.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-while-no-reassign.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo() {\n  let x = 1;\n  while (x < 10) {\n    x + 1;\n  }\n\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Conditional Property Access (Input)\nDESCRIPTION: This code defines a React component `Foo` that takes an object `a` and a boolean `shouldReadA` as props. Based on `shouldReadA`, it either attempts to access `a.b.c` or returns null.  The result is then stringified using the `Stringify` component for rendering. The `FIXTURE_ENTRYPOINT` provides different input values for testing.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/infer-function-cond-access-not-hoisted.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {Stringify} from 'shared-runtime';\n\nfunction Foo({a, shouldReadA}) {\n  return (\n    <Stringify\n      fn={() => {\n        if (shouldReadA) return a.b.c;\n        return null;\n      }}\n      shouldInvokeFns={true}\n    />\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{a: null, shouldReadA: true}],\n  sequentialRenders: [\n    {a: null, shouldReadA: true},\n    {a: null, shouldReadA: false},\n    {a: {b: {c: 4}}, shouldReadA: true},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: Initial implementation of a React component that creates a mutable object and array, demonstrating object capture and mutation patterns. Uses helper functions makeObject_Primitives and mutate.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/alias-capture-in-method-receiver-and-mutate.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {makeObject_Primitives, mutate} from 'shared-runtime';\n\nfunction Component() {\n  // a's mutable range should be the same as x's mutable range,\n  // since a is captured into x (which gets mutated later)\n  let a = makeObject_Primitives();\n\n  let x = [];\n  x.push(a);\n\n  mutate(x);\n  return [x, a];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: A simple React component implementation using useCallback hook to memoize a function that sets a global window property. The component renders a div with 'Ok' text.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-global-mutation-unused-usecallback.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useCallback, useEffect, useState} from 'react';\n\nfunction Component() {\n  const callback = useCallback(() => {\n    window.foo = true;\n  }, []);\n\n  return <div>Ok</div>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized Closure Implementation in JavaScript for React\nDESCRIPTION: This snippet shows an optimized version of the 'foo' function. It eliminates the closure by moving the inner function outside and directly using the value 42. It maintains the same functionality and exports the same fixture entry point.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/const-propagation-into-function-expression-primitive.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo() {\n  const f = _temp;\n\n  f();\n  return 42;\n}\nfunction _temp() {\n  console.log(42);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Input React Hook Component Definition\nDESCRIPTION: Original React hook component implementation with imports and simple JSX rendering.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/gating-nonreferenced-identifier-collision.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @gating\nimport {identity, useHook as useRenamed} from 'shared-runtime';\nconst _ = {\n  useHook: () => {},\n};\nidentity(_.useHook);\n\nfunction useHook() {\n  useRenamed();\n  return <div>hello world!</div>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useHook,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: Compiled output showing how React transforms the component to include memoization using Symbol.for('react.memo_cache_sentinel'). Implements caching logic to avoid unnecessary recomputation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/codegen-inline-iife.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { makeArray, print } from \"shared-runtime\";\n\nfunction useTest() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const t1 = print(1);\n    let t2;\n\n    print(2);\n    t2 = 2;\n    t0 = makeArray(t1, t2);\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useTest,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component (Code)\nDESCRIPTION: This code snippet demonstrates the optimized React component after constant propagation.  The original conditional assignments are replaced with a direct return of the constant value \"ok\". This simplification is possible because the initial value of 'a' is known, and the conditions are always met, leading to a deterministic outcome.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/sequentially-constant-progagatable-if-test-conditions.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component() {\n  return \"ok\";\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  isComponent: false,\n};\n\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component using Compiler Runtime in JavaScript\nDESCRIPTION: This snippet shows the optimized version of the component using React's compiler runtime. It introduces memoization to prevent unnecessary object creation and improves performance. The FIXTURE_ENTRYPOINT remains the same for testing consistency.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-object-pattern.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction component(t) {\n  const $ = _c(2);\n  const { a } = t;\n  let t0;\n  if ($[0] !== a) {\n    t0 = { a };\n    $[0] = a;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const y = t0;\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: [{ a: 42 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Utilizing React Compiler Runtime in Component - JavaScript\nDESCRIPTION: Illustrates how a React component can be enhanced with a compiler runtime, showing the usage of memoization for optimizing performance. The component uses a 'foo' function and maintains a cache using the 'react.memo_cache_sentinel' symbol to decide re-renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-call-jsx-2.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @Pass runMutableRangeAnalysis\nfunction foo() {}\n\nfunction Component(props) {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const a = [];\n    const b = {};\n    foo(a, b);\n    if (foo()) {\n    }\n\n    foo(a, b);\n    t0 = <div a={a} b={b} />;\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n```\n\n----------------------------------------\n\nTITLE: Reactive Array Handling with Compiler Runtime in JavaScript\nDESCRIPTION: This JavaScript snippet builds upon reactive rendering, leveraging a compiler-generated context _c from react/compiler-runtime to manage component state. It conditionally updates an array with new values and uses the mutate function from the shared-runtime, aiming to minimize unnecessary render cycles by caching previous results. Essential inputs include an object parameter with a value attribute to track and manage changes reactively.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/align-scopes-reactive-scope-overlaps-try.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { arrayPush, mutate } from \"shared-runtime\";\n\nfunction useFoo(t0) {\n  const $ = _c(2);\n  const { value } = t0;\n  let items;\n  if ($[0] !== value) {\n    try {\n      items = [];\n      arrayPush(items, value);\n    } catch {}\n\n    mutate(items);\n    $[0] = value;\n    $[1] = items;\n  } else {\n    items = $[1];\n  }\n  return items;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ value: 2 }],\n  sequentialRenders: [{ value: 2 }, { value: 2 }, { value: 3 }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Cache Implementation\nDESCRIPTION: Compiled version of the component that includes React's memoization logic using a cache sentinel. The transformation adds caching mechanism while maintaining the original component's functionality.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-of-conditional-break.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component() {\n  const $ = _c(1);\n  let x;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    x = [];\n    for (const item of [1, 2]) {\n      if (item === 1) {\n        break;\n      }\n\n      x.push(item);\n    }\n    $[0] = x;\n  } else {\n    x = $[0];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Initializing Component with Compiler Runtime - JavaScript\nDESCRIPTION: This snippet shows an advanced initialization of a React component leveraging the React compiler runtime. It introduces a caching strategy using an array and conditionally updates component state based on input. The component maintains its rendered output across multiple sequential renderings, demonstrating optimizations in state persistence.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactivity-via-aliased-mutation-lambda.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== props.input) {\n    const x = [];\n    const f = (arg) => {\n      const y = x;\n      y.push(arg);\n    };\n\n    f(props.input);\n\n    t0 = [x[0]];\n    $[0] = props.input;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  sequentialRenders: [\n    { input: 42 },\n    { input: 42 },\n    { input: \"sathya\" },\n    { input: \"sathya\" },\n    { input: 42 },\n    { input: \"sathya\" },\n    { input: 42 },\n    { input: \"sathya\" },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component Implementation in JavaScript\nDESCRIPTION: This snippet presents an optimized version of the React component. Unnecessary operations have been removed, and it directly assigns and returns the 'i' prop value.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/dce-unused-prefix-update.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let i;\n\n  i = props.i;\n  return i;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ i: 42 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: A React functional component that conditionally renders nested components based on an optional chained property. Takes props v1 and v2, and renders different component structures based on v5's value.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-propagate-type-of-ternary-jsx.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction V0({v1, v2}: V3<{v1: any, v2: V4}>): V12.V11 {\n  const v5 = v1.v6?.v7;\n  return (\n    <Component8 c9={va} cb=\"apqjx\">\n      {v5 != null ? (\n        <ComponentC cd={v5}>\n          <ComponentE cf={v1} c10={v2} />\n        </ComponentC>\n      ) : (\n        <ComponentE cf={v1} c10={v2} />\n      )}\n    </Component8>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Error: Unsafe Expression Reordering (JavaScript)\nDESCRIPTION: This snippet showcases an error message related to the potential unsafe reordering of expressions within an arrow function. Specifically, it indicates that an `ArrowFunctionExpression` cannot be safely reordered at the given location. This error typically arises during compilation or optimization processes where the order of execution might impact the final result.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.default-param-accesses-local.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n  1 | function Component(\n  2 |   x,\n> 3 |   y = () => {\n    |       ^^^^^^^\n> 4 |     return x;\n    | ^^^^^^^^^^^^^\n> 5 |   }\n    | ^^^^ Todo: (BuildHIR::node.lowerReorderableExpression) Expression type `ArrowFunctionExpression` cannot be safely reordered (3:5)\n  6 | ) {\n  7 |   return y();\n  8 | }\n\n```\n\n----------------------------------------\n\nTITLE: React useState Mutation Error\nDESCRIPTION: This snippet shows the error produced by a React linter when direct mutation of a state variable is detected. The linter points out the line where `x.value` is being directly modified, suggesting the use of the setter function `setX` instead.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-function-expression-mutates-immutable-value.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n  3 |   const onChange = e => {\n  4 |     // INVALID! should use copy-on-write and pass the new value\n> 5 |     x.value = e.target.value;\n    |     ^ InvalidReact: Mutating a value returned from 'useState()', which should not be mutated. Use the setter function to update instead. Found mutation of `x` (5:5)\n  6 |     setX(x);\n  7 |   };\n  8 |   return <input value={x.value} onChange={onChange} />;\n```\n\n----------------------------------------\n\nTITLE: React Component with Flow Type Suppression\nDESCRIPTION: React component example showing Flow type suppression using $FlowFixMe comment. Includes a custom hook useX and exports a fixture entrypoint configuration.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/no-flow-bailout-unrelated.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableFlowSuppressions\n\nfunction useX() {}\n\nfunction Foo(props) {\n  // $FlowFixMe[incompatible-type]\n  useX();\n  return null;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Integrating React Compiler Runtime in Hoisting Implementation\nDESCRIPTION: This snippet modifies the previous 'hoisting' function to utilize React's compiler runtime. It tracks state using arrays and conditional logic, allowing for optimized component behavior with React's state management.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-nested-const-declaration-2.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction hoisting(cond) {\n  const $ = _c(2);\n  let items;\n  if ($[0] !== cond) {\n    items = [];\n    if (cond) {\n      const foo = () => {\n        items.push(bar());\n      };\n\n      const bar = _temp;\n      foo();\n    }\n    $[0] = cond;\n    $[1] = items;\n  } else {\n    items = $[1];\n  }\n  return items;\n}\nfunction _temp() {\n  return true;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: hoisting,\n  params: [true],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a Functional Component and Identifying State Management Errors - JavaScript\nDESCRIPTION: This snippet defines a React functional component named 'Component' that includes a nested functional component 'Foo'. The 'Foo' component attempts to reassign a variable defined outside its scope, which raises an error related to React's purity rules for components. Instead of directly modifying the global variable, it suggests using React's state management with useState for managing side effects.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.assign-global-in-component-tag-function.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component() {\n  const Foo = () => {\n    someGlobal = true;\n  };\n  return <Foo />;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Initializing React Component with Fire Method\nDESCRIPTION: A React functional component importing an experimental `fire` method and attempting to invoke it within a useEffect hook. The code demonstrates an invalid usage that results in a compilation error.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/error.invalid-not-call.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableFire\nimport {fire} from 'react';\n\nfunction Component(props) {\n  const foo = () => {\n    console.log(props);\n  };\n  useEffect(() => {\n    fire(props);\n  });\n\n  return null;\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Optimization\nDESCRIPTION: This is the compiled and optimized version of the React component. It includes performance enhancements such as memoization of function references and conditional re-computations based on dependency changes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transitive-freeze-function-expressions.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enableTransitivelyFreezeFunctionExpressions\nfunction Component(props) {\n  const $ = _c(9);\n  const { data, loadNext, isLoadingNext } =\n    usePaginationFragment(props.key).items ?? [];\n  let t0;\n  if ($[0] !== data.length || $[1] !== loadNext) {\n    t0 = () => {\n      if (data.length === 0) {\n        return;\n      }\n\n      loadNext();\n    };\n    $[0] = data.length;\n    $[1] = loadNext;\n    $[2] = t0;\n  } else {\n    t0 = $[2];\n  }\n  const loadMoreWithTiming = t0;\n  let t1;\n  let t2;\n  if ($[3] !== isLoadingNext || $[4] !== loadMoreWithTiming) {\n    t1 = () => {\n      if (isLoadingNext) {\n        return;\n      }\n\n      loadMoreWithTiming();\n    };\n    t2 = [isLoadingNext, loadMoreWithTiming];\n    $[3] = isLoadingNext;\n    $[4] = loadMoreWithTiming;\n    $[5] = t1;\n    $[6] = t2;\n  } else {\n    t1 = $[5];\n    t2 = $[6];\n  }\n  useEffect(t1, t2);\n  let t3;\n  if ($[7] !== data) {\n    t3 = data.map(_temp);\n    $[7] = data;\n    $[8] = t3;\n  } else {\n    t3 = $[8];\n  }\n  const items = t3;\n  return items;\n}\nfunction _temp(x) {\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining an Enhanced React Component with State Management in JavaScript\nDESCRIPTION: This snippet expands on the previous component by introducing additional state management using a compiled runtime function. It also employs the use of conditional checks to manage the component's state across multiple render cycles. The component captures the previous state and conditionally updates it based on its inputs, returning the appropriate state management results.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/prune-scopes-whose-deps-may-invalidate-array.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useHook, identity } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(4);\n  let x = 42;\n  if (props.cond) {\n    x = [];\n  }\n\n  useHook();\n  identity(x);\n  let t0;\n  if ($[0] !== x) {\n    t0 = [x];\n    $[0] = x;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const y = t0;\n  let t1;\n  if ($[2] !== y) {\n    t1 = [y];\n    $[2] = y;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ value: \"sathya\" }],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component Definition (Input)\nDESCRIPTION: This JavaScript code defines a React component named `component` that takes two arguments, `a` and `b`. It creates two local objects `y` and `z`, where `y` contains `b` and `z` contains `a`. It also defines a function `x` that updates the value of `z.a` and accesses `y.b`. Finally, it returns the object `z`. The `FIXTURE_ENTRYPOINT` specifies the component function, parameters, and component name.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-mutate-3.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component(a, b) {\n  let y = {b};\n  let z = {a};\n  let x = function () {\n    z.a = 2;\n    y.b;\n  };\n  return z;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n\n```\n\n----------------------------------------\n\nTITLE: Creating Component with Props Handling - React - JavaScript\nDESCRIPTION: Defines a React functional component that processes props to potentially call an optional method. It uses two helper functions to make an optional object and create an object from props.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-receiver-optional-method.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const x = makeOptionalObject(props);\n  const y = makeObject(props);\n  const z = x?.optionalMethod?.(y.a, props.a, foo(y.b), bar(props.b));\n  return z;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Exposing createBridge and createStore in react-devtools-inline Frontend\nDESCRIPTION: The react-devtools-inline package now exports createBridge and createStore functions from the frontend entrypoint to support advanced use cases.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/CHANGELOG.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createBridge, createStore } from 'react-devtools-inline/frontend';\n\nconst bridge = createBridge();\nconst store = createStore(bridge);\n```\n\n----------------------------------------\n\nTITLE: Compiled useFoo with React Compiler\nDESCRIPTION: This snippet showcases the compiled version of the `useFoo` hook, likely after processing by a React compiler. It demonstrates how the `useMemo` hook is transformed to manage dependencies and memoize the result using the `_c` function (presumably from `react/compiler-runtime`). It also exports a `FIXTURE_ENTRYPOINT` to specify function and params.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useMemo-reordering-depslist-assignment.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useMemo } from \"react\";\n\nfunction useFoo(arr1, arr2) {\n  const $ = _c(5);\n  let y;\n  if ($[0] !== arr1 || $[1] !== arr2) {\n    const x = [arr1];\n\n    (y = x.concat(arr2)), y;\n    $[0] = arr1;\n    $[1] = arr2;\n    $[2] = y;\n  } else {\n    y = $[2];\n  }\n  let t0;\n  let t1;\n  if ($[3] !== y) {\n    t1 = { y };\n    $[3] = y;\n    $[4] = t1;\n  } else {\n    t1 = $[4];\n  }\n  t0 = t1;\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [\n    [1, 2],\n    [3, 4],\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: FIXTURE_ENTRYPOINT Configuration for Component Test\nDESCRIPTION: Defines a test fixture for the React component, specifying the component function and test parameters with a sample value of 42.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-object-expression-computed-key-modified-during-after-construction-sequence-expr.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: 42}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Function with Conditional Logic in JavaScript\nDESCRIPTION: This snippet defines a function 'foo' that takes four parameters and executes different actions based on the conditions. The function uses a while loop to process its first parameter and continues certain actions based on the conditions of the other parameters.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/while-conditional-continue.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(a, b, c, d) {\n  while (a) {\n    if (b) {\n      continue;\n    }\n    c();\n    continue;\n  }\n  d();\n}\n```\n\n----------------------------------------\n\nTITLE: Original React Component Function\nDESCRIPTION: A simple React component that creates objects from props, calls a method conditionally, and returns the result. The component performs several potentially expensive operations without any manual memoization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-receiver-method-call.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const x = makeOptionalObject(props);\n  const y = makeObject(props);\n  const z = x?.method(y.a, props.a, foo(y.b), bar(props.b));\n  return z;\n}\n```\n\n----------------------------------------\n\nTITLE: Removing Root Operation in React DevTools\nDESCRIPTION: Example showing the operation payload for removing an entire root including its descendants. This specialized message is used when updating component filters to preserve fiber ids.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/OVERVIEW.md#2025-04-21_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\n[\n  6, // remove root operation\n]\n```\n\n----------------------------------------\n\nTITLE: React Component with Multiple Parameters\nDESCRIPTION: Defines a React component named `Component` that accepts two parameters, `foo` and `bar`. The component returns a simple `div` element. It also defines and exports a constant `FIXTURE_ENTRYPOINT` which is an object containing the component function and a `params` array to be passed to the component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-dont-compile-components-with-multiple-params.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// @compilationMode(infer)\n// Takes multiple parameters - not a component!\nfunction Component(foo, bar) {\n  return <div />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [null, null],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Array Manipulation Function in JavaScript\nDESCRIPTION: This function creates an array by spreading a source array into a predefined array, then returns the length of the resulting array and the result of pushing a new element. It's designed to test order of evaluation in React compilation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/evaluation-order-mutate-call-after-dependency-load.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n/**\n * Test that we preserve order of evaluation on the following case scope@0\n * ```js\n * // simplified HIR\n * scope@0\n *    ...\n *    $0 = arr.length\n *    $1 = arr.push(...)\n *\n * scope@1 <-- here we should depend on $0 (the value of the property load before the\n *             mutable call)\n *   [$0, $1]\n * ```\n */\nfunction useFoo(source: Array<number>): [number, number] {\n  const arr = [1, 2, 3, ...source];\n  return [arr.length, arr.push(0)];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [[5, 6]],\n};\n```\n\n----------------------------------------\n\nTITLE: React Context Mutation Error Message\nDESCRIPTION: Error output highlighting the issue of attempting to mutate a context value returned by useContext(), which is not allowed in React\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-mutate-context.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n  1 | function Component(props) {\n  2 |   const context = useContext(FooContext);\n> 3 |   context.value = props.value;\n    |   ^^^^^^^ InvalidReact: Mutating a value returned from 'useContext()', which should not be mutated (3:3)\n  4 |   return context.value;\n  5 | }\n```\n\n----------------------------------------\n\nTITLE: Original React Hook Implementation\nDESCRIPTION: Input version of a React hook that implements conditional logging based on a constant string comparison and boolean parameter. Uses a labeled block with switch statement for flow control.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unlabeled-break-within-label-switch.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {CONST_STRING0} from 'shared-runtime';\n\nfunction useHook(cond) {\n  const log = [];\n  switch (CONST_STRING0) {\n    case CONST_STRING0:\n      log.push(`@A`);\n      bb0: {\n        if (cond) {\n          break;\n        }\n        log.push(`@B`);\n      }\n      log.push(`@C`);\n  }\n  return log;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useHook,\n  params: [true],\n};\n```\n\n----------------------------------------\n\nTITLE: Check Various Visibility and Invocation of useState Hook in JavaScript\nDESCRIPTION: This snippet repeats the earlier examples of functions invoking useState, structured similarly but follows a valid pattern by ensuring all functions are correctly formatted. Comment annotations indicate that the snippets serve to highlight the invalid forms of hook usage based on React's conventions. The hooks should only be defined in certain ways to maintain usability.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.bail.rules-of-hooks-fadd52c1e460.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// @skip\n// Unsupported input\n\n// Currently invalid.\n// These are variations capturing the current heuristic--\n// we only allow hooks in PascalCase or useFoo functions.\n// We *could* make some of these valid. But before doing it,\n// consider specific cases documented above that contain reasoning.\nfunction a() {\n  useState();\n}\n\nconst whatever = function b() {\n  useState();\n};\n\nconst c = () => {\n  useState();\n};\n\nlet d = () => {\n  return useState();\n};\ne = () => {\n  useState();\n};\n\n({\n  f: () => {\n    useState();\n  },\n});\n({\n  g() {\n    useState();\n  },\n});\nconst {\n  j = () => {\n    useState();\n  },\n} = {};\n({\n  k = () => {\n    useState();\n  },\n} = {});\n\n```\n\n----------------------------------------\n\nTITLE: Exporting a React fixture entry point in Javascript\nDESCRIPTION: This code snippet exports a constant named `FIXTURE_ENTRYPOINT`, which is an object that defines a React fixture. It specifies the function to be used (`foo`), the parameters to be passed to the function, and whether the function is a component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-sibling-phis.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Props\nDESCRIPTION: This JavaScript code defines a React component called `Component` that accepts props. It uses the spread operator to combine arrays from `props.foo` and `props.bar` with other values into a new array `x`. The `FIXTURE_ENTRYPOINT` object specifies the component and its initial parameters for testing or demonstration purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-expression-spread.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const x = [0, ...props.foo, null, ...props.bar, 'z'];\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{foo: [1, 2, 3], bar: [4, 5, 6]}],\n  isComponent: false,\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining Object Destructuring and Array Creation in JavaScript\nDESCRIPTION: This snippet defines a function 'foo' that performs object destructuring with renaming and creates an array. It also exports a FIXTURE_ENTRYPOINT object for testing purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructure-mixed-property-key-types.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo() {\n  const {'data-foo-bar': x, a: y, data: z} = {'data-foo-bar': 1, a: 2, data: 3};\n  return [x, y, z];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Invalid Hook Usage Inside Loop - JavaScript React\nDESCRIPTION: Example of incorrect React Hook implementation where a hook is called inside a while loop. This violates the Rules of Hooks by potentially calling the hook conditionally and in an inconsistent order.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-rules-of-hooks-79128a755612.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Expected to fail\n\n// Invalid because it's dangerous and might not warn otherwise.\n// This *must* be invalid.\nfunction ComponentWithHookInsideLoop() {\n  while (cond) {\n    useHookInsideLoop();\n  }\n}\n```\n\nLANGUAGE: text\nCODE:\n```\n   5 | function ComponentWithHookInsideLoop() {\n   6 |   while (cond) {\n>  7 |     useHookInsideLoop();\n     |     ^^^^^^^^^^^^^^^^^ InvalidReact: Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning) (7:7)\n   8 |   }\n   9 | }\n  10 |\n\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: Basic React component that renders a 'hello world' div element, using TypeScript type annotations and JSX syntax.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-duplicate-type-import.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport type {ReactElement} from 'react';\n\nfunction Component(_props: {}): ReactElement {\n  return <div>hello world</div>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Updated Fixture Entrypoint with String Literals in JavaScript\nDESCRIPTION: This snippet shows an updated version of the FIXTURE_ENTRYPOINT object. It uses double quotes for string literals instead of single quotes, adhering to a consistent string notation style.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/logical-expression.expect.md#2025-04-21_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with Invalid State Update in JavaScript\nDESCRIPTION: This code snippet demonstrates a React functional component that incorrectly uses the useState hook. It unconditionally calls setState during render, which triggers an infinite loop error. The component also includes a for...of loop with conditional statements.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.unconditional-set-state-in-render-after-loop-break.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validateNoSetStateInRender\nfunction Component(props) {\n  const [state, setState] = useState(false);\n  for (const _ of props) {\n    if (props.cond) {\n      break;\n    } else {\n      continue;\n    }\n  }\n  setState(true);\n  return state;\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled React Hook with Memoization\nDESCRIPTION: Compiler-optimized version of useBar that implements memoization using React's compiler runtime. The transformed code caches results based on the arg parameter to avoid unnecessary recomputation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-spread-later-mutated.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction useBar(t0) {\n  const $ = _c(2);\n  const { arg } = t0;\n  let arr;\n  if ($[0] !== arg) {\n    const obj = {};\n    const s = new Set([obj, 5, 4]);\n    const mutableIterator = s.values();\n    arr = [...mutableIterator];\n\n    obj.x = arg;\n    $[0] = arg;\n    $[1] = arr;\n  } else {\n    arr = $[1];\n  }\n  return arr;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useBar,\n  params: [{ arg: 3 }],\n  sequentialRenders: [{ arg: 3 }, { arg: 3 }, { arg: 4 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with State Updates\nDESCRIPTION: This snippet shows the original implementation of a React component that updates state based on props. It uses array destructuring and a closure to modify the state.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructure-array-assignment-to-context-var.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {identity} from 'shared-runtime';\n\nfunction Component(props) {\n  let x;\n  [x] = props.value;\n  const foo = () => {\n    x = identity(props.value[0]);\n  };\n  foo();\n  return {x};\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: [42]}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: This snippet shows the compiled version of the React component using React's compiler runtime. It implements memoization using Symbol.for('react.memo_cache_sentinel') to optimize performance by caching the computed value.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/lambda-reassign-primitive.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\n\nfunction Component() {\n  const $ = _c(1);\n  let x;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    x = 40;\n\n    const fn = function () {\n      x = x + 1;\n    };\n\n    fn();\n    $[0] = x;\n  } else {\n    x = $[0];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Defining useFoo Hook with Conditional State Update - JavaScript\nDESCRIPTION: This snippet defines a custom React hook 'useFoo' that takes in props and conditionally updates state based on these props. It utilizes the 'mutate' function to modify the state in an array 'x', either initializing it or reusing the existing data based on the current props. The hook reacts to changes in 'bar', 'cond', and 'foo' to update its internal state accordingly.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/ssa-renaming-ternary-destruction-with-mutation.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enablePropagateDepsInHIR\nimport {mutate} from 'shared-runtime';\n\nfunction useFoo(props) {\n  let x = [];\n  x.push(props.bar);\n  props.cond ? (({x} = {x: {}}), ([x] = [[]]), x.push(props.foo)) : null;\n  mutate(x);\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{cond: false, foo: 2, bar: 55}],\n  sequentialRenders: [\n    {cond: false, foo: 2, bar: 55},\n    {cond: false, foo: 3, bar: 55},\n    {cond: true, foo: 3, bar: 55},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component\nDESCRIPTION: This snippet shows the compiled version of the `VideoTab` component using React's compiler runtime. It utilizes `_c` for memoization and stores the result in a cache. The `ref` is still created using `useRef`, and the function accessing `ref.current.x` is created only when the component is initially rendered and stored in the cache. The cached component is then returned on subsequent renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ref-current-field-not-added-to-dep.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @validateRefAccessDuringRender false\nfunction VideoTab() {\n  const $ = _c(1);\n  const ref = useRef();\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const x = () => {\n      console.log(ref.current.x);\n    };\n\n    t0 = <VideoList videos={x} />;\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component\nDESCRIPTION: This code represents the compiled version of the React component, potentially optimized using a React compiler. It uses `_c` from 'react/compiler-runtime' for memoization. The compiled component aims to achieve the same functionality as the original component, calculating and rendering `expensiveNumber`, but with enhanced performance due to compiler optimizations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/babel-existing-react-namespace-import.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport * as React from \"react\";\nimport { calculateExpensiveNumber } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(4);\n  const [x] = React.useState(0);\n  let t0;\n  let t1;\n  if ($[0] !== x) {\n    t1 = calculateExpensiveNumber(x);\n    $[0] = x;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  t0 = t1;\n  const expensiveNumber = t0;\n  let t2;\n  if ($[2] !== expensiveNumber) {\n    t2 = <div>{expensiveNumber}</div>;\n    $[2] = expensiveNumber;\n    $[3] = t2;\n  } else {\n    t2 = $[3];\n  }\n  return t2;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Running React SSR fixtures in production mode\nDESCRIPTION: Command to run the server-side rendering fixtures in production mode, which pre-builds static resources and starts an HTTP server without hot reloading.\nSOURCE: https://github.com/facebook/react/blob/main/fixtures/ssr2/README.md#2025-04-21_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nyarn start:prod\n```\n\n----------------------------------------\n\nTITLE: Defining AllocatingPrimitiveAsDepNested Function - React - JavaScript\nDESCRIPTION: This snippet defines the function 'AllocatingPrimitiveAsDepNested', which leverages React's memoization to efficiently manage the state based on props. It uses identity functions and mutable objects to optimize rendering. Key dependencies include 'identity', 'mutate', and 'setProperty' from 'shared-runtime'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allocating-primitive-as-dep-nested-scope.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// bar(props.b) is an allocating expression that produces a primitive, which means\n// that Forget should memoize it.\n// Correctness:\n\nimport {identity, mutate, setProperty} from 'shared-runtime';\n\n//   - y depends on either bar(props.b) or bar(props.b) + 1\nfunction AllocatingPrimitiveAsDepNested(props) {\n  let x = {};\n  mutate(x);\n  let y = identity(identity(props.b) + 1);\n  setProperty(x, props.a);\n  return [x, y];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: AllocatingPrimitiveAsDepNested,\n  params: [{a: 1, b: 2}],\n  sequentialRenders: [\n    // change b\n    {a: 1, b: 3},\n    // change b\n    {a: 1, b: 4},\n    // change a\n    {a: 2, b: 4},\n    // change a\n    {a: 3, b: 4},\n  ],\n};\n```\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // bar(props.b) is an allocating expression that produces a primitive, which means\n// that Forget should memoize it.\n// Correctness:\n\nimport { identity, mutate, setProperty } from \"shared-runtime\";\n\n//   - y depends on either bar(props.b) or bar(props.b) + 1\nfunction AllocatingPrimitiveAsDepNested(props) {\n  const $ = _c(5);\n  let t0;\n  if ($[0] !== props.a || $[1] !== props.b) {\n    const x = {};\n    mutate(x);\n    const t1 = identity(props.b) + 1;\n    let t2;\n    if ($[3] !== t1) {\n      t2 = identity(t1);\n      $[3] = t1;\n      $[4] = t2;\n    } else {\n      t2 = $[4];\n    }\n    const y = t2;\n    setProperty(x, props.a);\n    t0 = [x, y];\n    $[0] = props.a;\n    $[1] = props.b;\n    $[2] = t0;\n  } else {\n    t0 = $[2];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: AllocatingPrimitiveAsDepNested,\n  params: [{ a: 1, b: 2 }],\n  sequentialRenders: [\n    // change b\n    { a: 1, b: 3 },\n    // change b\n    { a: 1, b: 4 },\n    // change a\n    { a: 2, b: 4 },\n    // change a\n    { a: 3, b: 4 },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Dynamic Context (JavaScript)\nDESCRIPTION: This snippet defines a React component that creates a dynamic context object based on input props. It uses the 'identity' function from a shared runtime and a constant SCALE factor.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-expression-computed-key.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {identity} from 'shared-runtime';\n\nconst SCALE = 2;\n\nfunction Component(props) {\n  const {key} = props;\n  const context = {\n    [key]: identity([props.value, SCALE]),\n  };\n  return context;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{key: 'Sathya', value: 'Compiler'}],\n};\n```\n\n----------------------------------------\n\nTITLE: Utilizing Compiler Runtime for Hooks in React - JavaScript\nDESCRIPTION: This JavaScript snippet showcases the integration of a compiler-supported runtime for hooks in React. It demonstrates a refined approach to the 'useHook' function by utilizing a compiler helper '_c'. This approach dynamically caches and updates the hook outputs based on input values, optimizing re-render cycles. 'FIXTURE_ENTRYPOINT' is set with the wrapped hook function 'useHook' and initializes parameters 'a' and 'b'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-shorthand-method-1.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { createHookWrapper } from \"shared-runtime\";\nfunction useHook(t0) {\n  const $ = _c(5);\n  const { a, b } = t0;\n  let t1;\n  if ($[0] !== a) {\n    t1 = function () {\n      return [a];\n    };\n    $[0] = a;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  let t2;\n  if ($[2] !== b || $[3] !== t1) {\n    t2 = {\n      x: t1,\n      y() {\n        return [b];\n      },\n    };\n    $[2] = b;\n    $[3] = t1;\n    $[4] = t2;\n  } else {\n    t2 = $[4];\n  }\n  return t2;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: createHookWrapper(useHook),\n  params: [{ a: 1, b: 2 }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Component with Computed Property Names\nDESCRIPTION: A React component function using computed property names in an object literal, which imports utility functions from 'shared-runtime'. It creates an object with a dynamically computed property key based on function calls.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-object-expression-member-expr-call.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {identity, mutate, mutateAndReturn} from 'shared-runtime';\n\nfunction Component(props) {\n  const obj = {mutateAndReturn};\n  const key = {};\n  const context = {\n    [obj.mutateAndReturn(key)]: identity([props.value]),\n  };\n  mutate(key);\n  return context;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: 42}],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component with Reactive References in useEffect\nDESCRIPTION: This code demonstrates a React component that uses references conditionally and includes them in an effect. The challenge is that setState variables cannot be automatically omitted from dependencies based on types alone - reactivity must be considered.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/reactive-setState.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @inferEffectDependencies\nimport {useEffect, useState} from 'react';\nimport {print} from 'shared-runtime';\n\n/*\n * setState types are not enough to determine to omit from deps. Must also take reactivity into account.\n */\nfunction ReactiveRefInEffect(props) {\n  const [_state1, setState1] = useRef('initial value');\n  const [_state2, setState2] = useRef('initial value');\n  let setState;\n  if (props.foo) {\n    setState = setState1;\n  } else {\n    setState = setState2;\n  }\n  useEffect(() => print(setState));\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing React Function with Infinite Loop and Variable Declaration\nDESCRIPTION: This code snippet defines a React function 'useFoo' that contains an infinite while loop with a variable declaration inside. The function will never terminate due to the constant true condition.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/loop-unused-let.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction useFoo() {\n  while (1) {\n    let foo;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Managing State with useFoo in JavaScript\nDESCRIPTION: The useFoo function manipulates an array based on properties in the props object. It includes dependencies on shared-runtime for array manipulation. Key properties include 'cond', 'foo', and 'bar'. Inputs affect the returned array structure, which handles conditional replacements and additions via arrayPush. Expected outputs vary based on conditions within, and state management includes caching state for optimization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/ssa-renaming-unconditional-ternary-with-mutation.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enablePropagateDepsInHIR\nimport {arrayPush} from 'shared-runtime';\nfunction useFoo(props) {\n  let x = [];\n  x.push(props.bar);\n  props.cond\n    ? ((x = {}), (x = []), x.push(props.foo))\n    : ((x = []), (x = []), x.push(props.bar));\n  arrayPush(x, 4);\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{cond: false, foo: 2, bar: 55}],\n  sequentialRenders: [\n    {cond: false, foo: 2, bar: 55},\n    {cond: false, foo: 3, bar: 55},\n    {cond: true, foo: 3, bar: 55},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Error Handling for Memoization in React - JavaScript\nDESCRIPTION: This error snippet outlines a compiler warning that indicates a failure to preserve existing memoization guarantees. It suggests that the inferred dependencies do not align with the specified dependencies, which could lead to unexpected behavior in the optimization of the component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.maybe-invalid-useCallback-read-maybeRef.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n  3 |\n  4 | function useHook(maybeRef) {\n> 5 |   return useCallback(() => {\n    |                      ^^^^^^^\n> 6 |     return [maybeRef.current];\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 7 |   }, [maybeRef]);\n    | ^^^^ CannotPreserveMemoization: React Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. The inferred dependencies did not match the manually specified dependencies, which could cause the value to change more or less frequently than expected (5:7)\n  8 | }\n  9 |\n\n```\n\n----------------------------------------\n\nTITLE: React Compiler-Optimized Function with Memoization\nDESCRIPTION: An optimized version of the function using React compiler runtime (_c) for memoization. Implements caching mechanisms to prevent unnecessary re-renders and improve performance by tracking component state changes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-scopes.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction f(a, b) {\n  const $ = _c(3);\n  let t0;\n  if ($[0] !== a.length || $[1] !== b) {\n    const x = [];\n    if (a.length === 1) {\n      if (b) {\n        x.push(b);\n      }\n    }\n\n    t0 = <div>{x}</div>;\n    $[0] = a.length;\n    $[1] = b;\n    $[2] = t0;\n  } else {\n    t0 = $[2];\n  }\n  return t0;\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing React Component with useCallback\nDESCRIPTION: A React functional component demonstrating the use of useCallback hook with a potential optimization issue due to eslint rule disabling\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.sketchy-code-exhaustive-deps.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component() {\n  const item = [];\n  const foo = useCallback(\n    () => {\n      item.push(1);\n    }, // eslint-disable-next-line react-hooks/exhaustive-deps\n    []\n  );\n\n  return <Button foo={foo} />;\n}\n```\n\n----------------------------------------\n\nTITLE: React Error Message for Invalid useRef Usage\nDESCRIPTION: The error message from React showing that accessing ref.current in the dependency array is invalid. It points to line 5 where the error occurs and provides a link to the React documentation about useRef.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.hook-ref-value.expect.md#2025-04-22_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n  3 | function Component(props) {\n  4 |   const ref = useRef();\n> 5 |   useEffect(() => {}, [ref.current]);\n    |                        ^^^^^^^^^^^ InvalidReact: Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef) (5:5)\n\nInvalidReact: Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef) (5:5)\n  6 | }\n  7 |\n  8 | export const FIXTURE_ENTRYPOINT = {\n```\n\n----------------------------------------\n\nTITLE: Transformed JavaScript function foo with memoization\nDESCRIPTION: This snippet shows the transformed `foo` function. It imports `_c` from `react/compiler-runtime`, likely used for memoization. The function checks if the input `a` is different from the previously stored value (`$[0]`). If it is, it recomputes the value, stores it in `$[1]`, and updates `$[0]`. Otherwise, it returns the cached value from `$[1]`. This effectively memoizes the function's result based on the input `a`.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-property-alias-mutate-if.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction foo(a) {\n  const $ = _c(2);\n  let x;\n  if ($[0] !== a) {\n    x = {};\n    if (a) {\n      const y = {};\n      x.y = y;\n    } else {\n      const z = {};\n      x.z = z;\n    }\n\n    mutate(x);\n    $[0] = a;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Component Logic with Props in JavaScript\nDESCRIPTION: This snippet defines a functional React component that takes `props` as an argument. It initializes an array `a`, conditionally fills it with values from `props`, and returns the modified array. This component reacts to the presence of `props.b` to decide whether to push another property `props.c` into the array. Dependencies include React.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/conditional-break-labeled.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enablePropagateDepsInHIR\n/**\n * props.b *does* influence `a`\n */\nfunction Component(props) {\n  const a = [];\n  a.push(props.a);\n  label: {\n    if (props.b) {\n      break label;\n    }\n    a.push(props.c);\n  }\n  a.push(props.d);\n  return a;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Simplified React Test Fixture with Empty Function\nDESCRIPTION: A minimalist version of the test fixture with an empty 'foo' function and the same FIXTURE_ENTRYPOINT export structure, likely representing a boilerplate or starter template for testing.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-simple-phi.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo() {}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Improper useRef Access in React Component\nDESCRIPTION: A React component that incorrectly tries to access the current property of a ref during render, which violates React's rules about ref access timing. This will trigger an error because refs should not be accessed during render.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.ref-optional.expect.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useRef} from 'react';\n\nfunction Component(props) {\n  const ref = useRef();\n  return ref?.current;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Compiler Runtime\nDESCRIPTION: This snippet shows an optimized version of the React component, likely produced by a compiler. It includes memoization and caching strategies to improve performance, while maintaining the same functionality as the original component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-global-reassignment-in-effect.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useEffect, useState } from \"react\";\n\nlet someGlobal = false;\n\nfunction Component() {\n  const $ = _c(5);\n  const [state, setState] = useState(someGlobal);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = [];\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  useEffect(_temp, t0);\n  let t1;\n  let t2;\n  if ($[1] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = () => {\n      setState(someGlobal);\n    };\n    t2 = [someGlobal];\n    $[1] = t1;\n    $[2] = t2;\n  } else {\n    t1 = $[1];\n    t2 = $[2];\n  }\n  useEffect(t1, t2);\n\n  const t3 = String(state);\n  let t4;\n  if ($[3] !== t3) {\n    t4 = <div>{t3}</div>;\n    $[3] = t3;\n    $[4] = t4;\n  } else {\n    t4 = $[4];\n  }\n  return t4;\n}\nfunction _temp() {\n  someGlobal = true;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Transformed Increment/Decrement Operations in React\nDESCRIPTION: This snippet shows the transformed version of the Foo component without Flow annotations. It replaces the increment and decrement operators with explicit addition and subtraction operations. The code maintains the same functionality as the input version but with more verbose and explicit operations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/member-inc.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Foo() {\n  const x = { a: 1 };\n  x.a = x.a + 1;\n  x.a = x.a - 1;\n  console.log((x.a = x.a + 1));\n  const t0 = x.a;\n  x.a = t0 + 1;\n  console.log(t0);\n\n  console.log(x.a);\n  const t1 = x.a;\n  x.a = t1 + 1;\n  const y = t1;\n  console.log(y);\n  console.log(x.a);\n\n  const t2 = (x.a = x.a + 1).toString();\n  const t3 = x.a;\n  x.a = t3 + 1;\n  console.log(t2, t3.toString(), x.a);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: React-Specific Object Mutation with Caching (JavaScript)\nDESCRIPTION: This snippet illustrates a React-specific pattern for object mutation, using a caching mechanism with a compiler runtime. It checks conditional parameters against cached values to optimize performance. Key parameters include 'a', the condition, and '$', the cache. Expected outputs are object 'x' with conditional properties. It assumes React and its compiler-runtime as dependencies.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-property-alias-mutate-inside-if.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction foo(a) {\n  const $ = _c(3);\n  let x;\n  if ($[0] !== a) {\n    x = {};\n    if (a) {\n      const y = {};\n      x.y = y;\n      mutate(y);\n    } else {\n      let t0;\n      if ($[2] === Symbol.for(\"react.memo_cache_sentinel\")) {\n        t0 = {};\n        $[2] = t0;\n      } else {\n        t0 = $[2];\n      }\n      const z = t0;\n      x.z = z;\n    }\n    $[0] = a;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  return x;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Memoization Violation with useCallback in React\nDESCRIPTION: This code shows an unsound memoization pattern where a mutable array is both used in the callback function and as a dependency. The array is later reassigned, which breaks memoization guarantees. React Compiler detects this and refuses to optimize the component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.invalid-useCallback-captures-reassigned-context.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees\n\nimport {useCallback} from 'react';\nimport {makeArray} from 'shared-runtime';\n\n// This case is already unsound in source, so we can safely bailout\nfunction Foo(props) {\n  let x = [];\n  x.push(props);\n\n  // makeArray() is captured, but depsList contains [props]\n  const cb = useCallback(() => [x], [x]);\n\n  x = makeArray();\n\n  return cb;\n}\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Building React DevTools Dependencies from Source\nDESCRIPTION: This command builds the required dependencies for React DevTools from source. It should be run from the root of the repository.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools-inline/README.md#2025-04-21_snippet_10\n\nLANGUAGE: sh\nCODE:\n```\nyarn build-for-devtools\n```\n\n----------------------------------------\n\nTITLE: Error Handling for Variable Reassignment in React\nDESCRIPTION: This snippet captures an error message generated when attempting to reassign a variable after the React render lifecycle has completed. It indicates that reassigning the variable 'x' can result in inconsistent behavior during subsequent renders. The error highlights the importance of managing state correctly in React applications to prevent issues during rendering.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.context-variable-only-chained-assign.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n   8 |   };\n   9 |   const fn2 = () => {\n> 10 |     const copy2 = (x = 4);\n     |                    ^ InvalidReact: Reassigning a variable after render has completed can cause inconsistent behavior on subsequent renders. Consider using state instead. Variable `x` cannot be reassigned after render (10:10)\n  11 |     return [invoke(fn1), copy2, identity(copy2)];\n  12 |   };\n  13 |   return invoke(fn2);\n```\n\n----------------------------------------\n\nTITLE: Optimized React.memo Component with Compiler-Runtime\nDESCRIPTION: Compiled output code showing how React optimizes the memoized component with a caching mechanism. It imports a compiler runtime utility and implements a cache check to avoid recreating the div element on re-renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-function-React-memo.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @compilationMode(infer)\nReact.memo((props) => {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = <div />;\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Claude Desktop for React MCP Server\nDESCRIPTION: JSON configuration for Claude Desktop to use the React MCP Server. The configuration specifies the node executable path and the path to the React MCP Server's index.js file.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/react-mcp-server/README.md#2025-04-21_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"mcpServers\": {\n    \"react\": {\n      \"command\": \"/Users/<username>/.asdf/shims/node\",\n      \"args\": [\n        \"/Users/<username>/code/react/compiler/packages/react-mcp-server/dist/index.js\"\n      ]\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Optimized Dependencies\nDESCRIPTION: The compiler-transformed version of the component that shows how React's compiler handles useRef dependencies. It creates a memoized callback and correctly determines that the useRef value is stable, resulting in an empty dependency array.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/nonreactive-ref.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @inferEffectDependencies\nimport { useEffect, useRef } from \"react\";\nimport { print } from \"shared-runtime\";\n\n/**\n * Special case of `infer-effect-deps/nonreactive-dep`.\n *\n * We know that local `useRef` return values are stable, regardless of\n * inferred memoization.\n */\nfunction NonReactiveRefInEffect() {\n  const $ = _c(1);\n  const ref = useRef(\"initial value\");\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = () => print(ref.current);\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  useEffect(t0, []);\n}\n```\n\n----------------------------------------\n\nTITLE: Build Error for Setter Function in React Component\nDESCRIPTION: The error output from the build system showing that it cannot handle setter functions in an object expression. The error points to the setter function definition and indicates a TODO item in the BuildHIR system.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-object-expression-set-syntax.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n  2 |   let value;\n  3 |   const object = {\n> 4 |     set value(v) {\n    |     ^^^^^^^^^^^^^^\n> 5 |       value = v;\n    | ^^^^^^^^^^^^^^^^\n> 6 |     },\n    | ^^^^^^ Todo: (BuildHIR::lowerExpression) Handle set functions in ObjectExpression (4:6)\n  7 |   };\n  8 |   object.value = props.value;\n  9 |   return <div>{value}</div>;\n```\n\n----------------------------------------\n\nTITLE: Implementing Triple Nested While Loops with Incrementing Variable in React Test Fixture\nDESCRIPTION: This code defines a JavaScript function 'foo' with triple nested while loops that increments a variable. The function is exported as a test fixture entrypoint with a 'TodoAdd' component parameter.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-nested-loops-no-reassign.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @xonly\nfunction foo(a, b, c) {\n  let x = 0;\n  while (a) {\n    while (b) {\n      while (c) {\n        x + 1;\n      }\n    }\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Validating React Ref Access During Render - JavaScript\nDESCRIPTION: This code defines a React functional component named 'Component' which tries to access the 'current' property of a ref passed in through props during the render phase, causing a validation error. Ref access should be avoided in this context to adhere to React's best practices.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-read-ref-prop-in-render-property-load.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validateRefAccessDuringRender @compilationMode(infer)\nfunction Component(props) {\n  const value = props.ref.current;\n  return <div>{value}</div>;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Hook with Dependency Tracking\nDESCRIPTION: Compiled version of the React hook with added dependency tracking and caching mechanism. Includes compiler-runtime utilities and optimized conditional checks for performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/infer-non-null-destructure.expect.md#2025-04-22_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enablePropagateDepsInHIR\nimport { identity, useIdentity } from \"shared-runtime\";\n\nfunction useFoo(t0) {\n  const $ = _c(10);\n  const { arg, cond } = t0;\n  let t1;\n  if ($[0] !== arg) {\n    t1 = { value: arg };\n    $[0] = arg;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  const maybeObj = useIdentity(t1);\n  const { value } = maybeObj;\n  useIdentity(null);\n  let arr;\n  if ($[2] !== cond || $[3] !== maybeObj.value) {\n    arr = [];\n    if (cond) {\n      let t2;\n      if ($[5] !== maybeObj.value) {\n        t2 = identity(maybeObj.value);\n        $[5] = maybeObj.value;\n        $[6] = t2;\n      } else {\n        t2 = $[6];\n      }\n      arr.push(t2);\n    }\n    $[2] = cond;\n    $[3] = maybeObj.value;\n    $[4] = arr;\n  } else {\n    arr = $[4];\n  }\n  let t2;\n  if ($[7] !== arr || $[8] !== value) {\n    t2 = { arr, value };\n    $[7] = arr;\n    $[8] = value;\n    $[9] = t2;\n  } else {\n    t2 = $[9];\n  }\n  return t2;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ arg: 2, cond: false }],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Context Memoization\nDESCRIPTION: This is the compiled version of the `App` component, utilizing a compiler runtime (`react/compiler-runtime`). It memoizes the `Bar` component based on the `bar` and `foo` context values. It utilizes an array `$` to store previous values and the rendered component to prevent re-renders if the context values haven't changed.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/todo.lower-context-access-nested-destructuring.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @lowerContextAccess\nfunction App() {\n  const $ = _c(3);\n  const { joe: t0, bar } = useContext(MyContext);\n  const { foo } = t0;\n  let t1;\n  if ($[0] !== bar || $[1] !== foo) {\n    t1 = <Bar foo={foo} bar={bar} />;\n    $[0] = bar;\n    $[1] = foo;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  return t1;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with FBT String Optimization\nDESCRIPTION: Compiled output of the React component that transforms the JSX-based FBT markup into optimized function calls. It includes memoization logic to prevent unnecessary re-rendering when the input value hasn't changed.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-no-whitespace-btw-text-and-param.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport fbt from \"fbt\";\n\nconst _ = fbt;\nfunction Component(t0) {\n  const $ = _c(2);\n  const { value } = t0;\n  let t1;\n  if ($[0] !== value) {\n    t1 = fbt._(\n      \"Before text{paramName}After text\",\n      [fbt._param(\"paramName\", value)],\n      { hk: \"aKEGX\" },\n    );\n    $[0] = value;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ value: \"hello world\" }],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a Function with Object Manipulation in JavaScript\nDESCRIPTION: This JavaScript snippet defines a function named 'foo' that takes three arguments (a, b, c). It destructures a property from 'a', uses spread syntax to create a new object 'y' based on nested properties of 'b', modifies 'y', and recursively calls itself with a nested property of 'a'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-properties.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(a, b, c) {\n  const x = a.x;\n  const y = {...b.c.d};\n  y.z = c.d.e;\n  foo(a.b.c);\n  [a.b.c];\n}\n```\n\n----------------------------------------\n\nTITLE: React Component and Fixture Definition\nDESCRIPTION: Defines a React component function `t` that destructures the `props` array and returns the second element (indexed as `foo`). It also defines a constant `FIXTURE_ENTRYPOINT` that serves as a fixture configuration.  This configuration specifies the component function (`fn`), the expected parameters (`params`), and the component name (`isComponent`).\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/holey-array-pattern-dce.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction t(props) {\n  let [, foo, bar] = props;\n  return foo;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: t,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Default Parameter in JavaScript\nDESCRIPTION: This snippet defines a simple React component named 'Component' that takes an optional parameter 'x' with a default value of [-1, 1]. The component simply returns the value of 'x'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/default-param-array-with-unary.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(x = [-1, 1]) {\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Using React Memoization with Hoisting\nDESCRIPTION: This snippet showcases a refined version of the 'hoisting' function that integrates the React compiler runtime for memoization. It uses the '_c' function from React to work with a parameter that is memoized. If a certain condition is met, it invokes 'bar' through 'foo'. This code aims to demonstrate functional behavior reliant on React's memoization which improves performance by avoiding unnecessary re-computation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-simple-function-expression.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction hoisting() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const foo = () => bar();\n\n    const bar = _temp;\n\n    t0 = foo();\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\nfunction _temp() {\n  return 1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: hoisting,\n  params: [],\n  isComponent: false,\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Component with Memoization Error\nDESCRIPTION: A React component that demonstrates a memoization error detected by React Compiler. The component uses useMemo to memoize a value returned by getIsEnabled, but this creates issues because the returned value might be mutable, which is later captured by getLoggingData and passed to other functions.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-repro-missed-memoization-from-capture-in-invoked-function-inferred-as-mutation.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @flow @validatePreserveExistingMemoizationGuarantees\nimport {useMemo} from 'react';\nimport {logValue, useFragment, useHook, typedLog} from 'shared-runtime';\n\ncomponent Component() {\n  const data = useFragment();\n\n  const getIsEnabled = () => {\n    if (data != null) {\n      return true;\n    } else {\n      return {};\n    }\n  };\n\n  // We infer that getIsEnabled returns a mutable value, such that\n  // isEnabled is mutable\n  const isEnabled = useMemo(() => getIsEnabled(), [getIsEnabled]);\n\n  // We then infer getLoggingData as capturing that mutable value,\n  // so any calls to this function are then inferred as extending\n  // the mutable range of isEnabled\n  const getLoggingData = () => {\n    return {\n      isEnabled,\n    };\n  };\n\n  // The call here is then inferred as an indirect mutation of isEnabled\n  useHook(getLoggingData());\n\n  return <div onClick={() => typedLog(getLoggingData())} />;\n}\n```\n\n----------------------------------------\n\nTITLE: React useState with useMemo Issue\nDESCRIPTION: This code demonstrates a potential issue with using `useState` and `useMemo` together in React.  The `useKeyedState` hook attempts to initialize state based on a `key` and `init` value.  `useMemo` is used to call a function that updates the state when `key` or `init` changes, but calling `setState` inside the `useMemo` callback will cause infinite re-renders and result in an infinite loop.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-setState-in-useMemo-indirect-useCallback.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useCallback} from 'react';\n\nfunction useKeyedState({key, init}) {\n  const [prevKey, setPrevKey] = useState(key);\n  const [state, setState] = useState(init);\n\n  const fn = useCallback(() => {\n    setPrevKey(key);\n    setState(init);\n  });\n\n  useMemo(() => {\n    fn();\n  }, [key, init]);\n\n  return state;\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect useState Usage in React\nDESCRIPTION: This code demonstrates an anti-pattern in React where the state object `x` obtained from `useState` is directly mutated.  The `onChange` handler directly modifies `x.value` which is against React's principle of immutability.  This mutation is then followed by calling `setX` with the mutated object.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-function-expression-mutates-immutable-value.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const [x, setX] = useState({value: ''});\n  const onChange = e => {\n    // INVALID! should use copy-on-write and pass the new value\n    x.value = e.target.value;\n    setX(x);\n  };\n  return <input value={x.value} onChange={onChange} />;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining Non-React Function in JavaScript\nDESCRIPTION: This snippet defines a function named 'nonReactFn' that returns an empty object. The function is preceded by a compilation mode directive that suggests inference should be used.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/apps/playground/__tests__/e2e/__snapshots__/page.spec.ts/compilationMode-infer-output.txt#2025-04-21_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\n// @compilationMode(infer)\nfunction nonReactFn() {\n  return {};\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering a React Component with Props\nDESCRIPTION: This snippet defines a simple React component and a child component that receives text props. The 'Component' function is exported for usage elsewhere, with a specific child 'Child' that renders the text prop passed from the parent component. 'FIXTURE_ENTRYPOINT' encapsulates the 'Component' function as an export along with parameter definitions.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/quoted-strings-in-jsx-attribute-escaped.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nexport function Component() {\n  return <Child text='Some \\\"text\\\"' />;\n}\n\nfunction Child(props) {\n  return props.text;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Optimizing useFoo for Performance in React\nDESCRIPTION: The second implementation of the useFoo function adds optimizations using internal state to minimize recomputation. It maintains state across calls, using a symbol to handle early returns and manages inputs and outputs efficiently. Dependencies include 'react/compiler-runtime' for terms and identity function from 'shared-runtime'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-unpoisoned/reduce-if-exhaustive-nonpoisoned-deps.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { identity } from \"shared-runtime\";\n\nfunction useFoo(t0) {\n  const $ = _c(9);\n  const { input, hasAB, returnNull } = t0;\n  let t1;\n  let x;\n  if ($[0] !== hasAB || $[1] !== input.a || $[2] !== returnNull) {\n    t1 = Symbol.for(\"react.early_return_sentinel\");\n    bb0: {\n      x = [];\n      if (!hasAB) {\n        let t2;\n        if ($[5] !== input.a) {\n          t2 = identity(input.a);\n          $[5] = input.a;\n          $[6] = t2;\n        } else {\n          t2 = $[6];\n        }\n        x.push(t2);\n        if (!returnNull) {\n          t1 = null;\n          break bb0;\n        }\n      } else {\n        let t2;\n        if ($[7] !== input.a.b) {\n          t2 = identity(input.a.b);\n          $[7] = input.a.b;\n          $[8] = t2;\n        } else {\n          t2 = $[8];\n        }\n        x.push(t2);\n      }\n    }\n    $[0] = hasAB;\n    $[1] = input.a;\n    $[2] = returnNull;\n    $[3] = t1;\n    $[4] = x;\n  } else {\n    t1 = $[3];\n    x = $[4];\n  }\n  if (t1 !== Symbol.for(\"react.early_return_sentinel\")) {\n    return t1;\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ input: { b: 1 }, hasAB: false, returnNull: false }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component\nDESCRIPTION: This snippet shows the compiled version of the `useFoo` React component, using `react/compiler-runtime` for optimization. It uses `_c` for memoization and caching. The compiled component checks for a sentinel value in the cache, and if not present, invokes the callback function `_temp` to render the `Stringify` component, then caches the result. The result is returned.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-local-tag-in-lambda.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { Stringify } from \"shared-runtime\";\nfunction useFoo() {\n  const $ = _c(1);\n\n  const callback = _temp;\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = callback();\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\nfunction _temp() {\n  return <Stringify value={4} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Function Hoisting in JavaScript\nDESCRIPTION: This snippet showcases hoisting with nested functions in JavaScript. It includes a main function 'hoisting' which demonstrates how nested functions like 'bar' and 'baz' have their declarations and values hoisted. The snippet also includes an export for use as a module entry point. It requires a JavaScript runtime to execute, with no specific version dependencies. Parameters and inputs are nil, while output is governed by hoisting mechanics.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.hoisting-simple-function-declaration.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction hoisting() {\n  function bar() {\n    return x;\n  }\n  return baz(); // OK: FuncDecls are HoistableDeclarations that have both declaration and value hoisting\n  function baz() {\n    return bar();\n  }\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: hoisting,\n  params: [],\n  isComponent: false,\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Props Destructuring - JavaScript\nDESCRIPTION: This snippet defines a functional React component `Foo` that destructures props to extract particular properties. It handles an unused property by excluding it from the returned object. The `FIXTURE_ENTRYPOINT` is an exported constant that references the `Foo` function and includes its parameters and metadata for component identification.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unused-object-element-with-rest.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Foo(props) {\n  // can't remove `unused` since it affects which properties are copied into `rest`\n  const {unused, ...rest} = props.a;\n  return rest;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n\n```\n\n----------------------------------------\n\nTITLE: Component Definition with Stringify\nDESCRIPTION: This code defines a React component named `Component` that takes a `kind` prop and other props. It uses a switch statement based on the `kind` prop to determine which component to render. In the default case, it renders a `Stringify` component, passing along all other props.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/switch-with-only-default.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {Stringify} from 'shared-runtime';\n\nfunction Component({kind, ...props}) {\n  switch (kind) {\n    default:\n      return <Stringify {...props} />;\n  }\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{kind: 'foo', a: 1, b: true, c: 'sathya'}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining React Component (Input)\nDESCRIPTION: This code defines a simple React component named `Component` that receives an object with a property `c`. It increments `c` to create `h`, decrements `c` to create `i`, and returns an array containing `c`, `h`, and `i`. The `FIXTURE_ENTRYPOINT` object configures the component for testing or demonstration purposes with initial parameters.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/update-expression-on-function-parameter-3.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component({c}) {\n  let h = c++;\n  let i = --c;\n  return [c, h, i];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{c: 4}],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: React Compiler Runtime Conditional Dependencies - JavaScript\nDESCRIPTION: This snippet enhances the previously defined function by incorporating the React compiler runtime. It uses '_c' from 'react/compiler-runtime' to manage reactive state within the function 'useReactiveDepsInCondScope'. This extended version introduces memoized state to store dependencies, such as 'props' and 'props.a.b'. It conditionally updates and retrieves values based on the current state, ensuring efficient dependency management within the reactive scope.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/cond-scope.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\\nimport { CONST_FALSE, identity } from \"shared-runtime\";\\n\\nfunction useReactiveDepsInCondScope(props) {\\n  const $ = _c(4);\\n  let x;\\n  if ($[0] !== props) {\\n    x = {};\\n    if (CONST_FALSE) {\\n      let t0;\\n      if ($[2] !== props.a.b) {\\n        t0 = identity(props.a.b);\\n        $[2] = props.a.b;\\n        $[3] = t0;\\n      } else {\\n        t0 = $[3];\\n      }\\n      const tmp = t0;\\n      x.a = tmp;\\n    }\\n    $[0] = props;\\n    $[1] = x;\\n  } else {\\n    x = $[1];\\n  }\\n  return x;\\n}\\n\\nexport const FIXTURE_ENTRYPOINT = {\\n  fn: useReactiveDepsInCondScope,\\n  params: [{}],\\n};\n```\n\n----------------------------------------\n\nTITLE: Simple Return Implementation in React Test Fixture\nDESCRIPTION: A simplified test fixture that logs a message and returns a constant value. Exports the same FIXTURE_ENTRYPOINT structure for consistency in testing.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/constant-propagation.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo() {\n  console.log(\"foo\");\n  return -6;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Rendering Condition Based on Feature Flag in React\nDESCRIPTION: This snippet demonstrates a React class component that conditionally invokes a feature flagging function within its render method. The component will call 'useFeatureFlag()' only if 'foo' evaluates to true, demonstrating a basic control structure for feature flags. Ensure that 'foo' and 'useFeatureFlag' are defined in the surrounding scope for this component to function correctly.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.invalid.invalid-rules-of-hooks-99b5c750d1d1.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @skip\n// Passed but should have failed\n\nclass ClassComponentWithFeatureFlag extends React.Component {\n  render() {\n    if (foo) {\n      useFeatureFlag();\n    }\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Transformed JavaScript Component\nDESCRIPTION: Transformed JavaScript code without Flow types, showing the compiled version with explicit parameter destructuring and value checking.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/logical-reorder.flow.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst foo = undefined;\n\nfunction C(t0) {\n  const { scope: t1 } = t0;\n  const scope = t1 === undefined ? (foo ?? null) : t1;\n  return scope;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: C,\n  params: [{ scope: undefined }],\n};\n```\n\n----------------------------------------\n\nTITLE: Git Cherry Pick for Patch Release\nDESCRIPTION: This command cherry-picks specific commits from the main branch into the patch release branch. This allows specific bug fixes or improvements to be included in the patch release. The `<commit-hash>` should be replaced with the actual commit hash to be included.\nSOURCE: https://github.com/facebook/react/blob/main/scripts/release/README.md#2025-04-21_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\ngit cherry-pick <commit-hash>\n```\n\n----------------------------------------\n\nTITLE: Refactored Fire Mechanism in React Component\nDESCRIPTION: This snippet showcases an updated implementation of the same React component where the useFire hook is utilized for the foo and bar functions. It destructures props directly in the function parameter and sets up useEffect to invoke the useFire instances accordingly. The component continues to maintain capitalized function call validation and integrates the shared runtime sum function as before.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/bailout-retry/bailout-capitalized-fn-call.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useFire } from \"react/compiler-runtime\"; // @validateNoCapitalizedCalls @enableFire @panicThreshold(none)\nimport { fire } from \"react\";\nconst CapitalizedCall = require(\"shared-runtime\").sum;\n\nfunction Component(t0) {\n  const { prop1, bar } = t0;\n  const foo = () => {\n    console.log(prop1);\n  };\n  const t1 = useFire(foo);\n  const t2 = useFire(bar);\n\n  useEffect(() => {\n    t1(prop1);\n    t1();\n    t2();\n  });\n  return CapitalizedCall();\n}\n\n```\n\n----------------------------------------\n\nTITLE: Caching and Mutating Component with React/Compiler Runtime in JavaScript\nDESCRIPTION: This code extends component mutation by introducing caching via React's compiler-runtime. The function checks a cached value before initializing 'x' and 'y', thereby optimizing repeated executions. The include of 'react/compiler-runtime' adds caching functionality, requiring this dependency for execution. The function inputs a string and outputs the mutated and potentially cached object.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-alias-receiver-mutate-iife.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nconst { mutate } = require(\"shared-runtime\");\n\nfunction component(a) {\n  const $ = _c(2);\n  let y;\n  if ($[0] !== a) {\n    const x = { a };\n    y = {};\n\n    const a_0 = y;\n    a_0.x = x;\n\n    mutate(y);\n    $[0] = a;\n    $[1] = y;\n  } else {\n    y = $[1];\n  }\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: [\"foo\"],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Original React Component with useMemo Hook\nDESCRIPTION: This snippet shows a React component that imports Stringify from shared-runtime and wraps it in a useMemo hook. The component renders Stringify with the passed props. An export FIXTURE_ENTRYPOINT is defined for testing with a sample parameter.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/context-variable-as-jsx-element-tag.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useMemo} from 'react';\nimport {Stringify} from 'shared-runtime';\n\nfunction Component(props) {\n  let Component = Stringify;\n\n  Component = useMemo(() => {\n    return Component;\n  });\n\n  return <Component {...props} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{name: 'Sathya'}],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: A React component that processes props into a JSON string, performs early return checks, and renders a Stringify component with various array values. Uses useMemo for performance optimization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-renaming-conflicting-decls.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {Stringify, identity, makeArray, toJSON} from 'shared-runtime';\nimport {useMemo} from 'react';\n\nfunction Component(props) {\n  const propsString = useMemo(() => toJSON(props), [props]);\n  if (propsString.length <= 2) {\n    return null;\n  }\n\n  const linkProps = {\n    url: identity(propsString),\n  };\n  const x = {};\n\n  // reactive scope ends at makeArray, as it is inferred as maybeMutate\n  return (\n    <Stringify\n      link={linkProps}\n      val1={[1]}\n      val2={[2]}\n      val3={[3]}\n      val4={[4]}\n      val5={[5]}>\n      {makeArray(x, 2)}\n    </Stringify>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{val: 2}],\n};\n```\n\n----------------------------------------\n\nTITLE: Initializing Nested Object Dependency Tracking in React\nDESCRIPTION: Function that creates a new object by accessing nested properties from input props, showcasing React compiler's ability to track object dependencies efficiently\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/uncond-subpath-order2.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction TestDepsSubpathOrder2(props) {\n  let x = {};\n  x.a = props.a;\n  x.b = props.a.b;\n  x.c = props.a.b.c;\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing React Component with Fire Import\nDESCRIPTION: Creates a React functional component with fire import and useEffect hook. The component currently returns null and does not implement any specific rendering logic.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/use-effect-no-args-no-op.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableFire\nimport {fire} from 'react';\n\nfunction Component(props) {\n  useEffect();\n\n  return null;\n}\n```\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableFire\nimport { fire } from \"react\";\n\nfunction Component(props) {\n  useEffect();\n  return null;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a React Component Function in JavaScript\nDESCRIPTION: The JavaScript code defines a function named 'component' that creates a closure capturing a variable 'z'. It then exports an object named FIXTURE_ENTRYPOINT that includes the function as a property. This exported object represents a module entry point for using 'component' with the 'TodoAdd' parameter. This snippet operates within a JavaScript environment and does not rely on external libraries.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-within-block.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component(a) {\n  let z = {a};\n  let x;\n  {\n    x = function () {\n      console.log(z);\n    };\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: Original React component implementation using useCallback hook for event handling optimization. The component creates an object, uses a custom hook, and sets up a click handler.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useCallback-call-second-function-which-captures-maybe-mutable-value-dont-preserve-memoization.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enablePreserveExistingMemoizationGuarantees:false @enableTransitivelyFreezeFunctionExpressions:false\nimport {useCallback} from 'react';\nimport {\n  identity,\n  logValue,\n  makeObject_Primitives,\n  useHook,\n} from 'shared-runtime';\n\nfunction Component(props) {\n  const object = makeObject_Primitives();\n\n  useHook();\n\n  const log = () => {\n    logValue(object);\n  };\n\n  const onClick = useCallback(() => {\n    log();\n  }, [log]);\n\n  identity(object);\n\n  return <div onClick={onClick} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Advanced Memoization Strategy with React and Shared Runtime\nDESCRIPTION: This React component demonstrates an advanced memoization approach using hooks and conditional logic. It utilizes 'react/compiler-runtime' and 'shared-runtime' dependencies to manage and preserve component states efficiently. The component tracks multiple parameters to ensure minimal re-computation and employs ValidateMemoization to check inputs and outputs. Key props include 'props.items', and the component returns a React element conditioned on memoized states, optimizing React performance through memoization guarantees.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/optional-member-expression-single-with-unconditional.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @validatePreserveExistingMemoizationGuarantees @enableOptionalDependencies @enablePropagateDepsInHIR\nimport { ValidateMemoization } from \"shared-runtime\";\nfunction Component(props) {\n  const $ = _c(7);\n  let t0;\n  let x;\n  if ($[0] !== props.items) {\n    x = [];\n    x.push(props?.items);\n    x.push(props.items);\n    $[0] = props.items;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  t0 = x;\n  const data = t0;\n  let t1;\n  if ($[2] !== props.items) {\n    t1 = [props.items];\n    $[2] = props.items;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  let t2;\n  if ($[4] !== data || $[5] !== t1) {\n    t2 = <ValidateMemoization inputs={t1} output={data} />;\n    $[4] = data;\n    $[5] = t1;\n    $[6] = t2;\n  } else {\n    t2 = $[6];\n  }\n  return t2;\n}\n```\n\n----------------------------------------\n\nTITLE: React Component with Error Handling and Constant Propagation\nDESCRIPTION: Implementation of a React component that demonstrates constant value propagation through try-catch blocks. The component accepts props with a default value but always returns a constant value of 42.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-try-immediately-throws-after-constant-propagation.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let x = props.default;\n  const y = 42;\n  try {\n    // note: this constant propagates so that we know\n    // the handler is unreachable\n    return y;\n  } catch (e) {\n    x = e;\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{default: 42}],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: Simple React component function that processes arrays based on input parameters and a FLAG condition. Takes two parameters and returns an array of processed results.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-reassign-to-variable-without-mutable-range.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @debug\nfunction Component(a, b) {\n  let x = [];\n  let y = [];\n  let z = foo(a);\n  if (FLAG) {\n    x = bar(z);\n    y = baz(b);\n  }\n  return [x, y];\n}\n```\n\n----------------------------------------\n\nTITLE: Input Implementation of Conditional Subpath Optimization in React\nDESCRIPTION: Original code showing a function that accesses 'props.a.b' unconditionally and 'props.a' conditionally. This represents the code as written by the developer before the React Compiler processes it.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/subpath-order1.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// When a conditional dependency `props.a` is a subpath of an unconditional\n// dependency `props.a.b`, we can access `props.a` while preserving program\n// semantics (with respect to nullthrows).\n// deps: {`props.a`, `props.a.b`} can further reduce to just `props.a`\n\nimport {identity} from 'shared-runtime';\n\n// ordering of accesses should not matter\nfunction useConditionalSubpath1(props, cond) {\n  const x = {};\n  x.b = props.a.b;\n  if (identity(cond)) {\n    x.a = props.a;\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useConditionalSubpath1,\n  params: [{a: {b: 3}}, false],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Hook to Manage State Immutability in React\nDESCRIPTION: This snippet defines a React functional component named `Foo` which utilizes a custom hook called `useIdentity`. The purpose of this snippet is to manage the internal state of the component while adhering to React's immutability principles. A `count` parameter is accepted, and the snippet highlights the risk of mutating an object that React treats as immutable, evidenced by an error message on line 13, which indicates the mutation of `x.value` is not permitted.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.hook-call-freezes-captured-memberexpr.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableTransitivelyFreezeFunctionExpressions\nimport {mutate, Stringify, useIdentity} from 'shared-runtime';\n\nfunction Foo({count}) {\n  const x = {value: 0};\n  /**\n   * After this custom hook call, it's no longer valid to mutate x.\n   */\n  const cb = useIdentity(() => {\n    x.value++;\n  });\n\n  x.value += count;\n  return <Stringify x={x} cb={cb} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{count: 1}],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with Hoisting Error\nDESCRIPTION: This code demonstrates a React functional component with a hoisting error. The function defines an inner function named 'hasErrors' that also declares a local variable with the same name, which causes a scoping issue when the function is called in the return statement.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-repro-named-function-with-shadowed-local-same-name.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  function hasErrors() {\n    let hasErrors = false;\n    if (props.items == null) {\n      hasErrors = true;\n    }\n    return hasErrors;\n  }\n  return hasErrors();\n}\n```\n\n----------------------------------------\n\nTITLE: Input React Component Function with JSX\nDESCRIPTION: A simple React component function that conditionally renders content based on input parameters. It creates arrays and renders JSX elements with conditional logic.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/overlapping-scopes-shadowing-within-block.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(a, b, c) {\n  let x = [];\n  if (a) {\n    let y = [];\n    if (b) {\n      y.push(c);\n    }\n\n    x.push(<div>{y}</div>);\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Memoization\nDESCRIPTION: Compiler-optimized version of the component that implements memoization using React's compiler runtime. Uses array-based caching to store and compare previous props and computed values.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructure-object-assignment-to-context-var.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { identity } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(4);\n  let x;\n  if ($[0] !== props) {\n    const { x: t0 } = props;\n    x = t0;\n    const foo = () => {\n      x = identity(props.x);\n    };\n\n    foo();\n    $[0] = props;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  let t0;\n  if ($[2] !== x) {\n    t0 = { x };\n    $[2] = x;\n    $[3] = t0;\n  } else {\n    t0 = $[3];\n  }\n  return t0;\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Changes with Browser Extension\nDESCRIPTION: Build and test the React DevTools within a Chrome browser extension.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/CONTRIBUTING.md#2025-04-21_snippet_6\n\nLANGUAGE: sh\nCODE:\n```\ncd <react-repo>\ncd packages/react-devtools-extensions\nyarn build:chrome:local && yarn test:chrome\n```\n\n----------------------------------------\n\nTITLE: Component Manipulation with Cached Values in React JavaScript\nDESCRIPTION: This code snippet enhances a component function by caching its previous state and inputs using an array. It utilizes a custom React compiler runtime import and handles object mutation based on the comparison of incoming parameters with cached values. Dependencies include `mutate` from `shared-runtime` and `_c` from 'react/compiler-runtime'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-alias-captured-mutate-iife.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nconst { mutate } = require(\"shared-runtime\");\n\nfunction component(foo, bar) {\n  const $ = _c(3);\n  let y;\n  if ($[0] !== bar || $[1] !== foo) {\n    const x = { foo };\n    y = { bar };\n\n    const a = { y };\n    const b = x;\n    a.x = b;\n\n    mutate(y);\n    $[0] = bar;\n    $[1] = foo;\n    $[2] = y;\n  } else {\n    y = $[2];\n  }\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: [\"foo\", \"bar\"],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Optimization\nDESCRIPTION: The compiled version of the component showing React's compiler optimizations including memoization and state tracking using the compiler runtime.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/alias-computed-load.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction component(a) {\n  const $ = _c(2);\n  let x;\n  if ($[0] !== a) {\n    x = { a };\n    const y = {};\n\n    y.x = x.a;\n    mutate(y);\n    $[0] = a;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Running the React Attribute Behavior Fixture\nDESCRIPTION: Command to build React in UMD development mode and run the attribute behavior fixture. This allows developers to test and compare attribute handling between different React versions.\nSOURCE: https://github.com/facebook/react/blob/main/fixtures/attribute-behavior/README.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nyarn build --type=UMD_DEV react/index,react-dom && cd fixtures/attribute-behavior && yarn install && yarn dev\n```\n\n----------------------------------------\n\nTITLE: Defining Original Function with Object Destructuring in JavaScript\nDESCRIPTION: This snippet defines a function 'foo' that uses object destructuring to extract a value. It also exports a FIXTURE_ENTRYPOINT object containing the function and its metadata.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructure-string-literal-property-key.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo() {\n  const {data: t} = {data: 1};\n  return t;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization Optimizations\nDESCRIPTION: This is the compiler-optimized version of the React component. The React compiler has added memoization logic using an array cache to store dependent values (a and props.c) and the resulting array b, preventing unnecessary recalculations on re-renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/escape-analysis-non-escaping-interleaved-primitive-dependency.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(3);\n\n  const a = props.a + props.b;\n  let b;\n  if ($[0] !== a || $[1] !== props.c) {\n    b = [];\n    const c = {};\n    c.a = a;\n    b.push(props.c);\n    $[0] = a;\n    $[1] = props.c;\n    $[2] = b;\n  } else {\n    b = $[2];\n  }\n  return b;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Invalid Conditional useState Hook in React\nDESCRIPTION: This code snippet demonstrates incorrect usage of the `useState` hook. The `useState` hook is called inside a conditional statement (`if (a) return;`), which violates the Rules of Hooks.  Hooks must always be called in the same order in every component render to maintain internal state correctly.  This conditional call can lead to inconsistent state management and is therefore flagged as an error by React's linting rules.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-rules-of-hooks-f3d6c5e9c83d.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Expected to fail\n\n// Invalid because it's dangerous and might not warn otherwise.\n// This *must* be invalid.\nfunction useHook() {\n  if (b) {\n    console.log('true');\n  } else {\n    console.log('false');\n  }\n  if (a) return;\n  useState();\n}\n\n```\n\n----------------------------------------\n\nTITLE: Test Fixture Configuration for React Hook\nDESCRIPTION: Configuration object defining test parameters for the useFoo hook. Includes initial parameters and a sequence of render states to test various conditions including null inputs that would cause runtime errors.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-poisoned/break-poisons-outer-scope.expect.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ input: { a: { b: 2 } }, cond: false }],\n  sequentialRenders: [\n    { input: { a: { b: 2 } }, cond: false },\n    // preserve nullthrows\n    { input: null, cond: false },\n    { input: null, cond: true },\n    { input: {}, cond: false },\n    { input: { a: { b: null } }, cond: false },\n    { input: { a: null }, cond: false },\n    { input: { a: { b: 3 } }, cond: false },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Running React View Transition test in production mode\nDESCRIPTION: Command to start the View Transition test in production mode with pre-built static resources and server-side rendering without hot reloading.\nSOURCE: https://github.com/facebook/react/blob/main/fixtures/view-transition/README.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nyarn start:prod\n```\n\n----------------------------------------\n\nTITLE: Compiler-Optimized React Component\nDESCRIPTION: The compiler-optimized version of the component that implements memoization using React's compiler runtime. It caches the computed array using a Symbol-based sentinel value to avoid recalculation on subsequent renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-of-simple.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component() {\n  const $ = _c(1);\n  let x;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    x = [];\n    const items = [0, 1, 2];\n    for (const ii of items) {\n      x.push(ii * 2);\n    }\n    $[0] = x;\n  } else {\n    x = $[0];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a Reactive Component with Memoization - JavaScript\nDESCRIPTION: This snippet demonstrates a more complex version of the 'Component' function that integrates memoization using 'react/compiler-runtime'. It processes props in a similar manner but includes additional logic to determine memoized output. Parameters include 'props' with 'cond' and the output is the memoized array based on the reactive state of 'x'. This version is crucial for performance in larger applications.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-from-interleaved-reactivity-for-update.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(1);\n\n  const a = [];\n  const b = [];\n  b.push(props.cond);\n  a.push(10);\n\n  const c = [a];\n\n  let x;\n  for (let i = 0; i < 10; i = i + c[0][0], i) {\n    x = 1;\n  }\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = [x];\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ cond: true }],\n};\n```\n\n----------------------------------------\n\nTITLE: Running React Async Demo from NPM Version\nDESCRIPTION: Instructions for installing dependencies and running the time-slicing demo using the npm version. This involves changing to the fixture directory, installing dependencies with yarn, and starting the application.\nSOURCE: https://github.com/facebook/react/blob/main/fixtures/concurrent/time-slicing/README.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n# 1: Install fixture dependencies\ncd fixtures/unstable-async/time-slicing/\nyarn\n\n# 2: Run the app\nyarn start\n```\n\n----------------------------------------\n\nTITLE: Invalid Conditional Hook Usage in React Component\nDESCRIPTION: Example of incorrect React Hook implementation where useHook() is called after a conditional return statement. This violates React's Rules of Hooks which require hooks to be called in the same order on every render and not within conditions.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-hook-after-early-return.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  if (props.cond) {\n    return null;\n  }\n  return useHook();\n}\n```\n\nLANGUAGE: plaintext\nCODE:\n```\n  3 |     return null;\n  4 |   }\n> 5 |   return useHook();\n    |          ^^^^^^^ InvalidReact: Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning) (5:5)\n  6 | }\n  7 |\n\n```\n\n----------------------------------------\n\nTITLE: Defining Conditional Function with Callback in JavaScript\nDESCRIPTION: This snippet illustrates how to define a normal JavaScript function that includes a conditional check. If a specific condition is met, it executes another function. It can be used as a basic example of control flow in function calls.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-e5dd6caf4084.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Valid because functions can call functions.\nfunction normalFunctionWithConditionalFunction() {\n  if (cond) {\n    doSomething();\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Original React Component with Array Push Operations\nDESCRIPTION: Simple React component that creates an array and pushes objects into it, including values derived from props. Shows basic array mutation pattern.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-push-effect.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// arrayInstance.push should have the following effects:\\n//  - read on all args (rest parameter)\\n//  - mutate on receiver\\nfunction Component(props) {\\n  const x = foo(props.x);\\n  const y = {y: props.y};\\n  const arr = [];\\n  arr.push({});\\n  arr.push(x, y);\\n  return arr;\\n}\n```\n\n----------------------------------------\n\nTITLE: Building the Extension Using Node.js\nDESCRIPTION: This snippet describes the command used to build the Microsoft Edge extension from its source code. Required dependencies include Node.js and a proper environment setup for building JavaScript projects.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools-extensions/edge/README.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnode build\n```\n\n----------------------------------------\n\nTITLE: Invalid Conditional Hook Usage in React\nDESCRIPTION: This code snippet demonstrates the incorrect usage of a React Hook (useConditionalHook) within a conditional statement.  React Hooks must be called unconditionally, in the same order, on every render. Calling a hook conditionally violates this rule and can lead to unexpected behavior and errors during runtime.  The 'cond' variable is assumed to be defined elsewhere and controls whether the hook is called.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-rules-of-hooks-ea7c2fb545a9.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Expected to fail\n\n// Invalid because it's dangerous and might not warn otherwise.\n// This *must* be invalid.\nfunction useHookWithConditionalHook() {\n  if (cond) {\n    useConditionalHook();\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: React Component with Array Destructuring Default Value\nDESCRIPTION: Demonstrates array destructuring in a React component with a default value of 42. Takes props.value array and assigns the first element to x with a default value.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-default-at-explicit-null.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  // destructure slot index has an explicit null in the input, should return null (not the default)\n  const [x = 42] = props.value;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: [null]}],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimizing Component with Compiler Runtime - React JavaScript\nDESCRIPTION: In this more optimized version, the 'Component' function utilizes 'react/compiler-runtime' to memoize and efficiently track changes in props and items across re-renders. It allows for reduced computational overhead, particularly beneficial for frequently updated React components. Dependencies include the 'react/compiler-runtime' library. Initial parameters involve an object with a nested 'id' property, ensuring component utility consistency.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-map-captures-receiver-noAlias.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(6);\n  let t0;\n  if ($[0] !== props.a) {\n    t0 = { a: props.a };\n    $[0] = props.a;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const item = t0;\n  let t1;\n  if ($[2] !== item) {\n    t1 = [item];\n    $[2] = item;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  const items = t1;\n  let t2;\n  if ($[4] !== items) {\n    t2 = items.map(_temp);\n    $[4] = items;\n    $[5] = t2;\n  } else {\n    t2 = $[5];\n  }\n  const mapped = t2;\n  return mapped;\n}\nfunction _temp(item_0) {\n  return item_0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ a: { id: 42 } }],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: React Hook with useRef and useSpecialEffect\nDESCRIPTION: This React hook, `useFoo`, takes a `cond` prop and conditionally assigns either `ref.current` or the result of `makeObject()` to `derived`. It then calls `useSpecialEffect` with a callback that logs `derived` and specifies `derived` as a dependency. The compiler reports an error indicating that it cannot infer the dependencies of the effect, potentially breaking the build.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/bailout-retry/error.todo-infer-deps-on-retry.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @inferEffectDependencies @panicThreshold(none)\nimport {useRef} from 'react';\nimport {useSpecialEffect} from 'shared-runtime';\n\n/**\n * The retry pipeline disables memoization features, which means we need to\n * provide an alternate implementation of effect dependencies which does not\n * rely on memoization.\n */\nfunction useFoo({cond}) {\n  const ref = useRef();\n  const derived = cond ? ref.current : makeObject();\n  useSpecialEffect(() => {\n    log(derived);\n  }, [derived]);\n  return ref;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation with External Function Call\nDESCRIPTION: A simple React component that creates a div element with style properties derived from props, includes an array child, and calls an external shallowCopy function. The component is exported through a FIXTURE_ENTRYPOINT object.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/createElement-freeze.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport React from 'react';\nimport {shallowCopy} from 'shared-runtime';\n\nfunction Component(props) {\n  const childProps = {style: {width: props.width}};\n  const element = React.createElement('div', childProps, ['hello world']);\n  shallowCopy(childProps); // function that in theory could mutate, we assume not bc createElement freezes\n  return element;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Illustrating JavaScript Hoisting without Local Variable Shadowing\nDESCRIPTION: This code snippet simplifies the example by removing the local `x` declaration in the `if` block, using the `print` function from `shared-runtime` module to illustrate hoisting. The `hoisting` function prints `1` if `cond` is true, otherwise prints `2`. The snippet is dependent on the shared-runtime for the print functionality. It highlights the absence of variable re-declaration's impact, showcasing hoisting effect clearly with each scenario.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-nested-block-statements.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { print } from \"shared-runtime\";\n\nfunction hoisting(cond) {\n  if (cond) {\n    print(1);\n  }\n\n  print(2);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: hoisting,\n  params: [false],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component Function with JSX\nDESCRIPTION: The original function creates a JSX element through a nested function and returns it. It uses a global variable GLOBAL_IS_X that is captured in the component closure.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/const-propagation-into-function-expression-global.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo() {\n  const isX = GLOBAL_IS_X;\n  const getJSX = () => {\n    return <Child x={isX}></Child>;\n  };\n  const result = getJSX();\n  return result;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Simple Input Handler in JavaScript\nDESCRIPTION: This snippet defines a basic React component that takes input from props and stores it in an array. The component returns the first item of the array after adding the input value.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactivity-via-aliased-mutation-array.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const x = [];\n  const y = x;\n  y.push(props.input);\n\n  return [x[0]];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  sequentialRenders: [\n    {input: 42},\n    {input: 42},\n    {input: 'sathya'},\n    {input: 'sathya'},\n    {input: 42},\n    {input: 'sathya'},\n    {input: 42},\n    {input: 'sathya'},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component with Memo\nDESCRIPTION: Source React component implementing memoization with 'use memo' directive, taking props and rendering a div element.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/use-memo-simple.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  'use memo';\n  let x = [props.foo];\n  return <div x={x}>\"foo\"</div>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{foo: 1}],\n  isComponent: true,\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with FBT Internationalization\nDESCRIPTION: This snippet shows the compiled output of the React component using FBT. It demonstrates how FBT translates the internationalized strings and optimizes the component for performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbtparam-with-jsx-element-content.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport fbt from \"fbt\";\n\nfunction Component(t0) {\n  const $ = _c(4);\n  const { name, data, icon } = t0;\n  let t1;\n  if ($[0] !== data || $[1] !== icon || $[2] !== name) {\n    t1 = (\n      <Text type=\"body4\">\n        {fbt._(\n          \"{item author}{icon}{=m2}\",\n          [\n            fbt._param(\n              \"item author\",\n\n              <Text type=\"h4\">{name}</Text>,\n            ),\n            fbt._param(\n              \"icon\",\n\n              icon,\n            ),\n            fbt._implicitParam(\n              \"=m2\",\n              <Text type=\"h4\">\n                {fbt._(\"{item details}\", [fbt._param(\"item details\", data)], {\n                  hk: \"4jLfVq\",\n                })}\n              </Text>,\n            ),\n          ],\n          { hk: \"2HLm2j\" },\n        )}\n      </Text>\n    );\n    $[0] = data;\n    $[1] = icon;\n    $[2] = name;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  return t1;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining React Component Function with Object Creation and Method Call\nDESCRIPTION: This snippet shows the original React component function 'foo' that creates objects, renders them in JSX, and performs a method call. It demonstrates the use of constants and JSX syntax within a function component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/method-call-computed.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(a, b, c) {\n  // Construct and freeze x, y\n  const x = makeObject(a);\n  const y = makeObject(a);\n  <div>\n    {x}\n    {y}\n  </div>;\n\n  // z should depend on `x`, `y.method`, and `b`\n  const z = x[y.method](b);\n  return z;\n}\n```\n\n----------------------------------------\n\nTITLE: Custom configuration with flat config format\nDESCRIPTION: Advanced setup using flat config (eslint.config.js) with manual configuration of individual rules for finer control.\nSOURCE: https://github.com/facebook/react/blob/main/packages/eslint-plugin-react-hooks/README.md#2025-04-21_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as reactHooks from 'eslint-plugin-react-hooks';\n\nexport default [\n  {\n    files: ['**/*.{js,jsx}'],\n    plugins: { 'react-hooks': reactHooks },\n    // ...\n    rules: {\n      'react-hooks/rules-of-hooks': 'error',\n      'react-hooks/exhaustive-deps': 'warn',\n    }\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: Defining Component with Conditional Dependencies (Input)\nDESCRIPTION: This code defines a React component `useOnlyConditionalDependencies` that conditionally reads properties from the `props.a` object based on the `cond` prop. The component returns a new object `x` containing the conditionally read properties. It imports the `identity` function from `shared-runtime` and uses it as part of the conditional logic.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/no-uncond.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n\"// When an object's properties are only read conditionally, we should\\n\\nimport {identity} from 'shared-runtime';\\n\\n// track the base object as a dependency.\\nfunction useOnlyConditionalDependencies({props, cond}) {\\n  const x = {};\\n  if (identity(cond)) {\\n    x.b = props.a.b;\\n    x.c = props.a.b.c;\\n  }\\n  return x;\\n}\\n\\nexport const FIXTURE_ENTRYPOINT = {\\n  fn: useOnlyConditionalDependencies,\\n  params: [{props: {a: {b: 2}}, cond: true}],\\n  sequentialRenders: [\\n    {props: {a: {b: 2}}, cond: true},\\n    {props: null, cond: false},\\n    // check we preserve nullthrows\\n    {props: {a: {b: {c: undefined}}}, cond: true},\\n    {props: {a: {b: undefined}}, cond: true},\\n    {props: {a: {b: {c: undefined}}}, cond: true},\\n    {props: undefined, cond: true},\\n  ],\\n};\\n\"\n```\n\n----------------------------------------\n\nTITLE: Original React Component with Switch Statement\nDESCRIPTION: Original React component function that processes props through a switch statement, manipulates arrays, and renders nested components. The component demonstrates conditional branching and child component rendering based on props.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/switch-non-final-default.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let x = [];\n  let y;\n  switch (props.p0) {\n    case 1: {\n      break;\n    }\n    case true: {\n      x.push(props.p2);\n      y = [];\n    }\n    default: {\n      break;\n    }\n    case false: {\n      y = x;\n      break;\n    }\n  }\n  const child = <Component data={x} />;\n  y.push(props.p4);\n  return <Component data={y}>{child}</Component>;\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization Strategy\nDESCRIPTION: The React compiler's output that transforms the original component to include memoization. It adds a caching mechanism that stores and reuses previously computed values when inputs haven't changed, optimizing re-renders by avoiding unnecessary object creation and JSX evaluation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/mutation-within-jsx.expect.md#2025-04-22_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport {\n  Stringify,\n  makeObject_Primitives,\n  mutateAndReturn,\n} from \"shared-runtime\";\n\n/**\n * In this example, the `<Stringify ... />` JSX block mutates then captures obj.\n * As JSX expressions freeze their values, we know that `obj` and `myDiv` cannot\n * be mutated past this.\n * This set of mutable range + scopes is an edge case because the JSX expression\n * references values in two scopes.\n * - (freeze) the result of `mutateAndReturn`\n *   this is a mutable value with a mutable range starting at `makeObject()`\n * - (mutate) the lvalue storing the result of `<Stringify .../>`\n *   this is a immutable value and so gets assigned a different scope\n *\n * obj@0 = makeObj();                         scope@0\n * if (cond) {                               |\n *   $1@0 = mutate(obj@0);                   |\n *   myDiv@1 = JSX $1@0          <- scope@1  |\n * }                                         \n *\n * Coincidentally, the range of `obj` is extended by alignScopesToBlocks to *past*\n * the end of the JSX instruction. As we currently alias identifier mutableRanges to\n * scope ranges, this `freeze` reference is perceived as occurring during the mutable\n * range of `obj` (even though it is after the last mutating reference).\n *\n * This case is technically safe as `myDiv` correctly takes `obj` as a dependency. As\n * a result, developers can never observe myDiv can aliasing a different value generation\n * than `obj` (e.g. the invariant `myDiv.props.value === obj` always holds).\n */\nfunction useFoo(t0) {\n  const $ = _c(3);\n  const { data } = t0;\n  let obj;\n  let myDiv = null;\n  if (data.cond) {\n    if ($[0] !== data.cond1) {\n      obj = makeObject_Primitives();\n      if (data.cond1) {\n        myDiv = <Stringify value={mutateAndReturn(obj)} />;\n      }\n      $[0] = data.cond1;\n      $[1] = obj;\n      $[2] = myDiv;\n    } else {\n      obj = $[1];\n      myDiv = $[2];\n    }\n  }\n  return myDiv;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ data: { cond: true, cond1: true } }],\n  sequentialRenders: [\n    { data: { cond: true, cond1: true } },\n    { data: { cond: true, cond1: true } },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Invalid Hook Reference in React Component\nDESCRIPTION: Example of incorrect hook usage where 'useFoo' is referenced directly as a value in a ternary operation instead of being called as a hook function. This violates React's rules of hooks which require hooks to be called at the top level of components.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-hook-as-conditional-test.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const x = props.cond ? (useFoo ? 1 : 2) : 3;\n  return x;\n}\n```\n\nLANGUAGE: plaintext\nCODE:\n```\n  1 | function Component(props) {\n> 2 |   const x = props.cond ? (useFoo ? 1 : 2) : 3;\n    |                           ^^^^^^ InvalidReact: Hooks may not be referenced as normal values, they must be called. See https://react.dev/reference/rules/react-calls-components-and-hooks#never-pass-around-hooks-as-regular-values (2:2)\n  3 |   return x;\n  4 | }\n  5 |\n```\n\n----------------------------------------\n\nTITLE: Implementing Dependency-driven React Component Rendering Logic in JavaScript\nDESCRIPTION: This snippet modifies the 'Component' function to preserve state over re-renders using a dependency list. It conditionally updates a stored array of values based on property changes and efficiently manages state through comparisons. Key dependencies include a '_c' utility from 'react/compiler-runtime'. Expected inputs are property objects, and outputs are arrays reflecting component states, constrained by the 'react/compiler-runtime' assumptions.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/ssa-cascading-eliminated-phis.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enablePropagateDepsInHIR\nfunction Component(props) {\n  const $ = _c(7);\n  let x = 0;\n  let values;\n  if (\n    $[0] !== props.a ||\n    $[1] !== props.b ||\n    $[2] !== props.c ||\n    $[3] !== props.d ||\n    $[4] !== x\n  ) {\n    values = [];\n    const y = props.a || props.b;\n    values.push(y);\n    if (props.c) {\n      x = 1;\n    }\n\n    values.push(x);\n    if (props.d) {\n      x = 2;\n    }\n\n    values.push(x);\n    $[0] = props.a;\n    $[1] = props.b;\n    $[2] = props.c;\n    $[3] = props.d;\n    $[4] = x;\n    $[5] = values;\n    $[6] = x;\n  } else {\n    values = $[5];\n    x = $[6];\n  }\n  return values;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ a: 0, b: 1, c: true, d: true }],\n  sequentialRenders: [\n    { a: 0, b: 1, c: true, d: true },\n    { a: 4, b: 1, c: true, d: true },\n    { a: 4, b: 1, c: false, d: true },\n    { a: 4, b: 1, c: false, d: false },\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Transformed Component with Separate Function Declaration\nDESCRIPTION: Compiled version of the component where the arrow function default is transformed into a separate function declaration _temp. Uses undefined check for parameter assignment.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/default-param-with-empty-callback.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(t0) {\n  const x = t0 === undefined ? _temp : t0;\n  return x;\n}\nfunction _temp() {}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component Definition\nDESCRIPTION: A React component that manipulates arrays based on props and returns a recursive component call. It demonstrates mutation patterns that might require special handling during compilation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reassignment-conditional.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let x = [];\n  x.push(props.p0);\n  let y = x;\n\n  if (props.p1) {\n    x = [];\n  }\n\n  y.push(props.p2);\n\n  return <Component x={x} y={y} />;\n}\n```\n\n----------------------------------------\n\nTITLE: React Compiler Transformed Function with Memoization\nDESCRIPTION: The output JavaScript code after React compiler processing, showing how the function is transformed to use memoization. It employs a cache sentinel symbol to check if the computation has been done before, storing and retrieving the result accordingly.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-property-mutate.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction foo() {\n  const $ = _c(1);\n  let y;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const x = [];\n    y = {};\n    y.x = x;\n    mutate(y);\n    $[0] = y;\n  } else {\n    y = $[0];\n  }\n  return y;\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional Rendering with ReactForgetFeatureFlag in JavaScript\nDESCRIPTION: This snippet conditionally defines the ErrorView component based on the isForgetEnabled_Fixtures flag. If enabled, the component uses a cached result for rendering with checksum verification. The snippet highlights advanced React feature flags and dynamic adjustments in rendering and exporting patterns.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/arrow-function-expr-gating-test.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { isForgetEnabled_Fixtures } from \"ReactForgetFeatureFlag\"; // @gating\nimport { Stringify } from \"shared-runtime\";\nconst ErrorView = isForgetEnabled_Fixtures()\n  ? (t0) => {\n      const $ = _c(2);\n      const { error } = t0;\n      let t1;\n      if ($[0] !== error) {\n        t1 = <Stringify error={error} />;\n        $[0] = error;\n        $[1] = t1;\n      } else {\n        t1 = $[1];\n      }\n      return t1;\n    }\n  : ({ error, _retry }) => <Stringify error={error}></Stringify>;\n\nexport default ErrorView;\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: eval(\"ErrorView\"),\n  params: [{}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with FBT Optimizations\nDESCRIPTION: This snippet shows the compiled version of the React component with FBT optimizations. It includes memoization for performance improvements and uses the FBT runtime functions.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-unmerged-fbt-call-merge-overlapping-reactive-scopes.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport fbt from \"fbt\";\nimport { Stringify } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(3);\n  let t0;\n  if ($[0] !== props.cond || $[1] !== props.value.length) {\n    const label = fbt._(\n      { \"*\": \"{number} bars\", _1: \"1 bar\" },\n      [fbt._plural(props.value.length, \"number\")],\n      { hk: \"4mUen7\" },\n    );\n\n    t0 = props.cond ? (\n      <Stringify\n        description={fbt._(\"Text here\", null, { hk: \"21YpZs\" })}\n        label={label.toString()}\n      />\n    ) : null;\n    $[0] = props.cond;\n    $[1] = props.value.length;\n    $[2] = t0;\n  } else {\n    t0 = $[2];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ cond: true, value: [0, 1, 2] }],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component Definition\nDESCRIPTION: Defines a React component named `Component` that receives `props` as input.  It initializes a variable `x` and defines an `onChange` handler that may mutate `x`. The component conditionally renders `x` and returns a `Foo` component with `x` as the `value` prop. The `onChange` function is called.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/todo-function-expression-captures-value-later-frozen.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let x = {};\n  // onChange should be inferred as immutable, because the value\n  // it captures (`x`) is frozen by the time the function is referenced\n  const onChange = e => {\n    maybeMutate(x, e.target.value);\n  };\n  if (props.cond) {\n    <div>{x}</div>;\n  }\n  // ideally this call would be outside the memoization block for `x`\n  onChange();\n  return <Foo value={x} />;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Transforming a Function with React Compiler\nDESCRIPTION: This code transforms the original JavaScript function `foo` using `react/compiler-runtime`.  It introduces a `_c` function (aliased as `_c`) to potentially optimize the function's execution. The transformed function uses memoization to store the result of `a.b` for potential reuse, improving performance if `a.b` doesn't change frequently.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/simple-scope.expect.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction foo(a) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== a.b) {\n    t0 = [a.b];\n    $[0] = a.b;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const x = t0;\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: React Component with Compilation Inference in JavaScript\nDESCRIPTION: This snippet imports a specific module from react/compiler-runtime and defines a React component Foo that uses compilation inference to manage component references and preserve component state. The function returns a div element, and changes are tracked with a cache mechanism. FIXTURE_ENTRYPOINT exports the component. It requires the react/compiler-runtime package.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-functions-component-with-ref-arg.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @compilationMode(infer)\n\nfunction Foo(t0, ref) {\n  const $ = _c(2);\n  let t1;\n  if ($[0] !== ref) {\n    t1 = <div ref={ref} />;\n    $[0] = ref;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiler-Optimized Output Implementation\nDESCRIPTION: Optimized version with React compiler runtime integration, implementing memoization using array-based caching for improved performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/assignment-expression-nested-path.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction g(props) {\n  const $ = _c(2);\n  let a;\n  if ($[0] !== props.c) {\n    a = { b: { c: props.c } };\n    a.b.c = a.b.c + 1;\n    a.b.c = a.b.c * 2;\n    $[0] = props.c;\n    $[1] = a;\n  } else {\n    a = $[1];\n  }\n  return a;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: g,\n  params: [{ c: 2 }],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized Snippet: React Compiler Runtime Memoization\nDESCRIPTION: Enhanced version of useFoo hook using React compiler runtime for performance optimization and memoized state tracking\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-renaming-via-destructuring-with-mutation.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { mutate } from \"shared-runtime\";\n\nfunction useFoo(props) {\n  const $ = _c(4);\n  let x;\n  if ($[0] !== props.bar || $[1] !== props.cond || $[2] !== props.foo) {\n    ({ x } = { x: [] });\n    x.push(props.bar);\n    if (props.cond) {\n      ({ x } = { x: [] });\n      x.push(props.foo);\n    }\n\n    mutate(x);\n    $[0] = props.bar;\n    $[1] = props.cond;\n    $[2] = props.foo;\n    $[3] = x;\n  } else {\n    x = $[3];\n  }\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing fire in React Component using JavaScript\nDESCRIPTION: This code defines a React functional component that uses the 'fire' function to log props. It incorporates useEffect but causes an error due to invalid argument spread for the fire function.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/error.invalid-spread.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableFire\nimport {fire} from 'react';\n\nfunction Component(props) {\n  const foo = () => {\n    console.log(props);\n  };\n  useEffect(() => {\n    fire(...foo);\n  });\n\n  return null;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Using React Hook to Mutate State in JavaScript\nDESCRIPTION: This snippet demonstrates the use of a React-like hook to handle state changes with mutation capabilities. It uses the `mutate` function from 'shared-runtime' to manage changes to an array based on the properties `bar`, `foo`, and `cond`. The function `useFoo` returns the mutated state, and the `FIXTURE_ENTRYPOINT` object sets up test parameters for sequential rendering.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-renaming-ternary-with-mutation.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {mutate} from 'shared-runtime';\n\nfunction useFoo(props) {\n  let x = [];\n  x.push(props.bar);\n  props.cond ? ((x = {}), (x = []), x.push(props.foo)) : null;\n  mutate(x);\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{cond: false, foo: 2, bar: 55}],\n  sequentialRenders: [\n    {cond: false, foo: 2, bar: 55},\n    {cond: false, foo: 3, bar: 55},\n    {cond: true, foo: 3, bar: 55},\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Building and Running the React VectorWidget Example\nDESCRIPTION: Commands to set up dependencies and build the React VectorWidget example project. Run these commands in the project directory, then open index.html in a browser to view the example.\nSOURCE: https://github.com/facebook/react/blob/main/fixtures/art/README.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn\nyarn build\n```\n\n----------------------------------------\n\nTITLE: React Rendering Error Message\nDESCRIPTION: This snippet captures the rendering error that arises when attempting to access the `current` property of a ref inappropriately. The error message indicates the exact location in the code where the violation occurs, referencing the React documentation for further clarification.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-pass-ref-to-function.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n  2 | function Component(props) {\n  3 |   const ref = useRef(null);\n> 4 |   const x = foo(ref);\n    |                 ^^^ InvalidReact: Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef) (4:4)\n  5 |   return x.current;\n  6 | }\n  7 |\n```\n\n----------------------------------------\n\nTITLE: Refreshing dependencies after React rebuild\nDESCRIPTION: Command to reinstall dependencies after making changes to React and rebuilding it.\nSOURCE: https://github.com/facebook/react/blob/main/fixtures/view-transition/README.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nyarn\n```\n\n----------------------------------------\n\nTITLE: Flow-Typed React Component Input\nDESCRIPTION: Original React component implementation using Flow type annotations. Defines a Component that takes props with an id number and returns a value from an array construction.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-annotations/type-annotation-var-array_.flow.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @flow @enableUseTypeAnnotations\nimport {identity} from 'shared-runtime';\n\nfunction Component(props: {id: number}) {\n  const x: Array<number> = makeArray(props.id);\n  const y = x.at(0);\n  return y;\n}\n\nfunction makeArray<T>(x: T): Array<T> {\n  return [x];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{id: 42}],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: Original implementation of a React component that performs a cumulative sum operation starting from an initial value and returns the result in an array. Includes a test fixture for component execution.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-with-assignment-as-update.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let x = props.init;\n  for (let i = 0; i < 100; i = i + 1) {\n    x += i;\n  }\n  return [x];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{init: 0}],\n};\n```\n\n----------------------------------------\n\nTITLE: Enhanced Component Function with Conditional State Mutation - JavaScript\nDESCRIPTION: This snippet showcases an enhanced version of the 'component' function that includes conditional invocation of state mutation based on previous state. It utilizes the mutable state from a cache-like structure and mutates only if the current parameters differ from the last. This structure improves efficiency. The expected input parameters are 'foo' and 'bar', while the output is a mutated object.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-fun-alias-captured-mutate-arr-2-iife.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nconst { mutate } = require(\"shared-runtime\");\n\nfunction component(foo, bar) {\n  const $ = _c(3);\n  let x;\n  if ($[0] !== bar || $[1] !== foo) {\n    x = { foo };\n    const y = { bar };\n\n    const a = [y];\n    const b = x;\n    a.x = b;\n\n    mutate(y);\n    $[0] = bar;\n    $[1] = foo;\n    $[2] = x;\n  } else {\n    x = $[2];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: [\"foo\", \"bar\"],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component Implementation\nDESCRIPTION: The optimized version of the component that directly assigns the prop value to the variable and returns it. Unnecessary initialization and increment operations have been removed.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/dce-unused-postfix-update.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let i;\n\n  i = props.i;\n  return i;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ i: 42 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Input React Component with Array Destructuring\nDESCRIPTION: Original React component using array destructuring with a conditional expression as default value. Props receive an array 'y' which is destructured with a default ternary expression.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-with-conditional-as-default-value.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const [x = true ? 1 : 0] = props.y;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{y: []}],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Triple Nested While Loops with Static Return in React Test Fixture\nDESCRIPTION: This code defines a JavaScript function 'foo' with triple nested while loops without any internal operations. The function always returns 0 and is exported as a test fixture entrypoint with a 'TodoAdd' component parameter.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-nested-loops-no-reassign.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// @xonly\nfunction foo(a, b, c) {\n  while (a) {\n    while (b) {\n      while (c) {}\n    }\n  }\n  return 0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Memoization in JavaScript\nDESCRIPTION: This snippet shows an optimized version of the 'Component' function using React's compiler runtime. It implements memoization to cache the rendered output and avoid unnecessary re-renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/constructor.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Foo() {}\n\nfunction Component(props) {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const a = [];\n    const b = {};\n    new Foo(a, b);\n    new Foo(b);\n    t0 = <div a={a} b={b} />;\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Conditional Rendering\nDESCRIPTION: This snippet defines a React component that conditionally renders a 'Stringify' component based on the 'props' value. It includes a function that accesses nested properties of 'props'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/functionexpr-conditional-access-2.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableTreatFunctionDepsAsConditional\nimport {Stringify} from 'shared-runtime';\n\nfunction Component({props}) {\n  const f = () => props.a.b;\n\n  return <Stringify f={props == null ? () => {} : f} />;\n}\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{props: null}],\n};\n```\n\n----------------------------------------\n\nTITLE: React Compiler-Optimized Version with Memoization\nDESCRIPTION: The compiler-transformed version of the hook, showing how React's compiler adds memoization. It uses a reactive scope with dependencies on 'other' and 'props' and only recalculates when those values change.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/cfg-switch-missing-case.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // props.a.b should NOT be added as a unconditional dependency to the reactive\n// scope that produces x if it is not accessed in every path\n\nimport { identity } from \"shared-runtime\";\n\nfunction useCondDepInSwitchMissingCase(props, other) {\n  const $ = _c(3);\n  let x;\n  if ($[0] !== other || $[1] !== props) {\n    x = {};\n    bb0: switch (identity(other)) {\n      case 1: {\n        x.a = props.a.b;\n        break bb0;\n      }\n      case 2: {\n        x.b = 42;\n        break bb0;\n      }\n      default: {\n        x.c = props.a.b;\n      }\n    }\n    $[0] = other;\n    $[1] = props;\n    $[2] = x;\n  } else {\n    x = $[2];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useCondDepInSwitchMissingCase,\n  params: [{ a: { b: 2 } }, 2],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a Function with Simplified Object Manipulation in JavaScript\nDESCRIPTION: This JavaScript snippet defines a function named 'foo' that takes three arguments (a, b, c). It uses spread syntax to create a new object 'y' based on nested properties of 'b', modifies 'y', and recursively calls itself with a nested property of 'a'. This version omits the const x = a.x and [a.b.c] lines from the original.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-properties.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(a, b, c) {\n  const y = { ...b.c.d };\n  y.z = c.d.e;\n  foo(a.b.c);\n}\n```\n\n----------------------------------------\n\nTITLE: React Component Function with Optimization in JavaScript\nDESCRIPTION: This snippet enhances the 'foo' function with performance optimizations using 'react/compiler-runtime'. It keeps track of previous property values to reduce unnecessary operations. The snippet relies on React's runtime performance optimizations, expecting 'props' and reacting to changes effectively. The function's input is 'props' and it outputs the array 'x', managed by optimization checks.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-renaming-via-destructuring.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction foo(props) {\n  const $ = _c(4);\n  let x;\n  if ($[0] !== props.bar) {\n    ({ x } = { x: [] });\n    x.push(props.bar);\n    $[0] = props.bar;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  if (props.cond) {\n    if ($[2] !== props.foo) {\n      ({ x } = { x: [] });\n      x.push(props.foo);\n      $[2] = props.foo;\n      $[3] = x;\n    } else {\n      x = $[3];\n    }\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Sequence Component Transformation with React Compiler Runtime\nDESCRIPTION: Transforms the `sequence` function component using React's compiler runtime for memoization. It imports `_c` from `react/compiler-runtime` and utilizes it to cache the results of expressions using `Symbol.for(\"react.memo_cache_sentinel\")`. This optimization aims to avoid redundant computations during component rendering, potentially improving performance by storing and reusing the previously computed values.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/sequence-expression.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction sequence(props) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = (Math.max(1, 2), foo());\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  let x = t0;\n  if ($[1] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    while ((foo(), true)) {\n      x = (foo(), 2);\n    }\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  return x;\n}\n\nfunction foo() {}\n\n```\n\n----------------------------------------\n\nTITLE: Defining a React Component with Fire Usage - JavaScript\nDESCRIPTION: This snippet defines a React functional component that imports the 'fire' function and logs a property to the console. It demonstrates error handling with try-finally and attempts to invoke the 'fire' function within a useEffect hook, noting potential limitations regarding React's compiler transformation of the 'fire' function.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/bailout-retry/error.todo-syntax.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableFire @panicThreshold(none)\nimport {fire} from 'react';\n\n/**\n * Note that a react compiler-based transform still has limitations on JS syntax.\n * In practice, we expect to surface these as actionable errors to the user, in\n * the same way that invalid `fire` calls error.\n */\nfunction Component({prop1}) {\n  const foo = () => {\n    try {\n      console.log(prop1);\n    } finally {\n      console.log('jbrown215');\n    }\n  };\n  useEffect(() => {\n    fire(foo());\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: React Component Input\nDESCRIPTION: This code defines a React component `useFoo` that takes `props` as input and calls a `foo` function with `props.x`. It also declares a variable `makeReadOnly` that conflicts with a later import.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/emit-freeze-conflicting-imports.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableEmitFreeze @instrumentForget\n\nlet makeReadOnly = 'conflicting identifier';\nfunction useFoo(props) {\n  return foo(props.x);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component\nDESCRIPTION: This snippet shows the compiled output of the React component.  It imports `_c` from `react/compiler-runtime` which is presumably a compiler-generated function used for memoization. The compiled component caches the `div` element, using `Symbol.for(\"react.memo_cache_sentinel\")` as a sentinel value to check if the element is already cached.  The purpose is to avoid re-rendering the same element unnecessarily.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-function-assignment.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @compilationMode(infer)\nconst Component = (props) => {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = <div />;\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: The original component function that creates and mutates objects based on an input parameter.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/alias-computed-load.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component(a) {\n  let x = {a};\n  let y = {};\n\n  y.x = x['a'];\n  mutate(y);\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: React Component with Compiler Runtime Optimization (Code)\nDESCRIPTION: This is the compiled version of the React component, utilizing React's compiler runtime (`react/compiler-runtime`). It memoizes the result of the function calls and object creation to prevent re-computation if the props haven't changed. This optimization improves performance by avoiding unnecessary calculations and re-renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-call.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== props) {\n    const x = makeOptionalFunction(props);\n    const y = makeObject(props);\n    t0 = x?.(y.a, props.a, foo(y.b), bar(props.b));\n    $[0] = props;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const z = t0;\n  return z;\n}\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: Basic React component function that creates an object with a property and returns a closure function that logs it.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-variable-in-nested-block.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component(a) {\n  let z = {a};\n  let x = function () {\n    {\n      console.log(z);\n    }\n  };\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Git Checkout for Patch Release\nDESCRIPTION: This command creates a new branch for a patch release, branching off from the previous release tag. This isolates the patch release work from ongoing development. For example, creating branch `16.8.3` from tag `v16.8.2`.\nSOURCE: https://github.com/facebook/react/blob/main/scripts/release/README.md#2025-04-21_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\ngit checkout -b 16.8.3 v16.8.2\n```\n\n----------------------------------------\n\nTITLE: Compiler-Transformed Implementation with Memoization\nDESCRIPTION: The React compiler's transformed version of the useMakeCallback hook with automatic memoization. It uses a cache array to store dependencies (obj.value and setState) and the memoized result to prevent unnecessary re-renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/assume-invoked/jsx-function.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { Stringify } from \"shared-runtime\";\n\nfunction useMakeCallback(t0) {\n  const $ = _c(3);\n  const { obj, setState } = t0;\n  let t1;\n  if ($[0] !== obj.value || $[1] !== setState) {\n    t1 = <Stringify cb={() => setState(obj.value)} shouldInvokeFns={true} />;\n    $[0] = obj.value;\n    $[1] = setState;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  return t1;\n}\n\nconst setState = (arg: number) => {\n  \"use no memo\";\n  return arg;\n};\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useMakeCallback,\n  params: [{ obj: { value: 1 }, setState }],\n  sequentialRenders: [\n    { obj: { value: 1 }, setState },\n    { obj: { value: 2 }, setState },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: React Compiler-Optimized Component with Memoization\nDESCRIPTION: The compiled version of the component that uses React compiler runtime to memoize calculations. It caches the result of 'bar()' when the inputs haven't changed, preventing unnecessary recalculations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/computed-load-primitive-as-dependency.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  const a = foo();\n\n  const t0 = a[props.a] + 1;\n  let t1;\n  if ($[0] !== t0) {\n    t1 = bar(t0);\n    $[0] = t0;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  const b = t1;\n  return b;\n}\n```\n\n----------------------------------------\n\nTITLE: Original React Function with Boolean Logic and Conditional Rendering\nDESCRIPTION: A React function that creates a component with various boolean expressions to be rendered through the Stringify component. The function includes conditionals and boolean operations on different data types.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/constant-propagation-unary.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {Stringify} from 'shared-runtime';\n\nfunction foo() {\n  let _b;\n  const b = true;\n  if (!b) {\n    _b = 'bar';\n  } else {\n    _b = 'baz';\n  }\n\n  return (\n    <Stringify\n      value={{\n        _b,\n        b0: !true,\n        n0: !0,\n        n1: !1,\n        n2: !2,\n        n3: !-1,\n        s0: !'',\n        s1: !'a',\n        s2: !'ab',\n        u: !undefined,\n        n: !null,\n      }}\n    />\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Function Component with Conditional Rendering\nDESCRIPTION: Defines a React function component useFoo that conditionally renders based on input properties. The function handles various conditions including potential null paths, and returns either null or an array of processed values.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-poisoned/reduce-if-nonexhaustive-poisoned-deps1.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {identity} from 'shared-runtime';\n\nfunction useFoo({input, cond, hasAB}) {\n  const x = [];\n  if (cond) {\n    if (!hasAB) {\n      return null;\n    } else {\n      x.push(identity(input.a.b));\n    }\n    x.push(identity(input.a.b));\n  } else {\n    x.push(identity(input.a.b));\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{input: {b: 1}, cond: true, hasAB: false}],\n  sequentialRenders: [\n    {input: {a: {b: 1}}, cond: true, hasAB: true},\n    {input: null, cond: true, hasAB: false},\n    // preserve nullthrows\n    {input: {a: {b: undefined}}, cond: true, hasAB: true},\n    {input: {a: null}, cond: true, hasAB: true},\n    {input: {a: {b: undefined}}, cond: true, hasAB: true},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Hook with Change Variable Codegen\nDESCRIPTION: This snippet shows the optimized version of the 'useFoo' hook. It uses the '_c' function from 'react/compiler-runtime' to implement memoization, improving performance by avoiding unnecessary calls to 'identity'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rename-source-variables.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enableChangeVariableCodegen\nimport { identity } from \"shared-runtime\";\n\nconst $ = \"module_$\";\nconst t0 = \"module_t0\";\nconst c_0 = \"module_c_0\";\nfunction useFoo(props) {\n  const $0 = _c(2);\n  const c_00 = $0[0] !== props.value;\n  let t1;\n  if (c_00) {\n    t1 = identity(props.value);\n    $0[0] = props.value;\n    $0[1] = t1;\n  } else {\n    t1 = $0[1];\n  }\n  const results = t1;\n  console.log($);\n  console.log(t0);\n  console.log(c_0);\n  return results;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ value: 0 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Original JavaScript Function with Nested Conditionals\nDESCRIPTION: A JavaScript function 'foo' that creates an array and conditionally pushes a value based on three parameters. The function returns the array if it has elements, otherwise null.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/extend-scopes-if.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(a, b, c) {\n  let x = [];\n  if (a) {\n    if (b) {\n      if (c) {\n        x.push(0);\n      }\n    }\n  }\n  if (x.length) {\n    return x;\n  }\n  return null;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Function with Memoization for Non-Overlapping Dependencies\nDESCRIPTION: The compiled version of the test function with React compiler-runtime additions. It implements memoization that separately tracks each dependency path (props.a.c.x.y.z, props.a.x.y, and props.b) to avoid unnecessary recalculations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/uncond-nonoverlap-descendant.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // Test that we can track non-overlapping dependencies separately.\n// (not needed for correctness but for dependency granularity)\nfunction TestNonOverlappingDescendantTracked(props) {\n  const $ = _c(4);\n  let x;\n  if ($[0] !== props.a.c.x.y.z || $[1] !== props.a.x.y || $[2] !== props.b) {\n    x = {};\n    x.a = props.a.x.y;\n    x.b = props.b;\n    x.c = props.a.c.x.y.z;\n    $[0] = props.a.c.x.y.z;\n    $[1] = props.a.x.y;\n    $[2] = props.b;\n    $[3] = x;\n  } else {\n    x = $[3];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: TestNonOverlappingDescendantTracked,\n  params: [{ a: { x: {}, c: { x: { y: { z: 3 } } } } }],\n};\n```\n\n----------------------------------------\n\nTITLE: Complex Calculation Implementation in React Test Fixture\nDESCRIPTION: A test fixture implementation that performs multiple arithmetic operations and conditional logging. Exports a function through FIXTURE_ENTRYPOINT with metadata about its usage.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/constant-propagation.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo() {\n  const a = 1;\n  const b = 2;\n  const c = 3;\n  const d = a + b;\n  const e = d * c;\n  const f = e / d;\n  const g = f - e;\n\n  if (g) {\n    console.log('foo');\n  }\n\n  const h = g;\n  const i = h;\n  const j = i;\n  return j;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component Input\nDESCRIPTION: Initial React component definition using Flow types, implementing a Foo component that forwards refs to a Stringify component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/component-syntax-ref-gating.flow.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @flow @gating\nimport {Stringify} from 'shared-runtime';\nimport * as React from 'react';\n\ncomponent Foo(ref: React.RefSetter<Controls>) {\n  return <Stringify ref={ref} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: eval('(...args) => React.createElement(Foo, args)'),\n  params: [{ref: React.createRef()}],\n};\n```\n\n----------------------------------------\n\nTITLE: Memoization Validation with Conditional Rendering - JavaScript\nDESCRIPTION: This code snippet expands on the memoization concept by introducing a conditional setup using the '_c' function from 'react/compiler-runtime'. It checks if the current props have changed and conditionally renders the 'ValidateMemoization' component to ensure any updates in inputs are reflected in outputs, thus preserving the memoization guarantees.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-member-expression-inverted-optionals-parallel-paths.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @validatePreserveExistingMemoizationGuarantees @enableOptionalDependencies\nimport { ValidateMemoization } from \"shared-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  let t0;\n\n  const x$0 = [];\n  x$0.push(props?.a.b?.c.d?.e);\n  x$0.push(props.a?.b.c?.d.e);\n  t0 = x$0;\n  let t1;\n  if ($[0] !== props.a.b.c.d.e) {\n    t1 = <ValidateMemoization inputs={[props.a.b.c.d.e]} output={x} />;\n    $[0] = props.a.b.c.d.e;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional Dependencies with React Compiler in JavaScript\nDESCRIPTION: The 'useFoo' function leverages a caching mechanism provided by the React compiler to efficiently handle state changes. It imports a special hook from 'react/compiler-runtime' and processes the 'screen' parameter to conditionally return specific strings. Dependencies include the identity function from 'shared-runtime' and a compiler hook imported as '_c'. The input is an object containing a 'screen' property, and the function uses cached values to optimize performance. Outputs depend on the state of 'screen.title_text'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/merge-uncond-optional-chain-and-cond.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enablePropagateDepsInHIR\nimport { identity } from \"shared-runtime\";\n\n/**\n * Very contrived text fixture showing that it's technically incorrect to merge\n * a conditional dependency (e.g. dep.path in `cond ? dep.path : ...`) and an\n * unconditionally evaluated optional chain (`dep?.path`).\n *\n *\n * when screen is non-null, useFoo returns { title: null } or \"(not null)\"\n * when screen is null, useFoo throws\n */\nfunction useFoo(t0) {\n  const $ = _c(2);\n  const { screen } = t0;\n  let t1;\n  if ($[0] !== screen) {\n    t1 =\n      screen?.title_text != null\n        ? \"(not null)\"\n        : identity({ title: screen.title_text });\n    $[0] = screen;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ screen: null }],\n  sequentialRenders: [{ screen: { title_bar: undefined } }, { screen: null }],\n};\n```\n\n----------------------------------------\n\nTITLE: Using React Compiler Runtime in Hoisting Function\nDESCRIPTION: This snippet incorporates React's compiler runtime to manage memoization and variable scoping more dynamically by checking for a cache sentinel. It defines a hoisting function that relies on React's internal caching mechanism to optimize performance while maintaining variable isolation. Dependencies: 'react/compiler-runtime'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-nested-const-declaration.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction hoisting() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const qux = () => {\n      let result;\n\n      result = foo();\n      return result;\n    };\n\n    const foo = () => bar + baz;\n\n    const bar = 3;\n    const baz = 2;\n    t0 = qux();\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: hoisting,\n  params: [],\n  isComponent: false,\n};\n\n```\n\n----------------------------------------\n\nTITLE: Invalid Conditional Hook Usage in React Component\nDESCRIPTION: Demonstrates a component that incorrectly uses a Hook within a ternary operator. This pattern violates React's Rules of Hooks by making the Hook call conditional, which is explicitly forbidden.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-rules-of-hooks-b4dcda3d60ed.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Expected to fail\n\n// Invalid because it's dangerous and might not warn otherwise.\n// This *must* be invalid.\nfunction ComponentWithTernaryHook() {\n  cond ? useTernaryHook() : null;\n}\n```\n\nLANGUAGE: plaintext\nCODE:\n```\n  4 | // This *must* be invalid.\n  5 | function ComponentWithTernaryHook() {\n> 6 |   cond ? useTernaryHook() : null;\n    |          ^^^^^^^^^^^^^^ InvalidReact: Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning) (6:6)\n  7 | }\n  8 |\n\n```\n\n----------------------------------------\n\nTITLE: Using Simple Assignment in Custom React Hook\nDESCRIPTION: This snippet shows an alternative implementation of the useFoo function without using useMemo. Instead, it performs a direct assignment of the identity result based on the input parameter x. This may not offer the same performance benefits as memoization, but serves as a baseline for understanding the function's behavior.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/prune-nonescaping-useMemo.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees\n\nimport { useMemo } from \"react\";\nimport { identity } from \"shared-runtime\";\n\n/**\n * This is technically a false positive, although it makes sense\n * to bailout as source code might be doing something sketchy.\n */\nfunction useFoo(x) {\n  let t0;\n  t0 = identity(x);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [2],\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Component Definition with Mutation\nDESCRIPTION: This snippet defines a React component that takes 'foo' and 'bar' as parameters, creates local objects x and y, and mutates the 'y' object within a function scope. It uses `shared-runtime`'s `mutate` function.  The component then returns the mutated 'y' object.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-alias-captured-mutate-arr-iife.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst {mutate} = require('shared-runtime');\n\nfunction component(foo, bar) {\n  let x = {foo};\n  let y = {bar};\n  (function () {\n    let a = [y];\n    let b = x;\n    a.x = b;\n  })();\n  mutate(y);\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: ['foo', 'bar'],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Error Handling for Reassignment in React - JavaScript\nDESCRIPTION: This snippet evaluates the potential error that arises when `x` is reassigned after the component has rendered. The error message suggests that such reassignments can lead to inconsistent behavior in React and recommends using state management techniques to handle variable updates.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.declare-reassign-variable-in-function-declaration.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n  2 |   let x = null;\n  3 |   function foo() {\n> 4 |     x = 9;\n    |     ^ InvalidReact: Reassigning a variable after render has completed can cause inconsistent behavior on subsequent renders. Consider using state instead. Variable `x` cannot be reassigned after render (4:4)\n  5 |   }\n  6 |   const y = bar(foo);\n  7 |   return <Child y={y} />;\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Test Function and Fixture Entrypoint for 'TodoAdd' Component\nDESCRIPTION: This snippet defines a JavaScript function 'f' that takes a parameter 'y', assigns it to 'x', and returns a sum involving reassignment. It also exports a fixture entrypoint object that specifies the function, parameters, and component name for testing.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/expression-with-assignment-dynamic.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction f(y) {\n  let x = y;\n  return x + (x = 2) + x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: f,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Using useMemo for Constant Value Caching in React\nDESCRIPTION: This snippet demonstrates the use of the `useMemo` hook to memoize a constant value in a custom React hook. The hook, `useFoo`, returns a memoized array containing `constVal`, which is useful for preventing unnecessary re-renders. It requires the React library and takes no parameters.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/todo-ensure-constant-prop-decls-get-removed.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees\n\nimport {useMemo} from 'react';\n\n// Todo: we currently only generate a `constVal` declaration when\n// validatePreserveExistingMemoizationGuarantees is enabled, as the\n// StartMemoize instruction uses `constVal`.\n// Fix is to rewrite StartMemoize instructions to remove constant\n// propagated values\nfunction useFoo() {\n  const constVal = 0;\n\n  return useMemo(() => [constVal], [constVal]);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Creating Object with Special Character Properties - Input Version\nDESCRIPTION: Original function that creates and returns an object with property names containing special characters like dots, backslashes, slashes, plus signs and spaces.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-non-identifier-object-keys.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Foo() {\n  return {\n    'a.b': 1,\n    'a\\b': 2,\n    'a/b': 3,\n    'a+b': 4,\n    'a b': 5,\n  };\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized and Transformed React Component\nDESCRIPTION: This snippet shows the optimized and transformed version of the React component. It uses the '_c' function from 'react/compiler-runtime' for memoization and implements efficient rendering of child components.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/maybe-mutate-object-in-callback.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nconst { mutate } = require(\"shared-runtime\");\n\nfunction Component(props) {\n  const $ = _c(3);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const object = {};\n\n    t0 = () => {\n      mutate(object);\n    };\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const onClick = t0;\n  let t1;\n  if ($[1] !== props.children) {\n    t1 = <Foo callback={onClick}>{props.children}</Foo>;\n    $[1] = props.children;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  return t1;\n}\n\nfunction Foo(t0) {\n  const { children } = t0;\n  return children;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ children: <div>Hello</div> }],\n};\n```\n\n----------------------------------------\n\nTITLE: React Compiler Runtime Optimized Dependency Tracking\nDESCRIPTION: Optimized version of the function using React compiler runtime, demonstrating memoization and efficient object tracking with minimal recomputation\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/uncond-subpath-order2.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction TestDepsSubpathOrder2(props) {\n  const $ = _c(2);\n  let x;\n  if ($[0] !== props.a) {\n    x = {};\n    x.a = props.a;\n    x.b = props.a.b;\n    x.c = props.a.b.c;\n    $[0] = props.a;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional Value Assignment Function in JavaScript\nDESCRIPTION: A function that assigns a value based on nested conditional checks. It takes multiple parameters and returns a value conditionally assigned based on the input conditions.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-nested-partial-reassignment.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(a, b, c, d, e) {\n  let x = null;\n  if (a) {\n    x = b;\n  } else {\n    if (c) {\n      x = d;\n    }\n  }\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Original React Component with useMemo\nDESCRIPTION: React component demonstrating useMemo usage to memoize array operations. Uses ValidateMemoization component to verify correct memoization behavior. Includes test fixtures for sequential rendering with different prop combinations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-of-nonmutating-loop-local-collection.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useMemo} from 'react';\nimport {ValidateMemoization} from 'shared-runtime';\n\nfunction Component({a, b}) {\n  const x = useMemo(() => {\n    return [a];\n  }, [a]);\n  const y = useMemo(() => {\n    const items = [b];\n    for (const i of x) {\n      items.push(i);\n    }\n    return items;\n  }, [x, b]);\n  return (\n    <>\n      <ValidateMemoization inputs={[a]} output={x} />\n      <ValidateMemoization inputs={[x, b]} output={y} />\n    </>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{a: 0, b: 0}],\n  sequentialRenders: [\n    {a: 1, b: 0},\n    {a: 1, b: 1},\n    {a: 0, b: 1},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Initializing Loop-Based Function with Fixture\nDESCRIPTION: Defines a function that performs iteration based on a nested object condition, with an exported fixture configuration for potential component testing\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/while-property.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(a, b) {\n  let x = 0;\n  while (a.b.c) {\n    x += b;\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(a, b) {\n  let x = 0;\n  while (a.b.c) {\n    x = x + b;\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with Destructuring in JavaScript\nDESCRIPTION: This snippet defines a function 'foo' that takes props as an argument, uses object destructuring to extract values, and performs some operations. It also includes a FIXTURE_ENTRYPOINT export for testing.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructure-direct-reassignment.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(props) {\n  let x, y;\n  ({x, y} = {x: props.a, y: props.b});\n  console.log(x); // prevent DCE from eliminating `x` altogether\n  x = props.c;\n  return x + y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Prepare Release from CI Example\nDESCRIPTION: This command downloads the artifacts from Circle CI for the commit `0e526bc`. It is preparing a stable release, as specified by the `-r stable` flag. This will download artifacts to prepare for a publish.\nSOURCE: https://github.com/facebook/react/blob/main/scripts/release/README.md#2025-04-21_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\nscripts/release/prepare-release-from-ci.js --commit=0e526bc -r stable\n```\n\n----------------------------------------\n\nTITLE: Advanced React Component Logic with Early Return - JavaScript\nDESCRIPTION: This snippet implements a more complex version of the component function which utilizes a symbol as an early return sentinel. It checks previous property values before executing its logic and handles errors by pushing properties into an error array. The component exports a fixed entry point for use in external contexts.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/try-catch-try-value-modified-in-catch.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enablePropagateDepsInHIR\nconst { throwInput } = require(\"shared-runtime\");\n\nfunction Component(props) {\n  const $ = _c(3);\n  let t0;\n  if ($[0] !== props.e || $[1] !== props.y) {\n    t0 = Symbol.for(\"react.early_return_sentinel\");\n    bb0: {\n      try {\n        const y = [];\n        y.push(props.y);\n        throwInput(y);\n      } catch (t1) {\n        const e = t1;\n        e.push(props.e);\n        t0 = e;\n        break bb0;\n      }\n    }\n    $[0] = props.e;\n    $[1] = props.y;\n    $[2] = t0;\n  } else {\n    t0 = $[2];\n  }\n  if (t0 !== Symbol.for(\"react.early_return_sentinel\")) {\n    return t0;\n  }\n  return null;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ y: \"foo\", e: \"bar\" }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining Custom useState Hook - JavaScript\nDESCRIPTION: This snippet defines a custom useState hook that mimics React's useState, utilizing a memoization technique to optimize state management. It captures state changes and optimally returns the state and setState function. The expected input is an initial value for the state, and the output is the current state along with a function to update it.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/globals-dont-resolve-local-useState.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useState as _useState, useCallback, useEffect} from 'react';\nimport {ValidateMemoization} from 'shared-runtime';\n\nfunction useState(value) {\n  const [state, setState] = _useState(value);\n  return [state, setState];\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization Cache\nDESCRIPTION: The compiled version of the Foo component that includes React's compiler runtime memoization. It uses a symbol-based cache sentinel to avoid redundant rendering of the same content.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-jsxtext-stringliteral-distinction.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Foo() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = <div> {\", \"}</div>;\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Optimized Memoization\nDESCRIPTION: The compiled version of the React component showing how the compiler transforms useMemo calls into an efficient caching system. It uses a cache array (_c2) to store dependencies and memoized values, implementing manual dependency checking.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/existing-variables-with-c-name.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c2 } from \"react/compiler-runtime\";\nimport { useMemo, useState } from \"react\";\nimport { ValidateMemoization } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c2(7);\n  const [state] = useState(0);\n\n  const c = state;\n  const _c = c;\n  const __c = _c;\n  const c1 = __c;\n  const $c = c1;\n  let t0;\n  let t1;\n  if ($[0] !== $c) {\n    t1 = [$c];\n    $[0] = $c;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  t0 = t1;\n  const array = t0;\n  let t2;\n  if ($[2] !== state) {\n    t2 = [state];\n    $[2] = state;\n    $[3] = t2;\n  } else {\n    t2 = $[3];\n  }\n  let t3;\n  if ($[4] !== array || $[5] !== t2) {\n    t3 = <ValidateMemoization inputs={t2} output={array} />;\n    $[4] = array;\n    $[5] = t2;\n    $[6] = t3;\n  } else {\n    t3 = $[6];\n  }\n  return t3;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n  sequentialRenders: [{}, {}, {}],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: Simple React component that creates an empty array and maps over it, updating each item's 'updated' property. Returns both the original and mapped arrays.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-map-mutable-array-mutating-lambda.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const x = [];\n  const y = x.map(item => {\n    item.updated = true;\n    return item;\n  });\n  return [x, y];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled: React Compiler Transformed Switch Statement\nDESCRIPTION: React compiler's transformed version of the function with memoization and optimization techniques to manage reactive dependencies\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/cfg-switch-missing-default.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction useCondDepInSwitchMissingDefault(props, other) {\n  const $ = _c(3);\n  let x;\n  if ($[0] !== other || $[1] !== props) {\n    x = {};\n    bb0: switch (identity(other)) {\n      case 1: {\n        x.a = props.a.b;\n        break bb0;\n      }\n      case 2: {\n        x.b = props.a.b;\n      }\n    }\n    $[0] = other;\n    $[1] = props;\n    $[2] = x;\n  } else {\n    x = $[2];\n  }\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Compiler-Transformed React Component with Optimization\nDESCRIPTION: The compiler-transformed version of the React component with explicit memoization caching. It uses a Symbol-based cache to avoid recalculating values that haven't changed between renders, implementing the same behavior as useMemo but with compiler optimizations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fast-refresh-reloading.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enableResetCacheOnSourceFileChanges\nimport { useMemo, useState } from \"react\";\nimport { ValidateMemoization } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(8);\n  if (\n    $[0] !== \"20945b0193e529df490847c66111b38d7b02485d5b53d0829ff3b23af87b105c\"\n  ) {\n    for (let $i = 0; $i < 8; $i += 1) {\n      $[$i] = Symbol.for(\"react.memo_cache_sentinel\");\n    }\n    $[0] = \"20945b0193e529df490847c66111b38d7b02485d5b53d0829ff3b23af87b105c\";\n  }\n  const [state] = useState(0);\n  let t0;\n  const t1 = state * 2;\n  let t2;\n  if ($[1] !== t1) {\n    t2 = [t1];\n    $[1] = t1;\n    $[2] = t2;\n  } else {\n    t2 = $[2];\n  }\n  t0 = t2;\n  const doubled = t0;\n  let t3;\n  if ($[3] !== state) {\n    t3 = [state];\n    $[3] = state;\n    $[4] = t3;\n  } else {\n    t3 = $[4];\n  }\n  let t4;\n  if ($[5] !== doubled || $[6] !== t3) {\n    t4 = <ValidateMemoization inputs={t3} output={doubled} />;\n    $[5] = doubled;\n    $[6] = t3;\n    $[7] = t4;\n  } else {\n    t4 = $[7];\n  }\n  return t4;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n  sequentialRenders: [{}, {}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Component Function in JavaScript\nDESCRIPTION: This snippet defines a basic component function that initializes an object with an input parameter, and uses an IIFE to manipulate the object's properties. It returns the initialized object and is designed to exhibit simple state-like behavior.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capture-indirect-mutate-alias-iife.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component(a) {\n  let x = {a};\n  (function () {\n    let q = x;\n    (function () {\n      q.b = 1;\n    })();\n  })();\n\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: [2],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Function Implementation\nDESCRIPTION: The original function creates arrays conditionally based on input parameters. It demonstrates a typical React pattern that would benefit from memoization to avoid recreating arrays on each render.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/overlapping-scopes-within-block.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(a, b, c) {\n  let x = [];\n  if (a) {\n    let y = [];\n    if (b) {\n      y.push(c);\n    }\n\n    x.push(y);\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Enhanced React Component with State Management\nDESCRIPTION: This snippet enhances the 'useFoo' function to include internal state management for efficient rendering. It uses a caching mechanism to avoid unnecessary re-computation by checking previous dependency values before rendering the Stringify component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/todo-infer-function-uncond-optionals-hoisted.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enablePropagateDepsInHIR\n\nimport { Stringify } from \"shared-runtime\";\n\nfunction useFoo(t0) {\n  const $ = _c(2);\n  const { a } = t0;\n  let t1;\n  if ($[0] !== a.b?.c.d?.e) {\n    t1 = <Stringify fn={() => a.b?.c.d?.e} shouldInvokeFns={true} />;\n    $[0] = a.b?.c.d?.e;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ a: null }],\n  sequentialRenders: [\n    { a: null },\n    { a: { b: null } },\n    { a: { b: { c: { d: null } } } },\n    { a: { b: { c: { d: { e: 4 } } } } },\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining and Exporting React Component with Parameters - JavaScript\nDESCRIPTION: This snippet defines a simple component function that takes an array as an argument, processes it into separate objects, and returns an array of these objects. It exports a constant that sets the component function with its parameters, specifying that it's not a component. It requires the use of JavaScript and is intended for use in a React environment.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-pattern-params.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component([a, b]) {\n  let y = {a};\n  let z = {b};\n  return [y, z];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: [['val1', 'val2']],\n  isComponent: false,\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: Compiler-transformed version of the component that implements memoization for the object spread operation. Uses React compiler runtime utilities to cache and reuse spread results.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-literal-spread-element.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== props.foo) {\n    t0 = { ...props.foo };\n    $[0] = props.foo;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const x = t0;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Function Definition with Conditional Element Handling in JavaScript\nDESCRIPTION: This snippet defines a function named 'foo' that processes a 'props' object, conditionally assigning and modifying an 'x' array. If 'props.cond' is true, 'x' is re-initialized and altered based on 'props.foo'. Dependencies include appropriate JavaScript runtime supporting dynamic object destructuring. Inputs are 'props' and the output is an array 'x', which contains elements based on 'props'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-renaming-via-destructuring.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(props) {\n  let {x} = {x: []};\n  x.push(props.bar);\n  if (props.cond) {\n    ({x} = {x: {}});\n    ({x} = {x: []});\n    x.push(props.foo);\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with Setter Function\nDESCRIPTION: A React component that declares an object with a setter function to update a local variable. The component renders a div displaying the value set via the object's setter. The issue is that the build system cannot handle the setter function syntax.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-object-expression-set-syntax.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let value;\n  const object = {\n    set value(v) {\n      value = v;\n    },\n  };\n  object.value = props.value;\n  return <div>{value}</div>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [{value: 0}],\n  sequentialRenders: [{value: 1}, {value: 2}],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component Definition with Mutation\nDESCRIPTION: This code defines a React component that utilizes object mutation within a computed object key.  The `mutate` function, presumably from a shared runtime, modifies the `key` object. The `identity` function appears to preserve a reference. The component returns a context object and the mutated key object.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/bug-object-expression-computed-key-modified-during-after-construction-hoisted-sequence-expr.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {identity, mutate} from 'shared-runtime';\n\n/**\n * Bug: copy of error.todo-object-expression-computed-key-modified-during-after-construction-sequence-expr\n * with the mutation hoisted to a named variable instead of being directly\n * inlined into the Object key.\n *\n * Found differences in evaluator results\n *   Non-forget (expected):\n *   (kind: ok) [{\"[object Object]\":[42]},{\"wat0\":\"joe\",\"wat1\":\"joe\"}]\n *   [{\"[object Object]\":[42]},{\"wat0\":\"joe\",\"wat1\":\"joe\"}]\n *   Forget:\n *   (kind: ok) [{\"[object Object]\":[42]},{\"wat0\":\"joe\",\"wat1\":\"joe\"}]\n *   [{\"[object Object]\":[42]},{\"wat0\":\"joe\",\"wat1\":\"joe\",\"wat2\":\"joe\"}]\n */\nfunction Component(props) {\n  const key = {};\n  const tmp = (mutate(key), key);\n  const context = {\n    // Here, `tmp` is frozen (as it's inferred to be a primitive/string)\n    [tmp]: identity([props.value]),\n  };\n  mutate(key);\n  return [context, key];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: 42}],\n  sequentialRenders: [{value: 42}, {value: 42}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Compiler Transformed Function with Memoization\nDESCRIPTION: The same function after being processed by the React compiler, which adds memoization using a Symbol-based cache sentinel. This optimization prevents recreating the array and object on each call by storing and reusing the previously created object.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-property.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction foo() {\n  const $ = _c(1);\n  let y;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const x = [];\n    y = {};\n    y.x = x;\n    $[0] = y;\n  } else {\n    y = $[0];\n  }\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Fixture Entrypoint Definition\nDESCRIPTION: This code defines a constant called `FIXTURE_ENTRYPOINT` that specifies the component to be used as the entry point for a fixture. It includes the component function (`Component`), a flag indicating that it is a component (`isComponent: true`), and parameters for the component (`params: [{x: 1}]`). This is likely used for testing or demonstration purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/import-as-local.expect.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  isComponent: true,\n  params: [{x: 1}],\n};\n```\n\n----------------------------------------\n\nTITLE: Using Compiler Runtime with React Component in JavaScript\nDESCRIPTION: This snippet defines the same 'Component' using React's compiler runtime functionality. It introduces a reactive variable '$' to track changes in props and leverage efficient state updates. The component's internal logic ensures that reactivity is maintained, especially when 'a' and 'c' change in response to 'b'. Dependencies include React's compiler runtime module.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactivity-analysis-interleaved-reactivity.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(6);\n  let a;\n  let t0;\n  if ($[0] !== props.b) {\n    a = {};\n    const b = [];\n    b.push(props.b);\n    a.a = null;\n\n    t0 = [a];\n    $[0] = props.b;\n    $[1] = a;\n    $[2] = t0;\n  } else {\n    a = $[1];\n    t0 = $[2];\n  }\n  const c = t0;\n  let t1;\n  if ($[3] !== a || $[4] !== c) {\n    t1 = [c, a];\n    $[3] = a;\n    $[4] = c;\n    $[5] = t1;\n  } else {\n    t1 = $[5];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n\n```\n\n----------------------------------------\n\nTITLE: State Management with React's Compiler Runtime in JavaScript\nDESCRIPTION: This snippet extends the `component` function from React using the `compiler-runtime`. It introduces caching with the use of special react compiler variables to store and update the state object `z` based on the input `a`. This approach helps in optimizing component re-rendering by checking if the state has changed before executing state updates.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capture_mutate-across-fns.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction component(a) {\n  const $ = _c(2);\n  let z;\n  if ($[0] !== a) {\n    z = { a };\n    const f0 = function () {\n      const f1 = function () {\n        z.b = 1;\n      };\n\n      f1();\n    };\n\n    f0();\n    $[0] = a;\n    $[1] = z;\n  } else {\n    z = $[1];\n  }\n  return z;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with Scoped Variables\nDESCRIPTION: This code defines a React component that demonstrates variable scoping. It creates an object 'x', then defines a new 'x' in a block scope, modifies it, but returns the original object 'x'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/lambda-reassign-shadowed-primitive.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component() {\n  const x = {};\n  {\n    let x = 56;\n    const fn = function () {\n      x = 42;\n    };\n    fn();\n  }\n  return x; // should return {}\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component Rendering Using Compiler Runtime - JavaScript\nDESCRIPTION: This snippet elaborates an optimized rendering of a React component using 'react/compiler-runtime'. It employs a caching mechanism to optimize performance by storing previously computed results. The 'Component' function checks for updates in 'items' and reuses cached values when no changes are detected. It depends on 'react/compiler-runtime' for managing component states efficiently. Inputs are 'items' as props, and the component outputs a div wrapping the rendered items via 'Stringify'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/outlined-helper.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { Stringify } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(4);\n  let t0;\n  if ($[0] !== props.items) {\n    t0 = props.items.map(_temp);\n    $[0] = props.items;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  let t1;\n  if ($[2] !== t0) {\n    t1 = <div>{t0}</div>;\n    $[2] = t0;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  return t1;\n}\nfunction _temp(item) {\n  return <Stringify key={item.id} item={item.name} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ items: [{ id: 1, name: \"one\" }] }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Input React Function with Stringify Wrapper\nDESCRIPTION: Initial implementation of useFoo function that wraps a function returning an object with nested property access\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/infer-nested-function-uncond-access.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enablePropagateDepsInHIR\n\nimport {Stringify} from 'shared-runtime';\n\nfunction useFoo({a}) {\n  const fn = () => {\n    return () => ({\n      value: a.b.c,\n    });\n  };\n  return <Stringify fn={fn} shouldInvokeFns={true} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Identity Function in JavaScript\nDESCRIPTION: This snippet defines a React component 'Test' that uses an 'identity' function from 'shared-runtime'. It also exports a 'FIXTURE_ENTRYPOINT' object with the component function and empty params.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ts-instantiation-expression.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {identity, invoke} from 'shared-runtime';\n\nfunction Test() {\n  const str = invoke(identity<string>, 'test');\n  return str;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Test,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: Transformed version of the component with compiler-runtime imports and memoization logic implemented through Symbol sentinel checking.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-duplicate-type-import.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport type { ReactElement } from \"react\";\n\nfunction Component(_props) {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = <div>hello world</div>;\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining ComponentB Using Custom Hook in JavaScript\nDESCRIPTION: The function 'componentB' utilizes a custom hook 'useFoo' to generate a greeting message. It takes 'props' as an argument, specifically using the property 'a'. The function returns the result from 'useFoo'. The code assumes 'useFoo' is defined elsewhere and properly imported or globally available.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/template-literal.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction componentB(props) {\n  let x = useFoo(`hello ${props.a}`);\n  return x;\n}\n\n```\n\nLANGUAGE: javascript\nCODE:\n```\nfunction componentB(props) {\n  const x = useFoo(`hello ${props.a}`);\n  return x;\n}\n\n```\n\n----------------------------------------\n\nTITLE: React Component with Const Declarations\nDESCRIPTION: Modified version of the component using const declarations instead of let. While the variables cannot be reassigned, their properties can still be mutated as they are objects.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/mutable-liverange-loop.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction mutate() {}\nfunction cond() {}\n\nfunction Component(props) {\n  const a = {};\n  const b = {};\n  const c = {};\n  const d = {};\n  while (true) {\n    mutate(a, b);\n    if (cond(a)) {\n      break;\n    }\n  }\n  if (a) {\n  }\n  if (b) {\n  }\n  if (c) {\n  }\n  if (d) {\n  }\n\n  mutate(d, null);\n}\n```\n\n----------------------------------------\n\nTITLE: Input React Component with Loop\nDESCRIPTION: Initial implementation of a React component with a for loop and fixture setup for testing. The component includes a basic loop structure with props.count parameter.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-return.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  for (let i = 0; i < props.count; i++) {\n    return;\n  }\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Compiler Runtime\nDESCRIPTION: This snippet shows an optimized version of the React component, likely produced by a compiler. It uses memoization techniques and a custom compiler runtime to improve performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/resolve-react-hooks-based-on-import-name.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useState as useReactState } from \"react\";\n\nfunction Component() {\n  const $ = _c(4);\n  const [state, setState] = useReactState(0);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = () => {\n      setState(_temp);\n    };\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const onClick = t0;\n  let t1;\n  if ($[1] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = <button onClick={onClick}>Increment</button>;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  let t2;\n  if ($[2] !== state) {\n    t2 = (\n      <>\n        Count {state}\n        {t1}\n      </>\n    );\n    $[2] = state;\n    $[3] = t2;\n  } else {\n    t2 = $[3];\n  }\n  return t2;\n}\nfunction _temp(s) {\n  return s + 1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with TypeScript-like Typing in JavaScript\nDESCRIPTION: This snippet defines a React component that takes a 'name' prop and returns a user object. It uses TypeScript-like type annotations within JavaScript.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-alias-declaration.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  type User = {name: string};\n  const user: User = {name: props.name};\n  return user;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{name: 'Mofei'}],\n};\n```\n\n----------------------------------------\n\nTITLE: Transformed React Hook with Compiler Optimizations\nDESCRIPTION: This code shows the compiled version of the `useFoo` hook, demonstrating the React compiler's optimizations for state updates and memoization. It uses `react/compiler-runtime` for efficient memoization and avoids unnecessary re-renders by caching the results of the `handleLogout` and `getComponent` functions. The compiler also ensures that the `onClick` handler and the component returned by `getComponent` are memoized correctly.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-setstate-captured-indirectly-jsx.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @validatePreserveExistingMemoizationGuarantees\nfunction useFoo() {\n  const $ = _c(9);\n  const onClick = (response) => {\n    setState(DISABLED_FORM);\n  };\n\n  const [, t0] = useState();\n  const setState = t0;\n  let t1;\n  if ($[0] !== setState) {\n    t1 = () => {\n      setState(DISABLED_FORM);\n    };\n    $[0] = setState;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  setState;\n  const handleLogout = t1;\n  let t2;\n  if ($[2] !== handleLogout) {\n    t2 = () => <ColumnItem onPress={() => handleLogout()} />;\n    $[2] = handleLogout;\n    $[3] = t2;\n  } else {\n    t2 = $[3];\n  }\n  const getComponent = t2;\n  let t3;\n  if ($[4] !== getComponent) {\n    t3 = getComponent();\n    $[4] = getComponent;\n    $[5] = t3;\n  } else {\n    t3 = $[5];\n  }\n  let t4;\n  if ($[6] !== onClick || $[7] !== t3) {\n    t4 = [t3, onClick];\n    $[6] = onClick;\n    $[7] = t3;\n    $[8] = t4;\n  } else {\n    t4 = $[8];\n  }\n  return t4;\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: The React compiler's output for the component, including memoization logic with a cache array. Despite compiling the code, the compiler still detects and logs the error regarding JSX in a catch block.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/invalid-jsx-in-catch-in-outer-try-with-catch.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @logger @validateNoJSXInTryStatements\nimport { identity } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(4);\n  let el;\n  try {\n    let value;\n    try {\n      let t0;\n      if ($[0] !== props.foo) {\n        t0 = identity(props.foo);\n        $[0] = props.foo;\n        $[1] = t0;\n      } else {\n        t0 = $[1];\n      }\n      value = t0;\n    } catch {\n      let t0;\n      if ($[2] !== value) {\n        t0 = <div value={value} />;\n        $[2] = value;\n        $[3] = t0;\n      } else {\n        t0 = $[3];\n      }\n      el = t0;\n    }\n  } catch {\n    return null;\n  }\n  return el;\n}\n```\n\n----------------------------------------\n\nTITLE: Forget-Optimized React Component\nDESCRIPTION: Presents the transformed React component after applying Forget optimization. It uses `react/compiler-runtime` to memoize the component's output based on changes in `props.a.b`. The optimized version avoids re-rendering unless `props.a.b` changes, improving performance. `_c` from `react/compiler-runtime` is the Forget compiler runtime.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/memberexpr-join-optional-chain.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // To preserve the nullthrows behavior and reactive deps of this code,\n// Forget needs to add `props.a.b` or a subpath as a dependency.\n//\n// (1) Since the reactive block producing x unconditionally read props.a.<...>,\n//     reading `props.a.b` outside of the block would still preserve nullthrows\n//     semantics of source code\n// (2) Technically, props.a, props.a.b, and props.a.b.c are all reactive deps.\n//     However, `props.a?.b` is only dependent on whether `props.a` is nullish,\n//     not its actual value. Since we already preserve nullthrows on `props.a`,\n//     we technically do not need to add `props.a` as a dependency.\n\nfunction Component(props) {\n  const $ = _c(2);\n  let x;\n  if ($[0] !== props.a.b) {\n    x = [];\n    x.push(props.a?.b);\n    x.push(props.a.b.c);\n    $[0] = props.a.b;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ a: { b: { c: 1 } } }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining Component Functionality in JavaScript\nDESCRIPTION: This snippet defines a simple function 'component' that creates a closure and logs a parameter 'a' when invoked. It captures the input into an object and returns a new function that logs this object's property. It serves as a basic demonstration of how to create and export a React component entry point.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-member-expr.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component(a) {\n  let z = {a};\n  let x = function () {\n    console.log(z.a);\n  };\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Enhanced React Component Logic with Compiler Runtime - JavaScript\nDESCRIPTION: This snippet expands the initial React component by importing and utilizing `react/compiler-runtime`. It introduces an optimization mechanism to cache memoized results, ensuring that unnecessary recomputations are avoided. The core logic follows similar reactive principles but with added performance enhancements.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-from-interleaved-reactivity-switch.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(1);\n\n  const a = [];\n  const b = [];\n  b.push(props.cond);\n  a.push(null);\n\n  const c = [a];\n\n  let x;\n  bb0: switch (c[0][0]) {\n    case true: {\n      x = 1;\n      break bb0;\n    }\n    default: {\n      x = 2;\n    }\n  }\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = [x];\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ cond: true }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with Pagination Fragment\nDESCRIPTION: This code snippet defines a React component that uses a pagination fragment to manage data loading and rendering. It includes a function to load more data and an effect hook to trigger loading based on certain conditions.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transitive-freeze-function-expressions.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableTransitivelyFreezeFunctionExpressions\nfunction Component(props) {\n  const {data, loadNext, isLoadingNext} =\n    usePaginationFragment(props.key).items ?? [];\n\n  const loadMoreWithTiming = () => {\n    if (data.length === 0) {\n      return;\n    }\n    loadNext();\n  };\n\n  useEffect(() => {\n    if (isLoadingNext) {\n      return;\n    }\n    loadMoreWithTiming();\n  }, [isLoadingNext, loadMoreWithTiming]);\n\n  const items = data.map(x => x);\n\n  return items;\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Invalid React Hook with Identity Function\nDESCRIPTION: A function that attempts to use an identifier before it is defined, causing a hoisting error. The identity function is incorrectly applied to an undefined variable.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.dont-hoist-inline-reference.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {identity} from 'shared-runtime';\nfunction useInvalid() {\n  const x = identity(x);\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useInvalid,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Exporting Fixture Entry Point with Updated Component - JavaScript\nDESCRIPTION: This snippet exports a constant 'FIXTURE_ENTRYPOINT' similar to the previous snippet but is associated with the new implementation of the 'Component'. It maintains the structure for testing or demonstration purposes, ensuring consistency across different component implementations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unused-conditional.expect.md#2025-04-21_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Direct Mutation and Variable Assignment in Component\nDESCRIPTION: A simplified React component function performing mutation directly and declaring an undefined variable\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-return-empty.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component(a) {\n  let t0;\n\n  mutate(a);\n  t0 = undefined;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Conditional Rendering in React Component\nDESCRIPTION: This snippet defines a React component that conditionally renders an array based on props. It demonstrates the use of a labeled block and conditional logic to control array content.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/conditional-break-labeled.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n/**\n * props.b *does* influence `a`\n */\nfunction Component(props) {\n  const a = [];\n  a.push(props.a);\n  label: {\n    if (props.b) {\n      break label;\n    }\n    a.push(props.c);\n  }\n  a.push(props.d);\n  return a;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component Input\nDESCRIPTION: Original source code showing a simple component function that creates an object combining a parameter and global variable. Includes test fixture configuration for the component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructure-capture-global.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nlet someGlobal = {};\nfunction component(a) {\n  let x = {a, someGlobal};\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: ['value 1'],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Input Implementation of useBar Hook\nDESCRIPTION: Original source code implementation of a React hook that demonstrates Set iterator behavior with object spreads. Uses memoization and returns an array combining an input argument with Set values.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-spread-mutable-iterator.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction useBar({arg}) {\n  'use memo';\n\n  /**\n   * Note that mutableIterator is mutated by the later object spread. Therefore,\n   * `s.values()` should be memoized within the same block as the object spread.\n   * In terms of compiler internals, they should have the same reactive scope.\n   */\n  const s = new Set([1, 5, 4]);\n  const mutableIterator = s.values();\n\n  return [arg, ...mutableIterator];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useBar,\n  params: [{arg: 3}],\n  sequentialRenders: [{arg: 3}, {arg: 3}, {arg: 4}],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Memoized Effect - Compiled Version\nDESCRIPTION: This snippet presents an optimized, compiled version of the React component. It uses memoization techniques to optimize re-renders and effect dependencies, demonstrating advanced React optimization strategies.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/merged-scopes-are-valid-effect-deps.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @validateMemoizedEffectDependencies\n\nimport { useEffect } from \"react\";\n\nfunction Component(props) {\n  const $ = _c(5);\n  let t0;\n  if ($[0] !== props.value) {\n    t0 = [[props.value]];\n    $[0] = props.value;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const y = t0;\n  let t1;\n  let t2;\n  if ($[2] !== y) {\n    t1 = () => {\n      console.log(y);\n    };\n    t2 = [y];\n    $[2] = y;\n    $[3] = t1;\n    $[4] = t2;\n  } else {\n    t1 = $[3];\n    t2 = $[4];\n  }\n  useEffect(t1, t2);\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ value: 42 }],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: React Flow Type Alias Compiled Code\nDESCRIPTION: Compiled JavaScript output after Flow type stripping. Shows how type annotations are removed and the function is transformed into a more standard JavaScript format.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-alias-used-as-variable-annotation_.flow.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\ntype Bar = string;\nfunction TypeAliasUsedAsAnnotation() {\n  const fun = _temp;\n\n  fun(\"hello, world\");\n}\nfunction _temp(f) {\n  const g = f;\n  console.log(g);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: TypeAliasUsedAsAnnotation,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: React Hook Definition with Conditional Array Modification\nDESCRIPTION: This code defines a React hook `useFoo` that takes `props` as input.  It initializes an array `x`, pushes `props.bar` into it, and conditionally modifies the array based on `props.cond`. If `props.cond` is true, it re-initializes the array and pushes `props.foo` into it. Finally, it calls `mutate(x)` and returns the array. The `FIXTURE_ENTRYPOINT` provides test data for sequential renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/ssa-renaming-ternary-with-mutation.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enablePropagateDepsInHIR\nimport {mutate} from 'shared-runtime';\n\nfunction useFoo(props) {\n  let x = [];\n  x.push(props.bar);\n  props.cond ? ((x = {}), (x = []), x.push(props.foo)) : null;\n  mutate(x);\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{cond: false, foo: 2, bar: 55}],\n  sequentialRenders: [\n    {cond: false, foo: 2, bar: 55},\n    {cond: false, foo: 3, bar: 55},\n    {cond: true, foo: 3, bar: 55},\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with Memoized Data Processing\nDESCRIPTION: This snippet defines a React component that processes input data using useMemo for optimization. It maps over nested array data and uses a ValidateMemoization component to verify inputs and outputs.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/optional-member-expression-as-memo-dep.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees @enableOptionalDependencies @enablePropagateDepsInHIR\nimport {identity, ValidateMemoization} from 'shared-runtime';\nimport {useMemo} from 'react';\n\nfunction Component({arg}) {\n  const data = useMemo(() => {\n    return arg?.items.edges?.nodes.map(identity);\n  }, [arg?.items.edges?.nodes]);\n  return (\n    <ValidateMemoization inputs={[arg?.items.edges?.nodes]} output={data} />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using React Compiler Runtime for Memoization - JavaScript\nDESCRIPTION: This snippet defines a function 'foo' using React's compiler runtime for improved optimization based on previous parameter checks. It conditionally updates and memoizes the array derived from parameters 'b' and 'c'. This pattern allows for efficient React component rendering and state management.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/independently-memoize-object-property.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction foo(a, b, c) {\n  const $ = _c(7);\n  let x;\n  if ($[0] !== a || $[1] !== b || $[2] !== c) {\n    x = { a };\n    let t0;\n    if ($[4] !== b || $[5] !== c) {\n      t0 = [b, c];\n      $[4] = b;\n      $[5] = c;\n      $[6] = t0;\n    } else {\n      t0 = $[6];\n    }\n    x.y = t0;\n    $[0] = a;\n    $[1] = b;\n    $[2] = c;\n    $[3] = x;\n  } else {\n    x = $[3];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a Functional Component with useRef in React\nDESCRIPTION: This snippet defines a React functional component `Foo` that uses the `useRef` hook to create a mutable ref object. It captures the `current` value of the ref and constructs an object that includes both the prop `a` and the ref's current value. The component then passes this object to the `VideoList` component as a prop named `videos`. This implementation helps ensure that the component re-renders correctly based on the ref's value, thereby optimizing rendering logic.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ref-current-aliased-not-added-to-dep-2.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validateRefAccessDuringRender:false\nfunction Foo({a}) {\n  const ref = useRef();\n  const val = ref.current;\n  const x = {a, val};\n\n  return <VideoList videos={x} />;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Output: Compiler-Optimized React Component Implementation with Memoization\nDESCRIPTION: The compiler-transformed version of the component with React memoization. It uses the React compiler runtime to cache computed values and object references, reducing unnecessary re-renders and object allocations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/hoist-deps-diff-ssa-instance1.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { identity, shallowCopy, Stringify, useIdentity } from \"shared-runtime\";\n\ntype HasA = { kind: \"hasA\"; a: { value: number } };\ntype HasC = { kind: \"hasC\"; c: { value: number } };\nfunction Foo(t0) {\n  const $ = _c(7);\n  const { cond } = t0;\n  let t1;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = shallowCopy({ kind: \"hasA\", a: { value: 2 } });\n    $[0] = t1;\n  } else {\n    t1 = $[0];\n  }\n  let x = t1;\n\n  Math.max(x.a.value, 2);\n  if (cond) {\n    let t2;\n    if ($[1] === Symbol.for(\"react.memo_cache_sentinel\")) {\n      t2 = shallowCopy({ kind: \"hasC\", c: { value: 3 } });\n      $[1] = t2;\n    } else {\n      t2 = $[1];\n    }\n    x = t2;\n  }\n  let t2;\n  if ($[2] !== cond || $[3] !== x) {\n    t2 = !cond && [(x as HasA).a.value + 2];\n    $[2] = cond;\n    $[3] = x;\n    $[4] = t2;\n  } else {\n    t2 = $[4];\n  }\n  let t3;\n  if ($[5] !== t2) {\n    t3 = <Stringify val={t2} />;\n    $[5] = t2;\n    $[6] = t3;\n  } else {\n    t3 = $[6];\n  }\n  return t3;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{ cond: false }],\n  sequentialRenders: [{ cond: false }, { cond: true }],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization Optimizations\nDESCRIPTION: The compiled output of the component with React's compiler optimizations. It introduces memoization using Symbol.for(\"react.memo_cache_sentinel\") to prevent unnecessary recalculations and instantiations on re-renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/new-does-not-mutate-class.expect.md#2025-04-22_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { identity } from \"shared-runtime\";\n\nclass Foo {}\nfunction Component(t0) {\n  const $ = _c(6);\n  const { val } = t0;\n  let t1;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = identity(Foo);\n    $[0] = t1;\n  } else {\n    t1 = $[0];\n  }\n  const MyClass = t1;\n  let t2;\n  if ($[1] !== val) {\n    t2 = [val];\n    $[1] = val;\n    $[2] = t2;\n  } else {\n    t2 = $[2];\n  }\n  const x = t2;\n  let t3;\n  if ($[3] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t3 = new MyClass();\n    $[3] = t3;\n  } else {\n    t3 = $[3];\n  }\n  const y = t3;\n  let t4;\n  if ($[4] !== x) {\n    t4 = [x, y];\n    $[4] = x;\n    $[5] = t4;\n  } else {\n    t4 = $[5];\n  }\n  return t4;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ val: 0 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining React Components and Fixture Entrypoint\nDESCRIPTION: This snippet defines two React components (Component and Component2) as empty fragments. It also sets display names for both components and exports a FIXTURE_ENTRYPOINT object with the Component function, empty params, and sequential renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/gating-preserves-function-properties.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// @gating\n\nexport default function Component() {\n  return <></>;\n}\n\nexport function Component2() {\n  return <></>;\n}\n\nComponent.displayName = 'Component ONE';\nComponent2.displayName = 'Component TWO';\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  sequentialRenders: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: A React component that initializes an array, performs mutation in a do-while loop, and returns the mutated array. The loop contains a break statement making it execute only once.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/do-while-early-unconditional-break.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let x = [1, 2, 3];\n  do {\n    mutate(x);\n    break;\n  } while (props.cond);\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Removing Nodes Operation in React DevTools\nDESCRIPTION: Example showing the operation payload for removing fibers from the component tree. It includes the operation type, count of removed fibers, and the ids of each removed fiber.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/OVERVIEW.md#2025-04-21_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n[\n  2, // remove operation\n  2, // number of removed fibers\n  35, // first removed id\n  21, // second removed id\n]\n```\n\n----------------------------------------\n\nTITLE: React Component with Impure Calls\nDESCRIPTION: This code defines a React component named `Component` that calls impure functions `Date.now()`, `performance.now()`, and `Math.random()` directly within its body. This violates React's purity rule, which requires components to be idempotent and predictable. The component returns a `<Foo>` element with props derived from these impure function calls.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-impure-functions-in-render.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validateNoImpureFunctionsInRender\n\nfunction Component() {\n  const date = Date.now();\n  const now = performance.now();\n  const rand = Math.random();\n  return <Foo date={date} now={now} rand={rand} />;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining React Test Fixture Input (JavaScript)\nDESCRIPTION: Input version of a sample function and test fixture setup for a React component. The function 'foo' creates arrays and populates them in a loop, while FIXTURE_ENTRYPOINT exports configuration for a 'TodoAdd' component test.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/overlapping-scopes-while.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(a, b, c) {\n  let x = [];\n  let y = [];\n  while (c) {\n    y.push(b);\n    x.push(a);\n  }\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Compiler Output for Object Destructuring and Array Creation\nDESCRIPTION: This snippet shows the React compiler's optimized version of the 'foo' function. It uses memoization techniques to cache the object and resulting array, potentially improving performance in repeated calls.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructure-mixed-property-key-types.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction foo() {\n  const $ = _c(2);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = { \"data-foo-bar\": 1, a: 2, data: 3 };\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const { \"data-foo-bar\": x, a: y, data: z } = t0;\n  let t1;\n  if ($[1] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = [x, y, z];\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Optimized Destructuring\nDESCRIPTION: This snippet shows the compiled version of the React component. It uses React's compiler runtime for optimized rendering. The compiled code implements the same functionality as the input, but with additional checks and caching mechanisms for performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-with-typecast-as-default-value.flow.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  const [t0] = props.y;\n  let t1;\n  if ($[0] !== t0) {\n    t1 = t0 === undefined ? ([]: Array<number>) : t0;\n    $[0] = t0;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  const x = t1;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ y: [] }],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimizing a Recursive Function in JavaScript\nDESCRIPTION: This optimized version of 'foo' replaces the immediately invoked function expression with a variable assignment. It stores the result of foo(x - 2) in variable t0 to avoid redundant calculations and improve performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/recursive-function.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(x) {\n  if (x <= 0) {\n    return 0;\n  }\n  let t0;\n  t0 = foo(x - 2);\n  return x + foo(x - 1) + t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [10],\n};\n```\n\n----------------------------------------\n\nTITLE: Running React Async Demo from Source Code\nDESCRIPTION: Steps to build React from source code, install fixture dependencies, copy the React source to the fixture, and run the demo application. This approach allows testing with a custom build of React.\nSOURCE: https://github.com/facebook/react/blob/main/fixtures/concurrent/time-slicing/README.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n# 1: Build react from source\ncd /path/to/react\nyarn\nyarn build react-dom/index,react/index,react-cache,scheduler --type=NODE\n\n# 2: Install fixture dependencies\ncd fixtures/unstable-async/time-slicing/\nyarn\n\n# 3: Copy React source code over\nyarn copy-source\n\n# 3: Run the app\nyarn start\n```\n\n----------------------------------------\n\nTITLE: Defining useFoo Hook in React with JavaScript\nDESCRIPTION: This snippet defines a custom React hook called useFoo, which is designed to demonstrate and address scoping issues in a functional component. Dependencies include React's useCallback and a custom Stringify component from a shared runtime. The hook takes two parameters, arr1 and arr2, and returns a JSX component that utilizes a memoized getVal function.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useCallback-reordering-depslist-assignment.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useCallback} from 'react';\nimport {Stringify} from 'shared-runtime';\n\n// We currently produce invalid output (incorrect scoping for `y` declaration)\nfunction useFoo(arr1, arr2) {\n  const x = [arr1];\n\n  let y;\n  const getVal = useCallback(() => {\n    return {y};\n  }, [((y = x.concat(arr2)), y)]);\n\n  return <Stringify getVal={getVal} shouldInvokeFns={true} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [\n    [1, 2],\n    [3, 4],\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiled Version of 'useFoo' React Hook in JavaScript\nDESCRIPTION: This snippet shows the compiled version of the 'useFoo' React hook. It includes optimizations for memoization and early returns. The code uses a compiler runtime and maintains the same functionality as the original implementation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-in-nested-scope.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { mutate, setProperty, throwErrorWithMessageIf } from \"shared-runtime\";\n\nfunction useFoo(t0) {\n  const $ = _c(6);\n  const { value, cond } = t0;\n  let t1;\n  let y;\n  if ($[0] !== cond || $[1] !== value) {\n    t1 = Symbol.for(\"react.early_return_sentinel\");\n    bb0: {\n      y = [value];\n      let x;\n      if ($[4] !== cond) {\n        x = { cond };\n        try {\n          mutate(x);\n          throwErrorWithMessageIf(x.cond, \"error\");\n        } catch {\n          setProperty(x, \"henderson\");\n          t1 = x;\n          break bb0;\n        }\n\n        setProperty(x, \"nevada\");\n        $[4] = cond;\n        $[5] = x;\n      } else {\n        x = $[5];\n      }\n      y.push(x);\n    }\n    $[0] = cond;\n    $[1] = value;\n    $[2] = t1;\n    $[3] = y;\n  } else {\n    t1 = $[2];\n    y = $[3];\n  }\n  if (t1 !== Symbol.for(\"react.early_return_sentinel\")) {\n    return t1;\n  }\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ value: 4, cond: true }],\n  sequentialRenders: [\n    { value: 4, cond: true },\n    { value: 5, cond: true },\n    { value: 5, cond: false },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Integrating Structural Checks in React Component - JavaScript\nDESCRIPTION: This enhanced snippet incorporates structural checks within a React Component to facilitate debugging by tracking changes and caching results to prevent unnecessary recalculations. It employs $structuralCheck and compiler runtime functions to handle these checks, improving component performance during state transitions.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useState-and-other-hook-unpruned-dependency.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { $structuralCheck } from \"react-compiler-runtime\";\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useState } from \"react\"; // @enableChangeDetectionForDebugging\n\nfunction useOther(x) {\n  return x;\n}\n\nfunction Component(props) {\n  const $ = _c(4);\n  let t0;\n  {\n    t0 = f(props.x);\n    let condition = $[0] !== props.x;\n    if (!condition) {\n      let old$t0 = $[1];\n      $structuralCheck(old$t0, t0, \"t0\", \"Component\", \"cached\", \"(8:8)\");\n    }\n    $[0] = props.x;\n    $[1] = t0;\n    if (condition) {\n      t0 = f(props.x);\n      $structuralCheck($[1], t0, \"t0\", \"Component\", \"recomputed\", \"(8:8)\");\n      t0 = $[1];\n    }\n  }\n  const w = t0;\n  const z = useOther(w);\n  const [x] = useState(z);\n  let t1;\n  {\n    t1 = <div>{x}</div>;\n    let condition = $[2] !== x;\n    if (!condition) {\n      let old$t1 = $[3];\n      $structuralCheck(old$t1, t1, \"t1\", \"Component\", \"cached\", \"(11:11)\");\n    }\n    $[2] = x;\n    $[3] = t1;\n    if (condition) {\n      t1 = <div>{x}</div>;\n      $structuralCheck($[3], t1, \"t1\", \"Component\", \"recomputed\", \"(11:11)\");\n      t1 = $[3];\n    }\n  }\n  return t1;\n}\n\nfunction f(x) {\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ x: 42 }],\n  isComponent: true,\n};\n\n```\n\n----------------------------------------\n\nTITLE: Optimizing useFoo Hook in React with JavaScript\nDESCRIPTION: This snippet further optimizes the previously defined useFoo hook by introducing conditionally memoized values and a cache mechanism using arrays. It aims to fix the scoping issues noted in the prior implementation, utilizing a custom compiler runtime function and maintaining the same dependencies and input/output structure.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useCallback-reordering-depslist-assignment.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useCallback } from \"react\";\nimport { Stringify } from \"shared-runtime\";\n\n// We currently produce invalid output (incorrect scoping for `y` declaration)\nfunction useFoo(arr1, arr2) {\n  const $ = _c(5);\n  let t0;\n  if ($[0] !== arr1 || $[1] !== arr2) {\n    const x = [arr1];\n\n    let y;\n    t0 = () => ({ y });\n\n    (y = x.concat(arr2)), y;\n    $[0] = arr1;\n    $[1] = arr2;\n    $[2] = t0;\n  } else {\n    t0 = $[2];\n  }\n  const getVal = t0;\n  let t1;\n  if ($[3] !== getVal) {\n    t1 = <Stringify getVal={getVal} shouldInvokeFns={true} />;\n    $[3] = getVal;\n    $[4] = t1;\n  } else {\n    t1 = $[4];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [\n    [1, 2],\n    [3, 4],\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Implementing useFoo with React Compiler Runtime\nDESCRIPTION: This snippet implements the useFoo function utilizing React's compiler runtime for optimized evaluation. Similar to the previous snippet, it deals with handling conditional dependencies and optional chains. It imports identity from shared-runtime and utilizes a caching mechanism to avoid redundant calculations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/edge-case-merge-uncond-optional-chain-and-cond.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { identity } from \"shared-runtime\";\n\n/**\n * Evaluator failure:\n * Found differences in evaluator results\n *   Non-forget (expected):\n *   (kind: ok) {}\n *   [[ (exception in render) TypeError: Cannot read properties of null (reading 'title_text') ]]\n *   Forget:\n *   (kind: ok) {}\n *   {}\n */\n/**\n * Very contrived text fixture showing that it's technically incorrect to merge\n * a conditional dependency (e.g. dep.path in `cond ? dep.path : ...`) and an\n * unconditionally evaluated optional chain (`dep?.path`).\n *\n *\n * when screen is non-null, useFoo returns { title: null } or \"(not null)\"\n * when screen is null, useFoo throws\n */\nfunction useFoo(t0) {\n  const $ = _c(2);\n  const { screen } = t0;\n  let t1;\n  if ($[0] !== screen) {\n    t1 =\n      screen?.title_text != null\n        ? \"(not null)\"\n        : identity({ title: screen.title_text });\n    $[0] = screen;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ screen: null }],\n  sequentialRenders: [{ screen: { title_bar: undefined } }, { screen: null }],\n};\n```\n\n----------------------------------------\n\nTITLE: Validating Ref Access During Render in React - JavaScript\nDESCRIPTION: This code demonstrates a React component using hooks to validate ref access during rendering. The Component function uses useRef to hold a mutable value updated within a useEffect hook, forcing a re-render and checking ref updates. The example illustrates how state changes trigger effects and check the impact of ref updates.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-ref-access-in-effect.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validateRefAccessDuringRender\nimport {useEffect, useRef, useState} from 'react';\n\nfunction Component() {\n  const ref = useRef(null);\n  const [state, setState] = useState(false);\n  useEffect(() => {\n    ref.current = 'Ok';\n  }, []);\n\n  useEffect(() => {\n    setState(true);\n  }, []);\n\n  // We use state to force a re-render and observe whether the\n  // ref updated. This lets us check that the effect actually ran\n  // and wasn't DCE'd\n  return <Child key={String(state)} ref={ref} />;\n}\n\nfunction Child({ref}) {\n  // This violates the rules of React, so we access the ref in a child\n  // component\n  return ref.current;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Component State Management with Shared Runtime and JavaScript\nDESCRIPTION: Defines and executes a function `Component` that utilizes shared runtime for state mutation. Dependencies include `mutate` from 'shared-runtime'. It initializes component state, applies mutations, and exports an entry point with function parameters for testing. The function manipulates objects and tracks state changes based on `a`. Input is a parameter object. Output is a mutated state object.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-alias-receiver-computed-mutate.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {mutate} from 'shared-runtime';\n\nfunction Component({a}) {\n  let x = {a};\n  let y = {};\n  const f0 = function () {\n    let a = y;\n    a['x'] = x;\n  };\n  f0();\n  mutate(y);\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{a: 2}],\n  sequentialRenders: [{a: 2}, {a: 2}, {a: 3}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Handling Component Error in React\nDESCRIPTION: This code snippet provides an error message associated with the 'Component' function, highlighting an invariant violation due to an improper reference to a const declaration. It indicates that certain coding practices should be adhered to prevent runtime issues.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.call-args-destructuring-asignment-complex.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n  1 | function Component(props) {\n  2 |   let x = makeObject();\n> 3 |   x.foo(([[x]] = makeObject()));\n    |          ^^^^^ Invariant: Const declaration cannot be referenced as an expression (3:3)\n  4 |   return x;\n  5 | }\n  6 |\n\n```\n\n----------------------------------------\n\nTITLE: Defining useFoo Function in React\nDESCRIPTION: This snippet defines the function useFoo which takes a screen object and returns \"(not null)\" if the title_text is non-null or uses identity when title_text is null. It demonstrates handling conditional dependencies and optional chains which can lead to errors if screen is null. Dependencies include importing identity from shared-runtime.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/edge-case-merge-uncond-optional-chain-and-cond.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {identity} from 'shared-runtime';\n\n/**\n * Evaluator failure:\n * Found differences in evaluator results\n *   Non-forget (expected):\n *   (kind: ok) {}\n *   [[ (exception in render) TypeError: Cannot read properties of null (reading 'title_text') ]]\n *   Forget:\n *   (kind: ok) {}\n *   {}\n */\n/**\n * Very contrived text fixture showing that it's technically incorrect to merge\n * a conditional dependency (e.g. dep.path in `cond ? dep.path : ...`) and an\n * unconditionally evaluated optional chain (`dep?.path`).\n *\n *\n * when screen is non-null, useFoo returns { title: null } or \"(not null)\"\n * when screen is null, useFoo throws\n */\nfunction useFoo({screen}: {screen: null | undefined | {title_text: null}}) {\n  return screen?.title_text != null\n    ? '(not null)'\n    : identity({title: screen.title_text});\n}\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{screen: null}],\n  sequentialRenders: [{screen: {title_bar: undefined}}, {screen: null}],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component Fixture with const Variables in JavaScript\nDESCRIPTION: Similar to the previous snippet but uses const instead of let for variable declarations. Creates a function that manipulates arrays and exports a fixture configuration for a 'TodoAdd' component with specified parameters.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/overlapping-scopes-interleaved.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(a, b) {\n  const x = [];\n  const y = [];\n  x.push(a);\n  y.push(b);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Input Fixture: React Component with Conditional Rendering\nDESCRIPTION: A basic React component demonstrating a simple implementation with an early return condition and fallback logic using makeArray\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/early-return-no-declarations-reassignments-dependencies.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {makeArray} from 'shared-runtime';\n\nlet ENABLE_FEATURE = false;\n\nfunction Component(props) {\n  let x = [];\n  if (ENABLE_FEATURE) {\n    x.push(42);\n    return x;\n  } else {\n    console.log('fallthrough');\n  }\n  return makeArray(props.a);\n}\n```\n\n----------------------------------------\n\nTITLE: React Component Definition with Conditional Logic\nDESCRIPTION: This code defines a functional React component that receives `props` as input. It declares a variable `x`, then uses a ternary operator to assign a value to `x` based on the value of `props.cond`. If `props.cond` is truthy, `x` is assigned 1, otherwise it's assigned 2. The component returns the value of `x`.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unused-logical.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let x;\n  props.cond ? (x = 1) : (x = 2);\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining Function Foo with Conditionals and Object Mutation - JavaScript\nDESCRIPTION: This snippet defines a function named 'Foo'. The function initializes a variable 'thing' and conditionally assigns it a value based on 'cond'. If 'CONST_TRUE' is true, it mutates 'thing' before returning. The function is designed to handle exceptions silently. Required dependencies include 'CONST_TRUE' and 'makeObject_Primitives' from 'shared-runtime'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/align-scopes-trycatch-nested-overlapping-range.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {CONST_TRUE, makeObject_Primitives} from 'shared-runtime';\n\nfunction Foo() {\n  try {\n    let thing = null;\n    if (cond) {\n      thing = makeObject_Primitives();\n    }\n    if (CONST_TRUE) {\n      mutate(thing);\n    }\n    return thing;\n  } catch {}\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component Using React Compiler Runtime in JavaScript\nDESCRIPTION: This JavaScript snippet optimizes the 'component' function with the help of React's compiler runtime. It uses the '_c' function to create compiler-specific optimizations by managing state changes efficiently with a tuple '$'. The code exports the component using a consistent fixture entry point object suitable for adding to a React project. This snippet requires the React compiler runtime for its execution.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-within-block.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction component(a) {\n  const $ = _c(4);\n  let t0;\n  if ($[0] !== a) {\n    t0 = { a };\n    $[0] = a;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const z = t0;\n  let x;\n  let t1;\n  if ($[2] !== z) {\n    t1 = function () {\n      console.log(z);\n    };\n    $[2] = z;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  x = t1;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Compiler Runtime\nDESCRIPTION: This snippet shows an optimized version of the React component using compiler runtime techniques. It includes memoization and conditional rendering to improve performance. The component's logic remains the same, but its implementation is more efficient.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructure-array-declaration-to-context-var.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { identity } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(4);\n  let x;\n  if ($[0] !== props.value) {\n    const [t0] = props.value;\n    x = t0;\n    const foo = () => {\n      x = identity(props.value[0]);\n    };\n\n    foo();\n    $[0] = props.value;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  let t0;\n  if ($[2] !== x) {\n    t0 = <div>{x}</div>;\n    $[2] = x;\n    $[3] = t0;\n  } else {\n    t0 = $[3];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ value: [42] }],\n};\n```\n\n----------------------------------------\n\nTITLE: React Compiler Error: Cannot Infer Effect Dependencies\nDESCRIPTION: This error message indicates that React Compiler is unable to determine the dependencies of the `useSpecialEffect` hook. This typically occurs when the dependencies are dynamically calculated or when the compiler encounters complex control flow. The error suggests either providing a manual dependency array or resolving the compiler bailout diagnostics.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/bailout-retry/error.todo-infer-deps-on-retry.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n  11 |   const ref = useRef();\n  12 |   const derived = cond ? ref.current : makeObject();\n> 13 |   useSpecialEffect(() => {\n     |   ^^^^^^^^^^^^^^^^^^^^^^^^\n> 14 |     log(derived);\n     | ^^^^^^^^^^^^^^^^^\n> 15 |   }, [derived]);\n     | ^^^^^^^^^^^^^^^^ InvalidReact: [InferEffectDependencies] React Compiler is unable to infer dependencies of this effect. This will break your build! To resolve, either pass your own dependency array or fix reported compiler bailout diagnostics.. (Bailout reason: Invariant: Expected function expression scope to exist (13:15)) (13:15)\n  16 |   return ref;\n  17 | }\n  18 |\n\n```\n\n----------------------------------------\n\nTITLE: Defining React Hook with Dependency Tracking\nDESCRIPTION: This snippet defines a React hook `useFoo` that takes props as input and returns an array. It utilizes conditional logic based on `props.cond` to push either `props.foo` or `props.bar` into the array. The hook is designed to showcase dependency propagation in HIR.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/ssa-renaming-unconditional-ternary.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enablePropagateDepsInHIR\nfunction useFoo(props) {\n  let x = [];\n  x.push(props.bar);\n  props.cond\n    ? ((x = {}), (x = []), x.push(props.foo))\n    : ((x = []), (x = []), x.push(props.bar));\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{cond: false, foo: 2, bar: 55}],\n  sequentialRenders: [\n    {cond: false, foo: 2, bar: 55},\n    {cond: false, foo: 3, bar: 55},\n    {cond: true, foo: 3, bar: 55},\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining Simple React Component with Object References\nDESCRIPTION: This snippet defines a simple React component that creates and manipulates object references. It also exports a FIXTURE_ENTRYPOINT object for testing or demonstration purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-test-field-store.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component() {\n  let x = {};\n  let q = {};\n  x.t = q;\n  let z = x.t;\n  return z;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Simulating Multi-touch Interactions with DOM Event Testing Library\nDESCRIPTION: This example demonstrates how to dispatch multiple pointer events to simulate multi-touch interactions. It shows activating two different pointers with unique IDs to test multi-touch gesture handling.\nSOURCE: https://github.com/facebook/react/blob/main/packages/dom-event-testing-library/README.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n// first pointer is active\ntarget.pointerdown({pointerId: 1, pointerType});\n// second pointer is active\ntarget.pointerdown({pointerId: 2, pointerType});\n```\n\n----------------------------------------\n\nTITLE: Advanced Component Definition Handling Memoization - JavaScript\nDESCRIPTION: This snippet provides a more complex React component definition that incorporates memoization to optimize rendering based on changes in props. It uses an internal cache to store previous states, thereby reducing unnecessary re-renders of child components.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/switch-non-final-default.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enablePropagateDepsInHIR\nfunction Component(props) {\n  const $ = _c(8);\n  let t0;\n  let y;\n  if ($[0] !== props.p0 || $[1] !== props.p2) {\n    const x = [];\n    bb0: switch (props.p0) {\n      case 1: {\n        break bb0;\n      }\n      case true: {\n        x.push(props.p2);\n        let t1;\n        if ($[4] === Symbol.for(\"react.memo_cache_sentinel\")) {\n          t1 = [];\n          $[4] = t1;\n        } else {\n          t1 = $[4];\n        }\n        y = t1;\n      }\n      default: {\n        break bb0;\n      }\n      case false: {\n        y = x;\n      }\n    }\n\n    t0 = <Component data={x} />;\n    $[0] = props.p0;\n    $[1] = props.p2;\n    $[2] = t0;\n    $[3] = y;\n  } else {\n    t0 = $[2];\n    y = $[3];\n  }\n  const child = t0;\n  y.push(props.p4);\n  let t1;\n  if ($[5] !== child || $[6] !== y) {\n    t1 = <Component data={y}>{child}</Component>;\n    $[5] = child;\n    $[6] = y;\n    $[7] = t1;\n  } else {\n    t1 = $[7];\n  }\n  return t1;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Modifying Props in a React Component\nDESCRIPTION: This JavaScript function iterates over the items passed in as props and attempts to modify each item directly by setting its 'modified' property to true. This operation is against React's practice of keeping props immutable, which can lead to unexpected behavior and errors.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-mutate-props-via-for-of-iterator.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const items = [];\n  for (const x of props.items) {\n    x.modified = true;\n    items.push(x);\n  }\n  return items;\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional Parameter Assignment Function\nDESCRIPTION: A JavaScript function that conditionally assigns a value based on multiple input parameters. The function takes three parameters and returns a value depending on the truthiness of parameters b and c.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-nested-partial-phi.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(a, b, c) {\n  let x = a;\n  if (b) {\n    if (c) {\n      x = c;\n    }\n    return x;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Fixture for React Hook Testing\nDESCRIPTION: This snippet exports a fixture object 'FIXTURE_ENTRYPOINT' for testing the 'useFoo' hook. It includes the hook function, initial parameters, and a sequence of renders with different prop values.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/global-types/set-for-of-iterate-values.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{propArr: [7, 8, 9]}],\n  sequentialRenders: [\n    {propArr: [7, 8, 9]},\n    {propArr: [7, 8, 9]},\n    {propArr: [7, 8, 10]},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Rendering Dynamic React Component with Hooks\nDESCRIPTION: Creates a component that generates list items dynamically from input props, using a custom hook and onClick handlers\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-for-in-loop-with-context-variable-iterator.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useHook} from 'shared-runtime';\n\nfunction Component(props) {\n  const data = useHook();\n  const items = [];\n  // NOTE: `item` is a context variable because it's reassigned and also referenced\n  // within a closure, the `onClick` handler of each item\n  for (let key in props.data) {\n    key = key ?? null; // no-op reassignment to force a context variable\n    items.push(\n      <div key={key} onClick={() => data.set(key)}>\n        {key}\n      </div>\n    );\n  }\n  return <div>{items}</div>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{data: {a: 'a', b: true, c: 'hello'}}],\n};\n```\n\n----------------------------------------\n\nTITLE: Error Message for Local FBT Variable\nDESCRIPTION: This error message indicates that there is an issue with using a local variable named 'fbt'. It suggests that support for such variables needs to be implemented or handled differently.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/error.todo-locally-require-fbt.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n  1 | function Component(props) {\n> 2 |   const fbt = require('fbt');\n    |         ^^^ Todo: Support local variables named \"fbt\" (2:2)\n  3 |\n  4 |   return <fbt desc=\"Description\">{'Text'}</fbt>;\n  5 | }\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Local State\nDESCRIPTION: This snippet defines a React component that initializes a local variable 'x' through a function call. It demonstrates basic component structure and local state management.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/declare-reassign-variable-in-closure.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(p) {\n  let x;\n  const foo = () => {\n    x = {};\n  };\n  foo();\n\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Importing and Defining Helper Functions for Fixtures\nDESCRIPTION: Example showing how to import shared helper functions or define custom helpers within a fixture file. Custom helpers can use the \"use no forget\" directive to exempt them from transformation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/snap/src/sprout/README.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n// test.js\nimport { addOne } from 'shared-runtime';\n\nfunction customHelper(val1, val2) {\n  // This directive is important, as helper functions don't\n  // always follow the rules of React.\n  \"use no forget\";\n  // ...\n}\n\n// ...\n```\n\n----------------------------------------\n\nTITLE: Compiled: React Component with Compiler Runtime\nDESCRIPTION: The compiled version of the component that includes the React compiler runtime. It shows how the component is transformed with additional caching logic for performance optimization while maintaining the same functionality.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reanimated-shared-value-writes.expect.md#2025-04-22_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enableCustomTypeDefinitionForReanimated\nimport { useSharedValue } from \"react-native-reanimated\";\n\n/**\n * https://docs.swmansion.com/react-native-reanimated/docs/2.x/api/hooks/useSharedValue/\n *\n * Test that shared values are treated as ref-like, i.e. allowing writes outside\n * of render\n */\nfunction SomeComponent() {\n  const $ = _c(2);\n  const sharedVal = useSharedValue(0);\n  let t0;\n  if ($[0] !== sharedVal) {\n    t0 = (\n      <Button\n        onPress={() => (sharedVal.value = Math.random())}\n        title=\"Randomize\"\n      />\n    );\n    $[0] = sharedVal;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Memoized Component in React\nDESCRIPTION: This snippet illustrates the creation of a memoized functional component in React that uses the useMemo hook to efficiently manage object states based on props. It imports required functions from 'shared-runtime' to handle object creation and mutations. The object returned from the component is memoized based on the input value, optimizing rendering performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-mabye-modified-free-variable-dont-preserve-memoization-guarantees.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enablePreserveExistingMemoizationGuarantees:false\nimport {useMemo} from 'react';\nimport {identity, makeObject_Primitives, mutate, useHook} from 'shared-runtime';\n\nfunction Component(props) {\n  // With the feature disabled these variables are inferred as being mutated inside the useMemo block\n  const free = makeObject_Primitives();\n  const free2 = makeObject_Primitives();\n  const part = free2.part;\n\n  // This causes their range to extend to include this hook call, and in turn for the memoization to be pruned\n  useHook();\n  const object = useMemo(() => {\n    const x = makeObject_Primitives();\n    x.value = props.value;\n    mutate(x, free, part);\n    return x;\n  }, [props.value]);\n\n  identity(free);\n  identity(part);\n  return object;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: 42}],\n};\n```\n\nLANGUAGE: javascript\nCODE:\n```\n// @enablePreserveExistingMemoizationGuarantees:false\nimport { useMemo } from \"react\";\nimport {\n  identity,\n  makeObject_Primitives,\n  mutate,\n  useHook,\n} from \"shared-runtime\";\n\nfunction Component(props) {\n  const free = makeObject_Primitives();\n  const free2 = makeObject_Primitives();\n  const part = free2.part;\n\n  useHook();\n  let t0;\n\n  const x = makeObject_Primitives();\n  x.value = props.value;\n  mutate(x, free, part);\n  t0 = x;\n  const object = t0;\n\n  identity(free);\n  identity(part);\n  return object;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ value: 42 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Conditional Symbol and Identity Handling in React - JavaScript\nDESCRIPTION: Implements 'useFoo' with additional logic for optimizations using symbols and compiler runtime integration. It handles state changes to prevent redundant computations, checking conditions against precalculated states. The snippet uses symbols 'react.early_return_sentinel' for control flow. Parameters include an object with 'input' and 'cond', outputting conditional results based on render sequences.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-poisoned/return-poisons-outer-scope.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { identity } from \"shared-runtime\";\n\nfunction useFoo(t0) {\n  const $ = _c(6);\n  const { input, cond } = t0;\n  let t1;\n  let x;\n  if ($[0] !== cond || $[1] !== input) {\n    t1 = Symbol.for(\"react.early_return_sentinel\");\n    bb0: {\n      x = [];\n      if (cond) {\n        t1 = null;\n        break bb0;\n      }\n      let t2;\n      if ($[4] !== input.a.b) {\n        t2 = identity(input.a.b);\n        $[4] = input.a.b;\n        $[5] = t2;\n      } else {\n        t2 = $[5];\n      }\n      x.push(t2);\n    }\n    $[0] = cond;\n    $[1] = input;\n    $[2] = t1;\n    $[3] = x;\n  } else {\n    t1 = $[2];\n    x = $[3];\n  }\n  if (t1 !== Symbol.for(\"react.early_return_sentinel\")) {\n    return t1;\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ input: { a: { b: 2 } }, cond: false }],\n  sequentialRenders: [\n    { input: { a: { b: 2 } }, cond: false },\n    // preserve nullthrows\n    { input: null, cond: false },\n    { input: null, cond: true },\n    { input: {}, cond: false },\n    { input: { a: { b: null } }, cond: false },\n    { input: { a: null }, cond: false },\n    { input: { a: { b: 3 } }, cond: false },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization Implementation\nDESCRIPTION: This snippet shows the compiled version of the React component, implementing memoization using React's compiler runtime. It uses a Symbol-based cache to store and retrieve the computed object.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/merge-consecutive-scopes-no-deps.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nconst { getNumber } = require(\"shared-runtime\");\n\nfunction Component(props) {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = { session_id: getNumber() };\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing a React Test Fixture with Conditional Logic\nDESCRIPTION: A JavaScript function with conditional logic that modifies variables based on conditions, along with an exported FIXTURE_ENTRYPOINT configuration that defines test parameters.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-complex-multiple-if.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo() {\n  let x = 1;\n  let y = 2;\n  if (y === 2) {\n    x = 3;\n  }\n\n  if (y === 3) {\n    x = 5;\n  }\n  y = x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Compiler Runtime\nDESCRIPTION: This snippet shows an optimized version of the React component using the compiler-runtime. It implements memoization to avoid unnecessary re-renders and uses a more efficient rendering approach.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-in-statement.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== props) {\n    const items = [];\n    for (const key in props) {\n      items.push(<div key={key}>{key}</div>);\n    }\n\n    t0 = <div>{items}</div>;\n    $[0] = props;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ hello: null, world: undefined, \"!\": true }],\n  sequentialRenders: [\n    { a: null, b: null, c: null },\n    { lauren: true, mofei: true, sathya: true, jason: true },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with Selective Memoization in JavaScript/JSX\nDESCRIPTION: This snippet defines a React component named TestComponent that uses selective memoization. It demonstrates the use of 'use no memo' directive at the file level and 'use memo' directive within the component to control rendering optimization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/apps/playground/__tests__/e2e/__snapshots__/page.spec.ts/todo-function-scope-does-not-beat-module-scope-output.txt#2025-04-21_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\n\"use no memo\";\nfunction TestComponent({ x }) {\n  \"use memo\";\n  return <Button>{x}</Button>;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Advanced React Component with Memoization\nDESCRIPTION: This code snippet defines a more complex version of a React functional component that employs memoization techniques to ensure optimal performance through conditional rendering based on state values. It checks whether the current props.count matches the stored value, resulting in either the reuse of existing elements or the creation of new ones. This component also requires the 'react/compiler-runtime' and 'shared-runtime' as dependencies. The inputs are props with a count property, resulting in a rendered React element in the form of a div containing dynamic content.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/dont-merge-overlapping-scopes-with-intermediate-reassignment.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { Stringify } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(7);\n  let x;\n  let t0;\n  if ($[0] !== props.count) {\n    t0 = [props.count];\n    $[0] = props.count;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const array = t0;\n  x = array;\n  let t1;\n  if ($[2] !== array) {\n    t1 = <div>{array}</div>;\n    $[2] = array;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  const element = t1;\n  let t2;\n  if ($[4] !== element || $[5] !== x) {\n    t2 = (\n      <div>\n        {element}\n        {x}\n      </div>\n    );\n    $[4] = element;\n    $[5] = x;\n    $[6] = t2;\n  } else {\n    t2 = $[6];\n  }\n  return t2;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ count: 42 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Input: Lambda Functions with Array Mapping in React\nDESCRIPTION: Original React code that demonstrates how lambdas are handled when passed to array.map. It shows a scenario where getVal1 has a known callsite in cb1, but cb1 is only passed to array.map rather than being directly called.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/array-map-named-chained-callbacks.expect.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n/**\n * Forked from array-map-simple.js\n *\n * Here, getVal1 has a known callsite in `cb1`, but `cb1` isn't known to be\n * called (it's only passed to array.map). In this case, we should be\n * conservative and assume that all named lambdas are conditionally called.\n */\nfunction useFoo({arr1, arr2}) {\n  const getVal1 = () => arr1[0].value;\n  const cb1 = e => getVal1() + e.value;\n  const x = arr1.map(cb1);\n  const getVal2 = () => arr2[0].value;\n  const cb2 = e => getVal2() + e.value;\n  const y = arr1.map(cb2);\n  return [x, y];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{arr1: [], arr2: []}],\n  sequentialRenders: [\n    {arr1: [], arr2: []},\n    {arr1: [], arr2: null},\n    {arr1: [{value: 1}, {value: 2}], arr2: [{value: -1}]},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Compiler Runtime\nDESCRIPTION: Enhanced version of the component using React compiler runtime for memoization, with conditional state updates and object manipulation\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-alias-computed-mutate.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { mutate } from \"shared-runtime\";\nfunction Component(t0) {\n  const $ = _c(2);\n  const { a } = t0;\n  let y;\n  if ($[0] !== a) {\n    const x = { a };\n    y = {};\n    const f0 = function () {\n      y.x = x;\n    };\n\n    f0();\n    mutate(y);\n    $[0] = a;\n    $[1] = y;\n  } else {\n    y = $[1];\n  }\n  return y;\n}\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Compiler-Runtime and Memoization\nDESCRIPTION: This snippet shows an optimized version of the component using React's compiler-runtime. It implements memoization for better performance and separates the onEvent function into a standalone _temp function.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/constant-propagation-into-function-expressions.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { Stringify, identity } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(1);\n\n  const onEvent = _temp;\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = <Stringify onEvent={onEvent} shouldInvokeFns={true} />;\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\nfunction _temp() {\n  return identity(42);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n  sequentialRenders: [{}, {}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Complex Logic\nDESCRIPTION: This code defines a React functional component named `MyComponent` that includes a significant number of conditional statements (`if/else`) and React hooks (`useHook`). The purpose is to simulate a component with high complexity, making it harder to compute efficiently. The function `useHook` is assumed to be a predefined or imported hook.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-c1e8c7f4c191.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Is valid but hard to compute by brute-forcing\nfunction MyComponent() {\n  // 40 conditions\n  if (c) {\n  } else {\n  }\n  if (c) {\n  } else {\n  }\n  if (c) {\n  } else {\n  }\n  if (c) {\n  } else {\n  }\n  if (c) {\n  } else {\n  }\n  if (c) {\n  } else {\n  }\n  if (c) {\n  } else {\n  }\n  if (c) {\n  } else {\n  }\n  if (c) {\n  } else {\n  }\n  if (c) {\n  } else {\n  }\n  if (c) {\n  } else {\n  }\n  if (c) {\n  } else {\n  }\n  if (c) {\n  } else {\n  }\n  if (c) {\n  } else {\n  }\n  if (c) {\n  } else {\n  }\n  if (c) {\n  } else {\n  }\n  if (c) {\n  } else {\n  }\n  if (c) {\n  } else {\n  }\n  if (c) {\n  } else {\n  }\n  if (c) {\n  } else {\n  }\n  if (c) {\n  } else {\n  }\n  if (c) {\n  } else {\n  }\n  if (c) {\n  } else {\n  }\n  if (c) {\n  } else {\n  }\n  if (c) {\n  } else {\n  }\n  if (c) {\n  } else {\n  }\n  if (c) {\n  } else {\n  }\n  if (c) {\n  } else {\n  }\n  if (c) {\n  } else {\n  }\n  if (c) {\n  } else {\n  }\n\n  // 10 hooks\n  useHook();\n  useHook();\n  useHook();\n  useHook();\n  useHook();\n  useHook();\n  useHook();\n  useHook();\n  useHook();\n  useHook();\n}\n\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component Rendering with Compiler Runtime in JavaScript\nDESCRIPTION: This code represents a compiler-generated optimized version of the previous React component definitions, aiming at reducing unnecessary re-renders using caching/indexing techniques. It relies on the \\'react/compiler-runtime\\' module, enhancing performance for dynamic React component rendering. Each functional React component includes indexed change detection, minimizing update processing and memory allocation. Inputs mirror the initial component interface, focused on enhanced rendering efficiency.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-outlining-with-non-jsx-children.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enableJsxOutlining\nfunction Component(t0) {\n  const $ = _c(7);\n  const { arr } = t0;\n  const x = useX();\n  let t1;\n  if ($[0] !== arr || $[1] !== x) {\n    let t2;\n    if ($[3] !== x) {\n      t2 = (i, id) => {\n        const t3 = \"Test\";\n        const T0 = _temp;\n        return <T0 i={i} t={t3} k={i} key={id} x={x} />;\n      };\n      $[3] = x;\n      $[4] = t2;\n    } else {\n      t2 = $[4];\n    }\n    t1 = arr.map(t2);\n    $[0] = arr;\n    $[1] = x;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  let t2;\n  if ($[5] !== t1) {\n    t2 = <>{t1}</>;\n    $[5] = t1;\n    $[6] = t2;\n  } else {\n    t2 = $[6];\n  }\n  return t2;\n}\nfunction _temp(t0) {\n  const $ = _c(9);\n  const { i: i, t: t, k: k, x: x } = t0;\n  let t1;\n  if ($[0] !== i || $[1] !== t) {\n    t1 = <Baz i={i}>{t}</Baz>;\n    $[0] = i;\n    $[1] = t;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  let t2;\n  if ($[3] !== k) {\n    t2 = <Foo k={k} />;\n    $[3] = k;\n    $[4] = t2;\n  } else {\n    t2 = $[4];\n  }\n  let t3;\n  if ($[5] !== t1 || $[6] !== t2 || $[7] !== x) {\n    t3 = (\n      <Bar x={x}>\n        {t1}\n        {t2}\n      </Bar>\n    );\n    $[5] = t1;\n    $[6] = t2;\n    $[7] = x;\n    $[8] = t3;\n  } else {\n    t3 = $[8];\n  }\n  return t3;\n}\n\nfunction Bar(t0) {\n  const $ = _c(3);\n  const { x, children } = t0;\n  let t1;\n  if ($[0] !== children || $[1] !== x) {\n    t1 = (\n      <>\n        {x}\n        {children}\n      </>\n    );\n    $[0] = children;\n    $[1] = x;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  return t1;\n}\n\nfunction Baz(t0) {\n  const $ = _c(3);\n  const { i, children } = t0;\n  let t1;\n  if ($[0] !== children || $[1] !== i) {\n    t1 = (\n      <>\n        {i}\n        {children}\n      </>\n    );\n    $[0] = children;\n    $[1] = i;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  return t1;\n}\n\nfunction Foo(t0) {\n  const { k } = t0;\n  return k;\n}\n\nfunction useX() {\n  return \"x\";\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ arr: [\"foo\", \"bar\"] }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Error-Handled React Component in JavaScript\nDESCRIPTION: This snippet defines a React component 'useFoo' that safely handles potential null values and uses a try-catch block for error handling. It also includes a fixture for testing with various input scenarios.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-maybe-null-dependency.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {identity} from 'shared-runtime';\n\n/**\n * Not safe to hoist read of maybeNullObject.value.inner outside of the\n * try-catch block, as that might throw\n */\nfunction useFoo(maybeNullObject: {value: {inner: number}} | null) {\n  const y = [];\n  try {\n    y.push(identity(maybeNullObject.value.inner));\n  } catch {\n    y.push('null');\n  }\n\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [null],\n  sequentialRenders: [null, {value: 2}, {value: 3}, null],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with Compiler Runtime Integration in JavaScript\nDESCRIPTION: This snippet showcases a React component that utilizes the react/compiler-runtime to achieve memoization. It imports a specific part of the compiler-runtime and utilizes symbols to cache frequently used values. It effectively optimizes state management by introducing memo cache sentinels and maintains it within the scope of the React component. This advanced implementation requires understanding of React\\'s memoization mechanism.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/globals-Boolean.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = {};\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const x = t0;\n  const y = Boolean(x);\n  let t1;\n  if ($[1] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = [x, y];\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n\n```\n\n----------------------------------------\n\nTITLE: Using Memoization for Caching Props in React (JavaScript)\nDESCRIPTION: This code snippet defines a React functional component that utilizes the 'useMemoCache' hook to cache the incoming 'props.value'. If the cached value is undefined, it initializes the cache with the new value. The memoized result is returned, which helps optimize component rendering by preventing unnecessary re-computation of prop values.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/skip-useMemoCache.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {c as useMemoCache} from 'react/compiler-runtime';\n\nfunction Component(props) {\n  const $ = useMemoCache();\n  let x;\n  if ($[0] === undefined) {\n    x = [props.value];\n    $[0] = x;\n  } else {\n    x = $[0];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: 42}],\n};\n```\n\n----------------------------------------\n\nTITLE: Managing Input with Identity Function in JavaScript\nDESCRIPTION: This snippet defines the function useFoo, which processes an input object to produce an array based on certain conditions and using an identity function. It checks for the presence of properties inputHasAB and inputHasABC, processes the input accordingly, and either returns null or an array constructed using the identity function. It requires 'shared-runtime' package for the identity function and inputs with specific properties to operate correctly.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/reduce-if-exhaustive-poisoned-deps.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {identity} from 'shared-runtime';\n\nfunction useFoo({input, inputHasAB, inputHasABC}) {\n  const x = [];\n  if (!inputHasABC) {\n    x.push(identity(input.a));\n    if (!inputHasAB) {\n      return null;\n    }\n    x.push(identity(input.a.b));\n  } else {\n    x.push(identity(input.a.b.c));\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{input: {b: 1}, inputHasAB: false, inputHasABC: false}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: JavaScript Hoisting Example\nDESCRIPTION: This code snippet demonstrates variable hoisting in JavaScript. The function `hoisting` attempts to use `bar` and `baz` within the function `foo` before they are declared. Due to hoisting, this code will run without errors, but might exhibit unexpected behaviour if `bar` and `baz` are not initialized before `foo` is called.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-simple-const-declaration.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n```javascript\nfunction hoisting() {\n  const foo = () => {\n    return bar + baz;\n  };\n  const bar = 3;\n  const baz = 2;\n  return foo(); // OK: called outside of TDZ for bar/baz\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: hoisting,\n  params: [],\n  isComponent: false,\n};\n\n```\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: Compiled version of the React component with added memoization logic using the compiler runtime. Includes caching mechanisms to optimize performance by avoiding unnecessary recomputation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-annotations/type-annotation-var-array.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enableUseTypeAnnotations\nfunction Component(props) {\n  const $ = _c(4);\n  let t0;\n  if ($[0] !== props.id) {\n    t0 = makeArray(props.id);\n    $[0] = props.id;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const x = t0;\n  let t1;\n  if ($[2] !== x) {\n    t1 = x.at(0);\n    $[2] = x;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  const y = t1;\n  return y;\n}\n\nfunction makeArray(x) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== x) {\n    t0 = [x];\n    $[0] = x;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ id: 42 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Flow and Default Array Destructuring\nDESCRIPTION: This snippet defines a React component using Flow type annotations. It demonstrates default array destructuring in the component's props. The component extracts an array from props.y with a default empty array of numbers.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-with-typecast-as-default-value.flow.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @flow\nfunction Component(props) {\n  const [x = ([]: Array<number>)] = props.y;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{y: []}],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Memoization\nDESCRIPTION: This snippet shows the optimized version of the Component after React compilation. It uses memoization to avoid unnecessary re-renders and optimizes the component's logic for better performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-reference-changes-type.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { mutate } from \"shared-runtime\";\nfunction Component(t0) {\n  const $ = _c(2);\n  const { a } = t0;\n  let y;\n  if ($[0] !== a) {\n    const x = { a };\n    y = 1;\n\n    y = x;\n\n    mutate(y);\n    $[0] = a;\n    $[1] = y;\n  } else {\n    y = $[1];\n  }\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ a: 2 }],\n  sequentialRenders: [{ a: 2 }, { a: 2 }, { a: 3 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic React Component in JavaScript\nDESCRIPTION: This snippet defines a simple React component function using JavaScript. It creates an object and applies a function on the same object, showcasing basic component structure. No special dependencies are required beyond standard JavaScript and React.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/call-args-assignment.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nfunction Component(props) {\n  let x = makeObject();\n  x.foo((x = makeObject()));\n  return x;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Initializing React Component with idx in JavaScript\nDESCRIPTION: This snippet showcases a basic React component that uses the `idx` library to safely access deeply nested properties. It uses a lambda function to avoid outlining. The component displays a group label if available. Dependencies include React and the `idx` package.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/idx-no-outlining.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @customMacros(idx)\nimport idx from 'idx';\n\nfunction Component(props) {\n  // the lambda should not be outlined\n  const groupName = idx(props, _ => _.group.label);\n  return <div>{groupName}</div>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiler-Optimized Version of the Callback Hook\nDESCRIPTION: The compiled version of the useMakeCallback hook, which includes automatic memoization using React's compiler runtime. It caches the callback based on dependencies (obj.value and setState) to avoid unnecessary rerenders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/assume-invoked/hook-call.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { createHookWrapper, useIdentity } from \"shared-runtime\";\n\n/**\n * Assume that functions passed hook arguments are invoked and that their\n * property loads are hoistable.\n */\nfunction useMakeCallback(t0) {\n  const $ = _c(3);\n  const { obj, setState } = t0;\n  let t1;\n  if ($[0] !== obj.value || $[1] !== setState) {\n    t1 = () => setState(obj.value);\n    $[0] = obj.value;\n    $[1] = setState;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  const cb = useIdentity(t1);\n  return cb;\n}\n\nconst setState = (arg: number) => {\n  \"use no memo\";\n  return arg;\n};\nexport const FIXTURE_ENTRYPOINT = {\n  fn: createHookWrapper(useMakeCallback),\n  params: [{ obj: { value: 1 }, setState }],\n  sequentialRenders: [\n    { obj: { value: 1 }, setState },\n    { obj: { value: 2 }, setState },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Hook with Memoization in React\nDESCRIPTION: This snippet defines a custom hook, useFoo, which utilizes the useRef hook to create a reference and the useMemo hook to return a memoized array created by a shared utility function. The purpose is to optimize performance by preventing unnecessary computations on each render. Note that the usage of the reference's current property during render is restricted, leading to an error during execution.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.maybe-mutable-ref-not-preserved.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees:true\n\nimport {useRef, useMemo} from 'react';\nimport {makeArray} from 'shared-runtime';\n\nfunction useFoo() {\n  const r = useRef();\n  return useMemo(() => makeArray(r), []);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Simplified React Component\nDESCRIPTION: Simplified version of the component that directly returns a constant value 42. Includes the same test fixture export but without error handling logic.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-try-immediately-returns.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let x;\n  return 42;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ default: 42 }],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with useMemo and Validation\nDESCRIPTION: This snippet defines a React component that uses `useMemo` to memoize a derived value based on an optional property (`arg?.items`). It then uses `ValidateMemoization` from `shared-runtime` to ensure the memoization is working as expected.  The component takes an argument `arg` that may or may not have an `items` property. The memoized value `data` is an array containing the value of `arg?.items`.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/optional-member-expression-single.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees @enableOptionalDependencies @enablePropagateDepsInHIR\nimport {ValidateMemoization} from 'shared-runtime';\nimport {useMemo} from 'react';\nfunction Component({arg}) {\n  const data = useMemo(() => {\n    const x = [];\n    x.push(arg?.items);\n    return x;\n  }, [arg?.items]);\n  return <ValidateMemoization inputs={[arg?.items]} output={data} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{arg: {items: 2}}],\n  sequentialRenders: [\n    {arg: {items: 2}},\n    {arg: {items: 2}},\n    {arg: null},\n    {arg: null},\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining React Test Fixture Code (JavaScript)\nDESCRIPTION: Refactored version of the test fixture where variables are declared with 'const' instead of 'let'. The function 'foo' and FIXTURE_ENTRYPOINT remain functionally the same, configuring a test for a 'TodoAdd' component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/overlapping-scopes-while.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(a, b, c) {\n  const x = [];\n  const y = [];\n  while (c) {\n    y.push(b);\n    x.push(a);\n  }\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Original Input Function with Object and Array Manipulation\nDESCRIPTION: A JavaScript function creating an object, array, and performing mutations with aliasing. Demonstrates basic object and array interactions before compiler transformation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-property-mutate-alias.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo() {\n  const a = {};\n  const y = a;\n  const x = [];\n\n  y.x = x;\n\n  mutate(a); // y & x are aliased to a\n  return y;\n}\n```\n\n----------------------------------------\n\nTITLE: React DOM Server Configuration\nDESCRIPTION: Server-side rendering configuration including error handling, stream abortion, and HTML optimization features.\nSOURCE: https://github.com/facebook/react/blob/main/CHANGELOG.md#2025-04-21_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nrenderToPipeableStream(element, {\n  bootstrapScriptContent: scriptContent,\n  onRecoverableError: (error, componentStack) => {\n    // Handle error with component stack\n  },\n  onShellError: (error) => {\n    // Handle shell error\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: React Component with Mutation after JSX\nDESCRIPTION: This React component attempts to modify an object `x` after it has been used within JSX. This violates React's principle of immutability for objects used in rendering, leading to an error. The `delete x[y]` statement attempts to remove a property from the object after `<div>{x}</div>` has already used it.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-delete-computed-property-of-frozen-value.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const x = makeObject();\n  // freeze\n  <div>{x}</div>;\n  delete x[y];\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: React Error Handling for State Mutation - JavaScript\nDESCRIPTION: The accompanying error message highlights a violation of React's rules regarding state and props. It indicates that the attempt to push a value into the array 'x' after it has already been rendered within JSX is not permitted, thus demonstrating the need to manage mutations correctly within functional components.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-mutate-after-freeze.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n   5 |\n   6 |   // x is Frozen at this point\n>  7 |   x.push(props.p2);\n     |   ^ InvalidReact: Updating a value used previously in JSX is not allowed. Consider moving the mutation before the JSX (7:7)\n   8 |\n   9 |   return <div>{_}</div>;\n  10 | }\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component Implementation\nDESCRIPTION: Compiled version of the component with React runtime optimizations, including memoization of the spread object using the _c compiler runtime function.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-in-statement-break.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  let x;\n  let t0;\n  if ($[0] !== props.value) {\n    t0 = { ...props.value };\n    $[0] = props.value;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const object = t0;\n  for (const y in object) {\n    if (y === \"break\") {\n      break;\n    }\n\n    x = object[y];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  // should return 'a'\n  params: [{ a: \"a\", break: null, c: \"C!\" }],\n};\n```\n\n----------------------------------------\n\nTITLE: Demonstrating JavaScript Variable Hoisting in Function\nDESCRIPTION: Illustrates how variable declarations are hoisted, causing undefined behavior before actual initialization. Shows a function that returns NaN due to accessing an undefined variable before its assignment.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-hoisting-simple-var-declaration.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction hoisting() {\n  function addOne(b) {\n    // a is undefined (only the declaration is hoisted, not the init) but shouldn't throw\n    return a + b;\n  }\n  const result = addOne(2);\n  var a = 1;\n\n  return result; // OK: returns NaN. The code is semantically wrong but technically correct\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Conditional Hook Usage in React Component\nDESCRIPTION: This code shows an anti-pattern where a hook (useFoo) is called conditionally inside an if statement. This violates React's Rules of Hooks which require hooks to be called in the same order on every render.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-conditionally-call-prop-named-like-hook.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component({cond, useFoo}) {\n  if (cond) {\n    useFoo();\n  }\n}\n```\n\nLANGUAGE: plaintext\nCODE:\n```\n  1 | function Component({cond, useFoo}) {\n  2 |   if (cond) {\n> 3 |     useFoo();\n    |     ^^^^^^ InvalidReact: Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning) (3:3)\n  4 |   }\n  5 | }\n  6 |\n\n```\n\n----------------------------------------\n\nTITLE: React Error: Invalid Hook Usage\nDESCRIPTION: This error message indicates that a React hook is being referenced as a normal value rather than being called directly. It highlights line 2 of the component where the hook `useA` or `useB` is conditionally assigned to the variable `x`. The error suggests consulting the React documentation regarding rules for calling components and hooks.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-ternary-with-hook-values.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n1 | function Component(props) {\n> 2 |   const x = props.cond ? useA : useB;\n    |                          ^^^^ InvalidReact: Hooks may not be referenced as normal values, they must be called. See https://react.dev/reference/rules/react-calls-components-and-hooks#never-pass-around-hooks-as-regular-values (2:2)\n\nInvalidReact: Hooks may not be referenced as normal values, they must be called. See https://react.dev/reference/rules/react-calls-components-and-hooks#never-pass-around-hooks-as-regular-values (2:2)\n\nInvalidReact: Hooks may not be referenced as normal values, they must be called. See https://react.dev/reference/rules/react-calls-components-and-hooks#never-pass-around-hooks-as-regular-values (2:2)\n\nInvalidReact: Hooks may not be referenced as normal values, they must be called. See https://react.dev/reference/rules/react-calls-components-and-hooks#never-pass-around-hooks-as-regular-values (3:3)\n  3 |   return x();\n  4 | }\n  5 |\n```\n\n----------------------------------------\n\nTITLE: React Class Component with Invalid useState Hook Usage\nDESCRIPTION: This code demonstrates an attempt to use the `useState` hook within a class component's `render` method. React hooks can only be used inside functional components or custom hooks, not within class components. This code is expected to fail in a proper React environment.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.invalid.invalid-rules-of-hooks-8303403b8e4c.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @skip\n// Passed but should have failed\n\nclass ClassComponentWithHook extends React.Component {\n  render() {\n    React.useState();\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Mutating State in React Component - JavaScript\nDESCRIPTION: This snippet defines a React component that mutates an object based on props input. It utilizes a shared runtime for state mutation, allowing reactivity tied to the component's properties. The main parameters include 'props' which supplies a 'y' value and integrates into an internal mutable structure.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-dependency-object-captured-with-reactive-mutated.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst {mutate} = require('shared-runtime');\n\nfunction Component(props) {\n  const x = {};\n  const y = props.y;\n  const z = [x, y];\n  mutate(z);\n  // x's object identity can change bc it co-mutates with z, which is reactive via props.y\n  return [x];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{y: 42}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with ESLint Rule Disable\nDESCRIPTION: A simple React functional component with ESLint rules temporarily disabled, demonstrating potential compilation and optimization warnings\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.sketchy-code-rules-of-hooks.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n/* eslint-disable react-hooks/rules-of-hooks */\nfunction lowercasecomponent() {\n  const x = [];\n  return <div>{x}</div>;\n}\n/* eslint-enable react-hooks/rules-of-hooks */\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: lowercasecomponent,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Error Handling for Memoization in React Hook\nDESCRIPTION: This snippet illustrates the error message generated when React cannot preserve the memoization guarantees due to mismatched dependencies. The error indicates that the inferred dependencies did not match the manually specified dependencies, which may lead to unexpected value changes during re-renders. This provides insight into debugging and optimizing React components.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.hoist-useCallback-infer-conditional-value-block.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nCannotPreserveMemoization: React Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. The inferred dependencies did not match the manually specified dependencies, which could cause the value to change more or less frequently than expected (6:14)\n```\n\n----------------------------------------\n\nTITLE: Code: Refactored Function Component with Temporary Function\nDESCRIPTION: Modified version of the previous component using a separate temporary function for variable modification, maintaining similar functional structure\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reassign-global-hook-arg.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nlet b = 1;\n\nexport default function MyApp() {\n  const fn = _temp;\n  return useFoo(fn);\n}\nfunction _temp() {\n  b = 2;\n}\n\nfunction useFoo(fn) {}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: MyApp,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Using useMemo in React Component with JavaScript\nDESCRIPTION: This React component uses the useMemo hook to memoize a value based on the props passed to the component. It ensures the array \\\\\"a\\\\\" is only recalculated when the \\\\\"name\\\\\" prop changes, improving performance by reducing unnecessary computations. The component also uses a \\\\\"ValidateMemoization\\\\\" component to validate the memoized inputs and outputs. Dependencies include \\\\\"React\\\\\" and \\\\\"shared-runtime\\\\\" packages.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/function-expression-prototype-call-mutating.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useMemo} from 'react';\nimport {ValidateMemoization} from 'shared-runtime';\n\nfunction Component(props) {\n  const a = useMemo(() => {\n    const a = [];\n    const f = function () {\n      a.push(props.name);\n    };\n    f.call();\n    return a;\n  }, [props.name]);\n  return <ValidateMemoization inputs={[props.name]} output={a} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{name: 'Jason'}],\n  sequentialRenders: [{name: 'Lauren'}, {name: 'Lauren'}, {name: 'Jason'}],\n};\n```\n\n----------------------------------------\n\nTITLE: Enhanced Memoization with Compiler Runtime\nDESCRIPTION: This snippet enhances memoization in a React component with compiler-runtime utilities. It checks cached inputs/output to avoid redundant computations, using shared-runtime's ValidateMemoization to ensure validity. Achieves memoization through React compiler-runtime transformations and tests with fixed input values.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-member-expression-as-memo-dep.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @validatePreserveExistingMemoizationGuarantees @enableOptionalDependencies\nimport { identity, ValidateMemoization } from \"shared-runtime\";\nimport { useMemo } from \"react\";\n\nfunction Component(t0) {\n  const $ = _c(7);\n  const { arg } = t0;\n\n  arg?.items.edges?.nodes;\n  let t1;\n  let t2;\n  if ($[0] !== arg?.items.edges?.nodes) {\n    t2 = arg?.items.edges?.nodes.map(identity);\n    $[0] = arg?.items.edges?.nodes;\n    $[1] = t2;\n  } else {\n    t2 = $[1];\n  }\n  t1 = t2;\n  const data = t1;\n\n  const t3 = arg?.items.edges?.nodes;\n  let t4;\n  if ($[2] !== t3) {\n    t4 = [t3];\n    $[2] = t3;\n    $[3] = t4;\n  } else {\n    t4 = $[3];\n  }\n  let t5;\n  if ($[4] !== data || $[5] !== t4) {\n    t5 = <ValidateMemoization inputs={t4} output={data} />;\n    $[4] = data;\n    $[5] = t4;\n    $[6] = t5;\n  } else {\n    t5 = $[6];\n  }\n  return t5;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ arg: null }],\n  sequentialRenders: [\n    { arg: null },\n    { arg: null },\n    { arg: { items: { edges: null } } },\n    { arg: { items: { edges: null } } },\n    { arg: { items: { edges: { nodes: [1, 2, \"hello\"] } } } },\n    { arg: { items: { edges: { nodes: [1, 2, \"hello\"] } } } },\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: Compiled version of the React component with explicit memoization logic implemented using compiler runtime. Shows how the compiler optimizes state management and memoization checks.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-invalid-pruned-scope-leaks-value-via-alias.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport invariant from \"invariant\";\nimport {\n  makeObject_Primitives,\n  mutate,\n  sum,\n  useIdentity,\n} from \"shared-runtime\";\n\n/**\n * Here, `z`'s original memo block is removed due to the inner hook call.\n * However, we also infer that `z` is non-reactive, so by default we would create\n * the memo block for `thing = [y, z]` as only depending on `y`.\n *\n * This could then mean that `thing[1]` and `z` may not refer to the same value,\n * since z recreates every time but `thing` doesn't correspondingly invalidate.\n *\n * The fix is to consider pruned memo block outputs as reactive, since they will\n * recreate on every render. This means `thing` depends on both y and z.\n */\nfunction MyApp(t0) {\n  const $ = _c(6);\n  const { count } = t0;\n  const z = makeObject_Primitives();\n  const x = useIdentity(2);\n  let t1;\n  if ($[0] !== count || $[1] !== x) {\n    t1 = sum(x, count);\n    $[0] = count;\n    $[1] = x;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  const y = t1;\n  mutate(z);\n  const z2 = z;\n  let t2;\n  if ($[3] !== y || $[4] !== z2) {\n    t2 = [y, z2];\n    $[3] = y;\n    $[4] = z2;\n    $[5] = t2;\n  } else {\n    t2 = $[5];\n  }\n  const thing = t2;\n  if (thing[1] !== z) {\n    invariant(false, \"oh no!\");\n  }\n  return thing;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: MyApp,\n  params: [{ count: 2 }],\n  sequentialRenders: [{ count: 2 }, { count: 2 }, { count: 3 }],\n};\n```\n\n----------------------------------------\n\nTITLE: React Reassignment Error\nDESCRIPTION: This code shows the error generated by React when a variable is reassigned after the component has rendered. The error message \"InvalidReact: Reassigning a variable after render has completed can cause inconsistent behavior on subsequent renders. Consider using state instead. Variable `onClick` cannot be reassigned after render\" is displayed. This highlights the anti-pattern of mutating variables directly after rendering.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-function-expression-references-later-variable-declaration.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n  1 | function Component() {\n  2 |   let callback = () => {\n> 3 |     onClick = () => {};\n    |     ^^^^^^^ InvalidReact: Reassigning a variable after render has completed can cause inconsistent behavior on subsequent renders. Consider using state instead. Variable `onClick` cannot be reassigned after render (3:3)\n  4 |   };\n  5 |   let onClick;\n  6 |\n```\n\n----------------------------------------\n\nTITLE: Validating Memoization in React Component with useMemo\nDESCRIPTION: Defines a React component using the useMemo hook to memoize array data derived from component props, optimizing re-renders. The component imports ValidateMemoization from 'shared-runtime' and checks memoized inputs and outputs. This ensures that the memoization guarantees are preserved while allowing optional dependencies.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-member-expression-single-with-unconditional.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees @enableOptionalDependencies\nimport {ValidateMemoization} from 'shared-runtime';\nfunction Component(props) {\n  const data = useMemo(() => {\n    const x = [];\n    x.push(props?.items);\n    x.push(props.items);\n    return x;\n  }, [props.items]);\n  return <ValidateMemoization inputs={[props.items]} output={data} />;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Functional Component with Compiler Runtime - JavaScript\nDESCRIPTION: The second snippet imports a compiler runtime from React and defines a more complex version of the 'bar' function. It utilizes a state-like mechanism to store a value based on an input and conditionally updates the output based on the argument passed.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-alias-computed-load-2.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction bar(a) {\n  const $ = _c(2);\n  let y;\n  if ($[0] !== a) {\n    const x = [a];\n    y = {};\n    const f0 = function () {\n      y = x[0][1];\n    };\n\n    f0();\n    $[0] = a;\n    $[1] = y;\n  } else {\n    y = $[1];\n  }\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: bar,\n  params: [[\"val1\", \"val2\"]],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Validating Ref Access During Render in React JavaScript\nDESCRIPTION: The code snippet demonstrates a React component that incorrectly accesses a ref during the render phase, which is against React's rules. This example aims to highlight the pitfalls of accessing the ref's current property during rendering, which can lead to errors. It showcases the use of the `useRef` hook and emphasizes the necessity of adhering to React's rules to avoid invalid operations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-use-ref-added-to-dep-without-type-info.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validateRefAccessDuringRender\nfunction Foo({a}) {\n  const ref = useRef();\n  // type information is lost here as we don't track types of fields\n  const val = {ref};\n  // without type info, we don't know that val.ref.current is a ref value so we\n  // *would* end up depending on val.ref.current\n  // however, this is an instance of accessing a ref during render and is disallowed\n  // under React's rules, so we reject this input\n  const x = {a, val: val.ref.current};\n\n  return <VideoList videos={x} />;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining a React Component with Compilation Mode Inference\nDESCRIPTION: A React function component that is skipped during compilation because it doesn't call any hooks or use JSX. The '@compilationMode(infer)' directive instructs the compiler to infer how to handle this component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-skip-components-without-hooks-or-jsx.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @compilationMode(infer)\n// This component is skipped bc it doesn't call any hooks or\n// use JSX:\nfunction Component(props) {\n  return render();\n}\n```\n\n----------------------------------------\n\nTITLE: Original JavaScript Switch Statement with Fallthrough Cases\nDESCRIPTION: A JavaScript function that demonstrates a switch statement with fallthrough cases. The function assigns values to variable y based on the input parameter x, with some cases containing explicit breaks and others falling through to the next case.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/switch-with-fallthrough.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(x) {\n  let y;\n  switch (x) {\n    case 0: {\n      y = 0;\n    }\n    case 1: {\n      y = 1;\n    }\n    case 2: {\n      break;\n    }\n    case 3: {\n      y = 3;\n      break;\n    }\n    case 4: {\n      y = 4;\n    }\n    case 5: {\n      y = 5;\n    }\n    default: {\n      y = 0;\n    }\n  }\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation with Unused Variable\nDESCRIPTION: The original component initializes and increments a local variable before overwriting it with a prop value and returning it. This implementation includes code that has no effect on the final output.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/dce-unused-postfix-update.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let i = 0;\n  i++;\n  i = props.i;\n  return i;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{i: 42}],\n};\n```\n\n----------------------------------------\n\nTITLE: Error Handling for Invalid Ref Access - JavaScript\nDESCRIPTION: This snippet shows the error output generated when executing the Component function that violates React's ref access rules. The error indicates that ref values should not be accessed during render, and provides a link to the documentation for further clarification.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-read-ref-prop-in-render-property-load.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n  1 | // @validateRefAccessDuringRender @compilationMode(infer)\n  2 | function Component(props) {\n> 3 |   const value = props.ref.current;\n    |                 ^^^^^^^^^^^^^^^^^ InvalidReact: Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef) (3:3)\n  4 |   return <div>{value}</div>;\n  5 | }\n  6 |\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Memoization - JavaScript\nDESCRIPTION: This snippet defines a React component that uses memoization techniques. It creates a context object with a unique key and memoized value, then mutates the key. The component is exported as a fixture for testing or demonstration purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-expression-computed-key-object-mutated-later.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {identity, mutate} from 'shared-runtime';\n\nfunction Component(props) {\n  const key = {};\n  const context = {\n    [key]: identity([props.value]),\n  };\n  mutate(key);\n  return context;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: 42}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a Hook with Invalid Prop Mutation in JavaScript\nDESCRIPTION: This function attempts to mutate the properties of the arguments passed, which violates React's practice of not mutating props directly. It highlights the importance of using local variables to manage component state instead of modifying incoming props. The snippet illustrates how React enforces immutability by providing an error message when attempting such mutations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.mutate-hook-argument.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction useHook(a, b) {\n  b.test = 1;\n  a.test = 2;\n}\n\n```\n\n----------------------------------------\n\nTITLE: React Build Error for Unsupported Throw Statement\nDESCRIPTION: The build error output from React's compiler highlighting that throw statements inside of try/catch blocks are not currently supported, specifically when throwing an array. The error points to the exact line where the issue occurs.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo.try-catch-with-throw.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n  2 |   let x;\n  3 |   try {\n> 4 |     throw [];\n    |     ^^^^^^^^^ Todo: (BuildHIR::lowerStatement) Support ThrowStatement inside of try/catch (4:4)\n  5 |   } catch (e) {\n  6 |     x.push(e);\n  7 |   }\n```\n\n----------------------------------------\n\nTITLE: Invalid Hook Usage in Nested Function Component\nDESCRIPTION: This code example demonstrates a common error pattern where a React Hook (useFoo) is incorrectly called within a nested function expression. React Hooks must be called at the top level of a function component or custom Hook.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-hook-in-nested-object-method.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @compilationMode(infer)\nfunction Component() {\n  'use memo';\n  const x = {\n    outer() {\n      const y = {\n        inner() {\n          return useFoo();\n        },\n      };\n      return y;\n    },\n  };\n  return x;\n}\n```\n\nLANGUAGE: text\nCODE:\n```\n   6 |       const y = {\n   7 |         inner() {\n>  8 |           return useFoo();\n     |                  ^^^^^^ InvalidReact: Hooks must be called at the top level in the body of a function component or custom hook, and may not be called within function expressions. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning). Cannot call Custom within a function component (8:8)\n   9 |         },\n  10 |       };\n  11 |       return y;\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with Invalid Ref Access during Render\nDESCRIPTION: This code demonstrates a React component that incorrectly accesses a ref's current property during render. The component uses useCallback and useRef hooks, but violates React's rules by calling reset() during render, which accesses ref.current.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.useCallback-accesses-ref-mutated-later-via-function-preserve-memoization.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enablePreserveExistingMemoizationGuarantees @validateRefAccessDuringRender\nimport {useCallback, useRef} from 'react';\n\nfunction Component(props) {\n  const ref = useRef({inner: null});\n\n  const onChange = useCallback(event => {\n    // The ref should still be mutable here even though function deps are frozen in\n    // @enablePreserveExistingMemoizationGuarantees mode\n    ref.current.inner = event.target.value;\n  });\n\n  // The ref is modified later, extending its range and preventing memoization of onChange\n  const reset = () => {\n    ref.current.inner = null;\n  };\n  reset();\n\n  return <input onChange={onChange} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component\nDESCRIPTION: This is the compiled version of the `VideoTab` component. It uses `react/compiler-runtime` to optimize the rendering. The compiled version caches the rendered output using the `_c` function and a sentinel value for memoization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ref-current-aliased-no-added-to-dep.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @validateRefAccessDuringRender false\nfunction VideoTab() {\n  const $ = _c(1);\n  const ref = useRef();\n  const t = ref.current;\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const x = () => {\n      console.log(t);\n    };\n\n    t0 = <VideoList videos={x} />;\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\n```\n\n----------------------------------------\n\nTITLE: React Error Messaging for Invalid Ref Access - JavaScript\nDESCRIPTION: This section captures the error output generated by React when attempting to access the `current` property of a ref during render. It provides a line-by-line breakdown of where the error occurs and the accompanying message that advises against such usage, including a link to the React documentation for reference.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-set-and-read-ref-during-render.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n  2 | function Component(props) {\n  3 |   const ref = useRef(null);\n> 4 |   ref.current = props.value;\n    |   ^^^^^^^^^^^ InvalidReact: Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef) (4:4)\n\nInvalidReact: Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef) (5:5)\n  5 |   return ref.current;\n  6 | }\n  7 |\n\n```\n\n----------------------------------------\n\nTITLE: Creating Simple React Component\nDESCRIPTION: This snippet defines a basic React functional component that takes props and renders a div element displaying the count property from props. It utilizes JSX syntax to create elements and manage their display. The expected input is a props object containing a count property, and it outputs a rendered React element with the count value shown in two places within the JSX structure.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/dont-merge-overlapping-scopes-with-intermediate-reassignment.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {Stringify} from 'shared-runtime';\n\nfunction Component(props) {\n  let x;\n  const array = [props.count];\n  x = array;\n  const element = <div>{array}</div>;\n  return (\n    <div>\n      {element}\n      {x}\n    </div>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{count: 42}],\n};\n```\n\n----------------------------------------\n\nTITLE: Initializing Nullable Object Processing with Error Handling\nDESCRIPTION: Function that safely extracts and pushes values from potentially null objects using try-catch and identity function. Handles scenarios with null or partially defined objects.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/try-catch-maybe-null-dependency.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction useFoo(maybeNullObject: {value: {inner: number}} | null) {\n  const y = [];\n  try {\n    y.push(identity(maybeNullObject.value.inner));\n  } catch {\n    y.push('null');\n  }\n\n  return y;\n}\n```\n\n----------------------------------------\n\nTITLE: React Compiler-Transformed Function with Memoization\nDESCRIPTION: The compiler-transformed version of the original function. It uses memoization via Symbol.for('react.memo_cache_sentinel') and pre-evaluates the boolean expressions and conditional statements at compile time for optimization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/constant-propagation-unary.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { Stringify } from \"shared-runtime\";\n\nfunction foo() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = (\n      <Stringify\n        value={{\n          _b: \"baz\",\n          b0: false,\n          n0: true,\n          n1: false,\n          n2: false,\n          n3: !-1,\n          s0: true,\n          s1: false,\n          s2: false,\n          u: !undefined,\n          n: true,\n        }}\n      />\n    );\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Managing Object Mutation JavaScript\nDESCRIPTION: This function initializes arrays and objects, modifies an array, and returns an object containing the modified array. It relies on a mutate function which is not defined here. Accepts no parameters and returns an object containing a potentially mutated array. The main focus is on array and object manipulation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-property-mutate-2.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo() {\n  const x = [];\n  const y = {};\n  y.x = x;\n  mutate(x);\n  return y;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Compiled: React Compiler Output with Memoization for Allocating Primitive\nDESCRIPTION: The React compiler's output that includes memoization logic. It stores the computed value (bar(props).b + 1) and its result to avoid recalculation on re-renders when the dependency hasn't changed.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allocating-primitive-as-dep.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // bar(props.b) is an allocating expression that produces a primitive, which means\n// that Forget should memoize it.\n// Correctness:\n//   - y depends on either bar(props.b) or bar(props.b) + 1\nfunction AllocatingPrimitiveAsDep(props) {\n  const $ = _c(2);\n  const t0 = bar(props).b + 1;\n  let t1;\n  if ($[0] !== t0) {\n    t1 = foo(t0);\n    $[0] = t0;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  const y = t1;\n  return y;\n}\n```\n\n----------------------------------------\n\nTITLE: React Compiler Memoization Error\nDESCRIPTION: This error message from the React Compiler indicates that it could not preserve the existing manual memoization when optimizing the component. The mismatch between inferred and manually specified dependencies in the `useMemo` hook is the cause.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.useMemo-property-call-dep.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n  3 |\n  4 | function Component({propA}) {\n> 5 |   return useMemo(() => {\n    |                  ^^^^^^^\n> 6 |     return propA.x();\n    | ^^^^^^^^^^^^^^^^^^^^^\n> 7 |   }, [propA.x]);\n    | ^^^^ CannotPreserveMemoization: React Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. The inferred dependencies did not match the manually specified dependencies, which could cause the value to change more or less frequently than expected (5:7)\n  8 | }\n  9 |\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Optimizations\nDESCRIPTION: The compiled version of the React component with compiler runtime optimizations. Implements memoization using Symbol references and caching mechanisms, with separated helper functions for filtering and mapping operations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-no-declarations-in-reactive-scope-with-early-return.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enableAssumeHooksFollowRulesOfReact @enableTransitivelyFreezeFunctionExpressions\nfunction Component() {\n  const $ = _c(7);\n  const items = useItems();\n  let t0;\n  let t1;\n  let t2;\n  if ($[0] !== items) {\n    t2 = Symbol.for(\"react.early_return_sentinel\");\n    bb0: {\n      t0 = items.filter(_temp);\n      const filteredItems = t0;\n      if (filteredItems.length === 0) {\n        let t3;\n        if ($[4] === Symbol.for(\"react.memo_cache_sentinel\")) {\n          t3 = (\n            <div>\n              <span />\n            </div>\n          );\n          $[4] = t3;\n        } else {\n          t3 = $[4];\n        }\n        t2 = t3;\n        break bb0;\n      }\n\n      t1 = filteredItems.map(_temp2);\n    }\n    $[0] = items;\n    $[1] = t1;\n    $[2] = t2;\n    $[3] = t0;\n  } else {\n    t1 = $[1];\n    t2 = $[2];\n    t0 = $[3];\n  }\n  if (t2 !== Symbol.for(\"react.early_return_sentinel\")) {\n    return t2;\n  }\n  let t3;\n  if ($[5] !== t1) {\n    t3 = <>{t1}</>;\n    $[5] = t1;\n    $[6] = t3;\n  } else {\n    t3 = $[6];\n  }\n  return t3;\n}\nfunction _temp2(t0) {\n  const [item_0] = t0;\n  return <Stringify item={item_0} />;\n}\nfunction _temp(t0) {\n  const [item] = t0;\n  return item.name != null;\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Memoized Component with Conditional Logic\nDESCRIPTION: A React component using useMemo to create a memoized array with conditional pushing of items based on props, accompanied by memoization validation\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.hoist-optional-member-expression-with-conditional-optional.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees @enableOptionalDependencies\nimport {ValidateMemoization} from 'shared-runtime';\nfunction Component(props) {\n  const data = useMemo(() => {\n    const x = [];\n    x.push(props?.items);\n    if (props.cond) {\n      x.push(props?.items);\n    }\n    return x;\n  }, [props?.items, props.cond]);\n  return (\n    <ValidateMemoization inputs={[props?.items, props.cond]} output={data} />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: Compiled version of the React component with added memoization logic and dependency tracking. Shows how the compiler optimizes the component by tracking prop changes and caching results.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/primitive-as-dep-nested-scope.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // props.b + 1 is an non-allocating expression, which means Forget can\n// emit it trivially and repeatedly (e.g. no need to memoize props.b + 1\n// separately from props.b)\n// Correctness:\n\nimport { identity, mutate, setProperty } from \"shared-runtime\";\n\n//   y depends on either props.b or props.b + 1\nfunction PrimitiveAsDepNested(props) {\n  const $ = _c(5);\n  let t0;\n  if ($[0] !== props.a || $[1] !== props.b) {\n    const x = {};\n    mutate(x);\n    const t1 = props.b + 1;\n    let t2;\n    if ($[3] !== t1) {\n      t2 = identity(t1);\n      $[3] = t1;\n      $[4] = t2;\n    } else {\n      t2 = $[4];\n    }\n    const y = t2;\n    setProperty(x, props.a);\n    t0 = [x, y];\n    $[0] = props.a;\n    $[1] = props.b;\n    $[2] = t0;\n  } else {\n    t0 = $[2];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: PrimitiveAsDepNested,\n  params: [{ a: 1, b: 2 }],\n  sequentialRenders: [\n    // change b\n    { a: 1, b: 3 },\n    // change b\n    { a: 1, b: 4 },\n    // change a\n    { a: 2, b: 4 },\n    // change a\n    { a: 3, b: 4 },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with Local State Mutation\nDESCRIPTION: This snippet defines a React component that increments a local variable. It demonstrates writing to primitives, which is not considered a 'mutate' or 'store' operation in the context of AnalyzeFunctions.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/lambda-reassign-primitive.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component() {\n  let x = 40;\n\n  const fn = function () {\n    x = x + 1;\n  };\n  fn();\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Defining React component with conflicting global variable\nDESCRIPTION: This code defines a React component named `useFoo` that takes `props` as input. Inside the component, it declares a local variable `__DEV__` and initializes it with a string value. The component then logs the value of the local `__DEV__` and returns the result of calling the `foo` function with `props.x` as its argument. The snippet highlights a common issue when a local variable name accidentally shadows a global variable, potentially leading to unexpected behavior or compilation errors.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.emit-freeze-conflicting-global.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableEmitFreeze @instrumentForget\nfunction useFoo(props) {\n  const __DEV__ = 'conflicting global';\n  console.log(__DEV__);\n  return foo(props.x);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component\nDESCRIPTION: This is the compiled version of the React component, transformed by the React compiler.  It leverages the `_c` function from `react/compiler-runtime` for memoization and optimizes the component's rendering logic. This version aims to be more efficient than the original, uncompiled version.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/block-scoping-switch-variable-scoping.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useMemo } from \"react\";\n\nfunction Component(props) {\n  const $ = _c(2);\n  let t0;\n  let t1;\n  if ($[0] !== props.value) {\n    t1 = { value: props.value };\n    $[0] = props.value;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  const handlers = t1;\nbb0: switch (props.test) {\n    case true: {\n      console.log(handlers.value);\n      break bb0;\n    }\n    default: {\n    }\n  }\n\n  t0 = handlers;\n  const outerHandlers = t0;\n  return outerHandlers;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ test: true, value: \"hello\" }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Input React Component with Decrement Operations\nDESCRIPTION: A simple React component function that takes an array parameter and performs both post-decrement and pre-decrement operations. Returns an array containing the modified values.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/update-expression-on-function-parameter-4.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component([b]) {\n  let f = b--;\n  let g = --b;\n  return [b, f, g];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [[3]],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: React Compiler Runtime Optimized Component\nDESCRIPTION: Enhanced version of the component using React compiler runtime with memoization and conditional state updates. Implements caching and efficient state management using compiler-specific runtime hooks.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-alias-mutate-iife.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nconst { mutate } = require(\"shared-runtime\");\n\nfunction component(a) {\n  const $ = _c(2);\n  let y;\n  if ($[0] !== a) {\n    const x = { a };\n    y = {};\n\n    y.x = x;\n\n    mutate(y);\n    $[0] = a;\n    $[1] = y;\n  } else {\n    y = $[1];\n  }\n  return y;\n}\n```\n\n----------------------------------------\n\nTITLE: Component with Memoization - JavaScript\nDESCRIPTION: This snippet illustrates the use of memoization within a React functional component. It employs the 'react/compiler-runtime' to access a caching mechanism. The component checks if the cache for a specific key is available; if not, it renders the JSX and stores it in the cache. This approach optimizes re-renders by avoiding unnecessary computations. Outputs a cached component or fresh JSX when required.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-member-expression.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = (\n      <Sathya.Codes.Forget>\n        <Foo.Bar.Baz />\n      </Sathya.Codes.Forget>\n    );\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Initializing a Foo Object with Props in JavaScript React\nDESCRIPTION: This snippet defines a simple React functional component that initializes a Foo object using its props. It takes 'foo' and 'bar' from props to create a new instance of Foo, ensuring it receives the correct arguments.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/new-spread.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const x = new Foo(...props.foo, null, ...[props.bar]);\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: React Compiler Optimized Implementation\nDESCRIPTION: Compiler-optimized version using React's compiler runtime for memoization. Uses an array to cache the previous value of 'a' and its corresponding object, reducing unnecessary object creation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/obj-mutated-after-if-else.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction foo(a, b, c, d) {\n  const $ = _c(2);\n  someObj();\n  let x;\n  if ($[0] !== a) {\n    if (a) {\n      x = someObj();\n    } else {\n      x = someObj();\n    }\n\n    x.f = 1;\n    $[0] = a;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Original React Component with Variable References\nDESCRIPTION: The original component defines variables with references, calls a function that modifies one of the references, and returns an array containing both variables. This example demonstrates a pattern that would typically cause re-renders in React.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/chained-assignment-context-variable.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {makeArray} from 'shared-runtime';\n\nfunction Component() {\n  let x,\n    y = (x = {});\n  const foo = () => {\n    x = makeArray();\n  };\n  foo();\n  return [y, x];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: React Compiler Error: InvalidReact (JavaScript)\nDESCRIPTION: This error message indicates that the React Compiler failed to infer the dependencies of the effect created by `useMyEffect`. The compiler suggests either providing a dependency array manually or fixing any compiler bailout diagnostics that might be preventing the inference. The error points to the line where `useMyEffect` is called within the non-React function.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/bailout-retry/error.callsite-in-non-react-fn-default-import.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n  3 |\n  4 | function nonReactFn(arg) {\n> 5 |   useMyEffect(() => [1, 2, arg]);\n    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ InvalidReact: [InferEffectDependencies] React Compiler is unable to infer dependencies of this effect. This will break your build! To resolve, either pass your own dependency array or fix reported compiler bailout diagnostics. (5:5)\n  6 | }\n  7 |\n\n```\n\n----------------------------------------\n\nTITLE: Exporting Component Metadata with String Literals\nDESCRIPTION: This code exports a constant named `FIXTURE_ENTRYPOINT`. This constant is an object containing metadata about the `foo` component, including a reference to the component's function (`fn`), an array of parameters (`params`), and the component's name (`isComponent`). This metadata can be used for testing or other tooling that needs to understand the structure and behavior of the component. This example uses double quotes for strings.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/while-logical.expect.md#2025-04-21_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: Compiler-optimized version of the React component that implements automatic memoization for the context-dependent callback and rendered elements. Uses a closure array ($) to store and compare memoized values.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useContext-read-context-in-callback.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { createContext, useContext } from \"react\";\n\nconst FooContext = createContext({ current: null });\n\nfunction Component(props) {\n  const $ = _c(5);\n  const foo = useContext(FooContext);\n  let t0;\n  if ($[0] !== foo.current) {\n    t0 = () => {\n      console.log(foo.current);\n    };\n    $[0] = foo.current;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const onClick = t0;\n  let t1;\n  if ($[2] !== onClick || $[3] !== props.children) {\n    t1 = <div onClick={onClick}>{props.children}</div>;\n    $[2] = onClick;\n    $[3] = props.children;\n    $[4] = t1;\n  } else {\n    t1 = $[4];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ children: <div>Hello</div> }],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized String Concatenation Implementation\nDESCRIPTION: Optimized version of the same function that directly returns the concatenated string literal. Maintains the same fixture setup for consistent testing.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/constant-propagation-string-concat.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo() {\n  return \"abc\";\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Conditional Array Initialization Function in JavaScript\nDESCRIPTION: Original input code that defines a function which conditionally initializes an array and adds an element to it. This function is exported as part of a FIXTURE_ENTRYPOINT object for testing sequential renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/phi-reference-effects.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {arrayPush} from 'shared-runtime';\n\nfunction Foo(cond) {\n  let x = null;\n  if (cond) {\n    x = [];\n  } else {\n  }\n  // Here, x = phi(x$null, x$[]) should receive a ValueKind of Mutable\n  arrayPush(x, 2);\n\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{cond: true}],\n  sequentialRenders: [{cond: true}, {cond: true}],\n};\n```\n\n----------------------------------------\n\nTITLE: Running ESLint v6 Tests for React Hooks Plugin\nDESCRIPTION: A sequence of shell commands to test the eslint-plugin-react-hooks functionality with ESLint version 6. The commands navigate to the fixture directory, install dependencies, build the project, and run linting.\nSOURCE: https://github.com/facebook/react/blob/main/fixtures/eslint-v6/README.md#2025-04-21_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ncd fixtures/eslint-v6\nyarn\nyarn build\nyarn lint\n```\n\n----------------------------------------\n\nTITLE: Defining a React Component with Invalid Side Effect Handling\nDESCRIPTION: This code defines a functional React component 'Component' which contains a local function 'foo' that attempts to modify a global variable 'someGlobal'. This approach is incorrect according to React's strict rules regarding side effects, as components should remain pure. The error output specifies the issue with the variable reassignment that occurs within the component's scope.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.assign-global-in-jsx-children.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component() {\n  const foo = () => {\n    someGlobal = true;\n  };\n  // Children are generally access/called during render, so\n  // modifying a global in a children function is almost\n  // certainly a mistake.\n  return <Foo>{foo}</Foo>;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Building and Testing React DevTools Extensions for Different Browsers\nDESCRIPTION: Commands to build and test the React DevTools extension for Chrome, Firefox, and Edge browsers after dependencies have been installed.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools-extensions/README.md#2025-04-21_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\ncd packages/react-devtools-extensions/\n\nyarn build:chrome # => packages/react-devtools-extensions/chrome/build\nyarn run test:chrome # Test Chrome extension\n\nyarn build:firefox # => packages/react-devtools-extensions/firefox/build\nyarn run test:firefox # Test Firefox extension\n\nyarn build:edge # => packages/react-devtools-extensions/edge/build\nyarn run test:edge # Test Edge extension\n```\n\n----------------------------------------\n\nTITLE: Simplified Function Implementation in JavaScript\nDESCRIPTION: A simplified version of the function that directly assigns and returns the first parameter, with a consistent fixture entrypoint export\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-multiple-phis.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(a, b, c, d) {\n  let x;\n\n  x = a;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Compilation Error for Invalid Fire Method Usage\nDESCRIPTION: An error message explaining that the `fire()` method can only receive a direct function call, not method calls or other complex expressions. This highlights the strict syntax requirements for using the `fire()` method.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/error.todo-method.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n   7 |   };\n   8 |   useEffect(() => {\n>  9 |     fire(props.foo());\n     |     ^^^^^^^^^^^^^^^^^ InvalidReact: Cannot compile `fire`. `fire()` can only receive a function call such as `fire(fn(a,b)). Method calls and other expressions are not allowed (9:9)\n  10 |   });\n  11 |\n  12 |   return null;\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component Definition and Export\nDESCRIPTION: This snippet is an optimized version of the previous code. It defines the same React functional component 'Component' without the unused variable. The component is exported as part of the FIXTURE_ENTRYPOINT object with the same structure.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/dce-unused-const.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  return props.value;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ value: 42 }],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component and Fixture Definition\nDESCRIPTION: Defines a React component function `t` that destructures the `props` array and returns the second element (indexed as `foo`). It also defines a constant `FIXTURE_ENTRYPOINT` that serves as a fixture configuration.  This configuration specifies the component function (`fn`), the expected parameters (`params`), and the component name (`isComponent`).\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/holey-array-pattern-dce.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction t(props) {\n  const [, foo] = props;\n  return foo;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: t,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n\n```\n\n----------------------------------------\n\nTITLE: Initial Function Implementation with Nested Function\nDESCRIPTION: A JavaScript function demonstrating nested function execution and object manipulation with dynamic array access\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-alias-computed-load-4-iife.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction bar(a) {\n  let x = [a];\n  let y = {};\n  (function () {\n    y = x[0].a[1];\n  })();\n\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: bar,\n  params: [{a: ['val1', 'val2']}],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: React Component Destructuring Error\nDESCRIPTION: An error output showing that destructuring of context variables is not supported. The error points to the 'foo' parameter in the component definition.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-reassign-const.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n  1 | import {Stringify} from 'shared-runtime';\n  2 |\n> 3 | function Component({foo}) {\n    |                     ^^^ Todo: Support destructuring of context variables (3:3)\n  4 |   let bar = foo.bar;\n  5 |   return (\n  6 |     <Stringify\n```\n\n----------------------------------------\n\nTITLE: Original Input Function Implementation\nDESCRIPTION: Original function that performs mathematical operations on a nested object property, with exports for testing setup.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/assignment-expression-nested-path.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction g(props) {\n  const a = {b: {c: props.c}};\n  a.b.c = a.b.c + 1;\n  a.b.c *= 2;\n  return a;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: g,\n  params: [{c: 2}],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Importing React Feature Flag and Default Export\nDESCRIPTION: Demonstrates importing a feature flag from ReactForgetFeatureFlag module and exporting a default value of 42. The code includes a @gating comment indicating feature gating functionality.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/repro-no-gating-import-without-compiled-functions.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @gating\nimport {isForgetEnabled_Fixtures} from 'ReactForgetFeatureFlag';\n\nexport default 42;\n```\n\nLANGUAGE: javascript\nCODE:\n```\n// @gating\nimport { isForgetEnabled_Fixtures } from \"ReactForgetFeatureFlag\";\n\nexport default 42;\n```\n\n----------------------------------------\n\nTITLE: Implementing Memoized React Component in JavaScript/JSX\nDESCRIPTION: This code defines a React component named TestComponent that uses a custom memoization technique. It checks if the 'x' prop has changed and only updates the rendered Button component when necessary.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/apps/playground/__tests__/e2e/__snapshots__/page.spec.ts/function-scope-beats-module-scope-output.txt#2025-04-21_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nfunction TestComponent(t0) {\n  \"use memo\";\n  const $ = _c(2);\n  const { x } = t0;\n  let t1;\n  if ($[0] !== x) {\n    t1 = <Button>{x}</Button>;\n    $[0] = x;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Optimizations\nDESCRIPTION: Compiled output showing the same component with added compiler optimizations including memoization logic and runtime imports.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/constant-propagate-global-phis.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { CONST_STRING0, CONST_STRING1, Text } from \"shared-runtime\";\n\nfunction useFoo() {\n  \"use no forget\";\n  return { tab: CONST_STRING1 };\n}\n\nfunction Test() {\n  const $ = _c(2);\n  const { tab } = useFoo();\n  const currentTab = tab === CONST_STRING0 ? CONST_STRING0 : CONST_STRING1;\n  let t0;\n  if ($[0] !== currentTab) {\n    t0 = <Text value={currentTab} />;\n    $[0] = currentTab;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Test,\n  params: [],\n  isComponent: true,\n};\n```\n\n----------------------------------------\n\nTITLE: React Compiler Runtime Memoization Implementation\nDESCRIPTION: An optimized version of the React component using compiler runtime memoization techniques. Implements caching and state management with dynamic rendering and performance optimizations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/validate-no-set-state-in-render-uncalled-function-with-mutable-range-is-valid.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const $ = _c(7);\n  const logEvent = useLogging(props.appId);\n  const [currentStep, setCurrentStep] = useState(0);\n  let t0;\n  if ($[0] !== logEvent) {\n    t0 = (errorEvent) => {\n      logEvent(errorEvent);\n      setCurrentStep(1);\n    };\n    $[0] = logEvent;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const onSubmit = t0;\n  switch (currentStep) {\n    case 0: {\n      let t1;\n      if ($[2] === Symbol.for(\"react.memo_cache_sentinel\")) {\n        t1 = <OtherComponent data={{ foo: \"bar\" }} />;\n        $[2] = t1;\n      } else {\n        t1 = $[2];\n      }\n      return t1;\n    }\n    // ... rest of implementation\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Memoization with useCallback in React - JavaScript\nDESCRIPTION: This snippet defines a React functional component that uses the useCallback hook to memoize a function based on specified dependencies. It aims to optimize performance by ensuring the function is not recreated unless dependencies change. Dependencies include propA.a and propB.x.y, and the function performs a mutation on an object before returning a value.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.useCallback-infer-less-specific-conditional-access.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees\nimport {useCallback} from 'react';\nimport {mutate} from 'shared-runtime';\n\nfunction Component({propA, propB}) {\n  return useCallback(() => {\n    const x = {};\n    if (propA?.a) {\n      mutate(x);\n      return {\n        value: propB.x.y,\n      };\n    }\n  }, [propA?.a, propB.x.y]);\n}\n```\n\n----------------------------------------\n\nTITLE: Using React Compiler Runtime for Enhanced Functionality - JavaScript\nDESCRIPTION: This snippet defines a more complex version of the 'bar' function, utilizing the React compiler runtime to manage state and input checks. The function returns an internal state based on input while tracking changes, and is exported similarly as a fixture entry point.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-alias-computed-load.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction bar(a) {\n  const $ = _c(2);\n  let y;\n  if ($[0] !== a) {\n    const x = [a];\n    y = {};\n    const f0 = function () {\n      y = x[0];\n    };\n\n    f0();\n    $[0] = a;\n    $[1] = y;\n  } else {\n    y = $[1];\n  }\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: bar,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: React Flow Type Alias Input Code\nDESCRIPTION: Original Flow-typed code showing type alias usage and function annotations. Defines a Bar type alias as string and demonstrates its usage in a function parameter annotation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-alias-used-as-variable-annotation_.flow.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @flow @enableAssumeHooksFollowRulesOfReact @enableTransitivelyFreezeFunctionExpressions\ntype Bar = string;\nfunction TypeAliasUsedAsAnnotation() {\n  type Foo = Bar;\n  const fun = f => {\n    let g: Foo = f;\n    console.log(g);\n  };\n  fun('hello, world');\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: TypeAliasUsedAsAnnotation,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: React Fixture Entrypoint Configuration\nDESCRIPTION: A configuration object defining the function, parameters, and component type for testing or compilation purposes. Provides metadata about the React component for external tooling or test environments.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-scopes.expect.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nexport const FIXTURE_ENTRYPOINT = {\n  fn: f,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\"\n};\n```\n\n----------------------------------------\n\nTITLE: React Ref Access Error\nDESCRIPTION: This code snippet represents the error output from React. It indicates that the `current` property of a ref is being accessed during render, which is not allowed in React. The error message suggests using `useRef` instead.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.repro-ref-mutable-range.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n   9 |   mutate(value);\n  10 |   if (CONST_TRUE) {\n> 11 |     return <Stringify ref={identity(ref)} />;\n     |                                     ^^^ InvalidReact: Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef) (11:11)\n  12 |   }\n  13 |   return value;\n  14 | }\n\n```\n\n----------------------------------------\n\nTITLE: Using Custom Hooks to Fire Functions in a React Component\nDESCRIPTION: This code snippet demonstrates another implementation of a React component using custom hooks (useFire) to abstract firing functions. It also employs useEffect for handling side effects and useRef for maintaining a reference to a button element. Essential dependencies include React and the custom useFire hook.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/bailout-retry/bailout-eslint-suppressions.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useFire } from \"react/compiler-runtime\"; // @enableFire @panicThreshold(none)\nimport { useRef } from \"react\";\n\nfunction Component(t0) {\n  const { props, bar } = t0;\n  const foo = () => {\n    console.log(props);\n  };\n  const t1 = useFire(foo);\n  const t2 = useFire(bar);\n\n  useEffect(() => {\n    t1(props);\n    t1();\n    t2();\n  });\n\n  const ref = useRef(null);\n\n  ref.current = \"bad\";\n  return <button ref={ref} />;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: Basic React component that calls a mutation function and returns an array of values. Shows the pre-compilation version of the component code.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/uninitialized-declaration-in-reactive-scope.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let x = mutate();\n  let y;\n  foo(x);\n  return [y, x];\n}\n```\n\n----------------------------------------\n\nTITLE: Original Function Implementation\nDESCRIPTION: Original JavaScript function that conditionally creates and modifies objects based on input parameter 'a'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/obj-mutated-after-if-else-with-alias.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(a, b, c, d) {\n  let x = someObj();\n  if (a) {\n    const y = someObj();\n    const z = y;\n    x = z;\n  } else {\n    x = someObj();\n  }\n\n  x.f = 1;\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Handling JavaScript Const Reassignment\nDESCRIPTION: This JavaScript snippet defines a function that tries to reassign a const variable, triggering an error. No external dependencies are required. The const keyword is used to declare a variable `x`, which cannot be reassigned, leading to an 'InvalidJS' error when reassignment is attempted at line 3. The function takes no parameters and showcases the immutability constraint of const variables in JavaScript.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-reassign-const.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component() {\n  const x = 0;\n  x = 1;\n}\n\n```\n\nLANGUAGE: javascript\nCODE:\n```\n1 | function Component() {\n2 |   const x = 0;\n> 3 |   x = 1;\n    |   ^ InvalidJS: Cannot reassign a `const` variable. `x` is declared as const (3:3)\n4 | }\n5 |\n\n```\n\n----------------------------------------\n\nTITLE: Executing fire in a React Component - JavaScript\nDESCRIPTION: This snippet defines a React component that imports the 'fire' function from 'react' and attempts to use it within an effect hook. The component accepts props and logs them to the console. The 'nested' function calls 'fire' with the 'foo' function and subsequently calls 'foo', leading to a compilation error due to inconsistent usage of 'fire'. Dependencies include 'react'. Key parameters are the component props. The primary output is a null return and console logs.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/error.invalid-mix-fire-and-no-fire.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\n// @enableFire\nimport {fire} from 'react';\n\nfunction Component(props) {\n  const foo = props => {\n    console.log(props);\n  };\n  useEffect(() => {\n    function nested() {\n      fire(foo(props));\n      foo(props);\n    }\n\n    nested();\n  });\n\n  return null;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining Unreachable Function with Unconditional Return\nDESCRIPTION: A JavaScript function that includes an unconditional return statement preventing subsequent code execution. This example demonstrates a hook function with an unreachable code block.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-4f6c78a14bf7.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction useUnreachable() {\n  return;\n  useHook();\n}\n```\n\n----------------------------------------\n\nTITLE: Using getNumber in useFoo with Error Handling - JavaScript\nDESCRIPTION: This snippet defines a React hook 'useFoo' that attempts to retrieve a number using the 'getNumber' function from the shared runtime. It handles potential errors silently, ensuring that the application can continue running even if the retrieval fails. The exported 'FIXTURE_ENTRYPOINT' prepares this hook for use in other parts of the application, with no parameters required.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/empty-catch-statement.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {getNumber} from 'shared-runtime';\n\nfunction useFoo() {\n  try {\n    return getNumber();\n  } catch {} \n}\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Creating a Functional Component with Optional Function Calls - JavaScript\nDESCRIPTION: This snippet defines a functional component named 'Component' that uses an optional function call to render a JSX element. It utilizes the 'makeOptionalFunction' to handle the props optionally and returns the rendered element. The snippet illustrates how optional chaining is applied in functional components.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-call-with-independently-memoizable-arg.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const x = makeOptionalFunction(props);\n  // for a regular call, the JSX element could be independently memoized\n  // since it is an immutable value. however, because the call is optional,\n  // we can't extract out independent memoization for the element w/o\n  // forcing that argument to evaluate unconditionally\n  const y = x?.(\n    <div>\n      <span>{props.text}</span>\n    </div>\n  );\n  return y;\n}\n\n```\n\n----------------------------------------\n\nTITLE: React Immutability Violation Error Handling\nDESCRIPTION: This snippet includes an inline error comment that occurs when trying to mutate a React component state. The comment points out that `x.value` cannot be mutated after the use of the `useIdentity` hook, serving as a caution for developers about React's immutable state management principles.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.hook-call-freezes-captured-memberexpr.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n```\n  11 |   });\n  12 |\n> 13 |   x.value += count;\n     |   ^ InvalidReact: This mutates a variable that React considers immutable (13:13)\n  14 |   return <Stringify x={x} cb={cb} />;\n  15 | }\n  16 |\n```\n```\n\n----------------------------------------\n\nTITLE: Compiled React Runtime Optimized Version\nDESCRIPTION: The compiler-optimized version of the function that uses React's runtime cache (_c) to memoize values and prevent unnecessary object creation. It includes logic to only create new objects when values change.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/update-expression.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction foo(props) {\n  const $ = _c(4);\n  let x = props.x;\n  const y = x++;\n  const z = x--;\n  let t0;\n  if ($[0] !== x || $[1] !== y || $[2] !== z) {\n    t0 = { x, y, z };\n    $[0] = x;\n    $[1] = y;\n    $[2] = z;\n    $[3] = t0;\n  } else {\n    t0 = $[3];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [{ x: 1 }],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization for Invalid Tag Test\nDESCRIPTION: This is the compiled version of the test fixture with React compiler-runtime features. It demonstrates how the code is transformed to include memoization using a Symbol.for cache sentinel pattern, while preserving the invalid tag test case.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/invalid-jsx-lowercase-localvar.expect.md#2025-04-22_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { Throw } from \"shared-runtime\";\n\n/**\n * Note: this is disabled in the evaluator due to different devmode errors.\n * Found differences in evaluator results\n *  Non-forget (expected):\n *  (kind: ok) <invalidtag val=\"[object Object]\"></invalidtag>\n *  logs: ['Warning: <%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.%s','invalidTag']\n *\n *  Forget:\n *  (kind: ok) <invalidtag val=\"[object Object]\"></invalidtag>\n *  logs: [\n *   'Warning: <%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.%s','invalidTag',\n *   'Warning: The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.%s','invalidTag',\n *  ]\n */\nfunction useFoo() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = <invalidTag val={{ val: 2 }} />;\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Managing Key Commands in React - JavaScript\nDESCRIPTION: This snippet defines a React hook that manages key command interactions, primarily focusing on left and right movements. It uses the useRef hook to track the current position and an external addOne function to update this position. The snippet exports a fixture entry point with the function and its parameters.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capture-ref-for-later-mutation.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useRef} from 'react';\nimport {addOne} from 'shared-runtime';\n\nfunction useKeyCommand() {\n  const currentPosition = useRef(0);\n  const handleKey = direction => () => {\n    const position = currentPosition.current;\n    const nextPosition = direction === 'left' ? addOne(position) : position;\n    currentPosition.current = nextPosition;\n  };\n  const moveLeft = {\n    handler: handleKey('left'),\n  };\n  const moveRight = {\n    handler: handleKey('right'),\n  };\n  return [moveLeft, moveRight];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useKeyCommand,\n  params: [],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Advanced ReactiveScope Handling with Compiler Runtime in JavaScript\nDESCRIPTION: This advanced snippet handles variable propagation using React's compiler runtime, specifically using cache handling techniques. It ensures stability in rendering by capturing changes in objects and uses a caching mechanism for React's memory optimization. The dependencies include 'react/compiler-runtime' and aim to mitigate invariant breaking through memoization and react-specific pattern handling.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/bug-invalid-phi-as-dependency.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { CONST_TRUE, Stringify, mutate, useIdentity } from \"shared-runtime\";\n\n/**\n * Fixture showing an edge case for ReactiveScope variable propagation.\n *\n * Found differences in evaluator results\n *   Non-forget (expected):\n *   <div>{\"obj\":{\"inner\":{\"value\":\"hello\"},\"wat0\":\"joe\"},\"inner\":[\"[[ cyclic ref *2 ]]\"]}</div>\n *   <div>{\"obj\":{\"inner\":{\"value\":\"hello\"},\"wat0\":\"joe\"},\"inner\":[\"[[ cyclic ref *2 ]]\"]}</div>\n *   Forget:\n *   <div>{\"obj\":{\"inner\":{\"value\":\"hello\"},\"wat0\":\"joe\"},\"inner\":[\"[[ cyclic ref *2 ]]\"]}</div>\n *   [[ (exception in render) Error: invariant broken ]]\n *\n */\nfunction Component() {\n  const $ = _c(4);\n  const obj = CONST_TRUE ? { inner: { value: \"hello\" } } : null;\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = [obj?.inner];\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const boxedInner = t0;\n  useIdentity(null);\n  mutate(obj);\n  if (boxedInner[0] !== obj?.inner) {\n    throw new Error(\"invariant broken\");\n  }\n  let t1;\n  if ($[1] !== boxedInner || $[2] !== obj) {\n    t1 = <Stringify obj={obj} inner={boxedInner} />;\n    $[1] = boxedInner;\n    $[2] = obj;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ arg: 0 }],\n  sequentialRenders: [{ arg: 0 }, { arg: 1 }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Exporting Component Fixture Entry Point in React JavaScript\nDESCRIPTION: This code snippet initializes a global variable 'someGlobal', defines a React component 'Component' that modifies this global variable, and associates the component with a fixture entry point. It focuses on setting up a component structure to be potentially used as part of a React application setup. The snippet has no parameters or significant external dependencies and returns null from the component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/should-bailout-without-compilation-annotation-mode.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @gating @panicThreshold(none) @compilationMode(annotation)\nlet someGlobal = \\\"joe\\\";\n\nfunction Component() {\n  \\\"use forget\\\";\n  someGlobal = \\\"wat\\\";\n  return null;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component Implementation\nDESCRIPTION: Optimized version where the arrow function is hoisted to a named function _temp. The local variable assignments are simplified to directly return the final value, while maintaining the same behavior.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/constant-prop-colliding-identifier.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { invoke } from \"shared-runtime\";\n\nfunction Component() {\n  const fn = _temp;\n\n  invoke(fn);\n  return 3;\n}\nfunction _temp() {\n  return { x: \"value\" };\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: Simple React component implementing useDispatch and useEffect hooks with a memoized callback function. Shows the basic implementation pattern before compilation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useEffect-arg-memoized.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const dispatch = useDispatch();\n  useFreeze(dispatch);\n\n  // onUpdate should be memoized even though it doesn't\n  // flow into the return value\n  const onUpdate = () => {\n    dispatch({kind: 'update'});\n  };\n\n  useEffect(() => {\n    onUpdate();\n  }, [onUpdate]);\n\n  return <div />;\n}\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Compiler Runtime\nDESCRIPTION: This snippet shows the compiled and optimized version of the React component. It includes compiler-specific optimizations and memoization logic.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-unreachable-code-early-return-in-useMemo.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enableAssumeHooksFollowRulesOfReact @enableTransitivelyFreezeFunctionExpressions\nimport { useMemo, useState } from \"react\";\nimport { ValidateMemoization, identity } from \"shared-runtime\";\n\nfunction Component(t0) {\n  const $ = _c(7);\n  const { value } = t0;\n  let t1;\n  bb0: {\n    if (value == null) {\n      t1 = null;\n      break bb0;\n    }\n    try {\n      let t3;\n      if ($[0] !== value) {\n        t3 = { value };\n        $[0] = value;\n        $[1] = t3;\n      } else {\n        t3 = $[1];\n      }\n      t1 = t3;\n    } catch (t2) {\n      t1 = null;\n    }\n  }\n  const result = t1;\n  let t2;\n  if ($[2] !== value) {\n    t2 = [value];\n    $[2] = value;\n    $[3] = t2;\n  } else {\n    t2 = $[3];\n  }\n  let t3;\n  if ($[4] !== result || $[5] !== t2) {\n    t3 = <ValidateMemoization inputs={t2} output={result} />;\n    $[4] = result;\n    $[5] = t2;\n    $[6] = t3;\n  } else {\n    t3 = $[6];\n  }\n  return t3;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ value: null }],\n  sequentialRenders: [\n    { value: null },\n    { value: null },\n    { value: 42 },\n    { value: 42 },\n    { value: null },\n    { value: 42 },\n    { value: null },\n    { value: 42 },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Demonstrating React Compiler Memoization Preservation Error\nDESCRIPTION: This code snippet demonstrates a situation where React Compiler refuses to optimize a component due to an issue with preserving memoization guarantees. The useFoo function contains a useMemo call with an array dependency that might be mutated, causing the compiler to skip optimization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.false-positive-useMemo-infer-mutate-deps.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees\nimport {useMemo} from 'react';\nimport {identity} from 'shared-runtime';\n\n// This is a false positive as Forget's inferred memoization\n// invalidates strictly less than source. We currently do not\n// track transitive deps / invalidations of manual memo deps\n// because of implementation complexity\nfunction useFoo() {\n  const val = [1, 2, 3];\n\n  return useMemo(() => {\n    return identity(val);\n  }, [val]);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Mutation\nDESCRIPTION: This JavaScript code represents the compiled version of the React component. It utilizes React's compiler runtime ('react/compiler-runtime') and the 'shared-runtime' to achieve the mutation. The compiled component memoizes the result using _c, re-computing only when 'a' changes. It calls mutate(y) to perform the mutation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-simple-alias-iife.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nconst { mutate } = require(\"shared-runtime\");\n\nfunction component(a) {\n  const $ = _c(2);\n  let y;\n  if ($[0] !== a) {\n    const x = { a };\n    y = {};\n\n    y = x;\n\n    mutate(y);\n    $[0] = a;\n    $[1] = y;\n  } else {\n    y = $[1];\n  }\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: [\"foo\"],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: Compiled version of the React component with memoization logic using Symbol.for() and compiler runtime utilities.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/arrow-function-with-implicit-return.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @compilationMode(infer)\nconst Test = () => {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = <div />;\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n};\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Test,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Creating an Object with Properties - JavaScript\nDESCRIPTION: Defines a function 'makeObj' that creates and returns an array with an object storing a property 'b'. The function is intended to demonstrate object creation in JavaScript. It does not require any external dependencies.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/issue933-disjoint-set-infinite-loop.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction makeObj() {\n  'use no forget';\n  const result = [];\n  result.a = {b: 2};\n\n  return result;\n}\n```\n\n----------------------------------------\n\nTITLE: Managing React Component Dependencies Using Compiler Runtime in JavaScript\nDESCRIPTION: This snippet utilizes a more complex implementation for a React component by importing the `react/compiler-runtime` to manage reactive dependencies. It checks changes in `props.a?.b` to update internal state efficiently. It requires an environment with the appropriate runtime libraries available for import and execution.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/conditional-member-expr.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n```javascript\nimport { c as _c } from \"react/compiler-runtime\"; // To preserve the nullthrows behavior and reactive deps of this code,\n// Forget needs to add `props.a` as a dependency (since `props.a.b` is\n// a conditional dependency, i.e. gated behind control flow)\n\nfunction Component(props) {\n  const $ = _c(2);\n  let x;\n  if ($[0] !== props.a?.b) {\n    x = [];\n    x.push(props.a?.b);\n    $[0] = props.a?.b;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ a: null }],\n};\n\n```\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: The compiled version of the component with automatic memoization implementation using a cache array. Includes checks to prevent unnecessary recalculations of destructured objects and arrays.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/escape-analysis-destructured-rest-element.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(7);\n  let b;\n  if ($[0] !== props.a) {\n    const { a, ...t0 } = props.a;\n    b = t0;\n    $[0] = props.a;\n    $[1] = b;\n  } else {\n    b = $[1];\n  }\n  let d;\n  if ($[2] !== props.c) {\n    [, ...d] = props.c;\n    $[2] = props.c;\n    $[3] = d;\n  } else {\n    d = $[3];\n  }\n  let t0;\n  if ($[4] !== b || $[5] !== d) {\n    t0 = <div b={b} d={d} />;\n    $[4] = b;\n    $[5] = d;\n    $[6] = t0;\n  } else {\n    t0 = $[6];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Invalid Hook Usage in React Component\nDESCRIPTION: This code snippet illustrates an incorrect implementation of hooks in a React component. It attempts to use a custom hook (useHookInsideCallback) within a useEffect callback, which violates the Rules of Hooks. This pattern is not supported and leads to a runtime error.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.bail.rules-of-hooks-3d692676194b.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @skip\n// Unsupported input\n\n// Invalid because it's a common misunderstanding.\n// We *could* make it valid but the runtime error could be confusing.\nconst ComponentWithHookInsideCallback = React.forwardRef((props, ref) => {\n  useEffect(() => {\n    useHookInsideCallback();\n  });\n  return <button {...props} ref={ref} />;\n});\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with fbt Internationalization\nDESCRIPTION: This snippet shows an optimized version of the React component using fbt. It includes memoization for better performance and uses the compiled format of fbt calls.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-param-with-leading-whitespace.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport fbt from \"fbt\";\nimport { identity } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(3);\n  let t0;\n  if ($[0] !== props.count || $[1] !== props.option) {\n    t0 = (\n      <span>\n        {fbt._(\n          { \"*\": \"{count} votes for {option}\", _1: \"1 vote for {option}\" },\n          [\n            fbt._plural(identity(props.count), \"count\"),\n            fbt._param(\n              \"option\",\n\n              props.option,\n            ),\n          ],\n          { hk: \"3Bg20a\" },\n        )}\n        !\n      </span>\n    );\n    $[0] = props.count;\n    $[1] = props.option;\n    $[2] = t0;\n  } else {\n    t0 = $[2];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ count: 42, option: \"thing\" }],\n  sequentialRenders: [\n    { count: 42, option: \"thing\" },\n    { count: 42, option: \"thing\" },\n    { count: 1, option: \"other\" },\n    { count: 1, option: \"other\" },\n    { count: 42, option: \"thing\" },\n    { count: 1, option: \"other\" },\n    { count: 42, option: \"thing\" },\n    { count: 1, option: \"other\" },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining React Component 'Foo' with Array Operations\nDESCRIPTION: This snippet defines a React component 'Foo' that creates an array of objects, selects a value based on a constant, and invokes a function with the result. It also exports a fixture for testing purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/lambda-array-access-member-expr-captured.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {CONST_NUMBER0, invoke} from 'shared-runtime';\n\nfunction Foo() {\n  const x = [{value: 0}, {value: 1}, {value: 2}];\n  const param = CONST_NUMBER0;\n  const foo = () => {\n    return x[param].value;\n  };\n\n  return invoke(foo);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Debugging Options\nDESCRIPTION: This JavaScript snippet defines a simple React functional component. It attempts to enable both `disableMemoizationForDebugging` and `enableChangeDetectionForDebugging` simultaneously, which are mutually exclusive debugging options.  This configuration is intended to trigger an error.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.nomemo-and-change-detect.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @disableMemoizationForDebugging @enableChangeDetectionForDebugging\nfunction Component(props) {}\n```\n\n----------------------------------------\n\nTITLE: Enhanced Component with React Compiler Runtime - JavaScript\nDESCRIPTION: This snippet enhances the previous React component with compiler runtime functionalities to manage state. It checks for changes in props to decide whether to mutate an internal state. The 'props' parameter retains the same functionality, being critical for determining if a re-render is necessary.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-dependency-object-captured-with-reactive-mutated.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nconst { mutate } = require(\"shared-runtime\");\n\nfunction Component(props) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== props.y) {\n    const x = {};\n    const y = props.y;\n    const z = [x, y];\n    mutate(z);\n\n    t0 = [x];\n    $[0] = props.y;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ y: 42 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Function in JavaScript\nDESCRIPTION: This snippet defines a basic function `bar` that takes an argument, manipulates it, and returns a specific value. It initializes an array and an object, uses an immediately invoked function expression to set a property of the object, and returns the value from the array, which is indirectly modified.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-alias-computed-load-2-iife.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction bar(a) {\n  let x = [a];\n  let y = {};\n  (function () {\n    y = x[0][1];\n  })();\n\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: bar,\n  params: [['val1', 'val2']],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Basic React Component with forwardRef\nDESCRIPTION: This snippet defines a basic React component using forwardRef. The component is not named like a typical component and simply returns an empty div element.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/infer-function-expression-React-memo-gating.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @gating @compilationMode(infer)\nimport React from 'react';\nexport default React.forwardRef(function notNamedLikeAComponent(props) {\n  return <div />;\n});\n```\n\n----------------------------------------\n\nTITLE: Installing ESLint via npm\nDESCRIPTION: Command to install ESLint as a dev dependency using npm. ESLint is required to lint JavaScript projects.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/eslint-plugin-react-compiler/README.md#2025-04-21_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm i eslint --save-dev\n```\n\n----------------------------------------\n\nTITLE: React Compiler Transformed JavaScript Function\nDESCRIPTION: The compiled version of the same function after React's compiler processes it. It uses the compiler runtime, implements memoization with Symbol.for(), and optimizes the code by removing unused variables and simplifying the logic.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-for-of.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction foo(cond) {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = [];\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const items = t0;\n  for (const item of items) {\n    if (cond) {\n    }\n  }\n  return items;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: React Mutation Error\nDESCRIPTION: This error message indicates an attempt to mutate a variable defined outside a component or hook. Specifically, it highlights a mutation of `x` within the `mutatePhiThatCouldBeProps` function. The error suggests using an effect to manage state changes instead of directly mutating variables derived from props or global variables.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-mutation-of-possible-props-phi-indirect.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n  2 |   let x = cond ? someGlobal : props.foo;\n  3 |   const mutatePhiThatCouldBeProps = () => {\n> 4 |     x.y = true;\n    |     ^ InvalidReact: Writing to a variable defined outside a component or hook is not allowed. Consider using an effect. Found mutation of `x` (4:4)\n  5 |   };\n  6 |   const indirectMutateProps = () => {\n  7 |     mutatePhiThatCouldBeProps();\n\n```\n\n----------------------------------------\n\nTITLE: Defining a React Component\nDESCRIPTION: This code snippet defines a React component named 'Component' that uses the 'makeObject' function to create an object and invoke a method on it. The snippet captures the initialization of a component and demonstrates an expected error when trying to destructure a const declaration improperly.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.call-args-destructuring-asignment-complex.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let x = makeObject();\n  x.foo(([[x]] = makeObject()));\n  return x;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Error Message for Multiple FBT Plural Tags\nDESCRIPTION: The error message shown when attempting to use multiple fbt:plural tags within a single fbt component. The error indicates that support for multiple fbt:plural values is not implemented.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/error.todo-multiple-fbt-plural.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n  31 |       </fbt:plural>\n  32 |       to Rust \n> 33 |       <fbt:plural count={months} name=\"number of months\" showCount=\"yes\">\n     |        ^^^^^^^^^^ Todo: Support <fbt> tags with multiple <fbt:plural> values (33:33)\n  34 |         month\n  35 |       </fbt:plural>\n  36 |       traveling\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Custom Compiler Runtime\nDESCRIPTION: This snippet demonstrates an optimized version of the component using a custom compiler runtime. It implements memoization and conditional state updates for improved performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructure-array-assignment-to-context-var.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { identity } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(4);\n  let x;\n  if ($[0] !== props.value) {\n    const [t0] = props.value;\n    x = t0;\n    const foo = () => {\n      x = identity(props.value[0]);\n    };\n\n    foo();\n    $[0] = props.value;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  let t0;\n  if ($[2] !== x) {\n    t0 = { x };\n    $[2] = x;\n    $[3] = t0;\n  } else {\n    t0 = $[3];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ value: [42] }],\n};\n```\n\n----------------------------------------\n\nTITLE: Creating Invalid Hook Usage in React JavaScript\nDESCRIPTION: The provided snippet demonstrates an incorrect pattern of using hooks inside function expressions in React. The createHook function defines a nested useHookWithConditionalHook function that conditionally calls another hook, which is against React rules as hooks must be at the top level of a function component or custom hook. This snippet requires understanding of React's hooks and the Rules of Hooks.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid.invalid-rules-of-hooks-0a1dbff27ba0.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Invalid because it\\'s dangerous and might not warn otherwise.\\n// This *must* be invalid.\\nfunction createHook() {\\n  return function useHookWithConditionalHook() {\\n    if (cond) {\\n      useConditionalHook();\\n    }\\n  };\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Memoization\nDESCRIPTION: The compiler-optimized version of the same component that adds memoization to improve performance. It uses a caching mechanism from react/compiler-runtime to avoid redundant calculations and object creations based on dependency tracking.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-global-object.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { identity, sum } from \"shared-runtime\";\n\n// Check that we correctly resolve type and effect lookups on the javascript\n// global object.\nfunction Component(props) {\n  const $ = _c(4);\n  let t0;\n  if ($[0] !== props.b) {\n    t0 = identity(props.b);\n    $[0] = props.b;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const neverAliasedOrMutated = t0;\n  const primitiveVal1 = Math.max(props.a, neverAliasedOrMutated);\n\n  const primitiveVal3 = globalThis.globalThis.NaN;\n\n  sum(primitiveVal1, Infinity, primitiveVal3);\n  let t1;\n  if ($[2] !== primitiveVal1) {\n    t1 = { primitiveVal1, primitiveVal2: Infinity, primitiveVal3 };\n    $[2] = primitiveVal1;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ a: 1, b: 2 }],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized Function Definition with Compiler Runtime in JavaScript\nDESCRIPTION: This code snippet provides an optimized version of the function 'bar', utilizing the 'react/compiler-runtime' for performance improvement. The function checks previous input parameters to avoid redundant calculations and uses a caching mechanism with an array-like structure, improving efficiency. It exports the function with associated parameters for testing, requiring the 'react/compiler-runtime' import.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-alias-computed-load-3-iife.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction bar(a, b) {\n  const $ = _c(3);\n  let y;\n  if ($[0] !== a || $[1] !== b) {\n    const x = [a, b];\n    y = {};\n    let t;\n    t = {};\n\n    y = x[0][1];\n    t = x[1][0];\n    $[0] = a;\n    $[1] = b;\n    $[2] = y;\n  } else {\n    y = $[2];\n  }\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: bar,\n  params: [\n    [1, 2],\n    [2, 3],\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with Conditional Props\nDESCRIPTION: A React function component that takes props and performs conditional assignment based on props.a. The component returns either props.b or props.c depending on the evaluation of props.a in an array context.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/escape-analysis-not-if-test.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const x = [props.a];\n  let y;\n  if (x) {\n    y = props.b;\n  } else {\n    y = props.c;\n  }\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Click Handler in React Component\nDESCRIPTION: This snippet defines a functional React component with a click event handler. The callback function is intended to be used as an event handler for an onClick event but attempts to reassign itself, resulting in an error that suggests managing state instead.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.function-expression-references-variable-its-assigned-to.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component() {\n  let callback = () => {\n    callback = null;\n  };\n  return <div onClick={callback} />;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Function Component Definition in JavaScript\nDESCRIPTION: Defines a basic function component in JavaScript that uses an instance of the Foo class. It initializes and returns a component object with internal properties. This snippet doesn't require specific dependencies other than the Foo class definition.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-newexpression.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nfunction Foo() {}\n\nfunction Component(props) {\n  const a = [];\n  const b = {};\n  let c = new Foo(a, b);\n  return c;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Error Message for Invalid Hook Usage in React\nDESCRIPTION: This error message is generated when attempting to use a hook inside a callback function within a React component. It points out the specific line where the invalid hook call occurs and provides a link to the Rules of Hooks documentation for further information.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.bail.rules-of-hooks-3d692676194b.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n   6 | const ComponentWithHookInsideCallback = React.forwardRef((props, ref) => {\n   7 |   useEffect(() => {\n>  8 |     useHookInsideCallback();\n     |     ^^^^^^^^^^^^^^^^^^^^^ InvalidReact: Hooks must be called at the top level in the body of a function component or custom hook, and may not be called within function expressions. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning). Cannot call Custom within a function component (8:8)\n   9 |   });\n  10 |   return <button {...props} ref={ref} />;\n  11 | });\n```\n\n----------------------------------------\n\nTITLE: Implementing React Test Fixture with Block Label\nDESCRIPTION: Implements a test fixture function using a labeled block statement to set a variable before returning. Exports a fixture entrypoint configuration for a TodoAdd component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unconditional-break-label.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(a) {\n  let x = 0;\n  bar: {\n    x = 1;\n    break bar;\n  }\n  return a + x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Exporting React Component as FIXTURE_ENTRYPOINT\nDESCRIPTION: This code exports the 'Foo' component as part of an object assigned to 'FIXTURE_ENTRYPOINT'. This object configures the component for use in a fixture or testing setup. It includes the component function itself, the component's parameters, and the component's name.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unused-object-element.expect.md#2025-04-21_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Input Test Function with Intentional Loop Issue in JavaScript\nDESCRIPTION: Defines a function 'foo' that initializes a variable and contains a for loop with an intentionally missing update expression. The function is exported as a fixture entry point for testing purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-for-trivial-update.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo() {\n  let x = 1;\n  for (let i = 0; i < 10; /* update is intentally a single identifier */ i) {\n    x += 1;\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Creating an Array with Optional Chaining from Nullable Values in React\nDESCRIPTION: This code defines a 'useFoo' function that handles a prop containing a nullable nested object, attempts to create an array from its properties using optional chaining, and then tries to join the array elements. It also includes a helper 'createArray' function and exports a test fixture. The code generates a type error for the optional chaining usage.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-optional-call-chain-in-optional.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction useFoo(props: {value: {x: string; y: string} | null}) {\n  const value = props.value;\n  return createArray(value?.x, value?.y)?.join(', ');\n}\n\nfunction createArray<T>(...args: Array<T>): Array<T> {\n  return args;\n}\n\nexport const FIXTURE_ENTRYPONT = {\n  fn: useFoo,\n  props: [{value: null}],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component Implementation\nDESCRIPTION: Identical implementation of the React component showing the same functionality with slightly different formatting in the fixture object.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-in-statement-body-always-returns.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  for (const x in props.value) {\n    return x;\n  }\n  return null;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ value: { a: \"A!\" } }],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Hook with Attached Method\nDESCRIPTION: Creates a custom hook function with an additional static method, showing an incorrect way of referencing hooks\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.hook-property-load-local-hook.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction useFoo() {}\nuseFoo.useBar = function () {\n  return 'foo';\n};\n\nfunction Foo() {\n  let bar = useFoo.useBar;\n  return bar();\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled Conditional Subpath Dependency React Code\nDESCRIPTION: This JavaScript code represents the compiled version of the `useConditionalSubpath2` function. It utilizes the `react/compiler-runtime` to optimize the function's execution and dependency tracking. The compiler inserts logic to cache the result of the function based on the input `props.a` and `other` values. If the inputs haven't changed, the cached result is returned, otherwise, the function executes and the result is cached.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/subpath-order2.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // When a conditional dependency `props.a` is a subpath of an unconditional\n// dependency `props.a.b`, we can access `props.a` while preserving program\n// semantics (with respect to nullthrows).\n// deps: {`props.a`, `props.a.b`} can further reduce to just `props.a`\n\nimport { identity } from \"shared-runtime\";\n\n// ordering of accesses should not matter\nfunction useConditionalSubpath2(props, other) {\n  const $ = _c(3);\n  let x;\n  if ($[0] !== other || $[1] !== props.a) {\n    x = {};\n    if (identity(other)) {\n      x.a = props.a;\n    }\n\n    x.b = props.a.b;\n    $[0] = other;\n    $[1] = props.a;\n    $[2] = x;\n  } else {\n    x = $[2];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useConditionalSubpath2,\n  params: [{ a: { b: 3 } }, false],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Function in JavaScript\nDESCRIPTION: This snippet defines a simple function 'g' that initializes an object and manipulates its properties by incrementing and then doubling a value. The result is returned from the function. There are no external dependencies for this function.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/assignment-variations-complex-lvalue.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction g() {\n  const x = {y: {z: 1}};\n  x.y.z = x.y.z + 1;\n  x.y.z *= 2;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: g,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Function for Data Manipulation - JavaScript\nDESCRIPTION: This snippet defines a simple function 'bar' that takes an argument 'a', initializes an array with it, and assigns it to a variable 'y' through an inner function. The function is then exported as part of a fixture entry point with specified parameters.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-alias-computed-load.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction bar(a) {\n  let x = [a];\n  let y = {};\n  const f0 = function () {\n    y = x[0];\n  };\n  f0();\n\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: bar,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a React Component with Ref Usage\nDESCRIPTION: This snippet defines a React functional component that incorrectly accesses the 'current' property of a ref during the render phase, triggering a warning. The use of the `useRef` hook is demonstrated, and the resulting behavior highlights the violation of React's rules regarding ref access in the render cycle.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-pass-ref-to-function.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validateRefAccessDuringRender\nfunction Component(props) {\n  const ref = useRef(null);\n  const x = foo(ref);\n  return x.current;\n}\n```\n\n----------------------------------------\n\nTITLE: Optimized Component with Compiler Runtime Memoization\nDESCRIPTION: An enhanced version of the previous component using React compiler runtime for memoization. Implements caching of component state and optimizes re-rendering by tracking changes in input parameters.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/try-catch-try-value-modified-in-catch-escaping.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enablePropagateDepsInHIR\nconst { throwInput } = require(\"shared-runtime\");\n\nfunction Component(props) {\n  const $ = _c(3);\n  let x;\n  if ($[0] !== props.e || $[1] !== props.y) {\n    try {\n      const y = [];\n      y.push(props.y);\n      throwInput(y);\n    } catch (t0) {\n      const e = t0;\n      e.push(props.e);\n      x = e;\n    }\n    $[0] = props.e;\n    $[1] = props.y;\n    $[2] = x;\n  } else {\n    x = $[2];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ y: \"foo\", e: \"bar\" }],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining React Compiler Fixture Entrypoint\nDESCRIPTION: Configuration for testing the compiler transformation with sequential render scenarios\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/infer-function-uncond-access-local-var.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{a: null}],\n  sequentialRenders: [{a: null}, {a: {b: {c: 4}}}],\n};\n```\n\n----------------------------------------\n\nTITLE: Downloading Dependencies from CI for React DevTools\nDESCRIPTION: Commands to download the latest experimental build from CI for React DevTools development, starting from the repository root.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools-extensions/README.md#2025-04-21_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\ncd scripts/release\nyarn install\n./download-experimental-build.js\n```\n\n----------------------------------------\n\nTITLE: Error Handling for Invalid Type Configuration\nDESCRIPTION: This snippet shows the error that arises when the expected type configuration for the imported module is not a hook, as indicated by the error message. This highlights the importance of adhering to naming conventions for module exports in React projects.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-type-provider-hooklike-module-default-not-hook.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n  2 |\n  3 | function Component() {\n> 4 |   return <div>{foo()}</div>;\n    |                ^^^ InvalidConfig: Invalid type configuration for module. Expected type for `import ... from 'useDefaultExportNotTypedAsHook'` to be a hook based on the module name (4:4)\n  5 | }\n  6 |\n\n```\n\n----------------------------------------\n\nTITLE: Original Array Manipulation Function\nDESCRIPTION: Input function that creates a nested array, accesses its first element using at(), and modifies it using set(). Includes an export of fixture configuration.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/assignment-variations-complex-lvalue-array.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo() {\n  const a = [[1]];\n  const first = a.at(0);\n  first.set(0, 2);\n  return a;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Hook Implementation\nDESCRIPTION: Original implementation of a custom React hook that creates and mutates an object based on input parameters. The hook takes an object with 'a' and 'b' properties and returns a mutated object structure.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/computed-store-alias.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {mutate} from 'shared-runtime';\nfunction useHook({a, b}) {\n  let y = {a};\n  let x = {b};\n  x['y'] = y;\n  mutate(x);\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useHook,\n  params: [{a: 2, b: 3}],\n  sequentialRenders: [\n    {a: 2, b: 3},\n    {a: 2, b: 3},\n    {a: 3, b: 3},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Basic Flow-typed React Component with Hook\nDESCRIPTION: Initial version of a React component using Flow annotations and a dynamic hook. Includes special Flow directives for hook guards and other configurations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-dont-add-hook-guards-on-retry.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @flow @enableEmitHookGuards @panicThreshold(none) @enableFire\n\ncomponent Foo(useDynamicHook) {\n  useDynamicHook();\n  return <div>hello world</div>;\n}\n```\n\n----------------------------------------\n\nTITLE: Refactored React Component Function\nDESCRIPTION: This snippet demonstrates the refactored version of the component function. It uses const declarations for improved immutability and removes the unnecessary object declaration inside the conditional block.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-binary-operator.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component() {\n  const a = some();\n  const b = someOther();\n  if (a > b) {\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining React Component Fixture with Array Manipulation in JavaScript\nDESCRIPTION: Defines a function 'foo' that creates and populates two arrays, followed by exporting a FIXTURE_ENTRYPOINT object that specifies the function, its parameters, and identifies it as a 'TodoAdd' component for testing purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/overlapping-scopes-interleaved.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(a, b) {\n  let x = [];\n  let y = [];\n  x.push(a);\n  y.push(b);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component with Conditional Object Mutation\nDESCRIPTION: This snippet shows a React component that creates and mutates an object conditionally. It demonstrates a case where the compiler cannot safely hoist property reads as dependencies because x.a.b is accessed unconditionally before a potential mutation of x.a.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/uncond-access-in-mutable-range.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// x.a.b was accessed unconditionally within the mutable range of x.\n// As a result, we cannot infer anything about whether `x` or `x.a`\n// may be null. This means that it's not safe to hoist reads from x\n// (e.g. take `x.a` or `x.a.b` as a dependency).\n\nimport {identity, makeObject_Primitives, setProperty} from 'shared-runtime';\n\nfunction Component({cond, other}) {\n  const x = makeObject_Primitives();\n  setProperty(x, {b: 3, other}, 'a');\n  identity(x.a.b);\n  if (!cond) {\n    x.a = null;\n  }\n\n  const y = [identity(cond) && x.a.b];\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{cond: false}],\n  sequentialRenders: [\n    {cond: false},\n    {cond: false},\n    {cond: false, other: 8},\n    {cond: true},\n    {cond: true},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Hook Wrapper in React - JavaScript\nDESCRIPTION: This snippet demonstrates how to define a custom hook in React using JavaScript. It uses the 'createHookWrapper' from a shared runtime to wrap the 'useHook' function, which manages values 'a' and 'b'. It returns an object with methods 'x' and 'y' that encapsulate these values. The FIXTURE_ENTRYPOINT establishes how the hook will be used, defining 'params' with initial values for 'a' and 'b'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-shorthand-method-1.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {createHookWrapper} from 'shared-runtime';\nfunction useHook({a, b}) {\n  return {\n    x: function () {\n      return [a];\n    },\n    y() {\n      return [b];\n    },\n  };\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: createHookWrapper(useHook),\n  params: [{a: 1, b: 2}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with Structural Checks\nDESCRIPTION: This snippet builds upon the previous component by integrating structural checks using the '$structuralCheck' method from 'react-compiler-runtime'. It performs change detection on the component's props and state for debugging purposes. The code includes the useState hook and checks for updates, recomputing values as necessary. This component expects a props object similar to the basic version and includes additional dependencies for debugging.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useState-unpruned-dependency.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { $structuralCheck } from \"react-compiler-runtime\";\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useState } from \"react\"; // @enableChangeDetectionForDebugging\n\nfunction Component(props) {\n  const $ = _c(5);\n  let t0;\n  {\n    t0 = f(props.x);\n    let condition = $[0] !== props.x;\n    if (!condition) {\n      let old$t0 = $[1];\n      $structuralCheck(old$t0, t0, \"t0\", \"Component\", \"cached\", \"(4:4)\");\n    }\n    $[0] = props.x;\n    $[1] = t0;\n    if (condition) {\n      t0 = f(props.x);\n      $structuralCheck($[1], t0, \"t0\", \"Component\", \"recomputed\", \"(4:4)\");\n      t0 = $[1];\n    }\n  }\n  const w = t0;\n  const [x] = useState(w);\n  let t1;\n  {\n    t1 = (\n      <div>\n        {x}\n        {w}\n      </div>\n    );\n    let condition = $[2] !== w || $[3] !== x;\n    if (!condition) {\n      let old$t1 = $[4];\n      $structuralCheck(old$t1, t1, \"t1\", \"Component\", \"cached\", \"(7:10)\");\n    }\n    $[2] = w;\n    $[3] = x;\n    $[4] = t1;\n    if (condition) {\n      t1 = (\n        <div>\n          {x}\n          {w}\n        </div>\n      );\n      $structuralCheck($[4], t1, \"t1\", \"Component\", \"recomputed\", \"(7:10)\");\n      t1 = $[4];\n    }\n  }\n  return t1;\n}\n\nfunction f(x) {\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ x: 42 }],\n  isComponent: true,\n};\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Conditional Dependencies in React Custom Hook (Input)\nDESCRIPTION: A React custom hook that demonstrates how props accessed within multiple conditional blocks should be tracked as unconditional dependencies. The function creates an object with different properties depending on condition evaluation, but accesses props.a.b in all possible execution paths.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/cfg-nested-ifelse.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// props.a.b should be added as a unconditional dependency to the reactive\n// scope that produces x, since it is accessed unconditionally in all cfg\n// paths\n\nimport {getNull, identity} from 'shared-runtime';\n\nfunction useCondDepInNestedIfElse(props, cond) {\n  const x = {};\n  if (identity(cond)) {\n    if (getNull()) {\n      x.a = props.a.b;\n    } else {\n      x.b = props.a.b;\n    }\n  } else if (identity(cond)) {\n    x.c = props.a.b;\n  } else {\n    x.d = props.a.b;\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useCondDepInNestedIfElse,\n  params: [{a: {b: 2}}, true],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component with Context\nDESCRIPTION: Basic React component implementation using Context API and a memoized click handler that reads context value. Demonstrates the pattern of creating and consuming context with a callback function.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useContext-read-context-in-callback.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {createContext, useContext} from 'react';\n\nconst FooContext = createContext({current: null});\n\nfunction Component(props) {\n  const foo = useContext(FooContext);\n  // This function should be memoized since it is only reading the context value\n  const onClick = () => {\n    console.log(foo.current);\n  };\n  return <div onClick={onClick}>{props.children}</div>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{children: <div>Hello</div>}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Compiler Runtime\nDESCRIPTION: This snippet shows the compiled version of the React component, leveraging the `react/compiler-runtime` for memoization. It initializes a cache using `_c` and conditionally updates the returned array based on changes in props. This optimizes re-renders by caching previous results.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-dependency-nonreactive-captured-with-reactive.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(3);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = {};\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const x = t0;\n  const y = props.y;\n  let t1;\n  if ($[1] !== y) {\n    t1 = [x, y];\n    $[1] = y;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ y: 42 }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: Compiled version of the component with added memoization logic, dependency tracking, and early return handling. Includes runtime optimizations and caching mechanisms.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/partial-early-return-within-reactive-scope.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enablePropagateDepsInHIR\nfunction Component(props) {\n  const $ = _c(6);\n  let t0;\n  let y;\n  if ($[0] !== props.a || $[1] !== props.b || $[2] !== props.cond) {\n    t0 = Symbol.for(\"react.early_return_sentinel\");\n    bb0: {\n      const x = [];\n      if (props.cond) {\n        x.push(props.a);\n        t0 = x;\n        break bb0;\n      } else {\n        let t1;\n        if ($[5] === Symbol.for(\"react.memo_cache_sentinel\")) {\n          t1 = foo();\n          $[5] = t1;\n        } else {\n          t1 = $[5];\n        }\n        y = t1;\n        if (props.b) {\n          t0 = undefined;\n          break bb0;\n        }\n      }\n    }\n    $[0] = props.a;\n    $[1] = props.b;\n    $[2] = props.cond;\n    $[3] = t0;\n    $[4] = y;\n  } else {\n    t0 = $[3];\n    y = $[4];\n  }\n  if (t0 !== Symbol.for(\"react.early_return_sentinel\")) {\n    return t0;\n  }\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ cond: true, a: 42 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Closure Capture in JavaScript\nDESCRIPTION: This JavaScript code defines a function `get2` that captures the variable `x` in a closure using a callback function. The callback function `callbk` returns a copy of `x`. The function then defines `x` and immediately calls `callbk`, returning the captured value.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-repro-variable-used-in-assignment.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction get2() {\n  const callbk = () => {\n    const copy = x;\n    return copy;\n  };\n  const x = 2;\n  return callbk();\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: get2,\n  params: [],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Creating a JavaScript Function with Deliberate Infinite Loop\nDESCRIPTION: A JavaScript function 'foo' containing an explicit infinite loop using 'while(true)'. The return statement after the loop will never be reached. This function is exported as part of a test fixture object.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-while-no-reassign.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo() {\n  while (true) {}\n  return 1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: React Compilation Error for Fire Method\nDESCRIPTION: Error message indicating an invalid usage of the `fire()` method in a React component. The error specifies that `fire()` can only receive a function call, not direct method or expression invocations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/error.invalid-not-call.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n   7 |   };\n   8 |   useEffect(() => {\n>  9 |     fire(props);\n     |     ^^^^^^^^^^^ InvalidReact: Cannot compile `fire`. `fire()` can only receive a function call such as `fire(fn(a,b)). Method calls and other expressions are not allowed (9:9)\n  10 |   });\n  11 |\n  12 |   return null;\n```\n\n----------------------------------------\n\nTITLE: Conditional State Management in React with JavaScript\nDESCRIPTION: This snippet redefines the useFoo function, integrating React's compiler-runtime to conditionally manage state and rendering. Dependencies include \"react/compiler-runtime\" and \"shared-runtime\". The function checks and updates state only when necessary, optimizing performance by reducing unnecessary operations. It accepts an object with properties \"bar\", \"foo\", and \"cond\" as input, aiming to minimize changes to component state unless conditions explicitly change.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/ssa-renaming-with-mutation.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enablePropagateDepsInHIR\\nimport { mutate } from \"shared-runtime\";\\n\\nfunction useFoo(props) {\\n  const $ = _c(4);\\n  let x;\\n  if ($[0] !== props.bar || $[1] !== props.cond || $[2] !== props.foo) {\\n    x = [];\\n    x.push(props.bar);\\n    if (props.cond) {\\n      x = [];\\n      x.push(props.foo);\\n    }\\n\\n    mutate(x);\\n    $[0] = props.bar;\\n    $[1] = props.cond;\\n    $[2] = props.foo;\\n    $[3] = x;\\n  } else {\\n    x = $[3];\\n  }\\n  return x;\\n}\\n\\nexport const FIXTURE_ENTRYPOINT = {\\n  fn: useFoo,\\n  params: [{ bar: \"bar\", foo: \"foo\", cond: true }],\\n  sequentialRenders: [\\n    { bar: \"bar\", foo: \"foo\", cond: true },\\n    { bar: \"bar\", foo: \"foo\", cond: true },\\n    { bar: \"bar\", foo: \"foo\", cond: false },\\n  ],\\n};\\n\n```\n\n----------------------------------------\n\nTITLE: Refreshing dependencies after React changes\nDESCRIPTION: Command to refresh dependencies after making changes to React and rebuilding it.\nSOURCE: https://github.com/facebook/react/blob/main/fixtures/ssr2/README.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nyarn\n```\n\n----------------------------------------\n\nTITLE: Input React Component with Array Transformation\nDESCRIPTION: Original input component showing array manipulation, identity usage, and rendering with Stringify component\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-from-maybemutates-arg0.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {mutateAndReturn, Stringify, useIdentity} from 'shared-runtime';\n\nfunction Component({value}) {\n  const arr = [{value: 'foo'}, {value: 'bar'}, {value}];\n  useIdentity();\n  const derived = Array.from(arr).map(mutateAndReturn);\n  return (\n    <Stringify>\n      {derived.at(0)}\n      {derived.at(-1)}\n    </Stringify>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Optimized: React Compiler Runtime Function\nDESCRIPTION: Compiler-optimized version of the function using React's compiler runtime with memoization and early return sentinel pattern\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-cond-deps-return-in-scope.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction useFoo(t0) {\n  const $ = _c(4);\n  const { obj, objIsNull } = t0;\n  let t1;\n  let x;\n  if ($[0] !== obj || $[1] !== objIsNull) {\n    t1 = Symbol.for(\"react.early_return_sentinel\");\n    bb0: {\n      x = [];\n      if (objIsNull) {\n        t1 = undefined;\n        break bb0;\n      } else {\n        x.push(obj.a);\n      }\n\n      x.push(obj.b);\n    }\n    $[0] = obj;\n    $[1] = objIsNull;\n    $[2] = t1;\n    $[3] = x;\n  } else {\n    t1 = $[2];\n    x = $[3];\n  }\n  if (t1 !== Symbol.for(\"react.early_return_sentinel\")) {\n    return t1;\n  }\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Simplified React Component Definition and Export\nDESCRIPTION: This snippet shows a simplified version of the component function that directly returns a value of 2. It exports the component as a fixture entrypoint with the same properties as the input version.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-test-primitive.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component() {\n  return 2;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Initial VideoTab Component Implementation\nDESCRIPTION: A basic React functional component that creates a reference and defines a function to access video list data\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ref-current-optional-field-no-added-to-dep.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction VideoTab() {\n  const ref = useRef();\n  let x = () => {\n    ref.current?.x;\n  };\n\n  return <VideoList videos={x} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Optimizing React Component with Memoization\nDESCRIPTION: This snippet shows an optimized version of the React component using memoization. It imports a compiler runtime function for caching and only updates the result when the sum changes. The test fixture remains the same as in the input version.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-dce-circular-reference.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { identity } from \"shared-runtime\";\n\nfunction Component(t0) {\n  const $ = _c(2);\n  const { data } = t0;\n  let x = 0;\n  for (const item of data) {\n    const { current, other } = item;\n    x = x + current;\n    identity(other);\n  }\n  let t1;\n  if ($[0] !== x) {\n    t1 = [x];\n    $[0] = x;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\n    {\n      data: [\n        { current: 2, other: 3 },\n        { current: 4, other: 5 },\n      ],\n    },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with react/compiler-runtime\nDESCRIPTION: This snippet shows the compiled output of the React component using `react/compiler-runtime`. It imports `_c` from `react/compiler-runtime` and uses it to memoize the component's rendering. The `onClick` handler, named `_temp`, still modifies the global variables.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-reassignment-to-global-function-jsx-prop.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component() {\n  const $ = _c(1);\n  const onClick = _temp;\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = <div onClick={onClick} />;\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\nfunction _temp() {\n  someUnknownGlobal = true;\n  moduleLocal = true;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}]\n};\n\n```\n\n----------------------------------------\n\nTITLE: Implementing useFoo Function with React Memoization\nDESCRIPTION: This snippet defines a useFoo function that uses React's useMemo hook for memoization. It calculates derived values based on a condition and a source dependency, demonstrating basic memoization patterns.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useMemo-constant-prop.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees\nimport {useMemo} from 'react';\nimport {identity} from 'shared-runtime';\n\nfunction useFoo(cond) {\n  const sourceDep = 0;\n  const derived1 = useMemo(() => {\n    return identity(sourceDep);\n  }, [sourceDep]);\n  const derived2 = (cond ?? Math.min(sourceDep, 1)) ? 1 : 2;\n  const derived3 = useMemo(() => {\n    return identity(sourceDep);\n  }, [sourceDep]);\n  const derived4 = (Math.min(sourceDep, -1) ?? cond) ? 1 : 2;\n  return [derived1, derived2, derived3, derived4];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [true],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component Definition with Ref\nDESCRIPTION: Defines a React component `Foo` that accepts `props` and a `ref`. It conditionally renders a `Stringify` component based on `CONST_TRUE` and attempts to access the `ref` within the render function.  The fixture entry point provides example parameters for the component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.repro-ref-mutable-range.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {Stringify, identity, mutate, CONST_TRUE} from 'shared-runtime';\n\nfunction Foo(props, ref) {\n  const value = {};\n  if (CONST_TRUE) {\n    mutate(value);\n    return <Stringify ref={ref} />;\n  }\n  mutate(value);\n  if (CONST_TRUE) {\n    return <Stringify ref={identity(ref)} />;\n  }\n  return value;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{}, {current: 'fake-ref-object'}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Running React Compiler Playground Tests\nDESCRIPTION: Commands for installing Playwright browser dependencies and running the test suite.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/apps/playground/README.md#2025-04-21_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\n# Install playwright browser binaries\n$ npx playwright install --with-deps\n# Run tests\n$ yarn test\n```\n\n----------------------------------------\n\nTITLE: Defining Minimal React Test Fixture in JavaScript\nDESCRIPTION: A minimal JavaScript test fixture with an empty 'foo' function and FIXTURE_ENTRYPOINT export for React testing. This simplified version contains just the function structure with no implementation details.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-single-if.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo() {}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Creating Component with Shared Runtime - JavaScript\nDESCRIPTION: This snippet defines the `useComponentFactory` function that takes an object with a `name` property and returns the result of invoking a callback function. It utilizes the `invoke` function from 'shared-runtime' for dynamic functionality and stringifies the output within a component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-lowercase-localvar-memberexpr-in-lambda.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as SharedRuntime from 'shared-runtime';\nimport {invoke} from 'shared-runtime';\nfunction useComponentFactory({name}) {\n  const localVar = SharedRuntime;\n  const cb = () => <localVar.Stringify>hello world {name}</localVar.Stringify>;\n  return invoke(cb);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useComponentFactory,\n  params: [{name: 'sathya'}],\n};\n```\n\n----------------------------------------\n\nTITLE: Original JavaScript Function Implementation\nDESCRIPTION: Original function implementation with conditional object creation and property assignment. The function creates new objects based on a condition and sets a property 'f' before returning.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/obj-mutated-after-if-else.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(a, b, c, d) {\n  let x = someObj();\n  if (a) {\n    x = someObj();\n  } else {\n    x = someObj();\n  }\n\n  x.f = 1;\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining useFoo Component with Compiler Optimizations (Code)\nDESCRIPTION: This snippet defines the `useFoo` component with optimizations added by the React compiler runtime (indicated by `_c`).  It caches the result of computations using an array `$` and compares current props against cached values to avoid unnecessary re-renders and mutations. `FIXTURE_ENTRYPOINT` object configures the component for testing with specific initial parameters and sequential renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/ssa-renaming-via-destructuring-with-mutation.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enablePropagateDepsInHIR\nimport { mutate } from \"shared-runtime\";\n\nfunction useFoo(props) {\n  const $ = _c(4);\n  let x;\n  if ($[0] !== props.bar || $[1] !== props.cond || $[2] !== props.foo) {\n    ({ x } = { x: [] });\n    x.push(props.bar);\n    if (props.cond) {\n      ({ x } = { x: [] });\n      x.push(props.foo);\n    }\n\n    mutate(x);\n    $[0] = props.bar;\n    $[1] = props.cond;\n    $[2] = props.foo;\n    $[3] = x;\n  } else {\n    x = $[3];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ bar: \"bar\", foo: \"foo\", cond: true }],\n  sequentialRenders: [\n    { bar: \"bar\", foo: \"foo\", cond: true },\n    { bar: \"bar\", foo: \"foo\", cond: true },\n    { bar: \"bar\", foo: \"foo\", cond: false },\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Original React Memo Input Code\nDESCRIPTION: Input code demonstrating improper usage of React.memo() with an undefined component, used to test error handling\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/invalid-fnexpr-reference.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @gating\nimport * as React from 'react';\n\nlet Foo;\nconst MemoFoo = React.memo(Foo);\nFoo = () => <div>hello world!</div>;\n\n/**\n * Evaluate this fixture module to assert that compiler + original have the same\n * runtime error message.\n */\nexport const FIXTURE_ENTRYPOINT = {\n  fn: () => {},\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining FIXTURE_ENTRYPOINT for React Component Testing\nDESCRIPTION: This snippet exports a FIXTURE_ENTRYPOINT object used for testing the React component. It includes the component function, initial parameters, and an array of sequential renders with different prop combinations to test various scenarios.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-mutable-range-extending-into-ternary.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ cond: false, items: [{ id: 0, name: \"Alice\" }] }],\n  sequentialRenders: [\n    { cond: false, items: [{ id: 0, name: \"Alice\" }] },\n    {\n      cond: false,\n      items: [\n        { id: 0, name: \"Alice\" },\n        { id: 1, name: \"Bob\" },\n      ],\n    },\n    {\n      cond: true,\n      items: [\n        { id: 0, name: \"Alice\" },\n        { id: 1, name: \"Bob\" },\n      ],\n    },\n    {\n      cond: false,\n      items: [\n        { id: 1, name: \"Bob\" },\n        { id: 2, name: \"Claire\" },\n      ],\n    },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with Conditional Assignment and Destructuring\nDESCRIPTION: This snippet defines a React component that conditionally assigns a value to 'x' based on props. It uses destructuring assignment and provides a fallback option.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-assignment-array-default.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let x;\n  if (props.cond) {\n    [[x] = ['default']] = props.y;\n  } else {\n    x = props.fallback;\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Component with Relay Environment and Mutator\nDESCRIPTION: This snippet presents a React component that integrates a Relay environment using a Mutator class. This setup promotes immutability, preventing direct alterations to `this`, and allows for the component's state and dependencies to be managed effectively. The Mutator class facilitates read-only operations, contributing to a stable component state. Supporting functions like `useOtherHook` and `foo` are essential for functionality but are assumed to be defined externally.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inadvertent-mutability-readonly-class.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const env = useRelayEnvironment();\n\n  const mutator = new Mutator(env);\n\n  useOtherHook();\n\n  const x = {};\n  foo(x, mutator);\n  return x;\n}\n\nclass Mutator {}\n\n```\n\n----------------------------------------\n\nTITLE: Compiled useFoo function with React compiler-runtime\nDESCRIPTION: This is the compiled version of the `useFoo` function. It uses `_c` from `react/compiler-runtime` for memoization and incorporates an early return mechanism. The function caches the results of conditional checks and input values to optimize performance in subsequent renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-unpoisoned/reduce-if-exhaustive-nonpoisoned-deps1.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { identity } from \"shared-runtime\";\n\nfunction useFoo(t0) {\n  const $ = _c(11);\n  const { input, cond2, cond1 } = t0;\n  let t1;\n  let x;\n  if ($[0] !== cond1 || $[1] !== cond2 || $[2] !== input.a.b) {\n    t1 = Symbol.for(\"react.early_return_sentinel\");\n    bb0: {\n      x = [];\n      if (cond1) {\n        if (!cond2) {\n          let t2;\n          if ($[5] !== input.a.b) {\n            t2 = identity(input.a.b);\n            $[5] = input.a.b;\n            $[6] = t2;\n          } else {\n            t2 = $[6];\n          }\n          x.push(t2);\n          t1 = null;\n          break bb0;\n        } else {\n          let t2;\n          if ($[7] !== input.a.b) {\n            t2 = identity(input.a.b);\n            $[7] = input.a.b;\n            $[8] = t2;\n          } else {\n            t2 = $[8];\n          }\n          x.push(t2);\n        }\n      } else {\n        let t2;\n        if ($[9] !== input.a.b) {\n          t2 = identity(input.a.b);\n          $[9] = input.a.b;\n          $[10] = t2;\n        } else {\n          t2 = $[10];\n        }\n        x.push(t2);\n      }\n    }\n    $[0] = cond1;\n    $[1] = cond2;\n    $[2] = input.a.b;\n    $[3] = t1;\n    $[4] = x;\n  } else {\n    t1 = $[3];\n    x = $[4];\n  }\n  if (t1 !== Symbol.for(\"react.early_return_sentinel\")) {\n    return t1;\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ input: { b: 1 }, cond1: true, cond2: false }],\n  sequentialRenders: [\n    { input: { a: { b: 1 } }, cond1: true, cond2: true },\n    { input: null, cond1: true, cond2: false },\n    // preserve nullthrows\n    { input: { a: { b: undefined } }, cond1: true, cond2: true },\n    { input: { a: null }, cond1: true, cond2: true },\n    { input: { a: { b: undefined } }, cond1: true, cond2: true },\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Optimizing useFoo using Compiler Runtimes in JavaScript\nDESCRIPTION: An enhanced version of the useFoo function introduces caching via the react/compiler-runtime. Dependencies include shared-runtime for array operations. This snippet optimizes rendering by tracking previous inputs to minimize processing. Parameters include 'cond', 'foo', and 'bar', with output arrays adjusting based on these properties, intended for optimized re-renders and state tracking.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/ssa-renaming-unconditional-ternary-with-mutation.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enablePropagateDepsInHIR\nimport { arrayPush } from \"shared-runtime\";\nfunction useFoo(props) {\n  const $ = _c(4);\n  let x;\n  if ($[0] !== props.bar || $[1] !== props.cond || $[2] !== props.foo) {\n    x = [];\n    x.push(props.bar);\n    props.cond ? ((x = []), x.push(props.foo)) : ((x = []), x.push(props.bar));\n    arrayPush(x, 4);\n    $[0] = props.bar;\n    $[1] = props.cond;\n    $[2] = props.foo;\n    $[3] = x;\n  } else {\n    x = $[3];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ cond: false, foo: 2, bar: 55 }],\n  sequentialRenders: [\n    { cond: false, foo: 2, bar: 55 },\n    { cond: false, foo: 3, bar: 55 },\n    { cond: true, foo: 3, bar: 55 },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: React Side-Effect Error\nDESCRIPTION: This snippet displays the error message generated by React when a component attempts to reassign a variable defined outside of its scope. The error message suggests using `useState` instead if the variable is used in rendering.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.reassign-global-fn-arg.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n  3 | export default function MyApp() {\n  4 |   const fn = () => {\n> 5 |     b = 2;\n    |     ^ InvalidReact: Unexpected reassignment of a variable which was defined outside of the component. Components and hooks should be pure and side-effect free, but variable reassignment is a form of side-effect. If this variable is used in rendering, use useState instead. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#side-effects-must-run-outside-of-render) (5:5)\n  6 |   };\n  7 |   return foo(fn);\n  8 | }\n```\n\n----------------------------------------\n\nTITLE: React Compiler Error for Memoization Violation\nDESCRIPTION: The error output from React Compiler showing it has skipped optimizing the component due to unsafe memoization patterns. The compiler detects that a dependency value is mutated later, which would cause unexpected behavior.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.invalid-useCallback-captures-reassigned-context.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n  10 |\n  11 |   // makeArray() is captured, but depsList contains [props]\n> 12 |   const cb = useCallback(() => [x], [x]);\n     |                                      ^ CannotPreserveMemoization: React Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. This dependency may be mutated later, which could cause the value to change unexpectedly (12:12)\n\nCannotPreserveMemoization: React Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. This value was memoized in source but not in compilation output. (12:12)\n  13 |\n  14 |   x = makeArray();\n  15 |\n```\n\n----------------------------------------\n\nTITLE: Defining and Exporting Function in JavaScript\nDESCRIPTION: This snippet defines a function 'f' that performs simple arithmetic operations on a variable 'x', and an object 'FIXTURE_ENTRYPOINT' that exports this function. The function manipulates the value of 'x' using increment and bitwise operations. It doesn\\'t take any parameters and returns an integer value. The snippet is part of the file that handles simple function definitions and exporting in JavaScript.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/assignment-variations.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction f() {\n  let x = 1;\n  x = x + 1;\n  x += 1;\n  x >>>= 1;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: f,\n  params: [],\n  isComponent: false,\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Functional Component with Flow Suppressions - JavaScript\nDESCRIPTION: This JavaScript snippet defines a functional component named 'Foo' which is using Flow type checking. The component includes a Flow suppression comment that indicates to the compiler to ignore specific rule violations related to React Hooks. The function takes props as an argument, calls a hook function called 'useX', and returns null. This is a common pattern in React when you need to bypass certain type checks temporarily.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.bailout-on-flow-suppression.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableFlowSuppressions\n\nfunction Foo(props) {\n  // $FlowFixMe[react-rule-hook]\n  useX();\n  return null;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing a React Hook with Conditional Logic Using Label Statement\nDESCRIPTION: This snippet implements a React hook called useFoo that conditionally manipulates an array based on input parameters. It uses a label statement with break to conditionally skip part of the logic, demonstrating a pattern for conditional manipulation of mutable state.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/align-scopes-reactive-scope-overlaps-label.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {arrayPush} from 'shared-runtime';\n\nfunction useFoo({cond, value}) {\n  let items;\n  label: {\n    items = [];\n    // Mutable range of `items` begins here, but its reactive scope block\n    // should be aligned to above the label-block\n    if (cond) break label;\n    arrayPush(items, value);\n  }\n  arrayPush(items, value);\n  return items;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{cond: true, value: 2}],\n  sequentialRenders: [\n    {cond: true, value: 2},\n    {cond: true, value: 2},\n    {cond: true, value: 3},\n    {cond: false, value: 3},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Optimization\nDESCRIPTION: Optimized version of the component with React compiler runtime additions. Implements caching mechanism using Symbol.for() and maintains reference equality checks for props and computed values.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-mutate-outer-value.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nconst { shallowCopy, throwErrorWithMessage } = require(\"shared-runtime\");\n\nfunction Component(props) {\n  const $ = _c(5);\n  let x;\n  if ($[0] !== props) {\n    x = [];\n    try {\n      let t0;\n      if ($[2] === Symbol.for(\"react.memo_cache_sentinel\")) {\n        t0 = throwErrorWithMessage(\"oops\");\n        $[2] = t0;\n      } else {\n        t0 = $[2];\n      }\n      x.push(t0);\n    } catch {\n      let t0;\n      if ($[3] !== props.a) {\n        t0 = shallowCopy({ a: props.a });\n        $[3] = props.a;\n        $[4] = t0;\n      } else {\n        t0 = $[4];\n      }\n      x.push(t0);\n    }\n    $[0] = props;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ a: 1 }],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with fire function\nDESCRIPTION: This code defines a React component that uses the `fire` function from 'react' within a `useEffect` hook. The `fire` function is called with the result of invoking `foo` with the component's props, effectively triggering a side effect when the props or `foo` function change.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/rewrite-deps.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableFire\nimport {fire} from 'react';\n\nfunction Component(props) {\n  const foo = props => {\n    console.log(props);\n  };\n  useEffect(() => {\n    fire(foo(props));\n  }, [foo, props]);\n\n  return null;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom React Hook with Conditional Object Property Access\nDESCRIPTION: A React hook that conditionally accesses an object property based on a nullability flag. It uses labeled blocks to control flow and avoids accessing properties when the object is null.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-poisoned/break-in-scope.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction useFoo({obj, objIsNull}) {\n  const x = [];\n  b0: {\n    if (objIsNull) {\n      break b0;\n    }\n    x.push(obj.a);\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{obj: null, objIsNull: true}],\n  sequentialRenders: [\n    {obj: null, objIsNull: true},\n    {obj: {a: 2}, objIsNull: false},\n    // check we preserve nullthrows\n    {obj: {a: undefined}, objIsNull: false},\n    {obj: undefined, objIsNull: false},\n    {obj: {a: undefined}, objIsNull: false},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component Definition\nDESCRIPTION: This code snippet defines a React component function named `component` that takes two parameters, `a` and `b`. It initializes local variables `y` and `z` with the provided parameters and defines an inner function `x` that modifies the value of `z.a`. The function then calls `x` and returns `z`. The `FIXTURE_ENTRYPOINT` object configures the component for testing or execution with predefined parameters.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-mutate-2.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component(a, b) {\n  let y = {b};\n  let z = {a};\n  let x = function () {\n    z.a = 2;\n    y.b;\n  };\n  x();\n  return z;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: [{a: 'val1', b: 'val2'}],\n  isComponent: false,\n};\n\n```\n\n----------------------------------------\n\nTITLE: Invalid React Hook Usage in Class Component\nDESCRIPTION: Demonstrates an incorrect attempt to use React useState hook within a class component method, which violates React hooks rules\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.invalid.invalid-rules-of-hooks-e69ffce323c3.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @skip\\n// Passed but should have failed\\n\\n(class {\\n  useHook = () => {\\n    useState();\\n  };\\n});\n```\n\n----------------------------------------\n\nTITLE: Compiled: React Hook with Memoization\nDESCRIPTION: The compiled version of useFoo hook with added memoization logic using React compiler runtime. Implements caching mechanism to prevent unnecessary recalculations while maintaining mutation behavior.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/mutation-within-capture-and-mutablerange.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { mutate } from \"shared-runtime\";\n\n/**\n * This test fixture is similar to mutation-within-jsx. The only difference\n * is that there is no `freeze` effect here, which means that `z` may be\n * mutated after its memo block through mutating `y`.\n *\n * While this is technically correct (as `z` is a nested memo block), it\n * is an edge case as we believe that values are not mutated after their\n * memo blocks (which may lead to 'tearing', i.e. mutating one render's\n * values in a subsequent render.\n */\nfunction useFoo(t0) {\n  const $ = _c(3);\n  const { a, b } = t0;\n  let z;\n  if ($[0] !== a || $[1] !== b) {\n    const x = { a };\n    const y = [b];\n    mutate(x);\n\n    z = [mutate(y)];\n\n    mutate(y);\n    $[0] = a;\n    $[1] = b;\n    $[2] = z;\n  } else {\n    z = $[2];\n  }\n  return z;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ a: 2, b: 3 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Original Input Function with Non-Overlapping Dependency Paths\nDESCRIPTION: A test function that demonstrates how different property paths can be tracked separately. It accesses multiple nested properties from the props object and combines them into a new object.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/uncond-nonoverlap-descendant.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Test that we can track non-overlapping dependencies separately.\n// (not needed for correctness but for dependency granularity)\nfunction TestNonOverlappingDescendantTracked(props) {\n  let x = {};\n  x.a = props.a.x.y;\n  x.b = props.b;\n  x.c = props.a.c.x.y.z;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: TestNonOverlappingDescendantTracked,\n  params: [{a: {x: {}, c: {x: {y: {z: 3}}}}}],\n};\n```\n\n----------------------------------------\n\nTITLE: Utilizing Fire Hook in React Component - JavaScript\nDESCRIPTION: The snippet showcases a React component that imports 'fire' and 'useEffect' from 'react'. Within the component, 'foo' function logs the argument and props.bar. The useEffect hook is employed to trigger effects by calling 'fire' with 'foo'. The fire hook is used to manage side effects effectively in the component lifecycle.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/fire-and-autodeps.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableFire @inferEffectDependencies\nimport {fire, useEffect} from 'react';\n\nfunction Component(props) {\n  const foo = arg => {\n    console.log(arg, props.bar);\n  };\n  useEffect(() => {\n    fire(foo(props));\n  });\n\n  return null;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Building React from Source\nDESCRIPTION: Build React from source if local changes are made to the DevTools.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/CONTRIBUTING.md#2025-04-21_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\ncd <react-repo>\nyarn build-for-devtools\n```\n\n----------------------------------------\n\nTITLE: Simplified React Component Definition and Fixture Entrypoint\nDESCRIPTION: This snippet defines a simplified React component function that directly returns its props. It also exports a FIXTURE_ENTRYPOINT object for testing, identical to the input version.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/do-while-break.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  return props;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: BuildHIR Error for Computed Property Key\nDESCRIPTION: This error message shows that the BuildHIR process cannot handle a CallExpression as a key in an ObjectExpression. The error points to line 6 where mutateAndReturn(key) is used as a computed property name.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-object-expression-computed-key-modified-during-after-construction.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n  4 |   const key = {};\n  5 |   const context = {\n> 6 |     [mutateAndReturn(key)]: identity([props.value]),\n    |      ^^^^^^^^^^^^^^^^^^^^ Todo: (BuildHIR::lowerExpression) Expected Identifier, got CallExpression key in ObjectExpression (6:6)\n  7 |   };\n  8 |   mutate(key);\n  9 |   return context;\n```\n\n----------------------------------------\n\nTITLE: Implementing React Function with Empty Infinite Loop\nDESCRIPTION: This code snippet defines a React function 'useFoo' that contains an infinite while loop with an empty body. The function will never terminate due to the constant true condition and performs no operations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/loop-unused-let.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction useFoo() {\n  while (1) {}\n}\n```\n\n----------------------------------------\n\nTITLE: React Function with No Memo Directive\nDESCRIPTION: A React function component that implements recursive logic and array manipulation. The function takes two parameters (x, y), uses conditional recursion, and returns an array with a multiplied value. The 'use no memo' directive indicates that React's memoization should not be applied to this component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/use-no-memo-module-level.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n'use no memo';\n\nexport default function foo(x, y) {\n  if (x) {\n    return foo(false, y);\n  }\n  return [y * 10];\n}\n```\n\n----------------------------------------\n\nTITLE: React Fixture Entrypoint Configuration\nDESCRIPTION: A configuration object for a React fixture, specifying the function, parameters, and component identifier. Used for testing or component initialization purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-nested-partial-reassignment.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\"\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with Fire Function\nDESCRIPTION: This snippet demonstrates a React component using the `fire` function from the 'react' library to execute a function `foo` within a `useEffect` hook. The function `foo` logs the component's props to the console.  The snippet also includes nested functions that also utilize `fire` to invoke `foo`.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/multiple-scope.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableFire\nimport {fire} from 'react';\n\nfunction Component(props) {\n  const foo = props => {\n    console.log(props);\n  };\n  useEffect(() => {\n    fire(foo(props));\n    function nested() {\n      fire(foo(props));\n      function innerNested() {\n        fire(foo(props));\n      }\n    }\n\n    nested();\n  });\n\n  return null;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Basic Markdown Link to React Contribution Guide\nDESCRIPTION: A Markdown link that directs users to React's comprehensive contribution documentation.\nSOURCE: https://github.com/facebook/react/blob/main/CONTRIBUTING.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n[contribution guide](https://reactjs.org/docs/how-to-contribute.html)\n```\n\n----------------------------------------\n\nTITLE: React Hook Error Message\nDESCRIPTION: Error output highlighting the invalid hook call, specifically pointing out that hooks must be called consistently and not conditionally\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.error.rules-of-hooks-e29c874aa913.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n7 |   try {\n8 |     f();\n> 9 |     useState();\n   |     ^^^^^^^^ InvalidReact: Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning) (9:9)\n10 |   } catch {}\n11 | }\n12 |\n```\n\n----------------------------------------\n\nTITLE: Original Hook Implementation\nDESCRIPTION: Implementation of a React hook that creates a log array based on loop iterations. Takes an 'end' parameter and builds log entries with markers @A, @B, and @C based on loop conditions.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unlabeled-break-within-label-loop.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction useHook(end) {\n  const log = [];\n  for (let i = 0; i < end + 1; i++) {\n    log.push(`${i} @A`);\n    bb0: {\n      if (i === end) {\n        break;\n      }\n      log.push(`${i} @B`);\n    }\n    log.push(`${i} @C`);\n  }\n  return log;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useHook,\n  params: [1],\n};\n```\n\n----------------------------------------\n\nTITLE: React Compiler output with memoization\nDESCRIPTION: This JavaScript code shows the compiled output of the `useFoo` function, utilizing memoization provided by `react/compiler-runtime`. The compiler generates code to check for changes in `cond` and `input.a.b` before re-executing the function's logic. The `_c` function manages the memoized state.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-unpoisoned/jump-target-within-scope-label.expect.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction useFoo(t0) {\n  const $ = _c(3);\n  const { input, cond } = t0;\n  let x;\n  if ($[0] !== cond || $[1] !== input.a.b) {\n    x = [];\n    bb0: if (cond) {\n      break bb0;\n    }\n\n    x.push(input.a.b);\n    $[0] = cond;\n    $[1] = input.a.b;\n    $[2] = x;\n  } else {\n    x = $[2];\n  }\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Basic React Components with ESLint Configuration\nDESCRIPTION: Demonstrates the definition of two React functional components with ESLint hooks rule disabled. Contains a basic static component and a component that renders props. Includes ESLint configuration comments to disable hooks-related rules.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unclosed-eslint-suppression-skips-all-components.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @panicThreshold(none)\n\n// unclosed disable rule should affect all components\n/* eslint-disable react-hooks/rules-of-hooks */\n\nfunction ValidComponent1(props) {\n  return <div>Hello World!</div>;\n}\n\nfunction ValidComponent2(props) {\n  return <div>{props.greeting}</div>;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Transformed Hoisting Function with React Compiler Runtime\nDESCRIPTION: This snippet shows the transformed `hoisting` function using React's compiler runtime (`_c`). It uses a memoization technique to avoid re-executing the conditional block if the `cond` value hasn't changed.  This version also utilizes a temporary function `_temp` to handle the `bar` function.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-nested-let-declaration-2.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction hoisting(cond) {\n  const $ = _c(2);\n  let items;\n  if ($[0] !== cond) {\n    items = [];\n    if (cond) {\n      const foo = () => {\n        items.push(bar());\n      };\n\n      let bar;\n      bar = _temp;\n      foo();\n    }\n    $[0] = cond;\n    $[1] = items;\n  } else {\n    items = $[1];\n  }\n  return items;\n}\nfunction _temp() {\n  return true;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: hoisting,\n  params: [true],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Function and Using Local State in React\nDESCRIPTION: This code snippet defines a functional component 'Foo' that utilizes a closure to manage a variable 'x' and returns a 'Stringify' component with the 'getX' function passed as a prop. The purpose is to demonstrate how to capture local state and behavior in a React component. It showcases the importance of variable declarations before usage, as accessing 'x' before initialization can lead to exceptions.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-invalid-tdz-let.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Foo() {\n  const getX = () => x;\n  console.log(getX());\n\n  let x = 4;\n  x += 5;\n\n  return <Stringify getX={getX} shouldInvokeFns={true} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Build Release Locally Script\nDESCRIPTION: This script creates a \"next\" build from the current local Git revision. It's an escape hatch, allowing releases without CI verification, but without automated unit tests.  Uncommitted changes are not included as it archives the React repo.\nSOURCE: https://github.com/facebook/react/blob/main/scripts/release/README.md#2025-04-21_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\nscripts/release/build-release-locally.js\n```\n\n----------------------------------------\n\nTITLE: Accessing import.meta Properties in JavaScript Functions\nDESCRIPTION: This code snippet defines four functions that demonstrate different ways of interacting with the import.meta object. Function 'a' returns the import.meta.url directly, while functions 'b', 'c', and 'd' use conditional statements to check various properties of import.meta.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/meta-property.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction a() {\n  return import.meta.url;\n}\n\nfunction b() {\n  let a = 0;\n  if (import.meta.url) {\n    a = 1;\n  }\n  return a;\n}\n\nfunction c() {\n  let a = 0;\n  if (import.meta.foo) {\n    a = 1;\n  }\n  return a;\n}\n\nfunction d() {\n  let a = 0;\n  if (import.meta) {\n    a = 1;\n  }\n  return a;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Closure in JavaScript with React\nDESCRIPTION: This snippet defines a function 'foo' that creates a closure. It declares a constant 'x', creates an inner function that logs 'x', calls the inner function, and returns 'x'. It also exports a fixture entry point for testing.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/const-propagation-into-function-expression-primitive.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo() {\n  const x = 42;\n  const f = () => {\n    console.log(x);\n  };\n  f();\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: FBT Implementation Error Output\nDESCRIPTION: Error output showing the issue with using 'fbt' as a local variable name, which conflicts with the FBT transform's expectations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/error.todo-fbt-as-local.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n  16 |\n  17 | function Foo(props) {\n> 18 |   const getText1 = fbt =>\n     |                    ^^^ Todo: Support local variables named \"fbt\" (18:18)\n  19 |     fbt(\n  20 |       `Hello, ${fbt.param('(key) name', identity(props.name))}!`,\n  21 |       '(description) Greeting'\n```\n\n----------------------------------------\n\nTITLE: Optimized Component with State Caching - React - JavaScript\nDESCRIPTION: Implements a React functional component that utilizes caching for improved performance by comparing current props with previous props. It conditionally calls processing functions based on the props state.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-receiver-optional-method.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== props) {\n    const x = makeOptionalObject(props);\n    const y = makeObject(props);\n    t0 = x?.optionalMethod?.(y.a, props.a, foo(y.b), bar(props.b));\n    $[0] = props;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const z = t0;\n  return z;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Understanding Dependency Propagation in React Scopes - JavaScript\nDESCRIPTION: This JavaScript function handles dependencies by conditioning propagation based on an inner scope's granularity. Using constants and helper functions from a shared runtime, it ensures that only necessary changes trigger updates. The function `useJoinCondDepsInUncondScopes` leverages prop values and checks against constants for conditional dependency management. Dependencies include `shared-runtime` and expected inputs as object parameters with nested properties.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/join-uncond-scopes-cond-deps.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {CONST_TRUE, setProperty} from 'shared-runtime';\n\nfunction useJoinCondDepsInUncondScopes(props) {\n  let y = {};\n  let x = {};\n  if (CONST_TRUE) {\n    setProperty(x, props.a.b);\n  }\n  setProperty(y, props.a.b);\n  return [x, y];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useJoinCondDepsInUncondScopes,\n  params: [{a: {b: 3}}],\n};\n```\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enablePropagateDepsInHIR\nimport { CONST_TRUE, setProperty } from \"shared-runtime\";\n\nfunction useJoinCondDepsInUncondScopes(props) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== props.a.b) {\n    const y = {};\n    const x = {};\n    if (CONST_TRUE) {\n      setProperty(x, props.a.b);\n    }\n    setProperty(y, props.a.b);\n    t0 = [x, y];\n    $[0] = props.a.b;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useJoinCondDepsInUncondScopes,\n  params: [{ a: { b: 3 } }],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Hook with Compiler Runtime\nDESCRIPTION: This snippet presents the compiled version of the `useFoo` React hook, leveraging `react/compiler-runtime` for optimization. It includes dependency tracking using the `_c` function. The compiled hook uses a state array (`$`) to cache values and minimize re-renders by tracking changes to `props.bar`, `props.cond`, and `props.foo`.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/ssa-renaming-unconditional-ternary.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enablePropagateDepsInHIR\nfunction useFoo(props) {\n  const $ = _c(6);\n  let x;\n  if ($[0] !== props.bar) {\n    x = [];\n    x.push(props.bar);\n    $[0] = props.bar;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  if ($[2] !== props.bar || $[3] !== props.cond || $[4] !== props.foo) {\n    props.cond ? ((x = []), x.push(props.foo)) : ((x = []), x.push(props.bar));\n    $[2] = props.bar;\n    $[3] = props.cond;\n    $[4] = props.foo;\n    $[5] = x;\n  } else {\n    x = $[5];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ cond: false, foo: 2, bar: 55 }],\n  sequentialRenders: [\n    { cond: false, foo: 2, bar: 55 },\n    { cond: false, foo: 3, bar: 55 },\n    { cond: true, foo: 3, bar: 55 },\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Component in React using Optional Chaining\nDESCRIPTION: This snippet defines a basic React functional component which employs optional chaining to safely access properties 'a', 'b', and 'c' from the received props. The use of optional chaining prevents the code from throwing errors if any of the properties are undefined.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-call-chained.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  return call?.(props.a)?.(props.b)?.(props.c);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Functional Components in React - JavaScript\nDESCRIPTION: This snippet defines a functional Component that conditionally renders a Foo component with a list of Item components wrapped in a Bar. It ensures that Fragment elements are not used as JSX attribute values to maintain compatibility with various tools. The Component receives a prop 'items' which is expected to be an array of objects, each containing an 'id' and 'name'. This functionality leverages React's rendering capabilities to efficiently display dynamically generated content.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-attribute-with-jsx-element-value.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @flow\nfunction Component({items}) {\n  // Per the spec, <Foo value=<>{...}</> /> is valid.\n  // But many tools don't allow fragments as jsx attribute values,\n  // so we ensure not to emit them wrapped in an expression container\n  return items.length > 0 ? (\n    <Foo\n      value={\n        <Bar>\n          {items.map(item => (\n            <Item key={item.id} item={item} />\n          ))}\n        </Bar>\n      }></Foo>\n  ) : null;\n}\n\nfunction Foo({value}) {\n  return value;\n}\n\nfunction Bar({children}) {\n  return <div>{children}</div>;\n}\n\nfunction Item({item}) {\n  return <div>{item.name}</div>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{items: [{id: 1, name: 'One!'}]}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Original Function Definition with Nested Functions\nDESCRIPTION: Initial implementation of Foo function with nested function and closure creating an empty object\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/nested-function-with-param-as-captured-dep.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Foo() {\n  return (function t() {\n    let x = {};\n    return function a(x = () => {}) {\n      return x;\n    };\n  })();\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Input React Component with Memoization\nDESCRIPTION: Original React component code showing useState, context usage, and scope creation patterns. Demonstrates primitive object creation and loop handling that will be optimized in compilation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/log-pruned-memoization.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @logger\nimport {createContext, use, useState} from 'react';\nimport {\n  Stringify,\n  identity,\n  makeObject_Primitives,\n  useHook,\n} from 'shared-runtime';\n\nfunction Component() {\n  const w = use(Context);\n\n  // The scopes for x and x2 are interleaved, so this is one scope with two values\n  const x = makeObject_Primitives();\n  const x2 = makeObject_Primitives();\n  useState(null);\n  identity(x);\n  identity(x2);\n\n  // We create a scope for all call expressions, but prune those with hook calls\n  // in this case it's _just_ a hook call, so we don't count this as pruned\n  const y = useHook();\n\n  const z = [];\n  for (let i = 0; i < 10; i++) {\n    // The scope for obj is pruned bc it's in a loop\n    const obj = makeObject_Primitives();\n    z.push(obj);\n  }\n\n  // Overall we expect two pruned scopes (for x+x2, and obj), with 3 pruned scope values.\n  return <Stringify items={[w, x, x2, y, z]} />;\n}\n\nconst Context = createContext();\n\nfunction Wrapper() {\n  return (\n    <Context value={42}>\n      <Component />\n    </Context>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Wrapper,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with Multiple FBT Enums\nDESCRIPTION: A React component that attempts to use multiple fbt:enum tags within a single FBT component for internationalization. The component takes two props 'a' and 'b' and tries to display them as enumerated values.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/error.todo-fbt-unknown-enum-value.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport fbt from 'fbt';\n\nfunction Component({a, b}) {\n  return (\n    <fbt desc=\"Description\">\n      <fbt:enum enum-range={['avalue1', 'avalue1']} value={a} />{' '}\n      <fbt:enum enum-range={['bvalue1', 'bvalue2']} value={b} />\n    </fbt>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: React Hook Error Message\nDESCRIPTION: This code shows the error message generated when a React hook is misused, specifically when it is passed as a regular value instead of being called. The error message indicates the location of the error and provides a link to React documentation for more information.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-pass-hook-as-call-arg.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n  1 | function Component(props) {\n> 2 |   return foo(useFoo);\n    |              ^^^^^^ InvalidReact: Hooks may not be referenced as normal values, they must be called. See https://react.dev/reference/rules/react-calls-components-and-hooks#never-pass-around-hooks-as-regular-values (2:2)\n  3 | }\n  4 |\n\n```\n\n----------------------------------------\n\nTITLE: React Component with Memoization Preservation Errors\nDESCRIPTION: This React component uses hooks like useFragment, useState, useMemo, and useCallback. The React Compiler fails to optimize it because it cannot preserve the existing manual memoization guarantees, likely due to potential mutations of memoized data.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-repro-missed-memoization-from-inferred-mutation-in-logger.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @flow @validatePreserveExistingMemoizationGuarantees\nimport {useFragment} from 'react-relay';\nimport LogEvent from 'LogEvent';\nimport {useCallback, useMemo} from 'react';\n\ncomponent Component(id) {\n  const items = useFragment();\n\n  const [index, setIndex] = useState(0);\n\n  const logData = useMemo(() => {\n    const item = items[index];\n    return {\n      key: item.key,\n    };\n  }, [index, items]);\n\n  const setCurrentIndex = useCallback(\n    (index: number) => {\n      const object = {\n        tracking: logData.key,\n      };\n      // We infer that this may mutate `object`, which in turn aliases\n      // data from `logData`, such that `logData` may be mutated.\n      LogEvent.log(() => object);\n      setIndex(index);\n    },\n    [index, logData, items]\n  );\n\n  if (prevId !== id) {\n    setCurrentIndex(0);\n  }\n\n  return (\n    <Foo\n      index={index}\n      items={items}\n      current={mediaList[index]}\n      setCurrentIndex={setCurrentIndex}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: React Fixture Entrypoint with Sequential Rendering Test Cases\nDESCRIPTION: Defines a test fixture for the useFoo hook with multiple sequential render scenarios to validate behavior under different prop configurations, including null, undefined, and populated object scenarios.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/nested-optional-chains.expect.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{\n    prop1: null,\n    prop2: null,\n    prop3: null,\n    prop4: null,\n    prop5: null,\n    prop6: null,\n  }],\n  sequentialRenders: [\n    // Multiple test cases with different prop configurations\n  ]\n};\n```\n\n----------------------------------------\n\nTITLE: Modified Test Function with Fixed Return Value for 'TodoAdd' Component\nDESCRIPTION: This snippet is a variation of the first function where the return statement has been modified to use a literal '2' instead of the variable 'x' in the last term. It maintains the same fixture entrypoint structure for the 'TodoAdd' component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/expression-with-assignment-dynamic.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction f(y) {\n  let x = y;\n  return x + (x = 2) + 2;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: f,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: React Hook Usage Error Message - JavaScript\nDESCRIPTION: This snippet presents an error message that arises when the rules of hooks are violated, specifically when a hook is called conditionally. It highlights the importance of adhering to the Rules of Hooks to ensure consistent behavior across React components.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.conditional-hooks-as-method-call.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n  2 |   let x = null;\n  3 |   if (props.cond) {\n> 4 |     x = Foo.useFoo();\n    |         ^^^^^^^^^^ InvalidReact: Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning) (4:4)\n  5 |   }\n  6 |   return x;\n  7 | }\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component Output\nDESCRIPTION: The compiled version of the component using React's compiler runtime. It shows how the destructuring is transformed into more verbose conditional checks with caching mechanism using the _c compiler helper.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-object-default.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  const { x: t0 } = props.y;\n  let t1;\n  if ($[0] !== t0) {\n    t1 = t0 === undefined ? { y: \"default\" } : t0;\n    $[0] = t0;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  const { y } = t1;\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Hook with Memoization - React - JavaScript\nDESCRIPTION: This snippet defines a custom React hook, 'useHook', utilizing 'useCallback' to return the current value of a passed ref. It ensures that the memoization guarantees are preserved, although there may be issues indicated by the compiler about matching inferred dependencies.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.maybe-invalid-useCallback-read-maybeRef.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees\nimport {useCallback} from 'react';\n\nfunction useHook(maybeRef) {\n  return useCallback(() => {\n    return [maybeRef.current];\n  }, [maybeRef]);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Function and Exporting a Fixture in Javascript\nDESCRIPTION: This JavaScript snippet defines a function `foo` that takes two arguments, `a` and `b`.  It contains a while loop that immediately breaks. The function then returns `b`.  The snippet also exports a constant `FIXTURE_ENTRYPOINT` which is an object that configures the function `foo` as a fixture, specifying its parameter as 'TodoAdd' and component as 'TodoAdd'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/while-break.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(a, b) {\n  while (a) {\n    break;\n  }\n  return b;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Dynamic State Update\nDESCRIPTION: This snippet defines a React component that uses destructuring, a closure, and state update. It demonstrates a simple component that renders a value from props after potential modification.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructure-array-declaration-to-context-var.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {identity} from 'shared-runtime';\n\nfunction Component(props) {\n  let [x] = props.value;\n  const foo = () => {\n    x = identity(props.value[0]);\n  };\n  foo();\n  return <div>{x}</div>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: [42]}],\n};\n```\n\n----------------------------------------\n\nTITLE: Updating Error and Warning Counts in React DevTools\nDESCRIPTION: Example showing the operation payload for updating error and warning counts for a component. It includes the operation type, fiber id, and the number of error and warning calls.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/OVERVIEW.md#2025-04-21_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\n[\n  5, // update error/warning counts operation\n  4, // fiber id\n  0, // number of calls to console.error from that fiber\n  3, // number of calls to console.warn from that fiber\n]\n```\n\n----------------------------------------\n\nTITLE: Using Destructuring and Symbols in React Component Function\nDESCRIPTION: This JavaScript snippet uses destructuring and memoization with symbols within a React component-related function. It imports a function from 'react/compiler-runtime' and checks for a specific symbol to manage cached component data. The function outputs a destructured value and is exported for use in other modules.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructure-string-literal-invalid-identifier-property-key.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction foo() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = { \"data-foo-bar\": 1 };\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const { \"data-foo-bar\": t } = t0;\n  return t;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized JavaScript Function with Non-Executing Loop\nDESCRIPTION: This snippet shows an optimized version of the 'foo' function where the loop condition is explicitly set to false, ensuring it never executes. It also exports the same fixture object for testing or analysis purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/constant-propagation-for.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo() {\n  let y = 0;\n  for (const x = 100; false; 100) {\n    y = y + 1;\n  }\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Hook Guards\nDESCRIPTION: The compiled version of the React component with added hook dispatcher guards and memo caching. Implements safety checks and caching mechanisms around hook calls to ensure hooks are called in the correct order and context.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/flag-enable-emit-hook-guards.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { $dispatcherGuard } from \"react-compiler-runtime\";\nimport { c as _c } from \"react/compiler-runtime\"; // @enableEmitHookGuards\nimport { createContext, useContext, useEffect, useState } from \"react\";\nimport {\n  CONST_STRING0,\n  ObjectWithHooks,\n  getNumber,\n  identity,\n  print,\n} from \"shared-runtime\";\n\nconst MyContext = createContext(\"my context value\");\nfunction Component(t0) {\n  const $ = _c(4);\n  try {\n    $dispatcherGuard(0);\n    const { value } = t0;\n    print(identity(CONST_STRING0));\n    let t1;\n    if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n      t1 = getNumber();\n      $[0] = t1;\n    } else {\n      t1 = $[0];\n    }\n    const [state, setState] = (function () {\n      try {\n        $dispatcherGuard(2);\n        return useState(t1);\n      } finally {\n        $dispatcherGuard(3);\n      }\n    })();\n    print(value, state);\n    let t2;\n    let t3;\n    if ($[1] !== state) {\n      t2 = () => {\n        if (state === 4) {\n          setState(5);\n        }\n      };\n\n      t3 = [state];\n      $[1] = state;\n      $[2] = t2;\n      $[3] = t3;\n    } else {\n      t2 = $[2];\n      t3 = $[3];\n    }\n    (function () {\n      try {\n        $dispatcherGuard(2);\n        return useEffect(t2, t3);\n      } finally {\n        $dispatcherGuard(3);\n      }\n    })();\n    print(identity(value + state));\n    return (function () {\n      try {\n        $dispatcherGuard(2);\n        return ObjectWithHooks.useIdentity(\n          (function () {\n            try {\n              $dispatcherGuard(2);\n              return useContext(MyContext);\n            } finally {\n              $dispatcherGuard(3);\n            }\n          })()\n        );\n      } finally {\n        $dispatcherGuard(3);\n      }\n    })();\n  } finally {\n    $dispatcherGuard(1);\n  }\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  args: [{ value: 0 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: Compiled version of the React component with memoization cache implementation. Shows how the compiler transforms useCallback and component rendering with cache sentinel checks.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useCallback-ref-in-render.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useCallback, useRef } from \"react\";\n\nfunction Foo() {\n  const $ = _c(2);\n  const ref = useRef();\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = () => ref.current;\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const s = t0;\n  let t1;\n  if ($[1] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = <A r={s} />;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n\nfunction A(t0) {\n  const $ = _c(1);\n  let t1;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = <div />;\n    $[0] = t1;\n  } else {\n    t1 = $[0];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized State Management with React Compiler in JavaScript\nDESCRIPTION: This snippet illustrates an optimized approach to managing component state using the react/compiler-runtime. It tracks changes in props to avoid unnecessary computations and uses a shared runtime to mutate state only when necessary.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-simple-alias.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { mutate } from \"shared-runtime\";\n\nfunction Component(t0) {\n  const $ = _c(2);\n  const { a } = t0;\n  let y;\n  if ($[0] !== a) {\n    const x = { a };\n    y = {};\n    const f0 = function () {\n      y = x;\n    };\n\n    f0();\n    mutate(y);\n    $[0] = a;\n    $[1] = y;\n  } else {\n    y = $[1];\n  }\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ a: 2 }],\n  sequentialRenders: [{ a: 2 }, { a: 2 }, { a: 3 }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Initializing Component Callback in React (JavaScript)\nDESCRIPTION: This JavaScript snippet defines a React functional component that conditionally accesses object properties and returns a callback function. It illustrates error handling when properties are accessed on potentially null objects, using a fallback when null is detected. Dependencies include React and a custom 'Stringify' module. The snippet expects an object and a flag determining if the object is null as inputs and returns JSX with the evaluated callback.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-functionexpr-conditional-dep.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {Stringify} from 'shared-runtime';\n\n/**\n * We currently hoist the accessed properties of function expressions,\n * regardless of control flow. This is simply because we wrote support for\n * function expressions before doing a lot of work in PropagateScopeDeps\n * to handle conditionally accessed dependencies.\n *\n * Current evaluator error:\n *  Found differences in evaluator results\n *  Non-forget (expected):\n *  (kind: ok) <div>{\"shouldInvokeFns\":true,\"callback\":{\"kind\":\"Function\",\"result\":null}}</div>\n *  Forget:\n *  (kind: exception) Cannot read properties of null (reading 'prop')\n */\nfunction Component({obj, isObjNull}) {\n  const callback = () => {\n    if (!isObjNull) {\n      return obj.prop;\n    } else {\n      return null;\n    }\n  };\n  return <Stringify shouldInvokeFns={true} callback={callback} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{obj: null, isObjNull: true}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining React Components with 'use forget' Directive\nDESCRIPTION: Input code showing React components with and without the 'use forget' directive. Components with this directive will be optimized by React's compiler to avoid unnecessary re-renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/codegen-instrument-forget-test.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableEmitInstrumentForget @compilationMode(annotation)\n\nfunction Bar(props) {\n  'use forget';\n  return <div>{props.bar}</div>;\n}\n\nfunction NoForget(props) {\n  return <Bar>{props.noForget}</Bar>;\n}\n\nfunction Foo(props) {\n  'use forget';\n  return <Foo>{props.bar}</Foo>;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a React Hook with Hook Usage (JavaScript)\nDESCRIPTION: This code defines a function `createHook` that returns another function, `useHookWithHook`. The returned function represents a custom React hook that internally calls the `useHook` function. This demonstrates that React hooks can indeed call other hooks within their implementation, which is a valid and common pattern for creating more complex and reusable hook logic.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-33a6e23edac1.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// @compilationMode(infer)\n// Valid because hooks can use hooks.\nfunction createHook() {\n  return function useHookWithHook() {\n    useHook();\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: React Hook Error Message\nDESCRIPTION: This error message shows the exact location of the invalid hook call within the callback function passed to `useEffect`. It clearly states that Hooks must be called at the top level in the body of a function component or custom hook and not within function expressions, and it provides a link to the Rules of Hooks documentation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid.invalid-rules-of-hooks-0de1224ce64b.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n  4 |   return function ComponentWithHookInsideCallback() {\n  5 |     useEffect(() => {\n> 6 |       useHookInsideCallback();\n    |       ^^^^^^^^^^^^^^^^^^^^^ InvalidReact: Hooks must be called at the top level in the body of a function component or custom hook, and may not be called within function expressions. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning). Cannot call Custom within a function component (6:6)\n\nInvalidReact: Hooks must be called at the top level in the body of a function component or custom hook, and may not be called within function expressions. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning). Cannot call useEffect within a function component (5:5)\n  7 |     });\n  8 |   };\n  9 | }\n\n```\n\n----------------------------------------\n\nTITLE: Using @validateBlocklistedImports Directive with a Dangerous Import in React\nDESCRIPTION: This code snippet demonstrates the usage of the @validateBlocklistedImports directive to mark certain imports as dangerous. The code attempts to import from a module named 'DangerousImport' which is blocklisted, causing validation to fail.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.validate-blocklisted-imports.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validateBlocklistedImports(DangerousImport)\nimport {foo} from 'DangerousImport';\nimport {useIdentity} from 'shared-runtime';\n\nfunction useHook() {\n  useIdentity(foo);\n  return;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Memoization\nDESCRIPTION: This snippet shows the optimized version of the 'Foo' component using React's compiler runtime. It implements memoization to cache the empty array, potentially improving performance in subsequent renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/memoize-value-block-value-sequence.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Foo(props) {\n  const $ = _c(1);\n  let x;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    (x = []), null;\n    $[0] = x;\n  } else {\n    x = $[0];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Error Message for Invalid Ref Access in React - JavaScript\nDESCRIPTION: This snippet includes the error message generated due to invalid access of the 'current' property on a ref during the render of a React component. It specifies the line number and provides a link to the React documentation for further information.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-write-ref-prop-in-render.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n  2 | function Component(props) {\n  3 |   const ref = props.ref;\n> 4 |   ref.current = true;\n    |   ^^^^^^^^^^^ InvalidReact: Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef) (4:4)\n  5 |   return <div>{value}</div>;\n  6 | }\n  7 |\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Function with Compiler Runtime Optimization\nDESCRIPTION: Optimized version of useFoo function using React compiler runtime for memoization and dependency tracking\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/infer-nested-function-uncond-access.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enablePropagateDepsInHIR\n\nimport { Stringify } from \"shared-runtime\";\n\nfunction useFoo(t0) {\n  const $ = _c(4);\n  const { a } = t0;\n  let t1;\n  if ($[0] !== a.b.c) {\n    t1 = () => () => ({ value: a.b.c });\n    $[0] = a.b.c;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  const fn = t1;\n  let t2;\n  if ($[2] !== fn) {\n    t2 = <Stringify fn={fn} shouldInvokeFns={true} />;\n    $[2] = fn;\n    $[3] = t2;\n  } else {\n    t2 = $[3];\n  }\n  return t2;\n}\n```\n\n----------------------------------------\n\nTITLE: Managing State with React useState - JavaScript\nDESCRIPTION: This JavaScript snippet demonstrates the use of an arrow function within a class to call React's useState hook. The code is commented to indicate that the test, which should have failed, unexpectedly passed. The snippet requires React and its hooks API as a dependency.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.invalid.invalid-rules-of-hooks-9c79feec4b9b.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\n// @skip\\n// Passed but should have failed\\n\\n(class {\\n  h = () => {\\n    useState();\\n  };\\n});\n```\n\n----------------------------------------\n\nTITLE: Starting React DevTools Development Environment\nDESCRIPTION: Command for starting the React DevTools development environment in the react-devtools package. Used for testing changes to the DevTools application itself.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/README.md#2025-04-21_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\nyarn start\n```\n\n----------------------------------------\n\nTITLE: Build Error for Variable Declaration Handling\nDESCRIPTION: Indicates a build-time todo item related to handling variable declaration kinds, specifically for 'var' declarations in the build process.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-hoisting-simple-var-declaration.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n   5 |   }\n   6 |   const result = addOne(2);\n>  7 |   var a = 1;\n     |   ^^^^^^^^^^ Todo: (BuildHIR::lowerStatement) Handle var kinds in VariableDeclaration (7:7)\n   8 |\n   9 |   return result; // OK: returns NaN. The code is semantically wrong but technically correct\n  10 | }\n```\n\n----------------------------------------\n\nTITLE: Validating Component Property in React\nDESCRIPTION: A functional component that uses a switch statement to compare a prop value against a global property. Returns true if the value matches Global.Property, otherwise returns false.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/switch-global-propertyload-case-test.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  switch (props.value) {\n    case Global.Property: {\n      return true;\n    }\n    default: {\n      return false;\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: React Counter Component Implementation - Input Source\nDESCRIPTION: Original React component implementation using useState hook to manage counter state with increment and decrement buttons. Shows the clean source code before compilation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/merge-consecutive-scopes-deps-subset-of-decls.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useState} from 'react';\n\nfunction Component() {\n  const [count, setCount] = useState(0);\n  return (\n    <div>\n      <button onClick={() => setCount(count - 1)}>Decrement</button>\n      /**\n       * The scope for the <button> depends on just the scope for the callback,\n       * but the previous scope (after merging) will declare both the above\n       * <button> and the callback.\n       */\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with Global State and Effects\nDESCRIPTION: This snippet defines a React component that uses useState and useEffect hooks to manage state based on a global variable. It includes functionality to update the global variable and synchronize the component state with it.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-global-reassignment-in-effect-indirect.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useEffect, useState} from 'react';\n\nlet someGlobal = false;\n\nfunction Component() {\n  const [state, setState] = useState(someGlobal);\n\n  const setGlobal = () => {\n    someGlobal = true;\n  };\n  useEffect(() => {\n    setGlobal();\n  }, []);\n\n  useEffect(() => {\n    setState(someGlobal);\n  }, [someGlobal]);\n\n  return <div>{String(state)}</div>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Adding Leaf Node Operation in React DevTools\nDESCRIPTION: Example showing the operation payload for adding a leaf node (component) to the tree. It includes the operation type, fiber id, element type, parent id, owner id, and references to the string table for display name and key.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/OVERVIEW.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n[\n  1,   // add operation\n  2,   // fiber id\n  1,   // ElementTypeClass\n  1,   // parent id\n  0,   // owner id\n  1,   // id of \"Foo\" displayName in the string table\n  0,   // id of null key in the string table (always zero for null)\n]\n```\n\n----------------------------------------\n\nTITLE: React Component with Invalid useState Hook\nDESCRIPTION: This code snippet defines a `List` component that takes `items` as props and attempts to render each item using the `renderItem` function. The `renderItem` function attempts to use the `useState` hook, which is invalid in this context because hooks must be called at the top level of a function component or custom hook. The intention is to demonstrate an incorrect usage of `useState` and its expected failure.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.invalid.invalid-rules-of-hooks-e675f0a672d8.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @skip\n// Passed but should have failed\n\n// Invalid because it's dangerous and might not warn otherwise.\n// This *must* be invalid.\nfunction renderItem() {\n  useState();\n}\n\nfunction List(props) {\n  return props.items.map(renderItem);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Testing React Compiler Memoization with Context Variables in JavaScript\nDESCRIPTION: This code demonstrates a test case where React Compiler cannot preserve memoization guarantees. It shows how capturing values in context variables creates mutable ranges that prevent optimization, specifically when useMemo is used within these ranges.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-repro-unmemoized-callback-captured-in-context-variable.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees\nimport {useMemo} from 'react';\nimport {ValidateMemoization, useHook} from 'shared-runtime';\n\nfunction UnmemoizedCallbackCapturedInContextVariable({cond1, cond2}) {\n  // The return value is captured by `x` which is a context variable, which\n  // extends a's range to include the call instruction. This prevents the entire\n  // range from being memoized\n  const a = useHook();\n  // Because b is also part of that same mutable range, it can't be memoized either\n  const b = useMemo(() => ({}), []);\n\n  // Conditional assignment without a subsequent mutation normally doesn't create a mutable\n  // range, but in this case we're reassigning a context variable\n  let x;\n  if (cond1) {\n    x = a;\n  } else if (cond2) {\n    x = b;\n  } else {\n    return null;\n  }\n\n  const f = () => {\n    return x;\n  };\n  const result = f();\n\n  return <ValidateMemoization inputs={[cond1, cond2]} output={result} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: UnmemoizedCallbackCapturedInContextVariable,\n  params: [{cond1: true, cond2: false}],\n  sequentialRenders: [\n    {cond1: true, cond2: true},\n    {cond1: false, cond2: true},\n    {cond1: false, cond2: true}, // fails sprout bc memoization is not preserved\n    {cond1: false, cond2: false},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Conditional Hoisting in JavaScript\nDESCRIPTION: This snippet defines a 'hoisting' function that conditionally pushes a value returned from 'bar' into an array, based on the input parameter 'cond'. It uses closures to wrap the calls and ensure correct scope usage.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-nested-const-declaration-2.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction hoisting(cond) {\n  let items = [];\n  if (cond) {\n    const foo = () => {\n      items.push(bar());\n    };\n    const bar = () => true;\n    foo();\n  }\n  return items;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: hoisting,\n  params: [true],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Reactive Component Implementation with React Compiler Runtime\nDESCRIPTION: This snippet uses the React Compiler Runtime to optimize the reactivity of component state. It introduces a compiled form of the `Component` function, employing runtime checks to prevent unnecessary state updates. This illustrates advanced techniques in managing render performance in React components, using the React Compiler as a dependency.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-via-mutation-switch.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n\n  const x = [];\n  if (props.cond) {\n    x.push(1);\n  }\n\n  let y = false;\n  switch (x[0]) {\n    case 1: {\n      y = true;\n    }\n  }\n  let t0;\n  if ($[0] !== y) {\n    t0 = [y];\n    $[0] = y;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  sequentialRenders: [\n    { cond: true },\n    { cond: true },\n    { cond: false },\n    { cond: false },\n    { cond: true },\n    { cond: false },\n    { cond: true },\n    { cond: false },\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Hook Wrapper in Shared Runtime - JavaScript\nDESCRIPTION: This snippet demonstrates how to create a custom hook using the 'shared-runtime' library. It uses the 'mutate' and 'mutateAndReturn' functions to manipulate state and demonstrate caching behavior. It returns an object with a 'getValue' function that fetches the current value for testing or other functional needs.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-method-shorthand-aliased-mutate-after.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {createHookWrapper, mutate, mutateAndReturn} from 'shared-runtime';\nfunction useHook({value}) {\n  const x = mutateAndReturn({value});\n  const obj = {\n    getValue() {\n      return value;\n    },\n  };\n  mutate(x);\n  return obj;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: createHookWrapper(useHook),\n  params: [{value: 0}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining React Fixture Entrypoint in JavaScript\nDESCRIPTION: This code defines a simple function 'foo' and exports a constant FIXTURE_ENTRYPOINT. The FIXTURE_ENTRYPOINT object specifies the function to be used, the parameters, and the name of the React component (TodoAdd) for fixture testing.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/trivial.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(x) {\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: React Compiler Output for useMakeCallback Hook with Optimized Memoization\nDESCRIPTION: The React compiler's output for the useMakeCallback hook, showing how it implements memoization for nested callbacks. The compiler adds cache checks to avoid recreating functions when dependencies haven't changed.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/assume-invoked/function-with-conditional-callsite-in-another-function.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { createHookWrapper } from \"shared-runtime\";\n\n/**\n * (Given that the returned lambda is assumed to be invoked, see\n * return-function)\n *\n * If lambda A conditionally calls lambda B, optimistically assume that property\n * loads from lambda B has the same hoistability of ones from lambda A. This\n * helps optimize components / hooks that create and chain many helper\n * functions.\n *\n * Type systems and code readability encourage developers to colocate length and\n * null checks values in the same function as where values are used. i.e.\n * developers are unlikely to write the following code.\n * ```js\n * function useFoo(obj, objNotNullAndHasElements) {\n *   // ...\n *   const get0th = () => obj.arr[0].value;\n *   return () => objNotNullAndHasElements ? get0th : undefined;\n * }\n * ```\n *\n * In Meta code, this assumption helps reduce the number of memo dependency\n * deopts.\n */\nfunction useMakeCallback(t0) {\n  const $ = _c(6);\n  const { obj, cond, setState } = t0;\n  let t1;\n  if ($[0] !== obj.value || $[1] !== setState) {\n    t1 = () => setState(obj.value);\n    $[0] = obj.value;\n    $[1] = setState;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  const cb = t1;\n  let t2;\n  if ($[3] !== cb || $[4] !== cond) {\n    t2 = () => (cond ? cb() : undefined);\n    $[3] = cb;\n    $[4] = cond;\n    $[5] = t2;\n  } else {\n    t2 = $[5];\n  }\n  return t2;\n}\n\nconst setState = (arg: number) => {\n  \"use no memo\";\n  return arg;\n};\nexport const FIXTURE_ENTRYPOINT = {\n  fn: createHookWrapper(useMakeCallback),\n  params: [{ obj: { value: 1 }, cond: true, setState }],\n  sequentialRenders: [\n    { obj: { value: 1 }, cond: true, setState },\n    { obj: { value: 2 }, cond: true, setState },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing useCallback with Dependency Mismatch in React\nDESCRIPTION: A React component that uses useCallback with manually specified dependencies that don't match what the React Compiler would infer. The component attempts to memoize a function that returns propB.x.y when propA is truthy, but the dependency array may not correctly capture all dependencies.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.hoist-useCallback-conditional-access-own-scope.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees\nimport {useCallback} from 'react';\n\nfunction Component({propA, propB}) {\n  return useCallback(() => {\n    if (propA) {\n      return {\n        value: propB.x.y,\n      };\n    }\n  }, [propA, propB.x.y]);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{propA: 1, propB: {x: {y: []}}}],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with Conditional Caching in JavaScript\nDESCRIPTION: A React component that demonstrates conditional caching using React's internal memoization pattern. It imports a compiler runtime utility, initializes an object only when a cache sentinel is detected, and utilizes optional chaining to access deeply nested properties based on dynamic props. This design ensures efficient rerenders with cached objects.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-member-expression-with-optional-member-expr-as-property.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = makeObject();\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const x = t0;\n  return x.y?.[props.a?.[props.b?.[props.c]]];\n}\n\n```\n\n----------------------------------------\n\nTITLE: Optimized React Components with Compiler Runtime\nDESCRIPTION: This snippet shows optimized versions of the four React components using React's compiler runtime. It includes memoization and early return optimizations to improve performance based on prop changes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/conditional-early-return.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enablePropagateDepsInHIR\n/**\n * props.b does *not* influence `a`\n */\nfunction ComponentA(props) {\n  const $ = _c(5);\n  let a_DEBUG;\n  let t0;\n  if ($[0] !== props.a || $[1] !== props.b || $[2] !== props.d) {\n    t0 = Symbol.for(\"react.early_return_sentinel\");\n    bb0: {\n      a_DEBUG = [];\n      a_DEBUG.push(props.a);\n      if (props.b) {\n        t0 = null;\n        break bb0;\n      }\n\n      a_DEBUG.push(props.d);\n    }\n    $[0] = props.a;\n    $[1] = props.b;\n    $[2] = props.d;\n    $[3] = a_DEBUG;\n    $[4] = t0;\n  } else {\n    a_DEBUG = $[3];\n    t0 = $[4];\n  }\n  if (t0 !== Symbol.for(\"react.early_return_sentinel\")) {\n    return t0;\n  }\n  return a_DEBUG;\n}\n\n/**\n * props.b *does* influence `a`\n */\nfunction ComponentB(props) {\n  const $ = _c(5);\n  let a;\n  if (\n    $[0] !== props.a ||\n    $[1] !== props.b ||\n    $[2] !== props.c ||\n    $[3] !== props.d\n  ) {\n    a = [];\n    a.push(props.a);\n    if (props.b) {\n      a.push(props.c);\n    }\n\n    a.push(props.d);\n    $[0] = props.a;\n    $[1] = props.b;\n    $[2] = props.c;\n    $[3] = props.d;\n    $[4] = a;\n  } else {\n    a = $[4];\n  }\n  return a;\n}\n\n/**\n * props.b *does* influence `a`, but only in a way that is never observable\n */\nfunction ComponentC(props) {\n  const $ = _c(6);\n  let a;\n  let t0;\n  if (\n    $[0] !== props.a ||\n    $[1] !== props.b ||\n    $[2] !== props.c ||\n    $[3] !== props.d\n  ) {\n    t0 = Symbol.for(\"react.early_return_sentinel\");\n    bb0: {\n      a = [];\n      a.push(props.a);\n      if (props.b) {\n        a.push(props.c);\n        t0 = null;\n        break bb0;\n      }\n\n      a.push(props.d);\n    }\n    $[0] = props.a;\n    $[1] = props.b;\n    $[2] = props.c;\n    $[3] = props.d;\n    $[4] = a;\n    $[5] = t0;\n  } else {\n    a = $[4];\n    t0 = $[5];\n  }\n  if (t0 !== Symbol.for(\"react.early_return_sentinel\")) {\n    return t0;\n  }\n  return a;\n}\n\n/**\n * props.b *does* influence `a`\n */\nfunction ComponentD(props) {\n  const $ = _c(6);\n  let a;\n  let t0;\n  if (\n    $[0] !== props.a ||\n    $[1] !== props.b ||\n    $[2] !== props.c ||\n    $[3] !== props.d\n  ) {\n    t0 = Symbol.for(\"react.early_return_sentinel\");\n    bb0: {\n      a = [];\n      a.push(props.a);\n      if (props.b) {\n        a.push(props.c);\n        t0 = a;\n        break bb0;\n      }\n\n      a.push(props.d);\n    }\n    $[0] = props.a;\n    $[1] = props.b;\n    $[2] = props.c;\n    $[3] = props.d;\n    $[4] = a;\n    $[5] = t0;\n  } else {\n    a = $[4];\n    t0 = $[5];\n  }\n  if (t0 !== Symbol.for(\"react.early_return_sentinel\")) {\n    return t0;\n  }\n  return a;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: ComponentA,\n  params: [{ a: 1, b: false, d: 3 }],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with useRef and Render-Time Access\nDESCRIPTION: This React component, `Component`, initializes a `useRef` and attempts to access its `current` property within a `renderItem` function, which is called during the rendering of a list of items. This pattern is flagged as invalid because accessing ref values during render can lead to unpredictable behavior and inconsistencies. The `renderItem` function creates an aliased reference and then accesses the `.current` property.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-aliased-ref-in-callback-invoked-during-render-.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validateRefAccessDuringRender\nfunction Component(props) {\n  const ref = useRef(null);\n  const renderItem = item => {\n    const aliasedRef = ref;\n    const current = aliasedRef.current;\n    return <Foo item={item} current={current} />;\n  };\n  return <Items>{props.items.map(item => renderItem(item))}</Items>;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Original React Component with Potential Memoization Opportunities\nDESCRIPTION: A React component that creates arrays from props, with comments identifying potential memoization opportunities. This is the source code before optimization by the React compiler.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/escape-analysis-non-escaping-interleaved-allocating-dependency.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  // a can be independently memoized, is not mutated later\n  const a = [props.a];\n\n  // b and c are interleaved and grouped into a single scope,\n  // but they are independent values. c does not escape, but\n  // we need to ensure that a is memoized or else b will invalidate\n  // on every render since a is a dependency.\n  const b = [];\n  const c = {};\n  c.a = a;\n  b.push(props.b);\n\n  return b;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing useTest Function with Builder Pattern in JavaScript\nDESCRIPTION: This snippet defines a 'useTest' function that uses the Builder pattern to construct a complex data structure. It takes an object with 'isNull' and 'data' properties as input and returns a nested array-like structure.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-slow-validate-preserve-memo.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees\n\nimport {Builder} from 'shared-runtime';\nfunction useTest({isNull, data}: {isNull: boolean; data: string}) {\n  const result = Builder.makeBuilder(isNull, 'hello world')\n    ?.push('1', 2)\n    ?.push(3, {\n      a: 4,\n      b: 5,\n      c: data,\n    })\n    ?.push(6, data)\n    ?.push(7, '8')\n    ?.push('8', Builder.makeBuilder(!isNull)?.push(9).vals)?.vals;\n  return result;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useTest,\n  params: [{isNull: false, data: 'param'}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining useFoo Function with Input and Loop Logic (original)\nDESCRIPTION: This JavaScript code defines the `useFoo` function, which takes an object with an `input` property (containing nested properties `a` and `b`) and a `max` property. It initializes an array `x`, iterates up to `max`, pushes the final `i` value and `input.a.b` into the array, and returns the array.  It also defines the `FIXTURE_ENTRYPOINT` object which specifies the function to test, the initial parameters and a list of `sequentialRenders` which are used to test different input scenarios.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-unpoisoned/jump-target-within-scope-loop-break.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction useFoo({input, max}) {\n  const x = [];\n  let i = 0;\n  while (true) {\n    i += 1;\n    if (i > max) {\n      break;\n    }\n  }\n  x.push(i);\n  x.push(input.a.b); // unconditional\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{input: {a: {b: 2}}, max: 8}],\n  sequentialRenders: [\n    {input: {a: {b: 2}}, max: 8},\n    // preserve nullthrows\n    {input: null, max: 8},\n    {input: {}}, max: 8},\n    {input: {a: {b: null}}, max: 8},\n    {input: {a: null}, max: 8},\n    {input: {a: {b: 3}}, max: 8},\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Destructuring Error with Computed Properties\nDESCRIPTION: An error message indicating a limitation in handling computed properties within an object pattern during the build or transformation process. The error suggests that the current implementation cannot fully process dynamic property destructuring.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/todo.error.object-pattern-computed-key.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n  3 | const SCALE = 2;\n  4 | function Component(props) {\n> 5 |   const {[props.name]: value} = props;\n    |          ^^^^^^^^^^^^^^^^^^^ Todo: (BuildHIR::lowerAssignment) Handle computed properties in ObjectPattern (5:5)\n  6 |   return value;\n  7 | }\n```\n\n----------------------------------------\n\nTITLE: Defining FixtureEntrypoint Type in TypeScript\nDESCRIPTION: Type definition for FIXTURE_ENTRYPOINT that Sprout requires for test execution. This type specifies the function to be tested and the parameters to pass to it.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/snap/src/sprout/README.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype FixtureEntrypoint<T> = {\n  // function to be invoked\n  fn: ((...params: Array<T>) => any),\n  // params to pass to fn\n  // (if `fn` is a react component, this should be an array\n  // with exactly one element -- props)\n  params: Array<T>,\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled React Hook with Memoization\nDESCRIPTION: Optimized version of the hook using React compiler runtime, implementing memoization and conditional re-computation strategy\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-method-shorthand-3.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { createHookWrapper, mutate } from \"shared-runtime\";\n\nfunction useHook(a) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== a) {\n    const x = { a };\n    const obj = {\n      method() {\n        mutate(x);\n        return x;\n      },\n    };\n\n    t0 = obj.method();\n    $[0] = a;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: createHookWrapper(useHook),\n  params: [{ x: 1 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Fixture Entrypoint for Function Hook Testing\nDESCRIPTION: Defines test parameters and sequential renders for the useFoo function, providing a test fixture to validate component behavior under different prop conditions\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/ssa-renaming-ternary.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{cond: false, foo: 2, bar: 55}],\n  sequentialRenders: [\n    {cond: false, foo: 2, bar: 55},\n    {cond: false, foo: 3, bar: 55},\n    {cond: true, foo: 3, bar: 55},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Initializing React Component with Computed Property Destructuring\nDESCRIPTION: A React component that dynamically extracts a property from props using a computed property name. The component imports the identity function and defines a SCALE constant, then destructures a prop based on a dynamically determined name.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/todo.error.object-pattern-computed-key.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {identity} from 'shared-runtime';\n\nconst SCALE = 2;\nfunction Component(props) {\n  const {[props.name]: value} = props;\n  return value;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{name: 'Sathya'}],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing useMemo with Mismatched Dependencies in React\nDESCRIPTION: A hook implementation that uses useMemo with manually specified dependencies that don't match what the React Compiler infers from the code. The hook creates a closure that accesses maybeRef.current but includes shouldRead before maybeRef in the dependency array.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.maybe-invalid-useMemo-read-maybeRef.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees\nimport {useMemo} from 'react';\n\nfunction useHook(maybeRef, shouldRead) {\n  return useMemo(() => {\n    return () => [maybeRef.current];\n  }, [shouldRead, maybeRef]);\n}\n\n```\n\n----------------------------------------\n\nTITLE: React Component with Memoization Caching - JavaScript\nDESCRIPTION: This code snippet features a React component with enhanced memoization capabilities using a custom caching mechanism. It focuses on optimizing the useEffect hooks by storing memoized computations and cache keys, allowing efficient re-rendering and dependency tracking of ref and state changes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-ref-access-in-effect.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @validateRefAccessDuringRender\nimport { useEffect, useRef, useState } from \"react\";\n\nfunction Component() {\n  const $ = _c(6);\n  const ref = useRef(null);\n  const [state, setState] = useState(false);\n  let t0;\n  let t1;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = () => {\n      ref.current = \"Ok\";\n    };\n    t1 = [];\n    $[0] = t0;\n    $[1] = t1;\n  } else {\n    t0 = $[0];\n    t1 = $[1];\n  }\n  useEffect(t0, t1);\n  let t2;\n  let t3;\n  if ($[2] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t2 = () => {\n      setState(true);\n    };\n    t3 = [];\n    $[2] = t2;\n    $[3] = t3;\n  } else {\n    t2 = $[2];\n    t3 = $[3];\n  }\n  useEffect(t2, t3);\n\n  const t4 = String(state);\n  let t5;\n  if ($[4] !== t4) {\n    t5 = <Child key={t4} ref={ref} />;\n    $[4] = t4;\n    $[5] = t5;\n  } else {\n    t5 = $[5];\n  }\n  return t5;\n}\n\nfunction Child(t0) {\n  const { ref } = t0;\n  return ref.current;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Using React Hooks to Create a Custom Hook in JavaScript\nDESCRIPTION: This snippet defines a custom React hook using useCallback and useTransition from React. It exposes a function called useFoo, which internally starts a transition using start from useTransition. The hook bypasses all parameters and aims to preserve existing memoization guarantees.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/preserve-use-memo-transition.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees\nimport {useCallback, useTransition} from 'react';\n\nfunction useFoo() {\n  const [t, start] = useTransition();\n\n  return useCallback(() => {\n    start();\n  }, []);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with useState Hook in JavaScript\nDESCRIPTION: This snippet shows a React component using the useState hook to manage a number state. It imports necessary types and functions from React, defines a Component function, and exports a FIXTURE_ENTRYPOINT object.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-duplicate-import-specifier.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport type {SetStateAction, Dispatch} from 'react';\nimport {useState} from 'react';\n\nfunction Component(_props: {}) {\n  const [x, _setX]: [number, Dispatch<SetStateAction<number>>] = useState(0);\n  return {x};\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization Logic\nDESCRIPTION: Compiled version of the React component showing the implementation of memoization logic. Includes compiler-generated code for tracking dependencies and managing reactive state.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-invalid-reactivity-value-block.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport {\n  CONST_TRUE,\n  identity,\n  makeObject_Primitives,\n  useNoAlias,\n} from \"shared-runtime\";\n\n/**\n * Here the scope for `obj` is pruned because it spans the `useNoAlias()` hook call.\n * Because `obj` is non-reactive, it would by default be excluded as dependency for\n * `result = [...identity(obj)..., obj]`, but this could then cause the values in\n * `result` to be out of sync with `obj`.\n *\n * The fix is to consider pruned memo block outputs as reactive, since they will\n * recreate on every render. This means `thing` depends on both y and z.\n */\nfunction Foo() {\n  const $ = _c(3);\n  const obj = makeObject_Primitives();\n\n  useNoAlias();\n\n  const shouldCaptureObj = obj != null && CONST_TRUE;\n  const t0 = shouldCaptureObj ? identity(obj) : null;\n  let t1;\n  if ($[0] !== obj || $[1] !== t0) {\n    t1 = [t0, obj];\n    $[0] = obj;\n    $[1] = t0;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  const result = t1;\n\n  useNoAlias(result, obj);\n  if (shouldCaptureObj && result[0] !== obj) {\n    throw new Error(\"Unexpected\");\n  }\n  return result;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{}],\n  sequentialRenders: [{}, {}],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimizing React Component with Memoization in JavaScript\nDESCRIPTION: By importing a compiler-runtime utility, this snippet applies memoization to optimize performance. It checks cache using react.memo_cache_sentinel and updates it with object data. Dependencies involve 'react/compiler-runtime', and the function effectively caches object creation to avoid unnecessary rendering.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/call-args-destructuring-assignment.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(1);\n  let x;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    x = makeObject();\n    x.foo(([x] = makeObject()));\n    $[0] = x;\n  } else {\n    x = $[0];\n  }\n  return x;\n}\n\n```\n\n----------------------------------------\n\nTITLE: React ForwardRef with Compiler Runtime and Hook\nDESCRIPTION: This snippet showcases `React.forwardRef` combined with a compiler runtime (`_c`) and a hook. It illustrates how the compiler runtime can be used for memoization and optimization within a forwarded ref component that also utilizes a custom hook (`useHook`).\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-9a47e97b5d13.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // Valid because hooks can be used in anonymous function arguments to\n// forwardRef.\nconst FancyButton = React.forwardRef(function (props, ref) {\n  const $ = _c(3);\n  useHook();\n  let t0;\n  if ($[0] !== props || $[1] !== ref) {\n    t0 = <button {...props} ref={ref} />;\n    $[0] = props;\n    $[1] = ref;\n    $[2] = t0;\n  } else {\n    t0 = $[2];\n  }\n  return t0;\n});\n\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: Defines a React component that uses the identity function from shared-runtime to process an array of values including a function, boolean, number, and string.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/default-param-calls-global-function.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {identity} from 'shared-runtime';\n\nfunction Component(x = identity([() => {}, true, 42, 'hello'])) {\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized Component with State Management in JavaScript React\nDESCRIPTION: This snippet features a more complex version of the React component which utilizes the 'react/compiler-runtime' to manage its state and optimize performance by checking prop changes before instantiating Foo. It ensures that the Foo object is only created if the props have changed, employing memoization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/new-spread.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(3);\n  let t0;\n  if ($[0] !== props.bar || $[1] !== props.foo) {\n    t0 = new Foo(...props.foo, null, ...[props.bar]);\n    $[0] = props.bar;\n    $[1] = props.foo;\n    $[2] = t0;\n  } else {\n    t0 = $[2];\n  }\n  const x = t0;\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Fragment & Memoization (JavaScript)\nDESCRIPTION: This JavaScript code snippet defines a React component that uses 'shared-runtime' and React's memoization to optimize the rendering of user data. The use of caching via a special array '$' minimizes unnecessary re-renders based on the 'user.timeline.posts.edges.nodes'. The code involves dependency on 'react/compiler-runtime'. The component processes 'props.user', performs caching of posts data, and returns a memoized list of <Post> components.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/readonly-object-method-calls.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useFragment } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(5);\n  const user = useFragment(\n    graphql`\n      fragment Component_user on User {\n        name\n      }\n    `,\n    props.user,\n  );\n  let posts;\n  if ($[0] !== user.timeline.posts.edges.nodes) {\n    posts = user.timeline.posts.edges.nodes.map(_temp);\n    let t0;\n    if ($[2] === Symbol.for(\"react.memo_cache_sentinel\")) {\n      t0 = {};\n      $[2] = t0;\n    } else {\n      t0 = $[2];\n    }\n    posts.push(t0);\n    $[0] = user.timeline.posts.edges.nodes;\n    $[1] = posts;\n  } else {\n    posts = $[1];\n  }\n  const count = posts.length;\n  foo(count);\n  let t0;\n  if ($[3] !== posts) {\n    t0 = <>{posts}</>;\n    $[3] = posts;\n    $[4] = t0;\n  } else {\n    t0 = $[4];\n  }\n  return t0;\n}\nfunction _temp(node) {\n  return <Post post={node} />;\n}\n\n```\n\n----------------------------------------\n\nTITLE: React Compiler Error for Unpreservable Memoization\nDESCRIPTION: The error output from React Compiler showing it cannot optimize the component because the existing manual memoization through useMemo cannot be preserved. The error pinpoints the exact location of the problematic useMemo call.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.false-positive-useMemo-dropped-infer-always-invalidating.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n  13 |   x.push(props);\n  14 |\n> 15 |   return useMemo(() => [x], [x]);\n     |          ^^^^^^^^^^^^^^^^^^^^^^^ CannotPreserveMemoization: React Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. This value was memoized in source but not in compilation output. (15:15)\n  16 | }\n  17 |\n  18 | export const FIXTURE_ENTRYPOINT = {\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization (Compiled Output)\nDESCRIPTION: This is the compiled version of the React component, utilizing React's compiler-runtime. It implements memoization using a symbol-based caching mechanism and preserves the mutation functionality from the input version.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transitive-freeze-array.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enablePreserveExistingMemoizationGuarantees\nconst { mutate } = require(\"shared-runtime\");\n\nfunction Component(props) {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const x = {};\n    const y = {};\n    const items = [x, y];\n    items.pop();\n\n    mutate(y);\n    t0 = [x, y, items];\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Optimized Effect Dependencies\nDESCRIPTION: The compiler-transformed output of the React component, showing how the compiler adds memoization for the effect callback and automatically sets an empty dependency array. This optimization recognizes that setState is a stable reference.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/nonreactive-setState.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @inferEffectDependencies\nimport { useEffect, useState } from \"react\";\nimport { print } from \"shared-runtime\";\n\n/**\n * Special case of `infer-effect-deps/nonreactive-dep`.\n *\n * We know that local `useRef` return values are stable, regardless of\n * inferred memoization.\n */\nfunction NonReactiveSetStateInEffect() {\n  const $ = _c(1);\n  const [, setState] = useState(\"initial value\");\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = () => print(setState);\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  useEffect(t0, []);\n}\n```\n\n----------------------------------------\n\nTITLE: Utilizing useIdentity Hook in React\nDESCRIPTION: This snippet defines a React component, Foo, which uses the useIdentity hook to create a memoized callback for accessing an object property. The identity function ensures immutability beyond this point. The component takes an object as a prop and renders a Stringify component with evaluated properties. Dependencies include the shared-runtime package. The component expects an object with a val1 parameter as input and outputs a JSX element.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hook-call-freezes-captured-memberexpr.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useIdentity, Stringify, identity} from 'shared-runtime';\n\nfunction Foo({val1}) {\n  // `x={inner: val1}` should be able to be memoized\n  const x = {inner: val1};\n\n  // Any references to `x` after this hook call should be read-only\n  const cb = useIdentity(() => x.inner);\n\n  // With enableTransitivelyFreezeFunctionExpressions, it's invalid\n  // to write to `x` after it's been frozen.\n  // TODO: runtime validation for DX\n  const copy = identity(x);\n  return <Stringify copy={copy} cb={cb} shouldInvokeFns={true} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{val1: 1}],\n  sequentialRenders: [{val1: 1}, {val1: 1}],\n};\n```\n\n----------------------------------------\n\nTITLE: Memoized Component with React Compiler Optimizations (Compiled Version)\nDESCRIPTION: The compiled version of the Component with React compiler optimizations applied. It uses memoization to avoid recreating the object on every render by tracking dependencies on props.cond and props.value. The code utilizes a React compiler runtime helper (_c) to manage the cached state.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/object-mutated-in-consequent-alternate-both-return.expect.md#2025-04-22_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enablePropagateDepsInHIR\nimport { makeObject_Primitives } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(3);\n  let t0;\n  if ($[0] !== props.cond || $[1] !== props.value) {\n    t0 = Symbol.for(\"react.early_return_sentinel\");\n    bb0: {\n      const object = makeObject_Primitives();\n      if (props.cond) {\n        object.value = 1;\n        t0 = object;\n        break bb0;\n      } else {\n        object.value = props.value;\n        t0 = object;\n        break bb0;\n      }\n    }\n    $[0] = props.cond;\n    $[1] = props.value;\n    $[2] = t0;\n  } else {\n    t0 = $[2];\n  }\n  if (t0 !== Symbol.for(\"react.early_return_sentinel\")) {\n    return t0;\n  }\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ cond: false, value: [0, 1, 2] }],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining React Hook useFoo for State Management\nDESCRIPTION: This code defines a React hook `useFoo` that utilizes `makeObject_Primitives` and `setPropertyByKey` to manage state based on input `value` and `cond`. It initializes an object `x`, conditionally sets the property 'a' on it, and creates an array `y` that may depend on `x.a.b`. Finally, it returns an array containing `y` and `x.a.b`.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/hoist-deps-diff-ssa-instance.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {makeObject_Primitives, setPropertyByKey} from 'shared-runtime';\n\nfunction useFoo({value, cond}) {\n  let x: any = makeObject_Primitives();\n  if (cond) {\n    setPropertyByKey(x, 'a', null);\n  } else {\n    setPropertyByKey(x, 'a', {b: 2});\n  }\n\n  /**\n   * y should take a dependency on `x`, not `x.a.b` here\n   */\n  const y = [];\n  if (!cond) {\n    y.push(x.a.b);\n  }\n\n  x = makeObject_Primitives();\n  setPropertyByKey(x, 'a', {b: value});\n\n  return [y, x.a.b];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{value: 3, cond: true}],\n  sequentialRenders: [\n    {value: 3, cond: true},\n    {value: 3, cond: false},\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Original React Fragment Implementation\nDESCRIPTION: Original implementation showing a React component using useFragment hook with optional chaining for toString conversion. Handles a special case where data has type BuiltInMixedReadonly.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allocating-logical-expression-instruction-scope.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n/**\n * This is a weird case as data has type `BuiltInMixedReadonly`.\n * The only scoped value we currently infer in this program is the\n * PropertyLoad `data?.toString`.\n */\nimport {useFragment} from 'shared-runtime';\n\nfunction Foo() {\n  const data = useFragment();\n  return [data?.toString() || ''];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: Simple React component that manages arrays based on input parameters. Creates and manipulates arrays conditionally while rendering a div element with dynamic content.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/dependencies-outputs.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(a, b) {\n  const x = [];\n  x.push(a);\n  <div>{x}</div>;\n\n  const y = [];\n  if (x.length) {\n    y.push(x);\n  }\n  if (b) {\n    y.push(b);\n  }\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Dependency Tracking\nDESCRIPTION: The compiled version of the component with added dependency tracking and caching logic. Uses compiler-runtime utilities to optimize re-renders based on props changes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reactive-dependencies-non-optional-properties-inside-optional-chain.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enablePropagateDepsInHIR\nfunction Component(props) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== props.post.feedback.comments?.edges) {\n    t0 = props.post.feedback.comments?.edges?.map(render);\n    $[0] = props.post.feedback.comments?.edges;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n```\n\n----------------------------------------\n\nTITLE: React Component with new.target\nDESCRIPTION: This code snippet defines a React component that attempts to access `new.target` within a function `foo` and pass it as a value to the `Stringify` component. The `Stringify` component (imported from `shared-runtime`) is used to render the value of `new.target`.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-new-target-meta-property.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {Stringify} from 'shared-runtime';\n\nfunction foo() {\n  const nt = new.target;\n  return <Stringify value={nt} />;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Exporting Fixture Entrypoint for React Component Testing\nDESCRIPTION: This snippet exports a constant FIXTURE_ENTRYPOINT object that contains metadata about the Component function. It specifies the function, parameters, and component name, likely used for testing or integration purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/conditional-set-state-in-render.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Props (JavaScript)\nDESCRIPTION: This snippet defines a React component named MyComponentName that takes props as input. It creates an object x, applies some operations based on props, and returns an array containing x.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/codegen-emit-make-read-only.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableEmitFreeze true\n\nfunction MyComponentName(props) {\n  let x = {};\n  foo(x, props.a);\n  foo(x, props.b);\n\n  let y = [];\n  y.push(x);\n  return y;\n}\n```\n\n----------------------------------------\n\nTITLE: Optimized Calculation Function with Fixture Entrypoint in JavaScript\nDESCRIPTION: This is an optimized version of the 'foo' function, with slight modifications in the loop update statement. It also exports a FIXTURE_ENTRYPOINT object for a 'TodoAdd' component, specifying the function, params, and component name.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-logical.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(props) {\n  let y = 0;\n  for (\n    let x = 0;\n    x > props.min && x < props.max;\n    x = x + (props.cond ? props.increment : 2), x\n  ) {\n    x = x * 2;\n    y = y + x;\n  }\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Components with Memoization\nDESCRIPTION: The compiled version of the React components with runtime optimizations. This code uses React's compiler runtime to create and memoize elements, enabling efficient re-rendering by caching values between renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inline-jsx-transform.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c2 } from \"react/compiler-runtime\"; // @inlineJsxTransform\n\nfunction Parent(t0) {\n  const $ = _c2(2);\n  const { children, ref } = t0;\n  let t1;\n  if ($[0] !== children) {\n    if (DEV) {\n      t1 = <div ref={ref}>{children}</div>;\n    } else {\n      t1 = {\n        $$typeof: Symbol.for(\"react.transitional.element\"),\n        type: \"div\",\n        ref: ref,\n        key: null,\n        props: { ref: ref, children: children },\n      };\n    }\n    $[0] = children;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n\nfunction Child(t0) {\n  const $ = _c2(2);\n  const { children } = t0;\n  let t1;\n  if ($[0] !== children) {\n    if (DEV) {\n      t1 = <>{children}</>;\n    } else {\n      t1 = {\n        $$typeof: Symbol.for(\"react.transitional.element\"),\n        type: Symbol.for(\"react.fragment\"),\n        ref: null,\n        key: null,\n        props: { children: children },\n      };\n    }\n    $[0] = children;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n\nfunction GrandChild(t0) {\n  const $ = _c2(3);\n  const { className } = t0;\n  let t1;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    if (DEV) {\n      t1 = <React.Fragment key=\"fragmentKey\">Hello world</React.Fragment>;\n    } else {\n      t1 = {\n        $$typeof: Symbol.for(\"react.transitional.element\"),\n        type: React.Fragment,\n        ref: null,\n        key: \"fragmentKey\",\n        props: { children: \"Hello world\" },\n      };\n    }\n    $[0] = t1;\n  } else {\n    t1 = $[0];\n  }\n  let t2;\n  if ($[1] !== className) {\n    if (DEV) {\n      t2 = <span className={className}>{t1}</span>;\n    } else {\n      t2 = {\n        $$typeof: Symbol.for(\"react.transitional.element\"),\n        type: \"span\",\n        ref: null,\n        key: null,\n        props: { className: className, children: t1 },\n      };\n    }\n    $[1] = className;\n    $[2] = t2;\n  } else {\n    t2 = $[2];\n  }\n  return t2;\n}\n\nfunction ParentAndRefAndKey(props) {\n  const $ = _c2(1);\n  const testRef = useRef();\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    if (DEV) {\n      t0 = <Parent a=\"a\" b={{ b: \"b\" }} c={C} key=\"testKey\" ref={testRef} />;\n    } else {\n      t0 = {\n        $$typeof: Symbol.for(\"react.transitional.element\"),\n        type: Parent,\n        ref: testRef,\n        key: \"testKey\",\n        props: { a: \"a\", b: { b: \"b\" }, c: C, ref: testRef },\n      };\n    }\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nfunction ParentAndChildren(props) {\n  const $ = _c2(14);\n  let t0;\n  if ($[0] !== props.foo) {\n    t0 = () => {\n      let t1;\n      if (DEV) {\n        t1 = <div key=\"d\">{props.foo}</div>;\n      } else {\n        t1 = {\n          $$typeof: Symbol.for(\"react.transitional.element\"),\n          type: \"div\",\n          ref: null,\n          key: \"d\",\n          props: { children: props.foo },\n        };\n      }\n      return t1;\n    };\n    $[0] = props.foo;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const render = t0;\n  let t1;\n  if ($[2] !== props) {\n    if (DEV) {\n      t1 = <Child key=\"a\" {...props} />;\n    } else {\n      t1 = {\n        $$typeof: Symbol.for(\"react.transitional.element\"),\n        type: Child,\n        ref: null,\n        key: \"a\",\n        props: props,\n      };\n    }\n    $[2] = props;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n\n  const t2 = props.foo;\n  let t3;\n  if ($[4] !== props) {\n    if (DEV) {\n      t3 = <GrandChild key=\"c\" className={t2} {...props} />;\n    } else {\n      t3 = {\n        $$typeof: Symbol.for(\"react.transitional.element\"),\n        type: GrandChild,\n        ref: null,\n        key: \"c\",\n        props: { className: t2, ...props },\n      };\n    }\n    $[4] = props;\n    $[5] = t3;\n  } else {\n    t3 = $[5];\n  }\n  let t4;\n  if ($[6] !== render) {\n    t4 = render();\n    $[6] = render;\n    $[7] = t4;\n  } else {\n    t4 = $[7];\n  }\n  let t5;\n  if ($[8] !== t3 || $[9] !== t4) {\n    if (DEV) {\n      t5 = (\n        <Child key=\"b\">\n          {t3}\n          {t4}\n        </Child>\n      );\n    } else {\n      t5 = {\n        $$typeof: Symbol.for(\"react.transitional.element\"),\n        type: Child,\n        ref: null,\n        key: \"b\",\n        props: { children: [t3, t4] },\n      };\n    }\n    $[8] = t3;\n    $[9] = t4;\n    $[10] = t5;\n  } else {\n    t5 = $[10];\n  }\n  let t6;\n  if ($[11] !== t1 || $[12] !== t5) {\n    if (DEV) {\n      t6 = (\n        <Parent>\n          {t1}\n          {t5}\n        </Parent>\n      );\n    } else {\n      t6 = {\n        $$typeof: Symbol.for(\"react.transitional.element\"),\n        type: Parent,\n        ref: null,\n        key: null,\n        props: { children: [t1, t5] },\n      };\n    }\n    $[11] = t1;\n    $[12] = t5;\n    $[13] = t6;\n  } else {\n    t6 = $[13];\n  }\n  return t6;\n}\n\nconst propsToSpread = { a: \"a\", b: \"b\", c: \"c\" };\nfunction PropsSpread() {\n  const $ = _c2(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    let t1;\n    if (DEV) {\n      t1 = <Test key=\"a\" {...propsToSpread} />;\n    } else {\n      t1 = {\n        $$typeof: Symbol.for(\"react.transitional.element\"),\n        type: Test,\n        ref: null,\n        key: \"a\",\n        props: propsToSpread,\n      };\n    }\n    let t2;\n    if (DEV) {\n      t2 = <Test key=\"b\" {...propsToSpread} a=\"z\" />;\n    } else {\n      t2 = {\n        $$typeof: Symbol.for(\"react.transitional.element\"),\n        type: Test,\n        ref: null,\n        key: \"b\",\n        props: { ...propsToSpread, a: \"z\" },\n      };\n    }\n    if (DEV) {\n      t0 = (\n        <>\n          {t1}\n          {t2}\n        </>\n      );\n    } else {\n      t0 = {\n        $$typeof: Symbol.for(\"react.transitional.element\"),\n        type: Symbol.for(\"react.fragment\"),\n        ref: null,\n        key: null,\n        props: { children: [t1, t2] },\n      };\n    }\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nfunction ConditionalJsx(t0) {\n  const $ = _c2(2);\n  const { shouldWrap } = t0;\n  let t1;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    if (DEV) {\n      t1 = <div>Hello</div>;\n    } else {\n      t1 = {\n        $$typeof: Symbol.for(\"react.transitional.element\"),\n        type: \"div\",\n        ref: null,\n        key: null,\n        props: { children: \"Hello\" },\n      };\n    }\n    $[0] = t1;\n  } else {\n    t1 = $[0];\n  }\n  let content = t1;\n  if (shouldWrap) {\n    const t2 = content;\n    let t3;\n    if ($[1] === Symbol.for(\"react.memo_cache_sentinel\")) {\n      if (DEV) {\n        t3 = <Parent>{t2}</Parent>;\n      } else {\n        t3 = {\n          $$typeof: Symbol.for(\"react.transitional.element\"),\n          type: Parent,\n          ref: null,\n          key: null,\n          props: { children: t2 },\n        };\n      }\n      $[1] = t3;\n    } else {\n      t3 = $[1];\n    }\n    content = t3;\n  }\n  return content;\n}\n\nfunction ComponentWithSpreadPropsAndRef(t0) {\n  const $ = _c2(6);\n  let other;\n  let ref;\n  if ($[0] !== t0) {\n    ({ ref, ...other } = t0);\n    $[0] = t0;\n    $[1] = other;\n    $[2] = ref;\n  } else {\n    other = $[1];\n    ref = $[2];\n  }\n  let t1;\n  if ($[3] !== other || $[4] !== ref) {\n    if (DEV) {\n      t1 = <Foo ref={ref} {...other} />;\n    } else {\n      t1 = {\n        $$typeof: Symbol.for(\"react.transitional.element\"),\n        type: Foo,\n        ref: ref,\n        key: null,\n        props: { ref: ref, ...other },\n      };\n    }\n    $[3] = other;\n    $[4] = ref;\n    $[5] = t1;\n  } else {\n    t1 = $[5];\n  }\n  return t1;\n}\n\n// TODO: Support value blocks\nfunction TernaryJsx(t0) {\n  const $ = _c2(2);\n  const { cond } = t0;\n  let t1;\n  if ($[0] !== cond) {\n    t1 = cond ? <div /> : null;\n    $[0] = cond;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n\nglobal.DEV = true;\nexport const FIXTURE_ENTRYPOINT = {\n  fn: ParentAndChildren,\n  params: [{ foo: \"abc\" }],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with Custom Hook and Memo Caching\nDESCRIPTION: This code snippet defines a React component 'Test' that uses a custom hook 'useFoo' and implements memo caching for performance optimization. It also includes an export for a fixture entrypoint.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/constant-propagate-global-phis-constant.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { CONST_STRING0, Text } from \"shared-runtime\";\nfunction useFoo() {\n  \"use no forget\";\n  return { tab: CONST_STRING0 };\n}\n\nfunction Test() {\n  const $ = _c(1);\n  const { tab } = useFoo();\n  tab === CONST_STRING0 ? CONST_STRING0 : CONST_STRING0;\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = <Text value={CONST_STRING0} />;\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Test,\n  params: [],\n  isComponent: true,\n};\n```\n\n----------------------------------------\n\nTITLE: Original Function Implementation with TypeScript Props\nDESCRIPTION: The original function implementation that takes props with a number value x, performs increment and decrement operations, and returns an object with the intermediate values.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/update-expression.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(props: {x: number}) {\n  let x = props.x;\n  let y = x++;\n  let z = x--;\n  return {x, y, z};\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [{x: 1}],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Complex Conditional Function Implementation in JavaScript\nDESCRIPTION: A multi-level conditional function that assigns values to variable x based on nested conditions and returns the final value\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-multiple-phis.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(a, b, c, d) {\n  let x = 0;\n  if (true) {\n    if (true) {\n      x = a;\n    } else {\n      x = b;\n    }\n    x;\n  } else {\n    if (true) {\n      x = c;\n    } else {\n      x = d;\n    }\n    x;\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Memoization in JavaScript\nDESCRIPTION: This snippet shows the optimized version of the Component function using React's compiler runtime. It implements memoization to cache the result of the 'foo' method call, potentially improving performance for repeated renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-within-object-method.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const object = {\n      foo() {\n        try {\n          return [];\n        } catch (t1) {\n          return;\n        }\n      },\n    };\n\n    t0 = object.foo();\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Using setProperty in Conditional State Management - JavaScript\nDESCRIPTION: This snippet defines the useFoo function which takes an object containing 'o' (with a numeric value) and 'branchCheck' (a boolean) as arguments. It conditionally modifies an object 'x' based on the value of 'branchCheck' and returns 'x'. The dependency 'setProperty' is used to assign values to 'x'. Inputs include the object 'o' with its numeric value and 'branchCheck'. The output is the modified object 'x'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-cond-deps-cfg-nested-testifelse.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {setProperty} from 'shared-runtime';\n\nfunction useFoo({o, branchCheck}: {o: {value: number}; branchCheck: boolean}) {\n  let x = {};\n  if (branchCheck) {\n    setProperty(x, o.value);\n  } else {\n    if (o.value) {\n      setProperty(x, o.value);\n    } else {\n      setProperty(x, o.value);\n    }\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{o: {value: 2}, branchCheck: false}],\n};\n```\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { setProperty } from \"shared-runtime\";\n\nfunction useFoo(t0) {\n  const $ = _c(3);\n  const { o, branchCheck } = t0;\n  let x;\n  if ($[0] !== branchCheck || $[1] !== o.value) {\n    x = {};\n    if (branchCheck) {\n      setProperty(x, o.value);\n    } else {\n      if (o.value) {\n        setProperty(x, o.value);\n      } else {\n        setProperty(x, o.value);\n      }\n    }\n    $[0] = branchCheck;\n    $[1] = o.value;\n    $[2] = x;\n  } else {\n    x = $[2];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ o: { value: 2 }, branchCheck: false }],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimizing React Component Performance with Compiler Runtime in JavaScript\nDESCRIPTION: This snippet optimizes a React component using a compiler runtime to handle caching effectively. It ensures components render efficiently by tracking changes to inputs and applying memoization techniques. The integration with `react/compiler-runtime` facilitates nuanced updates based on prior state and identity, leading to enhanced performance during component lifecycle operations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/sequential-destructuring-assignment-to-scope-declarations.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { identity } from \"shared-runtime\";\n\nfunction Component(statusName) {\n  const $ = _c(12);\n  let t0;\n  let t1;\n  let text;\n  if ($[0] !== statusName) {\n    const { status, text: t2 } = foo(statusName);\n    text = t2;\n    const { bg, color } = getStyles(status);\n\n    t1 = identity(bg);\n    t0 = identity(color);\n    $[0] = statusName;\n    $[1] = t0;\n    $[2] = t1;\n    $[3] = text;\n  } else {\n    t0 = $[1];\n    t1 = $[2];\n    text = $[3];\n  }\n  let t2;\n  if ($[4] !== text) {\n    t2 = [text];\n    $[4] = text;\n    $[5] = t2;\n  } else {\n    t2 = $[5];\n  }\n  let t3;\n  if ($[6] !== t0 || $[7] !== t2) {\n    t3 = <span className={t0}>{t2}</span>;\n    $[6] = t0;\n    $[7] = t2;\n    $[8] = t3;\n  } else {\n    t3 = $[8];\n  }\n  let t4;\n  if ($[9] !== t1 || $[10] !== t3) {\n    t4 = <div className={t1}>{t3}</div>;\n    $[9] = t1;\n    $[10] = t3;\n    $[11] = t4;\n  } else {\n    t4 = $[11];\n  }\n  return t4;\n}\n\nfunction foo(name) {\n  const $ = _c(2);\n\n  const t0 = `${name}!`;\n  let t1;\n  if ($[0] !== t0) {\n    t1 = { status: `<status>`, text: t0 };\n    $[0] = t0;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n\nfunction getStyles(status) {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = { bg: \"#eee8d5\", color: \"#657b83\" };\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\"Mofei\"],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiling React Component with Optimized Caching in JavaScript\nDESCRIPTION: This snippet is an optimized version of a React component using compiler runtime optimizations. It implements caching mechanisms to store properties and rendered outputs to minimize recalculations. The component still retrieves a nested group label but uses indexed caching for performance improvements. Dependencies include React and compiler-runtime.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/idx-no-outlining.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @customMacros(idx)\n\nfunction Component(props) {\n  var _ref2;\n  const $ = _c(4);\n  let t0;\n  if ($[0] !== props) {\n    var _ref;\n\n    t0 =\n      (_ref = props) != null\n        ? (_ref = _ref.group) != null\n          ? _ref.label\n          : _ref\n        : _ref;\n    $[0] = props;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const groupName = t0;\n  let t1;\n  if ($[2] !== groupName) {\n    t1 = <div>{groupName}</div>;\n    $[2] = groupName;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Memoization in JavaScript\nDESCRIPTION: This snippet shows the optimized version of the Component function. It uses memoization to avoid unnecessary re-renders and imports a compiler runtime function from React. The FIXTURE_ENTRYPOINT remains the same for testing consistency.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-multiple-variable-declarations-in-initializer.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  let items;\n  if ($[0] !== props.items) {\n    items = [];\n    for (let i = 0, length = props.items.length; i < length; i++) {\n      items.push(props.items[i]);\n    }\n    $[0] = props.items;\n    $[1] = items;\n  } else {\n    items = $[1];\n  }\n  return items;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ items: [\"a\", \"b\", 42] }],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled Output of FBT Internationalized React Component\nDESCRIPTION: This snippet shows the compiled output of the FBT-based React component. It includes optimizations for memoization and demonstrates how FBT transforms the internationalized strings.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-to-string.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport fbt from \"fbt\";\n\nfunction Component(props) {\n  const $ = _c(4);\n  let t0;\n  if ($[0] !== props.name) {\n    t0 = fbt._(\"Hello {user name}\", [fbt._param(\"user name\", props.name)], {\n      hk: \"2zEDKF\",\n    });\n    $[0] = props.name;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const element = t0;\n  let t1;\n  if ($[2] !== element) {\n    t1 = element.toString();\n    $[2] = element;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ name: \"Jason\" }],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component Definition with Props\nDESCRIPTION: This JavaScript code defines a React component named `Component` that accepts `props` as input. It creates an array `c_0` containing the values of `props.a` and `props.b.c` and returns this array. The `FIXTURE_ENTRYPOINT` object specifies the component and sample parameters for testing or demonstration purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/option-enable-change-variable-codegen.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableChangeVariableCodegen\nfunction Component(props) {\n  const c_0 = [props.a, props.b.c];\n  return c_0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{a: 3.14, b: {c: true}}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Exporting Component Metadata\nDESCRIPTION: This code exports a constant named `FIXTURE_ENTRYPOINT`. This constant is an object containing metadata about the `foo` component, including a reference to the component's function (`fn`), an array of parameters (`params`), and the component's name (`isComponent`). This metadata can be used for testing or other tooling that needs to understand the structure and behavior of the component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/while-logical.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization Optimizations\nDESCRIPTION: Compiled version of the React component showing how the compiler implements memoization optimizations. It uses Symbol.for(\"react.memo_cache_sentinel\") to track memoized values and includes compiler-specific runtime helpers.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useCallback-set-ref-value-dont-preserve-memoization.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enablePreserveExistingMemoizationGuarantees\nimport { useCallback, useRef } from \"react\";\n\nfunction Component(props) {\n  const $ = _c(2);\n  const ref = useRef(null);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = (event) => {\n      ref.current = event.target.value;\n    };\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const onChange = t0;\n  let t1;\n  if ($[1] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = <input onChange={onChange} />;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Unoptimized React Component in JavaScript\nDESCRIPTION: This snippet defines a simple React component that creates an array from the 'items' prop. It also exports a FIXTURE_ENTRYPOINT object for testing purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-multiple-variable-declarations-in-initializer.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const items = [];\n\n  for (let i = 0, length = props.items.length; i < length; i++) {\n    items.push(props.items[i]);\n  }\n\n  return items;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{items: ['a', 'b', 42]}],\n};\n```\n\n----------------------------------------\n\nTITLE: Updating Tree Base Duration Operation in React DevTools\nDESCRIPTION: Example showing the operation payload for updating the base duration of a fiber, which is used by the Profiler UI. It includes the operation type, fiber id, and the new duration value.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/OVERVIEW.md#2025-04-21_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\n[\n  4,  // update tree base duration operation\n  4,  // tree base duration operation\n  1,  // fiber id\n  32, // new tree base duration value\n]\n```\n\n----------------------------------------\n\nTITLE: React Fixture Entrypoint Configuration\nDESCRIPTION: Defines test fixture configuration for the React component, specifying function, initial parameters, and a sequence of renders to test component behavior\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-fun-alias-captured-mutate-arr-2.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{foo: 2, bar: 3}],\n  sequentialRenders: [\n    {foo: 2, bar: 3},\n    {foo: 2, bar: 3},\n    {foo: 2, bar: 4},\n    {foo: 3, bar: 4},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: React Hooks Dependency Linting Error\nDESCRIPTION: The error message generated by a React hooks linting tool when it detects a conditional dependency list in useMemo. It specifically highlights line 10 where a ternary operator is used instead of a literal array expression for dependencies.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.useMemo-non-literal-depslist.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n   8 |       return text.toUpperCase();\n   9 |     },\n> 10 |     hasDeps ? null : [text], // should be DCE'd\n     |     ^^^^^^^^^^^^^^^^^^^^^^^ InvalidReact: Expected the dependency list for useMemo to be an array literal (10:10)\n  11 |   );\n  12 |   return resolvedText;\n  13 | }\n```\n\n----------------------------------------\n\nTITLE: Defining a function in Javascript\nDESCRIPTION: This code snippet defines a simple Javascript function named `foo` that takes four arguments but has an empty body. This likely serves as a placeholder or a minimal definition for a more complex implementation elsewhere.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-sibling-phis.expect.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(a, b, c, d) {}\n```\n\n----------------------------------------\n\nTITLE: Handling React Memo Cache Sentinel JavaScript\nDESCRIPTION: This snippet imports a function and handles memo cache using React's compiler runtime. It checks for a sentinel value and conditionally initializes an array, assigns it to an object, mutates it, and stores it in a cache. The function returns an object from cache based on conditions. Requires the 'react/compiler-runtime' import, and effective management of memoization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-property-mutate-2.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction foo() {\n  const $ = _c(1);\n  let y;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const x = [];\n    y = {};\n    y.x = x;\n    mutate(x);\n    $[0] = y;\n  } else {\n    y = $[0];\n  }\n  return y;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Exporting Fixture Entry Point - JavaScript\nDESCRIPTION: This snippet exports a constant that contains the function reference of the component along with predefined parameters to be used for testing or rendering the component in isolation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/non-null-assertion.expect.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{name: 'Alice'}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining Component Logic with Reactive Values using React Compiler Runtime in JavaScript\nDESCRIPTION: This snippet enhances the previous component definition by using the React Compiler Runtime. It creates a reactive component where the values of x and y utilize React's state management. The while loop ensures that y fetches the value from props reactively, allowing for state updates in response to changes. The final output will also be an array containing the updated value of x, leveraging the compiler's optimizations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-dependency-fixpoint.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  let x = 0;\n  let y = 0;\n  while (x === 0) {\n    x = y;\n    y = props.value;\n  }\n  let t0;\n  if ($[0] !== x) {\n    t0 = [x];\n    $[0] = x;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ value: 42 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Input JSX Implementation with FBT Plural\nDESCRIPTION: JSX component implementation showing FBT plural handling with both fbt.plural() method and <fbt:plural> component. Demonstrates parameter passing and count display for multiple items (apples and bananas).\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/bug-fbt-plural-multiple-mixed-call-tag.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport fbt from 'fbt';\n\nfunction useFoo({apples, bananas}) {\n  return (\n    <div>\n      <fbt desc=\"Test Description\">\n        {fbt.param('number of apples', apples)}\n        {'  '}\n        {fbt.plural('apple', apples)} and\n        {'  '}\n        <fbt:plural name={'number of bananas'} count={bananas} showCount=\"yes\">\n          banana\n        </fbt:plural>\n      </fbt>\n    </div>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{apples: 1, bananas: 2}],\n};\n```\n\n----------------------------------------\n\nTITLE: Setting Subtree Mode Operation in React DevTools\nDESCRIPTION: Example showing the operation payload for setting the mode for a component subtree. It includes the operation type, subtree root fiber id, and a bitmask representing the mode.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/OVERVIEW.md#2025-04-21_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\n[\n  7,   // set subtree mode\n  1,   // subtree root fiber id\n  0b01 // mode bitmask\n]\n```\n\n----------------------------------------\n\nTITLE: Memoization and Dynamic Component Construction in React - JavaScript\nDESCRIPTION: This snippet demonstrates a pattern of using memoization with React components to optimize rendering by caching components. The code utilizes a compiler runtime import from React and checks a symbol for memoization cache validity before deciding to create a new component or reuse the cached one. Dependencies include the 'react/compiler-runtime'. Key parameters include the props passed to the Example function, and it outputs a React component that is memoized to prevent unnecessary renderings.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/static-components/invalid-dynamically-construct-component-in-render.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @logger @validateStaticComponents\nfunction Example(props) {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const Component = createComponent();\n    t0 = <Component />;\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with Memoization Strategies\nDESCRIPTION: This snippet shows a React component that demonstrates various memoization strategies for its internal variables. It includes comments explaining the rationale behind memoizing different values to optimize performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/escape-analysis-non-escaping-interleaved-allocating-nested-dependency.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  // a can be independently memoized, is not mutated later\n  // but a is a dependnecy of b, which is a dependency of c.\n  // we have to memoize a to avoid breaking memoization of b,\n  // to avoid breaking memoization of c.\n  const a = [props.a];\n\n  // a can be independently memoized, is not mutated later,\n  // but is a dependency of d which is part of c's scope.\n  // we have to memoize b to avoid breaking memoization of c.\n  const b = [a];\n\n  // c and d are interleaved and grouped into a single scope,\n  // but they are independent values. d does not escape, but\n  // we need to ensure that b is memoized or else b will invalidate\n  // on every render since a is a dependency. we also need to\n  // ensure that a is memoized, since it's a dependency of b.\n  const c = [];\n  const d = {};\n  d.b = b;\n  c.push(props.b);\n\n  return c;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: TypeScript Error for Optional Chaining in Function Arguments\nDESCRIPTION: This is the error output generated by the TypeScript compiler, showing a problem with using optional chaining (`value?.x`) in the arguments of the createArray function. The error specifically mentions an 'Unexpected terminal kind `optional` for optional fallthrough block'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-optional-call-chain-in-optional.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n  1 | function useFoo(props: {value: {x: string; y: string} | null}) {\n  2 |   const value = props.value;\n> 3 |   return createArray(value?.x, value?.y)?.join(', ');\n    |                      ^^^^^^^^ Todo: Unexpected terminal kind `optional` for optional fallthrough block (3:3)\n  4 | }\n  5 |\n  6 | function createArray<T>(...args: Array<T>): Array<T> {\n```\n\n----------------------------------------\n\nTITLE: Getting Performance Metrics with PerfCounters in Node.js\nDESCRIPTION: This snippet initializes the PerfCounters library and captures performance metrics at the start and end of a test. It logs the performance data to the console for analysis. The expected outputs include counts of instructions, loads, and stores before and after executing certain operations, which can help in performance evaluation.\nSOURCE: https://github.com/facebook/react/blob/main/scripts/perf-counters/README.md#2025-04-21_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\n$ node\n> var PerfCounters = require('perf-counters');\n> PerfCounters.init();\n> var start = PerfCounters.getCounters(); console.log('test'); var end = PerfCounters.getCounters();\ntest\n> start\n{ instructions: 1382, loads: 421, stores: 309 }\n> end\n{ instructions: 647633, loads: 195771, stores: 133246 }\n>\n```\n\n----------------------------------------\n\nTITLE: Compiled React Runtime Version\nDESCRIPTION: Compiled version using React's compiler runtime that implements memoization using a Symbol sentinel. The function caches its result and only recomputes when necessary.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/chained-assignment-expressions.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction foo() {\n  const $ = _c(1);\n  let z;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const x = { x: 0 };\n    const y = { z: 0 };\n    z = { z: 0 };\n    x.x = x.x + (y.y = y.y * 1);\n    z.z = z.z + (y.y = y.y * (x.x = x.x & 3));\n    $[0] = z;\n  } else {\n    z = $[0];\n  }\n  return z;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized VideoTab Component with React Compiler Runtime\nDESCRIPTION: An enhanced version of the VideoTab component using React compiler runtime for memoization and cached rendering\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ref-current-optional-field-no-added-to-dep.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction VideoTab() {\n  const $ = _c(1);\n  const ref = useRef();\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const x = () => {\n      ref.current?.x;\n    };\n\n    t0 = <VideoList videos={x} />;\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n```\n\n----------------------------------------\n\nTITLE: React Component with Async Variable Reassignment\nDESCRIPTION: This React component demonstrates an anti-pattern: reassigning a local variable (`value`) within an async function (`reassign`). This function is called when the user clicks on the div. The anti-pattern leads to a React error because direct reassignment in async functions may cause unexpected component behavior and incorrect rendering results. The error suggests the usage of state instead.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-reassign-local-variable-in-async-callback.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component() {\n  let value = null;\n  const reassign = async () => {\n    await foo().then(result => {\n      // Reassigning a local variable in an async function is *always* mutating\n      // after render, so this should error regardless of where this ends up\n      // getting called\n      value = result;\n    });\n  };\n\n  const onClick = async () => {\n    await reassign();\n  };\n  return <div onClick={onClick}>Click</div>;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component Output\nDESCRIPTION: The compiled version of the component showing compiler runtime optimizations. Includes memo cache sentinel checking and extraction of the callback function into a separate function declaration.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-global-mutation-unused-usecallback.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useCallback, useEffect, useState } from \"react\";\n\nfunction Component() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = <div>Ok</div>;\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\nfunction _temp() {\n  window.foo = true;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Foo Functionality with Conditional Logic - JavaScript\nDESCRIPTION: This snippet defines a function 'foo' that initializes a variable 'x' to 1 and changes its value to 2 if a conditional check passes. The function returns the final value of 'x'. It serves as an example of basic variable manipulation and condition handling in JavaScript. The 'FIXTURE_ENTRYPOINT' constant exports this function as part of an object, providing its callable reference.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-return.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo() {\n  let x = 1;\n  if (x === 1) {\n    x = 2;\n  }\n\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [],\n  isComponent: false,\n};\n\n```\n\n----------------------------------------\n\nTITLE: Rendering Button List in React (Compiled Version)\nDESCRIPTION: This is the compiled version of the React component, optimized for performance. It includes memoization techniques to avoid unnecessary re-renders and computations. The core functionality remains the same as the input version.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-undefined-expression-of-jsxexpressioncontainer.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { StaticText1, Stringify, Text } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(6);\n  const { buttons } = props;\n  let nonPrimaryButtons;\n  if ($[0] !== buttons) {\n    [, ...nonPrimaryButtons] = buttons;\n    $[0] = buttons;\n    $[1] = nonPrimaryButtons;\n  } else {\n    nonPrimaryButtons = $[1];\n  }\n  let t0;\n  if ($[2] !== nonPrimaryButtons) {\n    t0 = nonPrimaryButtons.map(_temp);\n    $[2] = nonPrimaryButtons;\n    $[3] = t0;\n  } else {\n    t0 = $[3];\n  }\n  const renderedNonPrimaryButtons = t0;\n  let t1;\n  if ($[4] !== renderedNonPrimaryButtons) {\n    t1 = <StaticText1>{renderedNonPrimaryButtons}</StaticText1>;\n    $[4] = renderedNonPrimaryButtons;\n    $[5] = t1;\n  } else {\n    t1 = $[5];\n  }\n  return t1;\n}\nfunction _temp(buttonProps, i) {\n  return (\n    <Stringify\n      {...buttonProps}\n      key={`button-${i}`}\n      style={\n        i % 2 === 0 ? styles.leftSecondaryButton : styles.rightSecondaryButton\n      }\n    />\n  );\n}\n\nconst styles = {\n  leftSecondaryButton: { left: true },\n  rightSecondaryButton: { right: true },\n};\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\n    {\n      buttons: [\n        {},\n        { type: \"submit\", children: [\"Submit!\"] },\n        { type: \"button\", children: [\"Reset\"] },\n      ],\n    },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Building and Serving Production React Application\nDESCRIPTION: Commands for building the React application for production and serving it using 'serve'. The build process optimizes resources for production, and 'serve' creates a local server to host the optimized build.\nSOURCE: https://github.com/facebook/react/blob/main/fixtures/nesting/README.md#2025-04-21_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\nnpm install\nnpm run build\nnpx serve -s build\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: Basic React component that creates an array from props and returns an object with array properties. Demonstrates array manipulation and object creation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-properties.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const a = [props.a, props.b, 'hello'];\n  const x = a.length;\n  const y = a.push;\n  return {a, x, y, z: a.concat};\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{a: [1, 2], b: 2}],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Incorrectly Mutating React Context Value\nDESCRIPTION: This code snippet shows an invalid approach to modifying context by directly assigning a value, which violates React's immutability principles and triggers a runtime error\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-mutate-context.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const context = useContext(FooContext);\n  context.value = props.value;\n  return context.value;\n}\n```\n\n----------------------------------------\n\nTITLE: React Component Definition\nDESCRIPTION: This code defines a simple React component that returns the result of a method call on an object. The component is exported as `FIXTURE_ENTRYPOINT` with a set of parameters.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-method-shorthand.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component() {\n  let obj = {\n    method() {\n      return 1;\n    },\n  };\n  return obj.method();\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{x: 1}, {a: 2}, {b: 2}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Implementing React Components with Hooks Misuse\nDESCRIPTION: This JavaScript snippet demonstrates the creation of React components with improper usage of React hooks and class components within function components. It highlights the usage of 'use forget' directive, which is a non-standard practice, and disabling of ESLint rules, causing React Compiler to skip optimization. The snippet includes functions like 'lowercasecomponent', 'Haunted', and 'CrimesAgainstReact' illustrating deviant patterns in React component design.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-unclosed-eslint-suppression.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Note: Everything below this is sketchy\n/* eslint-disable react-hooks/rules-of-hooks */\nfunction lowercasecomponent() {\n  'use forget';\n  const x = [];\n  return <div>{x}</div>;\n}\n\nfunction Haunted() {\n  return <div>This entire file is haunted oOoOo</div>;\n}\n\nfunction CrimesAgainstReact() {\n  let x = React.useMemo(async () => {\n    await a;\n  }, []);\n\n  class MyAmazingInnerComponent {\n    render() {\n      return <div>Why would you do this</div>;\n    }\n  }\n\n  // Note: This shouldn't reset the eslint suppression to just this line\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  return <MyAmazingInnerComponent />;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining Basic Log Function - JavaScript\nDESCRIPTION: This snippet defines a logging function named 'log' with no parameters or functionality. It serves as a placeholder for later implementation of logging logic. No dependencies are required.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-shadowing.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction log() {}\n```\n\n----------------------------------------\n\nTITLE: Defining Animated SVG Component with Reanimated\nDESCRIPTION: This code defines a React component that animates an SVG path using Reanimated's `useAnimatedProps` hook. It calculates the path based on a shared value `radius` and updates the SVG path's `d` attribute. The component uses `Svg` and `AnimatedPath` components, assumed to be available from a relevant library.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reanimated-no-memo-arg.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableCustomTypeDefinitionForReanimated\nimport {useAnimatedProps} from 'react-native-reanimated';\nfunction Component() {\n  const radius = useSharedValue(50);\n\n  const animatedProps = useAnimatedProps(() => {\n    // draw a circle\n    const path = `\n    M 100, 100\n    m -${radius.value}, 0\n    a ${radius.value},${radius.value} 0 1,0 ${radius.value * 2},0\n    a ${radius.value},${radius.value} 0 1,0 ${-radius.value * 2},0\n    `;\n    return {\n      d: path,\n    };\n  });\n\n  // attach animated props to an SVG path using animatedProps\n  return (\n    <Svg>\n      <AnimatedPath animatedProps={animatedProps} fill=\"black\" />\n    </Svg>\n  );\n}\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  isComponent: false,\n};\n\n```\n\n----------------------------------------\n\nTITLE: Enhanced Component Logic in React with State Management\nDESCRIPTION: This snippet imports a method from the React compiler runtime and uses it to manage component state. It retains the logic of optional chaining while caching the output to avoid redundant calculations, allowing for optimized rendering based on props equality.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-call-chained.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== props) {\n    t0 = call?.(props.a)?.(props.b)?.(props.c);\n    $[0] = props;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n```\n\n----------------------------------------\n\nTITLE: Running DevTools in DEV Mode\nDESCRIPTION: Start the DevTools in development mode to test changes interactively.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/CONTRIBUTING.md#2025-04-21_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\ncd <react-repo>\ncd packages/react-devtools-inline\nyarn start\n```\n\n----------------------------------------\n\nTITLE: Original Component Function with Nested Closures\nDESCRIPTION: This is the original implementation of a component function that creates nested closures accessing a variable from an outer scope. The function initializes an object and returns a nested function that logs a value.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-nested-member-expr-in-nested-func.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component(a) {\n  let z = {a: {a}};\n  let x = function () {\n    (function () {\n      console.log(z.a.a);\n    })();\n  };\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with State Manipulation in JavaScript\nDESCRIPTION: This snippet defines a React component that creates an object, manipulates it, and returns it within a JSX structure. It demonstrates the importance of avoiding mutations on variables used in JSX and includes an error scenario where this rule is violated. Key parameters include 'props' passed to the component, with expected outputs being the object and potential error messages indicating invalid operations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-delete-property-of-frozen-value.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const x = makeObject();\n  // freeze\n  <div>{x}</div>;\n  delete x.y;\n  return x;\n}\n\n\n```\n\n----------------------------------------\n\nTITLE: Input React Component with Type Annotations\nDESCRIPTION: Original React component implementation with TypeScript-like type annotations. Defines a Component that takes props with a numeric id, creates an array, and returns its first element.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-annotations/type-annotation-var-array.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableUseTypeAnnotations\nfunction Component(props: {id: number}) {\n  const x: number[] = makeArray(props.id);\n  const y = x.at(0);\n  return y;\n}\n\nfunction makeArray<T>(x: T): Array<T> {\n  return [x];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{id: 42}],\n};\n```\n\n----------------------------------------\n\nTITLE: Complex React Component Handler with Conditional Logic\nDESCRIPTION: Defines a handler function with multiple conditional branches and exports a test fixture configuration. The function evaluates conditions to return different parameters based on input value and computed results.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/constant-propagation-phi.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(a, b, c) {\n  let x;\n  if (a) {\n    x = 2 - 1;\n  } else {\n    x = 0 + 1;\n  }\n  if (x === 1) {\n    return b;\n  } else {\n    return c;\n  }\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized Compiler Output with Memoization\nDESCRIPTION: Transformed version of the function using React's compiler runtime for memoization. Implements caching using an array ($) to store previous values and avoid unnecessary re-computations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction foo(a, b, c) {\n  const $ = _c(18);\n  let d;\n  let h;\n  let t0;\n  if ($[0] !== a) {\n    [d, t0, ...h] = a;\n    $[0] = a;\n    $[1] = d;\n    $[2] = h;\n    $[3] = t0;\n  } else {\n    d = $[1];\n    h = $[2];\n    t0 = $[3];\n  }\n  const [t1] = t0;\n  let g;\n  let t2;\n  if ($[4] !== t1) {\n    ({ e: t2, ...g } = t1);\n    $[4] = t1;\n    $[5] = g;\n    $[6] = t2;\n  } else {\n    g = $[5];\n    t2 = $[6];\n  }\n  const { f } = t2;\n  const { l: t3, p } = b;\n  const { m: t4 } = t3;\n  let o;\n  let t5;\n  if ($[7] !== t4) {\n    [t5, ...o] = t4;\n    $[7] = t4;\n    $[8] = o;\n    $[9] = t5;\n  } else {\n    o = $[8];\n    t5 = $[9];\n  }\n  const [n] = t5;\n  let t6;\n  if (\n    $[10] !== d ||\n    $[11] !== f ||\n    $[12] !== g ||\n    $[13] !== h ||\n    $[14] !== n ||\n    $[15] !== o ||\n    $[16] !== p\n  ) {\n    t6 = [d, f, g, h, n, o, p];\n    $[10] = d;\n    $[11] = f;\n    $[12] = g;\n    $[13] = h;\n    $[14] = n;\n    $[15] = o;\n    $[16] = p;\n    $[17] = t6;\n  } else {\n    t6 = $[17];\n  }\n  return t6;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Compiler Runtime\nDESCRIPTION: This snippet shows the optimized version of the Component function using React's compiler runtime. It implements memoization to avoid unnecessary array creation. The FIXTURE_ENTRYPOINT is preserved for consistency with the input version.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rest-param-with-identifier.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(foo, ...t0) {\n  const $ = _c(3);\n  const bar = t0;\n  let t1;\n  if ($[0] !== bar || $[1] !== foo) {\n    t1 = [foo, bar];\n    $[0] = bar;\n    $[1] = foo;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\"foo\", \"bar\", \"baz\"],\n};\n```\n\n----------------------------------------\n\nTITLE: Using useEffectWrapper in non-React function (JavaScript)\nDESCRIPTION: This code defines a function, `nonReactFn`, that calls a custom hook `useMyEffect` outside of a React component. The `useMyEffect` hook is used to create an effect, and its dependencies are intended to be automatically inferred. However, because the hook is called within a non-React function, the React Compiler is unable to infer the dependencies, resulting in a compiler error.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/bailout-retry/error.callsite-in-non-react-fn-default-import.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @inferEffectDependencies @compilationMode(infer) @panicThreshold(none)\nimport useMyEffect from 'useEffectWrapper';\n\nfunction nonReactFn(arg) {\n  useMyEffect(() => [1, 2, arg]);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Set Operations with React Hook\nDESCRIPTION: Original implementation of a React hook that creates and manipulates multiple Sets. Takes an array of numbers as props and performs various Set operations with memoization opportunities.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/global-types/set-constructor-arg.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst MODULE_LOCAL = new Set([4, 5, 6]);\nfunction useFoo({propArr}: {propArr: Array<number>}) {\n  /* Array can be memoized separately of the Set */\n  const s1 = new Set([1, 2, 3]);\n  s1.add(propArr[0]);\n\n  /* but `.values` cannot be memoized separately */\n  const s2 = new Set(MODULE_LOCAL.values());\n  s2.add(propArr[1]);\n\n  const s3 = new Set(s2.values());\n  s3.add(propArr[2]);\n\n  /**\n   * s4 should be memoized separately from s3\n   */\n  const s4 = new Set(s3);\n  s4.add(propArr[3]);\n  return [s1, s2, s3, s4];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{propArr: [7, 8, 9]}],\n  sequentialRenders: [{propArr: [7, 8, 9]}, {propArr: [7, 8, 10]}],\n};\n```\n\n----------------------------------------\n\nTITLE: Initializing React Component with Props in JavaScript\nDESCRIPTION: This snippet defines two functions: `foo`, which appears to be a placeholder, and `Component`, a React component function. The component initializes an array and an object, passes them to the `foo` function, and returns a JSX element using them as props. There are no specific dependencies listed, although React and JSX syntax are used. This exercise primarily involves state creation and JSX return.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/call.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo() {}\n\nfunction Component(props) {\n  const a = [];\n  const b = {};\n  foo(a, b);\n  let _ = <div a={a} />;\n  foo(b);\n  return <div a={a} b={b} />;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Conditional Dependency Tracking in React\nDESCRIPTION: Original implementation of a React hook that accesses props.a unconditionally and props.a.b conditionally. This demonstrates how React handles dependency tracking when a property path is a superpath of another.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/superpath-order1.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// When an unconditional dependency `props.a` is the subpath of a conditional\n// dependency `props.a.b`, we can safely overestimate and only track `props.a`\n// as a dependency\n\nimport {identity} from 'shared-runtime';\n\n// ordering of accesses should not matter\nfunction useConditionalSuperpath1({props, cond}) {\n  const x = {};\n  x.a = props.a;\n  if (identity(cond)) {\n    x.b = props.a.b;\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useConditionalSuperpath1,\n  params: [{props: {a: null}, cond: false}],\n  sequentialRenders: [\n    {props: {a: null}, cond: false},\n    {props: {a: {}}, cond: true},\n    {props: {a: {b: 3}}, cond: true},\n    {props: {}, cond: false},\n    // test that we preserve nullthrows\n    {props: {a: {b: undefined}}, cond: true},\n    {props: {a: undefined}, cond: true},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Initializing Conditional Dependency Promotion in React Hook\nDESCRIPTION: A function that demonstrates runtime dependency tracking and conditional access promotion, using identity checks and nested object properties\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/promote-uncond.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction usePromoteUnconditionalAccessToDependency(props, other) {\n  const x = {};\n  x.a = props.a.a.a;\n  if (identity(other)) {\n    x.c = props.a.b.c;\n  }\n  return x;\n}\n```\n\nLANGUAGE: javascript\nCODE:\n```\nfunction usePromoteUnconditionalAccessToDependency(props, other) {\n  const $ = _c(4);\n  let x;\n  if ($[0] !== other || $[1] !== props.a.a.a || $[2] !== props.a.b) {\n    x = {};\n    x.a = props.a.a.a;\n    if (identity(other)) {\n      x.c = props.a.b.c;\n    }\n    $[0] = other;\n    $[1] = props.a.a.a;\n    $[2] = props.a.b;\n    $[3] = x;\n  } else {\n    x = $[3];\n  }\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: FBT Multiple Enum Error Message\nDESCRIPTION: Error output showing that multiple fbt:enum tags within a single FBT component are not supported. The error occurs on line 7 of the code.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/error.todo-fbt-unknown-enum-value.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n   5 |     <fbt desc=\"Description\">\n   6 |       <fbt:enum enum-range={['avalue1', 'avalue1']} value={a} />{' '}\n>  7 |       <fbt:enum enum-range={['bvalue1', 'bvalue2']} value={b} />\n     |        ^^^^^^^^ Todo: Support <fbt> tags with multiple <fbt:enum> values (7:7)\n   8 |     </fbt>\n   9 |   );\n  10 | }\n```\n\n----------------------------------------\n\nTITLE: Expanded Flow-typed React Component with Detailed Type Annotations\nDESCRIPTION: Enhanced version of the same component with explicit Flow type annotations, including ReadOnly type and React.Node return type specification.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-dont-add-hook-guards-on-retry.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Foo({\n  useDynamicHook,\n}: $ReadOnly<{ useDynamicHook: any }>): React.Node {\n  useDynamicHook();\n  return <div>hello world</div>;\n}\n```\n\n----------------------------------------\n\nTITLE: Original React Component with Ref Usage in Effects\nDESCRIPTION: Demonstrates a React component that uses refs within useEffect hooks without explicit dependency arrays. The code showcases the usage of refs and nested refs that will need proper dependency tracking.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/nonreactive-ref-helper.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @inferEffectDependencies\nimport {useEffect} from 'react';\nimport {print} from 'shared-runtime';\n\n/**\n * We never include a .current access in a dep array because it may be a ref access.\n * This might over-capture objects that are not refs and happen to have fields named\n * current, but that should be a rare case and the result would still be correct\n * (assuming the effect is idempotent). In the worst case, you can always write a manual\n * dep array.\n */\nfunction RefsInEffects() {\n  const ref = useRefHelper();\n  const wrapped = useDeeperRefHelper();\n  useEffect(() => {\n    print(ref.current);\n    print(wrapped.foo.current);\n  });\n}\n\nfunction useRefHelper() {\n  return useRef(0);\n}\n\nfunction useDeeperRefHelper() {\n  return {foo: useRefHelper()};\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled Animated SVG Component with Reanimated\nDESCRIPTION: This code represents the compiled version of the React component with Reanimated integration. It utilizes React's compiler runtime (`_c`) for optimization. The component memoizes the `animatedProps` and the resulting SVG element to prevent unnecessary re-renders. It relies on the `useAnimatedProps` hook for updating the SVG path.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reanimated-no-memo-arg.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enableCustomTypeDefinitionForReanimated\nimport { useAnimatedProps } from \"react-native-reanimated\";\nfunction Component() {\n  const $ = _c(2);\n  const radius = useSharedValue(50);\n\n  const animatedProps = useAnimatedProps(() => {\n    const path = `\n    M 100, 100\n    m -${radius.value}, 0\n    a ${radius.value},${radius.value} 0 1,0 ${radius.value * 2},0\n    a ${radius.value},${radius.value} 0 1,0 ${-radius.value * 2},0\n    `;\n    return { d: path };\n  });\n  let t0;\n  if ($[0] !== animatedProps) {\n    t0 = (\n      <Svg>\n        <AnimatedPath animatedProps={animatedProps} fill=\"black\" />\n      </Svg>\n    );\n    $[0] = animatedProps;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  isComponent: false,\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining Component and Exporting Fixture in React - JavaScript\nDESCRIPTION: This snippet defines a simple React functional component that takes props and returns an object containing two properties. It sets up an export named FIXTURE_ENTRYPOINT that includes the component function and associated parameters.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-objectexpression.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const a = 1;\n  const b = 2;\n  const x = {a: a, b: b};\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n\n```\n\n----------------------------------------\n\nTITLE: Exporting FIXTURE_ENTRYPOINT for React Component Testing\nDESCRIPTION: This code exports a FIXTURE_ENTRYPOINT object that contains the Component function, parameters, and a flag indicating it's a component. This is likely used for testing or fixture setup in the React project.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/dominator.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with Optional Chaining Error\nDESCRIPTION: This code defines a React component using the useNoAlias hook with optional chaining on nullable props. The component receives an object with a nullable value property that has x and y string properties, then attempts to use optional chaining to safely access these properties.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-optional-call-chain-in-logical-expr.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useNoAlias} from 'shared-runtime';\n\nfunction useFoo(props: {value: {x: string; y: string} | null}) {\n  const value = props.value;\n  return useNoAlias(value?.x, value?.y) ?? {};\n}\n\nexport const FIXTURE_ENTRYPONT = {\n  fn: useFoo,\n  props: [{value: null}],\n};\n```\n\n----------------------------------------\n\nTITLE: Creating a Simple React Component with String Content\nDESCRIPTION: Defines a React component 'Foo' that renders a div containing a comma character, along with an export for testing purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-jsxtext-stringliteral-distinction.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Foo() {\n  return <div> {', '}</div>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: A React component that creates and manipulates arrays with object references. The component creates two arrays, maps over one, and modifies a property on the mapped result.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-map-mutable-array-non-mutating-lambda-mutated-result.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const x = [{}];\n  const y = x.map(item => {\n    return item;\n  });\n  y[0].flag = true;\n  return [x, y];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: Original implementation of a React component that creates an array by doubling values from an items array using destructuring and loop operations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-of-destructure.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component() {\n  let x = [];\n  let items = [{v: 0}, {v: 1}, {v: 2}];\n  for (const {v} of items) {\n    x.push(v * 2);\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Function Component with Callback in React\nDESCRIPTION: This snippet defines a simple React functional component, 'Foo', which includes a callback function to track the render count. The component uses 'Stringify' from 'shared-runtime' to allow for rendering with the callback. The main purpose is to establish the structure of a React component with state management based on function invocation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/update-global-in-callback.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {Stringify} from 'shared-runtime';\n\nlet renderCount = 0;\nfunction Foo() {\n  const cb = () => {\n    renderCount += 1;\n    return renderCount;\n  };\n  return <Stringify cb={cb} shouldInvokeFns={true} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Transformed JavaScript Switch Statement with Labeled Breaks\nDESCRIPTION: A transformed version of the same switch statement function, now using labeled breaks (bb0) and empty case blocks. This transformation likely represents an intermediate state in React's compilation or optimization process.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/switch-with-fallthrough.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(x) {\n  bb0: switch (x) {\n    case 0: {\n    }\n    case 1: {\n    }\n    case 2: {\n      break bb0;\n    }\n    case 3: {\n      break bb0;\n    }\n    case 4: {\n    }\n    case 5: {\n    }\n    default: {\n    }\n  }\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a Memoized Component Function - JavaScript\nDESCRIPTION: In this snippet, a more complex React component function is defined that utilizes the '_c' function from 'react/compiler-runtime' to create a caching mechanism for the component. It checks if the cache is empty and defines a function 'x' accordingly. The final output is a potentially memoized component function which does not require any parameters or external dependencies.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/function-declaration-redeclare.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction component() {\n  const $ = _c(1);\n  let x;\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = function x() {};\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  x = t0;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled: React Compiler Memoized Implementation\nDESCRIPTION: Compiled version of the function with React Compiler's memoization logic. It uses the _c runtime function to track changes to props.a.b and props.a.c separately, only recreating the object when those values change.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/uncond-nonoverlap-direct.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // Test that we can track non-overlapping dependencies separately.\n// (not needed for correctness but for dependency granularity)\nfunction TestNonOverlappingTracked(props) {\n  const $ = _c(3);\n  let x;\n  if ($[0] !== props.a.b || $[1] !== props.a.c) {\n    x = {};\n    x.b = props.a.b;\n    x.c = props.a.c;\n    $[0] = props.a.b;\n    $[1] = props.a.c;\n    $[2] = x;\n  } else {\n    x = $[2];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: TestNonOverlappingTracked,\n  params: [{ a: { b: 2, c: 3 } }],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple React Component with useState\nDESCRIPTION: This snippet defines a basic React component using the useState hook for state management. It imports useState from React and includes a component receiving props, an initial state setup, and a simple output structure. The component takes a props object with a key 'x' and returns a JSX element displaying the current state and a computed value.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useState-unpruned-dependency.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useState} from 'react'; // @enableChangeDetectionForDebugging\n\nfunction Component(props) {\n  const w = f(props.x);\n  const [x, _] = useState(w);\n  return (\n    <div>\n      {x}\n      {w}\n    </div>\n  );\n}\n\nfunction f(x) {\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{x: 42}],\n  isComponent: true,\n};\n\n```\n\n----------------------------------------\n\nTITLE: Creating React Component with No Memo\nDESCRIPTION: A functional React component that renders a Button component with a prop value. The component explicitly opts out of memoization using the 'use no memo' directive.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/apps/playground/__tests__/e2e/__snapshots__/page.spec.ts/module-scope-use-no-memo-output.txt#2025-04-21_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\n\"use no memo\";\nexport default function TestComponent({ x }) {\n  return <Button>{x}</Button>;\n}\n```\n\n----------------------------------------\n\nTITLE: React Component without Flow Type Suppression\nDESCRIPTION: Clean version of the same React component without Flow type suppression comments, showing the base implementation of the component and fixture export.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/no-flow-bailout-unrelated.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableFlowSuppressions\n\nfunction useX() {}\n\nfunction Foo(props) {\n  useX();\n  return null;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Displaying Error in JavaScript Syntax\nDESCRIPTION: This snippet contains a JavaScript error message output during compilation, highlighting syntax issues in the React component. It emphasizes the need for supporting non-trivial 'for..of' initializations. No specific inputs or outputs are associated other than displaying diagnostic error information during development.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-for-of-loop-with-context-variable-iterator.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\n   6 |   // NOTE: `item` is a context variable because it's reassigned and also referenced\n   7 |   // within a closure, the `onClick` handler of each item\n>  8 |   for (let item of props.data) {\n     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n>  9 |     item = item ?? {}; // reassignment to force a context variable\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 10 |     items.push(\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 11 |       <div key={item.id} onClick(() => data.set(item))>\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 12 |         {item.id}\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 13 |       </div>\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 14 |     );\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 15 |   }\n     | ^^^^ Todo: Support non-trivial for..of inits (8:15)\n  16 |   return <div>{items}</div>;\n  17 | }\n  18 |\n```\n\n----------------------------------------\n\nTITLE: Debugging React Component with Fixture Export\nDESCRIPTION: A React functional component that includes multiple debugger statements for debugging purposes, along with a fixture export configuration. The component uses conditional and loop structures with embedded debugger statements. Includes an export for testing setup with TodoAdd component parameters.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/debugger.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  debugger;\n  if (props.cond) {\n    debugger;\n  } else {\n    while (props.cond) {\n      debugger;\n    }\n  }\n  debugger;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: Compiled version of the React component with added memoization logic. Includes runtime checks to prevent unnecessary re-renders and optimized state management using compiler-generated variables.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useContext-maybe-mutate-context-in-callback.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport * as React from \"react\";\nimport { useContext } from \"react\";\nimport { mutate } from \"shared-runtime\";\n\nconst FooContext = React.createContext({ current: null });\n\nfunction Component(props) {\n  const $ = _c(5);\n  const Foo = useContext(FooContext);\n  let t0;\n  if ($[0] !== Foo.current) {\n    t0 = () => {\n      mutate(Foo.current);\n    };\n    $[0] = Foo.current;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const onClick = t0;\n  let t1;\n  if ($[2] !== onClick || $[3] !== props.children) {\n    t1 = <div onClick={onClick}>{props.children}</div>;\n    $[2] = onClick;\n    $[3] = props.children;\n    $[4] = t1;\n  } else {\n    t1 = $[4];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ children: <div>Hello</div> }],\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Mutable State in React Component\nDESCRIPTION: This snippet illustrates a basic React component in JavaScript that sets up initial mutable state and modifies it via a helper function 'mutate'. It highlights the creation of a stateful variable 'x', where its mutable range is modified based on the result from another function 'foo'. No external dependencies are required beyond standard React.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-at-mutate-after-capture.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// x's mutable range should extend to `mutate(y)`\n\nfunction Component(props) {\n  let x = [42, {}];\n  const idx = foo(props.b);\n  let y = x.at(idx);\n  mutate(y);\n\n  return x;\n}\n\n```\n\n----------------------------------------\n\nTITLE: React Compiler Output for Invalid Component\nDESCRIPTION: The compiled version of the invalid component using React's compiler-runtime. It shows how React attempts to memoize the inner component through a sentinel value check, but this pattern is still invalid for component definitions.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/static-components/invalid-dynamically-constructed-component-function.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @logger @validateStaticComponents\nfunction Example(props) {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const Component = function Component() {\n      return <div />;\n    };\n\n    t0 = <Component />;\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n```\n\n----------------------------------------\n\nTITLE: Utilizing Compiler Runtime in React Component (JavaScript)\nDESCRIPTION: This snippet defines a React component using the `react/compiler-runtime` for memoization and returns an object representing component state. It checks for a memoized sentinel and conditionally sets state values. The snippet requires React's compiler runtime library and outputs cached state values based on a custom memoization mechanism.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/update-expression-constant-propagation.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = { a: 0, b: 0, c: 2, d: 2, e: 0 };\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Validating Iterator Semantics in React using JavaScript\nDESCRIPTION: This snippet demonstrates the use of React components and hooks to validate the behavior of iterators based on their mutability. It uses 'ValidateMemoization' to check for compilation-only changes. The 'useFoo' function represents a higher-order structure for managing and testing input changes while leveraging memoization as part of React's shared runtime environment.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/todo-granular-iterator-semantics.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useIdentity, ValidateMemoization} from 'shared-runtime';\n\n/**\n * Fixture for granular iterator semantics:\n * 1. ConditionallyMutate the iterator itself, depending on whether the iterator\n *    is a mutable iterator.\n * 2. Capture effect on elements within the iterator.\n */\nfunction Validate({x, input}) {\n  'use no memo';\n  return (\n    <>\n      <ValidateMemoization inputs={[]} output={x[0]} onlyCheckCompiled={true} />\n      <ValidateMemoization\n        inputs={[input]}\n        output={x[1]}\n        onlyCheckCompiled={true}\n      />\n    </>\n  );\n}\nfunction useFoo(input) {\n  'use memo';\n  /**\n   * We should be able to memoize {} separately from `x`.\n   */\n  const x = Array.from([{}]);\n  useIdentity();\n  x.push([input]);\n  return <Validate x={x} input={input} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [1],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with External Function Invocation (Input)\nDESCRIPTION: A React component that initializes a null variable, reassigns it through a closure function invoked externally, and returns the updated value. Includes test fixture configuration for sequential renders with different prop values.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/context-variable-reassigned-reactive-capture.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {invoke} from 'shared-runtime';\n\nfunction Component({value}) {\n  let x = null;\n  const reassign = () => {\n    x = value;\n  };\n  invoke(reassign);\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: 2}],\n  sequentialRenders: [{value: 2}, {value: 4}],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component with useMemo\nDESCRIPTION: React component implementing useMemo for object memoization with validation. Demonstrates memoization of two separate objects based on individual props with validation components to verify proper memoization behavior.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-provider-log.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useMemo} from 'react';\nimport {typedLog, ValidateMemoization} from 'shared-runtime';\n\nexport function Component({a, b}) {\n  const item1 = useMemo(() => ({a}), [a]);\n  const item2 = useMemo(() => ({b}), [b]);\n  typedLog(item1, item2);\n\n  return (\n    <>\n      <ValidateMemoization inputs={[a]} output={item1} />\n      <ValidateMemoization inputs={[b]} output={item2} />\n    </>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{a: 0, b: 0}],\n  sequentialRenders: [\n    {a: 0, b: 0},\n    {a: 1, b: 0},\n    {a: 1, b: 1},\n    {a: 1, b: 2},\n    {a: 2, b: 2},\n    {a: 3, b: 2},\n    {a: 0, b: 0},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a Memoized Function for React - JavaScript\nDESCRIPTION: This snippet defines a function 'foo' which accepts three parameters and memoizes a derived array based on dependencies 'b' and 'c'. It returns an object containing 'a' and the memoized array. No specific dependencies are required beyond JavaScript runtime.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/independently-memoize-object-property.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(a, b, c) {\n  const x = {a: a};\n  // NOTE: this array should memoize independently from x, w only b,c as deps\n  x.y = [b, c];\n\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: This is the compiled version of the `Component` function using the React compiler. It demonstrates memoization and optimization techniques, using `_c` for component creation and state management. The code includes checks to avoid re-rendering if the props haven't changed, improving performance by caching previous results.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-outlining-dup-key-diff-value.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enableJsxOutlining\nfunction Component(t0) {\n  const $ = _c(7);\n  const { arr } = t0;\n  const x = useX();\n  let t1;\n  if ($[0] !== arr || $[1] !== x) {\n    let t2;\n    if ($[3] !== x) {\n      t2 = (i, id) => {\n        const T0 = _temp;\n        return <T0 i={i + \"i\"} k={i + \"j\"} key={id} x={x} />;\n      };\n      $[3] = x;\n      $[4] = t2;\n    } else {\n      t2 = $[4];\n    }\n    t1 = arr.map(t2);\n    $[0] = arr;\n    $[1] = x;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  let t2;\n  if ($[5] !== t1) {\n    t2 = <>{t1}</>;\n    $[5] = t1;\n    $[6] = t2;\n  } else {\n    t2 = $[6];\n  }\n  return t2;\n}\nfunction _temp(t0) {\n  const $ = _c(8);\n  const { i: i, k: k, x: x } = t0;\n  let t1;\n  if ($[0] !== i) {\n    t1 = <Baz i={i} />;\n    $[0] = i;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  let t2;\n  if ($[2] !== k) {\n    t2 = <Foo k={k} />;\n    $[2] = k;\n    $[3] = t2;\n  } else {\n    t2 = $[3];\n  }\n  let t3;\n  if ($[4] !== t1 || $[5] !== t2 || $[6] !== x) {\n    t3 = (\n      <Bar x={x}>\n        {t1}\n        {t2}\n      </Bar>\n    );\n    $[4] = t1;\n    $[5] = t2;\n    $[6] = x;\n    $[7] = t3;\n  } else {\n    t3 = $[7];\n  }\n  return t3;\n}\n\nfunction Bar(t0) {\n  const $ = _c(3);\n  const { x, children } = t0;\n  let t1;\n  if ($[0] !== children || $[1] !== x) {\n    t1 = (\n      <>\n        {x}\n        {children}\n      </>\n    );\n    $[0] = children;\n    $[1] = x;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  return t1;\n}\n\nfunction Baz(t0) {\n  const { i } = t0;\n  return i;\n}\n\nfunction Foo(t0) {\n  const { k } = t0;\n  return k;\n}\n\nfunction useX() {\n  return \"x\";\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ arr: [\"foo\", \"bar\"] }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Using Action State in React Component (Initial Version)\nDESCRIPTION: This snippet demonstrates a functional component 'Component' that uses the 'useActionState' hook from React. It manages an action state, defining an 'onSubmitAction' function to dispatch actions. The component renders the 'Foo' component, passing the action handler as a prop. Prerequisites include the React library where 'useActionState' is defined. Expected inputs are user actions that trigger the submission, while the output is the 'Foo' component rendered with the submission handler.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useActionState-dispatch-considered-as-non-reactive.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useActionState} from 'react';\n\nfunction Component() {\n  const [actionState, dispatchAction] = useActionState();\n  const onSubmitAction = () => {\n    dispatchAction();\n  };\n  return <Foo onSubmitAction={onSubmitAction} />;\n}\n\nfunction Foo() {}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Transformed Function with Explicit Destructuring in JavaScript\nDESCRIPTION: This snippet shows a transformed version of the 'foo' function where the object destructuring is done explicitly in the function body. The 'FIXTURE_ENTRYPOINT' export remains the same.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructure-param-string-literal-key.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(t0) {\n  const { data: dataTestID } = t0;\n  return dataTestID;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [{ data: {} }],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: React Compiler Output with Memoization Transformation\nDESCRIPTION: Compiled output showing how React's compiler transforms components with 'use forget' directive. The compiler adds memoization logic using the compiler-runtime utilities and cell-based cache to avoid unnecessary re-renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/codegen-instrument-forget-test.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { shouldInstrument, useRenderCounter } from \"react-compiler-runtime\";\nimport { c as _c } from \"react/compiler-runtime\"; // @enableEmitInstrumentForget @compilationMode(annotation)\n\nfunction Bar(props) {\n  \"use forget\";\n  if (DEV && shouldInstrument)\n    useRenderCounter(\"Bar\", \"/codegen-instrument-forget-test.ts\");\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== props.bar) {\n    t0 = <div>{props.bar}</div>;\n    $[0] = props.bar;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\nfunction NoForget(props) {\n  return <Bar>{props.noForget}</Bar>;\n}\n\nfunction Foo(props) {\n  \"use forget\";\n  if (DEV && shouldInstrument)\n    useRenderCounter(\"Foo\", \"/codegen-instrument-forget-test.ts\");\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== props.bar) {\n    t0 = <Foo>{props.bar}</Foo>;\n    $[0] = props.bar;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n```\n\n----------------------------------------\n\nTITLE: Transformed React Component Implementation\nDESCRIPTION: Shows how React transforms the component by extracting nested functions into separate named functions, hoisting them, and replacing closure variables with direct values for better performance and optimization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rewrite-phis-in-lambda-capture-context.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component() {\n  const get4 = _temp2;\n  return get4;\n}\nfunction _temp2() {\n  while (bar()) {\n    if (baz) {\n      bar();\n    }\n  }\n  return _temp;\n}\nfunction _temp() {\n  return 4;\n}\n```\n\n----------------------------------------\n\nTITLE: Input: React Component with UseMemo\nDESCRIPTION: Original React component using useMemo to memoize an array based on a prop\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-simple-preserved.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enablePreserveExistingManualUseMemo\nimport {useMemo} from 'react';\n\nfunction Component({a}) {\n  let x = useMemo(() => [a], []);\n  return <div>{x}</div>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{a: 42}],\n  isComponent: true,\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Transformed Test Function with Infinite Loop in JavaScript\nDESCRIPTION: A transformed version of the 'foo' function that creates an explicit infinite loop using a constant variable and true condition. This version is likely the result of an optimization or transformation process.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-for-trivial-update.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo() {\n  let x = 1;\n  for (const i = 0; true; 0) {\n    x = x + 1;\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Building Dependencies from Source for React DevTools\nDESCRIPTION: Command to build the required dependencies from source for React DevTools development, executed from the repository root.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools-extensions/README.md#2025-04-21_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nyarn build-for-devtools\n```\n\n----------------------------------------\n\nTITLE: Original React Component with Potential Performance Issues\nDESCRIPTION: A React function component that computes values which could be memoized for better performance. It creates a variable 'a' from foo() and a variable 'b' that depends on props and 'a'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/computed-load-primitive-as-dependency.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let a = foo();\n  // freeze `a` so we know the next line cannot mutate it\n  <div>{a}</div>;\n\n  // b should be dependent on `props.a`\n  let b = bar(a[props.a] + 1);\n  return b;\n}\n```\n\n----------------------------------------\n\nTITLE: Original React Hook Implementation\nDESCRIPTION: Simple React hook function that conditionally sets a variable based on props and returns it. Shows nested conditional logic without memoization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/assignment-in-nested-if.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction useBar(props) {\n  let z;\n\n  if (props.a) {\n    if (props.b) {\n      z = baz();\n    }\n  }\n\n  return z;\n}\n```\n\n----------------------------------------\n\nTITLE: Compiler-Optimized React Component\nDESCRIPTION: Compiler-transformed version of the component with optimized memoization logic. Uses compiler-runtime helpers to implement caching and dependency tracking for better performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(7);\n  const item = props.item;\n  let baseVideos;\n  let t0;\n  let thumbnails;\n  if ($[0] !== item) {\n    thumbnails = [];\n    baseVideos = getBaseVideos(item);\n\n    baseVideos.forEach((video) => {\n      const baseVideo = video.hasBaseVideo;\n      if (Boolean(baseVideo)) {\n        thumbnails.push({ extraVideo: true });\n      }\n    });\n    $[0] = item;\n    $[1] = baseVideos;\n    $[2] = t0;\n    $[3] = thumbnails;\n  } else {\n    baseVideos = $[1];\n    t0 = $[2];\n    thumbnails = $[3];\n  }\n  t0 = undefined;\n  let t1;\n  if ($[4] !== baseVideos || $[5] !== thumbnails) {\n    t1 = <FlatList baseVideos={baseVideos} items={thumbnails} />;\n    $[4] = baseVideos;\n    $[5] = thumbnails;\n    $[6] = t1;\n  } else {\n    t1 = $[6];\n  }\n  return t1;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Component with Conditional Logic - JavaScript\nDESCRIPTION: This snippet defines a React functional component that utilizes props to determine how to construct its state. It uses a switch-case statement to manage different scenarios based on props. The component recursively renders itself based on derived state values from props.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/switch-non-final-default.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enablePropagateDepsInHIR\nfunction Component(props) {\n  let x = [];\n  let y;\n  switch (props.p0) {\n    case 1: {\n      break;\n    }\n    case true: {\n      x.push(props.p2);\n      y = [];\n    }\n    default: {\n      break;\n    }\n    case false: {\n      y = x;\n      break;\n    }\n  }\n  const child = <Component data={x} />;\n  y.push(props.p4);\n  return <Component data={y}>{child}</Component>;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Flow-typed React Component Input\nDESCRIPTION: Original React component implementation with Flow type annotations. Takes a props object with numeric id, processes it through makeArray utility, and returns the first element.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-annotations/type-annotation-as-array_.flow.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @flow @enableUseTypeAnnotations\nimport {identity, makeArray} from 'shared-runtime';\n\nfunction Component(props: {id: number}) {\n  const x = (makeArray(props.id): Array<number>);\n  const y = x.at(0);\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{id: 42}],\n};\n```\n\n----------------------------------------\n\nTITLE: Flow-Typed React Component Input\nDESCRIPTION: Original React component implementation with Flow type annotations. Defines a User type and creates an object based on props.name.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-alias.flow.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @flow\nfunction Component(props) {\n  type User = {name: string};\n  const user: User = {name: props.name};\n  return user;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{name: 'Mofei'}],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized Component with Memoization\nDESCRIPTION: This code snippet optimizes a React component by using memoization to avoid unnecessary calculations. It checks previous props and states, only updating when there's a change. It utilizes the internal state `$` to hold previous values, ensuring efficiency in rendering data and computing the count.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactivity-analysis-reactive-via-mutation-of-computed-load.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(8);\n  let items;\n  if ($[0] !== props.a || $[1] !== props.key) {\n    items = bar();\n    mutate(items[props.key], props.a);\n    $[0] = props.a;\n    $[1] = props.key;\n    $[2] = items;\n  } else {\n    items = $[2];\n  }\n\n  const t0 = items.length + 1;\n  let t1;\n  if ($[3] !== t0) {\n    t1 = foo(t0);\n    $[3] = t0;\n    $[4] = t1;\n  } else {\n    t1 = $[4];\n  }\n  const count = t1;\n  let t2;\n  if ($[5] !== count || $[6] !== items) {\n    t2 = { items, count };\n    $[5] = count;\n    $[6] = items;\n    $[7] = t2;\n  } else {\n    t2 = $[7];\n  }\n  return t2;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: Input source code showing a React component with a custom hook useFoo that manages tab state and renders conditional text.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/constant-propagate-global-phis.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {CONST_STRING0, CONST_STRING1, Text} from 'shared-runtime';\n\nfunction useFoo() {\n  'use no forget';\n  return {tab: CONST_STRING1};\n}\n\nfunction Test() {\n  const {tab} = useFoo();\n  const currentTab = tab === CONST_STRING0 ? CONST_STRING0 : CONST_STRING1;\n\n  return <Text value={currentTab} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Test,\n  params: [],\n  isComponent: true,\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized Functional Component Implementation in React - JavaScript\nDESCRIPTION: This snippet shows the optimized version of the same Component which utilizes an internal memoization technique using '_c' to store previous values of props to avoid unnecessary re-renders. The same structures, types, and component functionalities are preserved with added performance enhancements through memoization. The Component receives an 'items' prop, and it renders the Foo, Bar, and Item components similarly while checking and optimizing rendering logic based on previous values.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-attribute-with-jsx-element-value.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(t0) {\n  const $ = _c(2);\n  const { items } = t0;\n  let t1;\n  if ($[0] !== items) {\n    t1 =\n      items.length > 0 ? <Foo value={<Bar>{items.map(_temp)}</Bar>} /> : null;\n    $[0] = items;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\nfunction _temp(item) {\n  return <Item key={item.id} item={item} />;\n}\n\nfunction Foo(t0) {\n  const { value } = t0;\n  return value;\n}\n\nfunction Bar(t0) {\n  const $ = _c(2);\n  const { children } = t0;\n  let t1;\n  if ($[0] !== children) {\n    t1 = <div>{children}</div>;\n    $[0] = children;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n\nfunction Item(t0) {\n  const $ = _c(2);\n  const { item } = t0;\n  let t1;\n  if ($[0] !== item.name) {\n    t1 = <div>{item.name}</div>;\n    $[0] = item.name;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ items: [{ id: 1, name: \"One!\" }] }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: This snippet represents the compiled version of the React component, demonstrating the compiler's optimization of `useMemo`. It replaces `useMemo` with inline checks and state updates to avoid unnecessary recalculations.  The compiler generates optimized code using the `_c` function from `react/compiler-runtime` to manage memoized values and conditional rendering based on dependency changes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/optional-member-expression-single.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @validatePreserveExistingMemoizationGuarantees @enableOptionalDependencies @enablePropagateDepsInHIR\nimport { ValidateMemoization } from \"shared-runtime\";\nimport { useMemo } from \"react\";\nfunction Component(t0) {\n  const $ = _c(7);\n  const { arg } = t0;\n\n  arg?.items;\n  let t1;\n  let x;\n  if ($[0] !== arg?.items) {\n    x = [];\n    x.push(arg?.items);\n    $[0] = arg?.items;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  t1 = x;\n  const data = t1;\n  const t2 = arg?.items;\n  let t3;\n  if ($[2] !== t2) {\n    t3 = [t2];\n    $[2] = t2;\n    $[3] = t3;\n  } else {\n    t3 = $[3];\n  }\n  let t4;\n  if ($[4] !== data || $[5] !== t3) {\n    t4 = <ValidateMemoization inputs={t3} output={data} />;\n    $[4] = data;\n    $[5] = t3;\n    $[6] = t4;\n  } else {\n    t4 = $[6];\n  }\n  return t4;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ arg: { items: 2 } }],\n  sequentialRenders: [\n    { arg: { items: 2 } },\n    { arg: { items: 2 } },\n    { arg: null },\n    { arg: null },\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Compiler Error for Memoization Preservation Issue\nDESCRIPTION: This is the error output from React Compiler when processing the above code. It shows that the compiler has skipped optimizing the component because it cannot preserve the manual memoization, as the 'x' dependency may be mutated later.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.false-positive-useMemo-overlap-scopes.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n  21 |   const result = useMemo(() => {\n  22 |     return [Math.max(x[1], a)];\n> 23 |   }, [a, x]);\n     |          ^ CannotPreserveMemoization: React Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. This dependency may be mutated later, which could cause the value to change unexpectedly (23:23)\n  24 |   arrayPush(y, 3);\n  25 |   return {result, y};\n  26 | }\n```\n\n----------------------------------------\n\nTITLE: Optimized React Hook with Compiler Runtime and Mutation\nDESCRIPTION: This code snippet represents an optimized version of the `useFoo` React hook using `react/compiler-runtime` for memoization and `shared-runtime` for mutation.  The hook conditionally updates the value of `x` based on whether the props have changed, using a memoized array `$`. This approach aims to prevent unnecessary re-renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-renaming-unconditional-with-mutation.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { mutate } from \"shared-runtime\";\n\nfunction useFoo(props) {\n  const $ = _c(4);\n  let x;\n  if ($[0] !== props.bar || $[1] !== props.cond || $[2] !== props.foo) {\n    x = [];\n    x.push(props.bar);\n    if (props.cond) {\n      x = [];\n      x.push(props.foo);\n    } else {\n      x = [];\n      x.push(props.bar);\n    }\n\n    mutate(x);\n    $[0] = props.bar;\n    $[1] = props.cond;\n    $[2] = props.foo;\n    $[3] = x;\n  } else {\n    x = $[3];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ bar: \"bar\", foo: \"foo\", cond: true }],\n  sequentialRenders: [\n    { bar: \"bar\", foo: \"foo\", cond: true },\n    { bar: \"bar\", foo: \"foo\", cond: true },\n    { bar: \"bar\", foo: \"foo\", cond: false },\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Initial Input Function with Object Property Access\nDESCRIPTION: JavaScript function demonstrating object property access and dependency tracking in nested objects\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/uncond-subpath-order3.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction TestDepsSubpathOrder3(props) {\n  let x = {};\n  x.c = props.a.b.c;\n  x.a = props.a;\n  x.b = props.a.b;\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Calculating Sum from Queue - JavaScript (Alternative)\nDESCRIPTION: This snippet is an alternative implementation of the same Component function that also calculates the sum of an array. It uses a different way to add the popped values to the sum, illustrating minor variations in syntax.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/while-with-assignment-in-test.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component() {\n  const queue = [1, 2, 3];\n  let value;\n  let sum = 0;\n  while ((value = queue.pop()) != null) {\n    sum = sum + value;\n  }\n  return sum;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with Array and Math.max\nDESCRIPTION: This snippet defines a React component that uses the `makeArray` function to create an array, pushes a value onto it using `push`, and calculates the maximum value among several numbers, including elements from another array using the spread operator.  The component returns the calculated maximum value. It depends on the `makeArray` function and highlights an error during code generation related to the inline usage of `push` with `Math.max`.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-nested-method-calls-lower-property-load-into-temporary.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {makeArray} from 'shared-runtime';\n\nconst other = [0, 1];\nfunction Component({}) {\n  const items = makeArray(0, 1, 2, null, 4, false, 6);\n  const max = Math.max(2, items.push(5), ...other);\n  return max;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}]\n};\n```\n\n----------------------------------------\n\nTITLE: React Component Rendering\nDESCRIPTION: This React component takes `props` as input, specifically expecting an `items` property that is potentially nullable. It maps over the `items` array using a `render` function, filters out falsy values, and returns the resulting array. If `props` or `items` are null/undefined, it returns an empty array.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-call-with-optional-property-load.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  return props?.items?.map?.(render)?.filter(Boolean) ?? [];\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Input React Component in JavaScript\nDESCRIPTION: This snippet shows the original React component with a mutable variable 'a' and an array operation. It demonstrates the basic structure before optimization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/alias-capture-in-method-receiver.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component() {\n  // a's mutable range should be limited\n  // the following line\n  let a = someObj();\n\n  let x = [];\n  x.push(a);\n\n  return [x, a];\n}\n```\n\n----------------------------------------\n\nTITLE: React Component with Error Handling\nDESCRIPTION: Implementation of a React component with try-catch block handling potential errors. Returns either a constant value 42 or falls back to the default prop value if an error occurs.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-try-immediately-returns.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let x = props.default;\n  try {\n    // note: has to be a primitive, we want an instruction that cannot throw\n    // to ensure there is no maybe-throw terminal\n    const y = 42;\n    return y;\n  } catch (e) {\n    x = e;\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{default: 42}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Mutable Range Example\nDESCRIPTION: This snippet defines a React component function that handles props and returns an object. It includes comments about mutable range issues and potential aliasing problems.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/logical-expression-object.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component(props) {\n  // The mutable range for a extens the entire body.\n  // commenting out the last line of InferMutableRanges fixes it.\n  // my guess of what's going on is that a is aliased into the return value object literal,\n  // and that alias makes it look like the range of a needs to be extended to that point.\n  // but what's weird is that the end of a's range doesn't quite extend to the object.\n  let a = props.a || (props.b && props.c && props.d);\n  let b = (props.a && props.b && props.c) || props.d;\n  return {a, b};\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Input: Conditional Switch Statement Dependency Management\nDESCRIPTION: Function demonstrating handling of conditional dependencies in a switch statement using identity and props access\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/cfg-switch-missing-default.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction useCondDepInSwitchMissingDefault(props, other) {\n  const x = {};\n  switch (identity(other)) {\n    case 1:\n      x.a = props.a.b;\n      break;\n    case 2:\n      x.b = props.a.b;\n      break;\n  }\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Error Handling in Fire Function Invocation\nDESCRIPTION: This snippet illustrates the error encountered when the fire function is called with multiple arguments instead of a single expression. This highlights potential pitfalls in usage, providing insight into the expected input format for the fire method.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/error.invalid-multiple-args.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n   7 |   };\n   8 |   useEffect(() => {\n>  9 |     fire(foo(bar), baz);\n     |     ^^^^^^^^^^^^^^^^^^^ InvalidReact: Cannot compile `fire`. fire() can only take in a single call expression as an argument but received multiple arguments (9:9)\n  10 |   });\n  11 |\n  12 |   return null;\n\n```\n\n----------------------------------------\n\nTITLE: Original Component Implementation\nDESCRIPTION: Simple React component that creates an object with a property and returns its value. This represents the code before compiler optimization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-field-load.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component() {\n  let x = {t: 1};\n  let p = x.t;\n  return p;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Dynamic Components with JSX in JavaScript\nDESCRIPTION: This code defines a functional React component 'Component' that takes an array as a prop and dynamically renders child components 'Bar', 'Foo', and 'Baz' based on the array contents. The 'useX' function provides a constant 'x' which is used in the rendering process. It also implements optimized rendering with memoization practices.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-outlining-dupe-attr-after-rename.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableJsxOutlining\nfunction Component({arr}) {\n  const x = useX();\n  return (\n    <>\n      {arr.map((i, id) => {\n        return (\n          <Bar key={id} x={x}>\n            <Foo k={i + 'i'}></Foo>\n            <Foo k={i + 'j'}></Foo>\n            <Baz k1={i + 'j'}></Baz>\n          </Bar>\n        );\n      })}\n    </>\n  );\n}\nfunction Bar({x, children}) {\n  return (\n    <>\n      {x}\n      {children}\n    </>\n  );\n}\n\nfunction Baz({k1}) {\n  return k1;\n}\n\nfunction Foo({k}) {\n  return k;\n}\n\nfunction useX() {\n  return 'x';\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{arr: ['foo', 'bar']}],\n};\n```\n\n----------------------------------------\n\nTITLE: Publish Stable Release Script\nDESCRIPTION: This script publishes a stable release to NPM, typically using the `latest` tag. It can optionally also include the `next` tag, allowing the current release to be available under both. This script follows the preparation of the release using `prepare-release-from-npm`.\nSOURCE: https://github.com/facebook/react/blob/main/scripts/release/README.md#2025-04-21_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\nscripts/release/publish.js --tags latest\n```\n\nLANGUAGE: shell\nCODE:\n```\nscripts/release/publish.js --tags latest next\n```\n\n----------------------------------------\n\nTITLE: Reinstalling Dependencies After React Changes\nDESCRIPTION: Command to reinstall dependencies after making changes to React and rebuilding it. This ensures the Fizz fixtures use the updated React build.\nSOURCE: https://github.com/facebook/react/blob/main/fixtures/fizz/README.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nyarn\n```\n\n----------------------------------------\n\nTITLE: Component Initialization with Optional Chaining in JavaScript\nDESCRIPTION: A simple React component that utilizes JavaScript's optional chaining to safely access nested object properties based on dynamic key access through props. The function takes 'props' as input and initializes an object 'x' using the 'makeObject' function, returning a deeply nested property if it exists.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-member-expression-with-optional-member-expr-as-property.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const x = makeObject();\n  return x.y?.[props.a?.[props.b?.[props.c]]];\n}\n\n```\n\n----------------------------------------\n\nTITLE: Exporting Fixture Entrypoint for React Component Testing in JavaScript\nDESCRIPTION: This snippet exports a constant FIXTURE_ENTRYPOINT object that defines a test fixture for the component. It includes the component function, parameters, and specifies the component name for testing purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/logical-expression.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Input: Testing Non-Overlapping Dependency Tracking in React\nDESCRIPTION: Original function that creates an object with properties from props.a. This tests React Compiler's ability to separately track non-overlapping dependencies for better granularity.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/uncond-nonoverlap-direct.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Test that we can track non-overlapping dependencies separately.\n// (not needed for correctness but for dependency granularity)\nfunction TestNonOverlappingTracked(props) {\n  let x = {};\n  x.b = props.a.b;\n  x.c = props.a.c;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: TestNonOverlappingTracked,\n  params: [{a: {b: 2, c: 3}}],\n};\n```\n\n----------------------------------------\n\nTITLE: Error during Code Generation\nDESCRIPTION: This snippet demonstrates an error encountered during code generation.  The error arises when attempting to use the return value of `items.push(5)` directly within the arguments of `Math.max`. The error message indicates that the `property` of `MethodCall` must be an unpromoted, unmemoized MemberExpression.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-nested-method-calls-lower-property-load-into-temporary.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n  4 | function Component({}) {\n  5 |   const items = makeArray(0, 1, 2, null, 4, false, 6);\n> 6 |   const max = Math.max(2, items.push(5), ...other);\n    |               ^^^^^^^^ Invariant: [Codegen] Internal error: MethodCall::property must be an unpromoted + unmemoized MemberExpression. Got a `Identifier` (6:6)\n  7 |   return max;\n  8 | }\n  9 |\n```\n\n----------------------------------------\n\nTITLE: Implementing a React Component with Array Manipulation\nDESCRIPTION: This snippet defines a React component that performs array manipulation based on props. It uses a do-while loop to process an array and create a new array with modified values.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/do-while-compound-test.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let x = [1, 2, 3];\n  let ret = [];\n  do {\n    let item = x.pop();\n    ret.push(item * 2);\n  } while (x.length && props.cond);\n  return ret;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Installing Project Dependencies\nDESCRIPTION: Install the necessary dependencies for the React project using Yarn.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/CONTRIBUTING.md#2025-04-21_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\ncd <react-repo>\nyarn install\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: Compiler-transformed version of the component using memoization cache sentinel to optimize repeated renders. Uses react/compiler-runtime for caching mechanism.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-of-mutate-item-of-local-collection.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { makeObject_Primitives } from \"shared-runtime\";\n\nfunction Component(props) {\n  const $ = _c(1);\n  let items;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    items = [makeObject_Primitives(), makeObject_Primitives()];\n    for (const x of items) {\n      x.a = x.a + 1;\n    }\n    $[0] = items;\n  } else {\n    items = $[0];\n  }\n  return items;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n  sequentialRenders: [{}, {}, {}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Component and Exporting Fixture Entry Point - JavaScript\nDESCRIPTION: This snippet defines a React component named 'Component' that retrieves a number from a shared runtime module and returns it. It also exports a constant 'FIXTURE_ENTRYPOINT' that holds the component along with parameters for testing or demonstration purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-types-through-type-cast.flow.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @flow\nimport {getNumber} from 'shared-runtime';\n\nfunction Component(props) {\n  // We can infer that `x` is a primitive bc it is aliased to `y`,\n  // which is used in a binary expression\n  const x = getNumber();\n  const y = (x: any);\n  y + 1;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n  isComponent: false,\n};\n\n```\n\n----------------------------------------\n\nTITLE: React Component with Compiler Runtime\nDESCRIPTION: This snippet shows an optimized React component using the `react/compiler-runtime`.  It uses `_c` to create a memoized value for `makeObject(props)`. The compiler ensures that `makeObject` is only called when `props` changes, optimizing performance.  The component still returns a value from the object based on `props.key`.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-computed-member-expression.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== props) {\n    t0 = makeObject(props);\n    $[0] = props;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const object = t0;\n  return object?.[props.key];\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled React Hook with Memoization\nDESCRIPTION: The compiled version of the useTest hook showing React's internal memoization implementation using Symbol.for('react.memo_cache_sentinel'). Includes optimization and caching logic.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/codegen-inline-iife-reassign.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { makeArray, print } from \"shared-runtime\";\n\nfunction useTest() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    let w;\n    w = {};\n\n    const t1 = (w = 42);\n    const t2 = w;\n    let t3;\n\n    w = 999;\n    t3 = 2;\n    t0 = makeArray(t1, t2, t3);\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useTest,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized Implementation of Custom React Hook\nDESCRIPTION: This snippet shows an optimized version of the 'useFoo' hook. It uses destructuring for parameters and simplifies the function structure. The functionality remains the same as the original implementation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/global-types/set-for-of-iterate-values.expect.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { makeArray, useHook } from \"shared-runtime\";\n\nfunction useFoo(t0) {\n  const { propArr } = t0;\n  const s1 = new Set([1, 2, 3]);\n  s1.add(makeArray(propArr[0]));\n\n  useHook();\n  const s2 = new Set();\n  for (const el of s1.values()) {\n    s2.add(el);\n  }\n  return [s1, s2];\n}\n```\n\n----------------------------------------\n\nTITLE: Original JavaScript Function\nDESCRIPTION: This snippet presents the original JavaScript function `foo`. It initializes three objects (a, b, c), reassigns them in a circular fashion (a = b; b = c; c = a), then calls `mutate` with `a` and `b`. Finally, it returns `c`. The purpose is to illustrate a scenario where the React compiler might apply optimizations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/simple-alias.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction mutate() {}\nfunction foo() {\n  let a = {};\n  let b = {};\n  let c = {};\n  a = b;\n  b = c;\n  c = a;\n  mutate(a, b);\n  return c;\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled React Function Component\nDESCRIPTION: Compiled version of the React component showing how the compiler transforms nested functions using React's compiler runtime. It implements caching logic using Symbol.for() and handles default parameters differently.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/deeply-nested-function-expressions-with-params.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Foo() {\n  const $ = _c(1);\n  let t0;\n  let t1;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = function a(t2) {\n      const x_0 = t2 === undefined ? _temp : t2;\n      return (function b(t3) {\n        const y_0 = t3 === undefined ? [] : t3;\n        return [x_0, y_0];\n      })();\n    };\n    $[0] = t1;\n  } else {\n    t1 = $[0];\n  }\n  t0 = t1;\n  return t0;\n}\nfunction _temp() {}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Conditional Property Handling - JavaScript\nDESCRIPTION: This snippet defines a more complex version of the `Foo` component, leveraging a caching mechanism for props. It uses the `react/compiler-runtime` library's `_c` function to check if the current props differ from previous ones and conditionally extracts properties. The `FIXTURE_ENTRYPOINT` remains similar, serving the same purpose of component identification.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unused-object-element-with-rest.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Foo(props) {\n  const $ = _c(2);\n  let rest;\n  if ($[0] !== props.a) {\n    const { unused, ...t0 } = props.a;\n    rest = t0;\n    $[0] = props.a;\n    $[1] = rest;\n  } else {\n    rest = $[1];\n  }\n  return rest;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n\n```\n\n----------------------------------------\n\nTITLE: Port Forwarding for React Native Debugging\nDESCRIPTION: ADB command to forward the TCP port used by React DevTools when debugging on a physical device. This enables communication between the DevTools application and React Native running on a device.\nSOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/README.md#2025-04-21_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nadb reverse tcp:8097 tcp:8097\n```\n\n----------------------------------------\n\nTITLE: Simplified React Component Handler\nDESCRIPTION: Shows a simplified version of the handler function with minimal conditional logic. Exports the same fixture configuration structure but with a more straightforward implementation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/constant-propagation-phi.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(a, b, c) {\n  if (a) {\n  }\n  return b;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: React Component Error Message\nDESCRIPTION: This snippet shows the error message generated when attempting to use the incorrect React component. It highlights the specific line where the error occurs and provides an explanation of why this approach violates React's rules for pure components and hooks.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-destructure-to-local-global-variables.expect.md#2025-04-22_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n  1 | function Component(props) {\n  2 |   let a;\n> 3 |   [a, b] = props.value;\n    |       ^ InvalidReact: Unexpected reassignment of a variable which was defined outside of the component. Components and hooks should be pure and side-effect free, but variable reassignment is a form of side-effect. If this variable is used in rendering, use useState instead. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#side-effects-must-run-outside-of-render) (3:3)\n  4 |\n  5 |   return [a, b];\n  6 | }\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Runtime Optimizations\nDESCRIPTION: The compiled version of the component using React compiler runtime with memoization optimization. Includes Symbol-based cache checking for improved performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/meta-isms/repro-cx-namespace-nesting.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { makeArray } from \"shared-runtime\";\n\nfunction Component() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const items = makeArray(\"foo\", \"bar\", \"\", null, \"baz\", false, \"merp\");\n    const classname = cx.namespace(...items.filter(isNonEmptyString));\n    t0 = <div className={classname}>Ok</div>;\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nfunction isNonEmptyString(s) {\n  return typeof s === \"string\" && s.trim().length !== 0;\n}\n\nconst cx = {\n  namespace(...items) {\n    return items.join(\" \");\n  },\n};\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Error Handling in React Hook Usage\nDESCRIPTION: The snippet includes an error message indicating that the React reference's current property cannot be accessed during the render phase of the useFoo hook. This is a critical limitation that developers need to address when working with useRef and useMemo to ensure proper component functionality without violating React's rules.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.maybe-mutable-ref-not-preserved.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n```\n   6 | function useFoo() {\n   7 |   const r = useRef();\n>  8 |   return useMemo(() => makeArray(r), []);\n     |                                  ^ InvalidReact: Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef) (8:8)\n   9 | }\n  10 |\n  11 | export const FIXTURE_ENTRYPOINT = {\n```\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Runtime Optimizations\nDESCRIPTION: Compiler-transformed version of the component with React runtime optimizations. Includes memoization logic using Symbol sentinels and block-scoped error handling with labeled breaks.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-with-catch-param.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nconst { throwInput } = require(\"shared-runtime\");\n\nfunction Component(props) {\n  const $ = _c(2);\n  let t0;\n  let x;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = Symbol.for(\"react.early_return_sentinel\");\n    bb0: {\n      x = [];\n      try {\n        throwInput(x);\n      } catch (t1) {\n        const e = t1;\n        e.push(null);\n        t0 = e;\n        break bb0;\n      }\n    }\n    $[0] = t0;\n    $[1] = x;\n  } else {\n    t0 = $[0];\n    x = $[1];\n  }\n  if (t0 !== Symbol.for(\"react.early_return_sentinel\")) {\n    return t0;\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component Definition\nDESCRIPTION: Defines a React component that accesses nested properties of the `props.a` object. It pushes values from `props.a?.b` and `props.a.b.c` into an array and returns it. This code snippet serves as the original component before Forget optimization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/memberexpr-join-optional-chain.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// To preserve the nullthrows behavior and reactive deps of this code,\n// Forget needs to add `props.a.b` or a subpath as a dependency.\n//\n// (1) Since the reactive block producing x unconditionally read props.a.<...>,\n//     reading `props.a.b` outside of the block would still preserve nullthrows\n//     semantics of source code\n// (2) Technically, props.a, props.a.b, and props.a.b.c are all reactive deps.\n//     However, `props.a?.b` is only dependent on whether `props.a` is nullish,\n//     not its actual value. Since we already preserve nullthrows on `props.a`,\n//     we technically do not need to add `props.a` as a dependency.\n\nfunction Component(props) {\n  let x = [];\n  x.push(props.a?.b);\n  x.push(props.a.b.c);\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{a: {b: {c: 1}}}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Implementing React Component with Generator in useMemo\nDESCRIPTION: This code snippet defines a React component that attempts to use a generator function within a useMemo hook. The purpose is to yield a value, but this is not currently supported and leads to an error.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.useMemo-callback-generator.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component(a, b) {\n  // we don't handle generators at all so this test isn't\n  // useful for now, but adding this test in case we do\n  // add support for generators in the future.\n  let x = useMemo(function* () {\n    yield a;\n  }, []);\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining and Using a Hook in JavaScript\nDESCRIPTION: This snippet imports a constant, defines a function `useHook` that logs messages based on a boolean condition, and exports a constant object representing the fixture entry point. It relies on the `shared-runtime` for the `CONST_STRING0` constant. The function returns an array of log messages depending on the condition provided as input.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/labeled-break-within-label-switch.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {CONST_STRING0} from 'shared-runtime';\n\nfunction useHook(cond) {\n  const log = [];\n  switch (CONST_STRING0) {\n    case CONST_STRING0:\n      log.push(`@A`);\n      bb0: {\n        if (cond) {\n          break bb0;\n        }\n        log.push(`@B`);\n      }\n      log.push(`@C`);\n  }\n  return log;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useHook,\n  params: [true],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Input: Defining a Conditional Component with TypeScript in React\nDESCRIPTION: The original component definition using TypeScript with conditional type narrowing. It manipulates an object with a discriminated union type (HasA | HasC) and performs conditional rendering based on a boolean prop.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/hoist-deps-diff-ssa-instance1.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {identity, shallowCopy, Stringify, useIdentity} from 'shared-runtime';\n\ntype HasA = {kind: 'hasA'; a: {value: number}};\ntype HasC = {kind: 'hasC'; c: {value: number}};\nfunction Foo({cond}: {cond: boolean}) {\n  let x: HasA | HasC = shallowCopy({kind: 'hasA', a: {value: 2}});\n  /**\n   * This read of x.a.value is outside of x's identifier mutable\n   * range + scope range. We mark this ssa instance (x_@0) as having\n   * a non-null object property `x.a`.\n   */\n  Math.max(x.a.value, 2);\n  if (cond) {\n    x = shallowCopy({kind: 'hasC', c: {value: 3}});\n  }\n\n  /**\n   * Since this x (x_@2 = phi(x_@0, x_@1)) is a different ssa instance,\n   * we cannot safely hoist a read of `x.a.value`\n   */\n  return <Stringify val={!cond && [(x as HasA).a.value + 2]} />;\n}\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{cond: false}],\n  sequentialRenders: [{cond: false}, {cond: true}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization in JavaScript\nDESCRIPTION: This snippet shows the compiled version of the React component 'Test'. It implements memoization using a custom compiler runtime from React. The component uses a Symbol-based cache sentinel for optimization.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ts-instantiation-expression.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { identity, invoke } from \"shared-runtime\";\n\nfunction Test() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = invoke(identity, \"test\");\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const str = t0;\n  return str;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Test,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component with Context Access\nDESCRIPTION: Simple React component that accesses multiple values from the same context using separate useContext calls.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/lower-context-acess-multiple.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @lowerContextAccess\nfunction App() {\n  const {foo} = useContext(MyContext);\n  const {bar} = useContext(MyContext);\n  return <Bar foo={foo} bar={bar} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Console Logging and Object Mutation\nDESCRIPTION: This is the compiled version of the React component. It uses React's compiler runtime and implements caching logic. The component achieves the same functionality as the input version but with optimized and transformed code.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/computed-call-evaluation-order.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // Should print A, B, arg, original\nfunction Component() {\n  const $ = _c(1);\n  const changeF = _temp2;\n  let x;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    x = { f: _temp3 };\n\n    (console.log(\"A\"), x)[(console.log(\"B\"), \"f\")](\n      (changeF(x), console.log(\"arg\"), 1),\n    );\n    $[0] = x;\n  } else {\n    x = $[0];\n  }\n  return x;\n}\nfunction _temp3() {\n  return console.log(\"original\");\n}\nfunction _temp2(o) {\n  o.f = _temp;\n}\nfunction _temp() {\n  return console.log(\"new\");\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Defining useFoo function and fixture entrypoint in React\nDESCRIPTION: This code defines a `useFoo` function that takes an input object and conditional flags as arguments. It conditionally pushes the result of `identity(input.a.b)` to an array based on the values of `cond1` and `cond2`.  It also exports a `FIXTURE_ENTRYPOINT` object that contains test data for the function, including parameters and expected sequential renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-unpoisoned/reduce-if-exhaustive-nonpoisoned-deps1.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {identity} from 'shared-runtime';\n\nfunction useFoo({input, cond2, cond1}) {\n  const x = [];\n  if (cond1) {\n    if (!cond2) {\n      x.push(identity(input.a.b));\n      return null;\n    } else {\n      x.push(identity(input.a.b));\n    }\n  } else {\n    x.push(identity(input.a.b));\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{input: {b: 1}, cond1: true, cond2: false}],\n  sequentialRenders: [\n    {input: {a: {b: 1}}, cond1: true, cond2: true},\n    {input: null, cond1: true, cond2: false},\n    // preserve nullthrows\n    {input: {a: {b: undefined}}, cond1: true, cond2: true},\n    {input: {a: null}, cond1: true, cond2: true},\n    {input: {a: {b: undefined}}, cond1: true, cond2: true},\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple React Component in JavaScript\nDESCRIPTION: This snippet defines a simple React component named 'Component' that takes props as an argument and returns an array consisting of the props and a mutated value from a MaybeMutable instance. The function illustrates basic component creation and interaction in React.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/temporary-accessed-outside-scope.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const maybeMutable = new MaybeMutable();\n  let x = props;\n  return [x, maybeMutate(maybeMutable)];\n}\n\n```\n\n----------------------------------------\n\nTITLE: React Component with Compiled Memoization\nDESCRIPTION: Implements a React functional component using React Compiler runtime with automatic memoization and cache management using compiler runtime symbols\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ref-like-name-in-effect.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Foo() {\n  const ref = useCustomRef();\n\n  useEffect(() => {\n    ref.current?.click();\n  }, []);\n\n  return <div>foo</div>;\n}\n```\n\n----------------------------------------\n\nTITLE: Original Implementation of useMakeCallback Hook with JSX\nDESCRIPTION: A React hook that creates a callback function to update state based on an object's value property. The callback is passed to a Stringify component with a flag to invoke functions.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/assume-invoked/jsx-function.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @flow\nimport {Stringify} from 'shared-runtime';\n\n/**\n * Assume that functions captured directly as jsx attributes are invoked and\n * that their property loads are hoistable.\n */\nfunction useMakeCallback({\n  obj,\n  setState,\n}: {\n  obj: {value: number};\n  setState: (newState: number) => void;\n}) {\n  return <Stringify cb={() => setState(obj.value)} shouldInvokeFns={true} />;\n}\n\nconst setState = (arg: number) => {\n  'use no memo';\n  return arg;\n};\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useMakeCallback,\n  params: [{obj: {value: 1}, setState}],\n  sequentialRenders: [\n    {obj: {value: 1}, setState},\n    {obj: {value: 2}, setState},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Error Handling for Invalid useEffect Argument in React\nDESCRIPTION: This snippet shows the error generated when attempting to use the 'fire' function with a spread argument in a React component. The error message clarifies that 'fire' should receive a single call expression only.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/error.invalid-spread.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n```\n   7 |   };\n   8 |   useEffect(() => {\n>  9 |     fire(...foo);\n     |     ^^^^^^^^^^^^ InvalidReact: Cannot compile `fire`. fire() can only take in a single call expression as an argument but received a spread argument (9:9)\n  10 |   });\n  11 |\n  12 |   return null;\n```\n\n```\n\n----------------------------------------\n\nTITLE: Creating Browser History with History Library - JavaScript\nDESCRIPTION: This snippet initializes browser history using the 'history' library version 2.1.2, encapsulated in a React environment. It defines a browser history object using the 'useBasename' function to set a base URL for navigation. The calling of the top-level Hook-like construct is warned against due to potential runtime errors in environments that support inline requires.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.invalid.invalid-rules-of-hooks-28a7111f56a7.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @skip\n// Passed but should have failed\n\n// Technically this is a false positive.\n// We *could* make it valid (and it used to be).\n//\n// However, top-level Hook-like calls can be very dangerous\n// in environments with inline requires because they can mask\n// the runtime error by accident.\n// So we prefer to disallow it despite the false positive.\n\nconst {createHistory, useBasename} = require('history-2.1.2');\nconst browserHistory = useBasename(createHistory)({\n  basename: '/',\n});\n\n```\n\n----------------------------------------\n\nTITLE: Original React Component Function\nDESCRIPTION: A simple React function component named Foo that creates an object, passes it to a new instance of itself, mutates it, and returns it.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/store-via-new.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Foo() {\n  const x = {};\n  const y = new Foo(x);\n  y.mutate();\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a React Component with Hooks in JavaScript\nDESCRIPTION: This snippet defines a functional component in React that uses useEffect and useRef hooks for handling state and side effects. It shows how to log props and creates a button that uses a ref. Dependencies include React itself and related hooks.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/bailout-retry/bailout-eslint-suppressions.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableFire @panicThreshold(none)\nimport {useRef} from 'react';\n\nfunction Component({props, bar}) {\n  const foo = () => {\n    console.log(props);\n  };\n  useEffect(() => {\n    fire(foo(props));\n    fire(foo());\n    fire(bar());\n  });\n\n  const ref = useRef(null);\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  ref.current = 'bad';\n  return <button ref={ref} />;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Mutable Object and Function Expression\nDESCRIPTION: This is the compiled version of the React component, generated potentially by a compiler like React Compiler. It utilizes the `_c` helper from `react/compiler-runtime` for memoization and optimization. The logic regarding mutable object manipulation and function expression dependency remains similar, but the structure is transformed to leverage compiler optimizations. This code illustrates how the original component's logic is adapted for efficient execution.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/aliased-nested-scope-fn-expr.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enableTransitivelyFreezeFunctionExpressions:false\nimport {\n  Stringify,\n  mutate,\n  identity,\n  setPropertyByKey,\n  shallowCopy,\n} from \"shared-runtime\";\n/**\n * Function expression version of `aliased-nested-scope-truncated-dep`.\n * \n * In this fixture, the output would be invalid if propagateScopeDeps did not\n * avoid adding MemberExpression dependencies which would other evaluate during\n * the mutable ranges of their base objects.\n * This is different from `aliased-nested-scope-truncated-dep` which *does*\n * produce correct output regardless of MemberExpression dependency truncation.\n * \n * Note while other expressions evaluate inline, function expressions *always*\n * represent deferred evaluation. This means that\n * (1) it's always safe to reorder function expression creation until its\n *     earliest potential invocation\n * (2) it's invalid to eagerly evaluate function expression dependencies during\n *     their respective mutable ranges.\n */\n\nfunction Component(t0) {\n  const $ = _c(2);\n  const { prop } = t0;\n  let t1;\n  if ($[0] !== prop) {\n    const obj = shallowCopy(prop);\n\n    const aliasedObj = identity(obj);\n\n    const getId = () => obj.id;\n\n    mutate(aliasedObj);\n    setPropertyByKey(aliasedObj, \"id\", prop.id + 1);\n\n    t1 = <Stringify getId={getId} shouldInvokeFns={true} />;\n    $[0] = prop;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ prop: { id: 1 } }],\n  sequentialRenders: [\n    { prop: { id: 1 } },\n    { prop: { id: 1 } },\n    { prop: { id: 2 } },\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Refactored React Component with Destructuring in JavaScript\nDESCRIPTION: This snippet is a refactored version of the previous function 'foo'. It separates variable declarations and uses a slightly different formatting for object destructuring. The FIXTURE_ENTRYPOINT export remains the same.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructure-direct-reassignment.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(props) {\n  let x;\n  let y;\n  ({ x, y } = { x: props.a, y: props.b });\n  console.log(x);\n  x = props.c;\n  return x + y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component Function Input\nDESCRIPTION: Original function implementation that creates an object, renders it in a div, and processes it through a method call. Contains JSX and demonstrates typical React component patterns.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/method-call-fn-call.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(a, b, c) {\n  // Construct and freeze x\n  const x = makeObject(a);\n  <div>{x}</div>;\n\n  // y should depend on `x` and `b`\n  const method = x.method;\n  const y = method.call(x, b);\n  return y;\n}\n```\n\n----------------------------------------\n\nTITLE: Original React Component with Context Variable Test\nDESCRIPTION: A React component that tests forget's ability to handle context variables. It creates a context variable with a mutable range and then references it after that range, checking if proper memoization occurs based on the component's inputs.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/context-var-granular-dep.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {throwErrorWithMessage, ValidateMemoization} from 'shared-runtime';\n\n/**\n * Context variables are local variables that (1) have at least one reassignment\n * and (2) are captured into a function expression. These have a known mutable\n * range: from first declaration / assignment to the last direct or aliased,\n * mutable reference.\n *\n * This fixture validates that forget can take granular dependencies on context\n * variables when the reference to a context var happens *after* the end of its\n * mutable range.\n */\nfunction Component({cond, a}) {\n  let contextVar;\n  if (cond) {\n    contextVar = {val: a};\n  } else {\n    contextVar = {};\n    throwErrorWithMessage('');\n  }\n  const cb = {cb: () => contextVar.val * 4};\n\n  /**\n   * manually specify input to avoid adding a `PropertyLoad` from contextVar,\n   * which might affect hoistable-objects analysis.\n   */\n  return (\n    <ValidateMemoization\n      inputs={[cond ? a : undefined]}\n      output={cb}\n      onlyCheckCompiled={true}\n    />\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{cond: false, a: undefined}],\n  sequentialRenders: [\n    {cond: true, a: 2},\n    {cond: true, a: 2},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Transpiled React Component with Conditional Property Access (Code)\nDESCRIPTION: This code represents the transpiled version of the React component `Foo`, likely generated by a compiler like React Compiler. It utilizes `react/compiler-runtime` to optimize rendering by memoizing the `Stringify` component based on the props `a` and `shouldReadA`.  This optimization prevents unnecessary re-renders when the input props are unchanged.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/infer-function-cond-access-not-hoisted.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { Stringify } from \"shared-runtime\";\n\nfunction Foo(t0) {\n  const $ = _c(3);\n  const { a, shouldReadA } = t0;\n  let t1;\n  if ($[0] !== a || $[1] !== shouldReadA) {\n    t1 = (\n      <Stringify\n        fn={() => {\n          if (shouldReadA) {\n            return a.b.c;\n          }\n          return null;\n        }}\n        shouldInvokeFns={true}\n      />\n    );\n    $[0] = a;\n    $[1] = shouldReadA;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{ a: null, shouldReadA: true }],\n  sequentialRenders: [\n    { a: null, shouldReadA: true },\n    { a: null, shouldReadA: false },\n    { a: { b: { c: 4 } }, shouldReadA: true },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom React Hook\nDESCRIPTION: The function useFoo is a custom React Hook that iterates five times and conditionally appends a property's value of an object to an array. It takes in an object and a boolean indicating if the object is null. It returns an array containing the value of obj.a up to five times.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-poisoned/loop-break-in-scope.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nfunction useFoo({obj, objIsNull}) {\n  const x = [];\n  for (let i = 0; i < 5; i++) {\n    if (objIsNull) {\n      continue;\n    }\n    x.push(obj.a);\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{obj: null, objIsNull: true}],\n  sequentialRenders: [\n    {obj: null, objIsNull: true},\n    {obj: {a: 2}, objIsNull: false},\n    // check we preserve nullthrows\n    {obj: {a: undefined}, objIsNull: false},\n    {obj: undefined, objIsNull: false},\n    {obj: {a: undefined}, objIsNull: false},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining React Hook with Dynamic Array Manipulation in JavaScript\nDESCRIPTION: This code snippet defines a React hook `useFoo`, which manipulates an array `x` based on the boolean condition `props.cond`. The hook adds properties `bar` or `foo` to the array. No external dependencies are required other than standard ECMAScript 2015+ features for JavaScript. Input properties include `cond`, `foo`, and `bar`. The output is an array with added elements based on the input condition, with potential constraints in managing stateful complexity.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-renaming-ternary.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction useFoo(props) {\n  let x = [];\n  x.push(props.bar);\n  props.cond ? ((x = {}), (x = []), x.push(props.foo)) : null;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{cond: false, foo: 2, bar: 55}],\n  sequentialRenders: [\n    {cond: false, foo: 2, bar: 55},\n    {cond: false, foo: 3, bar: 55},\n    {cond: true, foo: 3, bar: 55},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Error reporting conflicting global variable\nDESCRIPTION: This error message indicates that there is a naming conflict between a local variable named `__DEV__` defined within the `useFoo` function and a global variable with the same name. The error message specifies the line number and column where the conflict occurs and indicates that the local binding of `__DEV__` is causing the problem. This type of error is important to identify and resolve to avoid unexpected behavior during development and production.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.emit-freeze-conflicting-global.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n  1 | // @enableEmitFreeze @instrumentForget\n  2 | function useFoo(props) {\n> 3 |   const __DEV__ = 'conflicting global';\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Todo: Encountered conflicting global in generated program. Conflict from local binding __DEV__ (3:3)\n  4 |   console.log(__DEV__);\n  5 |   return foo(props.x);\n  6 | }\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: Compiled version of the React component with added memoization logic using compiler runtime. Shows how the component is optimized to avoid unnecessary re-renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-independently-memoized-property-load-for-method-call.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(t0) {\n  const $ = _c(8);\n  const { label, highlightedItem } = t0;\n  const serverTime = useServerTime();\n  let t1;\n  let timestampLabel;\n  if ($[0] !== highlightedItem || $[1] !== label || $[2] !== serverTime) {\n    const highlight = new Highlight(highlightedItem);\n\n    const time = serverTime.get();\n\n    timestampLabel = time / 1000 || label;\n\n    t1 = highlight.render();\n    $[0] = highlightedItem;\n    $[1] = label;\n    $[2] = serverTime;\n    $[3] = t1;\n    $[4] = timestampLabel;\n  } else {\n    t1 = $[3];\n    timestampLabel = $[4];\n  }\n  let t2;\n  if ($[5] !== t1 || $[6] !== timestampLabel) {\n    t2 = (\n      <>\n        {t1}\n        {timestampLabel}\n      </>\n    );\n    $[5] = t1;\n    $[6] = timestampLabel;\n    $[7] = t2;\n  } else {\n    t2 = $[7];\n  }\n  return t2;\n}\n\nfunction useServerTime() {\n  \"use no forget\";\n\n  return {\n    get() {\n      return 42000;\n    },\n  };\n}\n\nclass Highlight {\n  constructor(value) {\n    this.value = value;\n  }\n\n  render() {\n    return this.value;\n  }\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ label: \"<unused>\", highlightedItem: \"Seconds passed: \" }],\n};\n```\n\n----------------------------------------\n\nTITLE: State Comparison and Conditional Rendering in React JavaScript\nDESCRIPTION: The code features an advanced version of ComponentA and ComponentB in React JavaScript using a state array `_c` for efficient re-rendering by comparing current and previous props. State and mutation handling is carried out with array-based checks, ensuring re-renders only occur when necessary to improve performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/conditional-on-mutable.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enablePropagateDepsInHIR\nfunction ComponentA(props) {\n  const $ = _c(4);\n  let t0;\n  if ($[0] !== props.p0 || $[1] !== props.p1 || $[2] !== props.p2) {\n    const a = [];\n    const b = [];\n    if (b) {\n      a.push(props.p0);\n    }\n    if (props.p1) {\n      b.push(props.p2);\n    }\n\n    t0 = <Foo a={a} b={b} />;\n    $[0] = props.p0;\n    $[1] = props.p1;\n    $[2] = props.p2;\n    $[3] = t0;\n  } else {\n    t0 = $[3];\n  }\n  return t0;\n}\n\nfunction ComponentB(props) {\n  const $ = _c(4);\n  let t0;\n  if ($[0] !== props.p0 || $[1] !== props.p1 || $[2] !== props.p2) {\n    const a = [];\n    const b = [];\n    if (mayMutate(b)) {\n      a.push(props.p0);\n    }\n    if (props.p1) {\n      b.push(props.p2);\n    }\n\n    t0 = <Foo a={a} b={b} />;\n    $[0] = props.p0;\n    $[1] = props.p1;\n    $[2] = props.p2;\n    $[3] = t0;\n  } else {\n    t0 = $[3];\n  }\n  return t0;\n}\n\nfunction Foo() {}\nfunction mayMutate() {}\n```\n\n----------------------------------------\n\nTITLE: Original React Component with Global Object Type Resolution\nDESCRIPTION: A React function component that demonstrates how type and effect lookups are resolved on JavaScript global objects. It uses imported utility functions and accesses global properties like Math.max, Infinity, and NaN.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-global-object.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {identity, sum} from 'shared-runtime';\n\n// Check that we correctly resolve type and effect lookups on the javascript\n// global object.\nfunction Component(props) {\n  let neverAliasedOrMutated = identity(props.b);\n  let primitiveVal1 = Math.max(props.a, neverAliasedOrMutated);\n  let primitiveVal2 = Infinity;\n  let primitiveVal3 = globalThis.globalThis.NaN;\n\n  // Even though we don't know the function signature of sum,\n  // we should be able to infer that it does not mutate its inputs.\n  sum(primitiveVal1, primitiveVal2, primitiveVal3);\n  return {primitiveVal1, primitiveVal2, primitiveVal3};\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{a: 1, b: 2}],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: Defines a React component that initializes an array from a nullable value and adds a prop to it. Uses nullish coalescing operator for default empty array.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/align-scopes-iife-return-modified-later-logical.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {getNull} from 'shared-runtime';\n\nfunction Component(props) {\n  const items = (() => {\n    return getNull() ?? [];\n  })();\n  items.push(props.a);\n  return items;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{a: {}}],\n};\n```\n\n----------------------------------------\n\nTITLE: React Error Handling for useKeyedState Hook (JavaScript)\nDESCRIPTION: This snippet captures an error related to the 'useKeyedState' hook. The error states that calling 'setState' from within 'useMemo' can potentially trigger an infinite loop, highlighting the need for caution when using state updates in React hooks. It provides context around the specific line of code to help developers troubleshoot.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-setState-in-useMemo.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n  4 |\n  5 |   useMemo(() => {\n> 6 |     setPrevKey(key);\n    |     ^^^^^^^^^^ InvalidReact: Calling setState from useMemo may trigger an infinite loop. (https://react.dev/reference/react/useState) (6:6)\n\nInvalidReact: Calling setState from useMemo may trigger an infinite loop. (https://react.dev/reference/react/useState) (7:7)\n  7 |     setState(init);\n  8 |   }, [key, init]);\n  9 |\n```\n\n----------------------------------------\n\nTITLE: React Compiler Runtime Optimized Object Processing\nDESCRIPTION: Compiled version of the useFoo function with added memoization and runtime optimization using React compiler runtime. Includes dynamic caching and conditional value extraction.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/try-catch-maybe-null-dependency.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction useFoo(maybeNullObject) {\n  const $ = _c(4);\n  let y;\n  if ($[0] !== maybeNullObject) {\n    y = [];\n    try {\n      let t0;\n      if ($[2] !== maybeNullObject.value.inner) {\n        t0 = identity(maybeNullObject.value.inner);\n        $[2] = maybeNullObject.value.inner;\n        $[3] = t0;\n      } else {\n        t0 = $[3];\n      }\n      y.push(t0);\n    } catch {\n      y.push(\"null\");\n    }\n    $[0] = maybeNullObject;\n    $[1] = y;\n  } else {\n    y = $[1];\n  }\n  return y;\n}\n```\n\n----------------------------------------\n\nTITLE: Input React Component Definition\nDESCRIPTION: Original React component implementation with Flow types and memo wrapper. Defines a simple component that renders a div with a string value prop.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/gating-with-hoisted-type-reference.flow.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @flow @gating\nimport {memo} from 'react';\n\ntype Props = React.ElementConfig<typeof Component>;\n\ncomponent Component(value: string) {\n  return <div>{value}</div>;\n}\n\nexport default memo<Props>(Component);\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: eval('Component'),\n  params: [{value: 'foo'}],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with useMemo - Source Code\nDESCRIPTION: Original React component implementation using useMemo hook with optional chaining for nested object access. Includes validation of memoization using ValidateMemoization component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/optional-member-expression-inverted-optionals-parallel-paths.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validatePreserveExistingMemoizationGuarantees @enableOptionalDependencies @enablePropagateDepsInHIR\nimport {ValidateMemoization} from 'shared-runtime';\nfunction Component(props) {\n  const data = useMemo(() => {\n    const x = [];\n    x.push(props?.a.b?.c.d?.e);\n    x.push(props.a?.b.c?.d.e);\n    return x;\n  }, [props.a.b.c.d.e]);\n  return <ValidateMemoization inputs={[props.a.b.c.d.e]} output={x} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Component with Feature Flag Check - React - JavaScript\nDESCRIPTION: This code defines a React component named 'Foo' which extends from React's Component class. Within the render method, it conditionally calls 'useFeatureFlag' from 'FooStore' based on a condition variable. The use of 'use' in the method name led to a false positive warning which indicates a potential design issue with naming conventions in React hooks. This snippet requires React and FooStore to function correctly.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.invalid.invalid-rules-of-hooks-206e2811c87c.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @skip\n// Passed but should have failed\n\n// This is a false positive (it's valid) that unfortunately\n// we cannot avoid. Prefer to rename it to not start with \"use\"\nclass Foo extends Component {\n  render() {\n    if (cond) {\n      FooStore.useFeatureFlag();\n    }\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining Component Function - React JavaScript\nDESCRIPTION: This JavaScript snippet defines a React component function that initializes an item with memoization. The function uses a component-level prop 'a' to create an item, which is then mapped over; minimizing unnecessary re-renders. The 'FIXTURE_ENTRYPOINT' serves as an interface for testing purposes and requires an object parameter with a nested 'id' attribute.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-map-captures-receiver-noAlias.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  // This item is part of the receiver, should be memoized\n  const item = {a: props.a};\n  const items = [item];\n  const mapped = items.map(item => item);\n  return mapped;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{a: {id: 42}}],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with Unmemoized Effect Dependencies\nDESCRIPTION: A React component that demonstrates an issue with unmemoized effect dependencies. The component creates arrays that cannot be memoized properly and passes them to useEffect, which causes the React Compiler to reject optimizing the component to prevent infinite loops.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.validate-memoized-effect-deps-invalidated-dep-value.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @validateMemoizedEffectDependencies\nimport {useHook} from 'shared-runtime';\n\nfunction Component(props) {\n  const x = [];\n  useHook(); // intersperse a hook call to prevent memoization of x\n  x.push(props.value);\n\n  const y = [x];\n\n  useEffect(() => {\n    console.log(y);\n  }, [y]);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: 'sathya'}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Component Structure in JavaScript\nDESCRIPTION: This snippet defines a simple component function that takes an argument 'a', manipulates it, and returns a structured object. It also exports an entry point for use in a React application. The function modifies a property of the returned object based on an inner function call. Key parameters include 'a' which is the input to the component, and the structure returned contains nested properties.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-mutate-nested.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component(a) {\n  let y = {b: {a}};\n  let x = function () {\n    y.b.a = 2;\n  };\n  x();\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n\n```\n\n----------------------------------------\n\nTITLE: Transformed Worklet Function\nDESCRIPTION: Shows the compiler-transformed version of the worklet function where the inline arrow function is hoisted to a separate named function '_temp' while maintaining the same functionality.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/arrow-function-one-line-directive.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction useFoo() {\n  const update = _temp;\n  return update;\n}\nfunction _temp() {\n  \"worklet\";\n  return 1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with useCallback Implementation\nDESCRIPTION: Implements a React component using useCallback hook with primitive object mutations. The component creates mutable objects, assigns props values, and returns a memoized callback function.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useCallback-maybe-modify-free-variable-dont-preserve-memoization-guarantee.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enablePreserveExistingMemoizationGuarantees:false\nimport {useCallback} from 'react';\nimport {identity, makeObject_Primitives, mutate, useHook} from 'shared-runtime';\n\nfunction Component(props) {\n  const free = makeObject_Primitives();\n  const free2 = makeObject_Primitives();\n  const part = free2.part;\n  useHook();\n  const callback = useCallback(() => {\n    const x = makeObject_Primitives();\n    x.value = props.value;\n    mutate(x, free, part);\n  }, [props.value]);\n\n  mutate(free, part);\n  return callback;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: 42}],\n};\n```\n\n----------------------------------------\n\nTITLE: Invalid Hook Usage in React Component\nDESCRIPTION: Example of incorrect hook implementation where useHook is called within a for loop. This violates React's Rules of Hooks which require hooks to be called in a consistent order and not within loops, conditions, or nested functions.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-hook-for.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let i = 0;\n  for (let x = 0; useHook(x) < 10; useHook(i), x++) {\n    i += useHook(x);\n  }\n  return i;\n}\n```\n\nLANGUAGE: plaintext\nCODE:\n```\n  2 |   let i = 0;\n  3 |   for (let x = 0; useHook(x) < 10; useHook(i), x++) {\n> 4 |     i += useHook(x);\n    |          ^^^^^^^ InvalidReact: Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning) (4:4)\n\nInvalidReact: Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning) (3:3)\n  5 |   }\n  6 |   return i;\n  7 | }\n```\n\n----------------------------------------\n\nTITLE: Compiled Fixture Entrypoint Definition\nDESCRIPTION: This code defines the same `FIXTURE_ENTRYPOINT` as the original file.  It specifies the component function, indicates that it is a component, and provides parameters for the component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/import-as-local.expect.md#2025-04-21_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  isComponent: true,\n  params: [{ x: 1 }],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with Optional Chaining (Code)\nDESCRIPTION: This snippet defines a React component named `Component` that accepts `props`. It creates an object `obj` using `makeObject()` and then uses optional chaining `obj.a?.b?.(props.c)` to safely call a method `b` on potentially null or undefined properties `a` and `b` of the object. The `props.c` value is passed as an argument to the method `b`. The component returns null, indicating it doesn't render anything.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unused-optional-method-assigned-to-variable.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const obj = makeObject();\n  obj.a?.b?.(props.c);\n  return null;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Type Alias and Function with Flow Annotations in React\nDESCRIPTION: This snippet demonstrates the use of Flow annotations, type aliases, and function declarations in a React context. It defines a 'Bar' type alias, a 'TypeAliasUsedAsAnnotation' function, and exports a 'FIXTURE_ENTRYPOINT' object.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-alias-used-as-annotation_.flow.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @flow @enableAssumeHooksFollowRulesOfReact @enableTransitivelyFreezeFunctionExpressions\ntype Bar = string;\nfunction TypeAliasUsedAsAnnotation() {\n  type Foo = Bar;\n  const fun = (f: Foo) => {\n    console.log(f);\n  };\n  fun('hello, world');\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: TypeAliasUsedAsAnnotation,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Memoizing and Exporting a Function in Javascript\nDESCRIPTION: This code defines a memoized function `bar` that uses `react/compiler-runtime` to optimize execution. It checks if the input `a` has changed and only re-executes the function's core logic if it has, storing the result in the `$` array. The function returns a value derived from the input.  It also exports metadata needed to run and test this function.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-alias-computed-load-4.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n```javascript\nimport { c as _c } from \"react/compiler-runtime\";\nfunction bar(a) {\n  const $ = _c(2);\n  let y;\n  if ($[0] !== a) {\n    const x = [a];\n    y = {};\n    const f0 = function () {\n      y = x[0].a[1];\n    };\n\n    f0();\n    $[0] = a;\n    $[1] = y;\n  } else {\n    y = $[1];\n  }\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: bar,\n  params: [{ a: [\"val1\", \"val2\"] }],\n  isComponent: false,\n};\n\n```\n```\n\n----------------------------------------\n\nTITLE: Mutating Component State - JavaScript\nDESCRIPTION: This snippet defines a component function that receives an argument, constructs an object, and mutates it before returning. It leverages the `mutate` function from 'shared-runtime' for state modification, which is useful in managing shared application state.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-alias-computed-mutate-iife.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst {mutate} = require('shared-runtime');\n\nfunction component(a) {\n  let x = {a};\n  let y = {};\n  (function () {\n    y['x'] = x;\n  })();\n  mutate(y);\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: ['foo'],\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Hook with Memoization using React Compiler Runtime\nDESCRIPTION: The compiled version of the useFoo hook with memoization applied. It uses React's compiler runtime to store previous values and skip recalculations when props haven't changed, improving performance during re-renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-renaming-ternary-destruction.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction useFoo(props) {\n  const $ = _c(5);\n  let x;\n  if ($[0] !== props.bar) {\n    x = [];\n    x.push(props.bar);\n    $[0] = props.bar;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  if ($[2] !== props.cond || $[3] !== props.foo) {\n    props.cond ? (([x] = [[]]), x.push(props.foo)) : null;\n    $[2] = props.cond;\n    $[3] = props.foo;\n    $[4] = x;\n  } else {\n    x = $[4];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ cond: false, foo: 2, bar: 55 }],\n  sequentialRenders: [\n    { cond: false, foo: 2, bar: 55 },\n    { cond: false, foo: 3, bar: 55 },\n    { cond: true, foo: 3, bar: 55 },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Mutating Dependencies with React in JavaScript\nDESCRIPTION: Defines a useFoo function to process and mutate an array based on property conditions. It utilizes a mutate function from a shared runtime to apply mutations to the array. The code manages dependencies and tracks changes using conditionals and an external dependency checker.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/ssa-renaming-unconditional-with-mutation.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enablePropagateDepsInHIR\nimport {mutate} from 'shared-runtime';\n\nfunction useFoo(props) {\n  let x = [];\n  x.push(props.bar);\n  if (props.cond) {\n    x = {};\n    x = [];\n    x.push(props.foo);\n  } else {\n    x = [];\n    x = [];\n    x.push(props.bar);\n  }\n  mutate(x);\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{bar: 'bar', foo: 'foo', cond: true}],\n  sequentialRenders: [\n    {bar: 'bar', foo: 'foo', cond: true},\n    {bar: 'bar', foo: 'foo', cond: true},\n    {bar: 'bar', foo: 'foo', cond: false},\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Enhanced useHook Function with Block Label in React JavaScript\nDESCRIPTION: This snippet contains an enhanced version of the useHook function that utilizes a block label, bb0, for the switch statement to manage flow control. It demonstrates an alternate way to organize switch cases in JavaScript, which can be useful for more complex control flow logic within React applications. As with the previous version, it exports a FIXTURE_ENTRYPOINT object providing context for integrating this function.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/block-scoping-switch-dead-code.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction useHook(a, b) {\n  bb0: switch (a) {\n    case 1: {\n      if (b == null) {\n        return;\n      }\n\n      console.log(b);\n      break bb0;\n    }\n    case 2: {\n      return;\n    }\n    default: {\n      return;\n    }\n  }\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useHook,\n  params: [1, \"foo\"],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiled Version of Custom React Hook Using Compiler Runtime\nDESCRIPTION: This snippet shows the compiled version of the 'useTest' hook using React's compiler runtime. It includes memoization logic and optimizations for conditional rendering and value caching.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-allocating-ternary-test-instruction-scope.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { identity, makeObject_Primitives } from \"shared-runtime\";\n\nfunction useHook() {}\n\nfunction useTest(t0) {\n  const $ = _c(3);\n  const { cond } = t0;\n  let t1;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = makeObject_Primitives();\n    $[0] = t1;\n  } else {\n    t1 = $[0];\n  }\n  const val = t1;\n\n  useHook();\n  let t2;\n  if ($[1] !== cond) {\n    t2 = identity(cond) ? val : null;\n    $[1] = cond;\n    $[2] = t2;\n  } else {\n    t2 = $[2];\n  }\n  const result = t2;\n  return result;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useTest,\n  params: [{ cond: true }],\n};\n```\n\n----------------------------------------\n\nTITLE: Simplified Component Logic - JavaScript\nDESCRIPTION: This snippet shows a version of the React component with a simpler structure, focusing on a switch-case implementation that manages breaking out of the switch using labels. It also exports the FIXTURE_ENTRYPOINT similarly as the first snippet.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reverse-postorder.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  if (props.cond) {\n    bb0: switch (props.test) {\n      case 0: {\n        break bb0;\n      }\n      case 1: {\n        break bb0;\n      }\n      case 2: {\n      }\n      default: {\n      }\n    }\n  } else {\n    if (props.cond2) {\n    }\n  }\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React FBT Component Output\nDESCRIPTION: The compiled version of the FBT component showing how the internationalization markup is transformed into efficient runtime code. Includes caching mechanism for repeated values and parameter handling.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-whitespace-within-text.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport fbt from \"fbt\";\n\nconst _ = fbt;\nfunction Component(t0) {\n  const $ = _c(2);\n  const { value } = t0;\n  let t1;\n  if ($[0] !== value) {\n    t1 = fbt._(\n      \"Before text {paramName} after text more text and more and more and more and more and more and more and more and more and blah blah blah blah\",\n      [fbt._param(\"paramName\", value)],\n      { hk: \"24ZPpO\" },\n    );\n    $[0] = value;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ value: \"hello world\" }],\n};\n```\n\n----------------------------------------\n\nTITLE: Minimal React Test Fixture with Empty Function\nDESCRIPTION: A simplified JavaScript test fixture with an empty function implementation and an exported FIXTURE_ENTRYPOINT configuration that specifies test parameters.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-complex-multiple-if.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo() {}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Component with Context Variable Mutation in JavaScript\nDESCRIPTION: This snippet defines a function Component that accepts an object with properties foo and bar, demonstrating state management through mutation. It uses the makeArray function to alter the context of a variable y. The primary functionality revolves around capturing local variables and managing state effectively using shared utilities from 'shared-runtime'. It takes an object with properties foo and bar as input and returns the modified y object. Key dependency includes 'shared-runtime'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/bug-capturing-func-maybealias-captured-mutate.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {makeArray, mutate} from 'shared-runtime';\n\n/**\n * Bug repro:\n * Found differences in evaluator results\n *   Non-forget (expected):\n *   (kind: ok)\n *   {\"bar\":4,\"x\":{\"foo\":3,\"wat0\":\"joe\"}}\n *   {\"bar\":5,\"x\":{\"foo\":3,\"wat0\":\"joe\"}}\n *   Forget:\n *   (kind: ok)\n *   {\"bar\":4,\"x\":{\"foo\":3,\"wat0\":\"joe\"}}\n *   {\"bar\":5,\"x\":{\"foo\":3,\"wat0\":\"joe\",\"wat1\":\"joe\"}}\n *\n * Fork of `capturing-func-alias-captured-mutate`, but instead of directly\n * aliasing `y` via `[y]`, we make an opaque call.\n *\n * Note that the bug here is that we don't infer that `a = makeArray(y)`\n * potentially captures a context variable into a local variable. As a result,\n * we don't understand that `a[0].x = b` captures `x` into `y` -- instead, we're\n * currently inferring that this lambda captures `y` (for a potential later\n * mutation) and simply reads `x`.\n *\n * Concretely `InferReferenceEffects.hasContextRefOperand` is incorrectly not\n * used when we analyze CallExpressions.\n */\nfunction Component({foo, bar}: {foo: number; bar: number}) {\n  let x = {foo};\n  let y: {bar: number; x?: {foo: number}} = {bar};\n  const f0 = function () {\n    let a = makeArray(y); // a = [y]\n    let b = x;\n    // this writes y.x = x\n    a[0].x = b;\n  };\n  f0();\n  mutate(y.x);\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{foo: 3, bar: 4}],\n  sequentialRenders: [\n    {foo: 3, bar: 4},\n    {foo: 3, bar: 5},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component Compiled Output\nDESCRIPTION: Compiled version of the React component showing the implementation of memoization caching using symbols and compilation-time optimizations. Includes cache invalidation logic and memoized render output.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fast-refresh-refresh-on-const-changes-dev.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @compilationMode(infer) @enableResetCacheOnSourceFileChanges\nimport { useEffect, useMemo, useState } from \"react\";\nimport { ValidateMemoization } from \"shared-runtime\";\n\nlet pretendConst = 0;\n\nfunction unsafeResetConst() {\n  pretendConst = 0;\n}\n\nfunction unsafeUpdateConst() {\n  pretendConst += 1;\n}\n\nfunction Component() {\n  const $ = _c(3);\n  if (\n    $[0] !== \"8d7015668f857996c3d895a7a90e3e16b8a791d5b9cd13f2c76e1c254aeedebb\"\n  ) {\n    for (let $i = 0; $i < 3; $i += 1) {\n      $[$i] = Symbol.for(\"react.memo_cache_sentinel\");\n    }\n    $[0] = \"8d7015668f857996c3d895a7a90e3e16b8a791d5b9cd13f2c76e1c254aeedebb\";\n  }\n  useState(_temp);\n\n  unsafeUpdateConst();\n  let t0;\n  let t1;\n  if ($[1] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = [{ pretendConst }];\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  t0 = t1;\n  const value = t0;\n  let t2;\n  if ($[2] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t2 = <ValidateMemoization inputs={[pretendConst]} output={value} />;\n    $[2] = t2;\n  } else {\n    t2 = $[2];\n  }\n  return t2;\n}\nfunction _temp() {\n  unsafeResetConst();\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n  sequentialRenders: [{}, {}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic React Component in JavaScript\nDESCRIPTION: This snippet defines a simple React component that calculates a value based on the prop 'test'. The component uses a while loop to assign values to 'x' based on the index 'i' and the 'test' prop. It illustrates basic state management without any hooks.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-while-test.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let x;\n  let i = 0;\n  while (i < props.test) {\n    if (i > 10) {\n      x = 10;\n    } else {\n      x = 1;\n    }\n    i++;\n  }\n  // The values assigned to `x` are non-reactive, but the value of `x`\n  // depends on the \"control\" variable `i`, whose value is affected by\n  // `props.test` which is reactive.\n  // Therefore x should be treated as reactive too.\n  return [x];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  sequentialRenders: [\n    {test: 12},\n    {test: 12},\n    {test: 1},\n    {test: 1},\n    {test: 12},\n    {test: 1},\n    {test: 12},\n    {test: 1},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component with Interleaved Mutations\nDESCRIPTION: This code defines a React component `Component` that initializes two arrays, `a` and `b`. The component then pushes `props.cond` into `b` and `false` into `a`. This interleaving causes `a` to become reactive. The code then demonstrates how the reactive nature of `a` affects downstream consumers, specifically how it influences the `do...while` loop and ultimately impacts the component's output.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-from-interleaved-reactivity-do-while.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  // a and b are independent but their mutations are interleaved, so\n  // they get grouped in a reactive scope. this means that a becomes\n  // reactive since it will effectively re-evaluate based on a reactive\n  // input\n  const a = [];\n  const b = [];\n  b.push(props.cond);\n  a.push(false);\n\n  // Downstream consumer of a, which initially seems non-reactive except\n  // that a becomes reactive, per above\n  const c = [a];\n\n  let x = 0;\n  do {\n    x += 1;\n  } while (c[0][0]);\n  // The values assigned to `x` are non-reactive, but the value of `x`\n  // depends on the \"control\" value `c[0]` which becomes reactive via\n  // being interleaved with `b`.\n  // Therefore x should be treated as reactive too.\n  return [x];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{cond: true}],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Transformed TypeScript-like Code in React\nDESCRIPTION: This snippet shows the transformed version of the input code, removing Flow annotations and type aliases. It retains the core functionality of the 'TypeAliasUsedAsAnnotation' function and the 'FIXTURE_ENTRYPOINT' export.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-alias-used-as-annotation_.flow.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\ntype Bar = string;\nfunction TypeAliasUsedAsAnnotation() {\n  const fun = _temp;\n\n  fun(\"hello, world\");\n}\nfunction _temp(f) {\n  console.log(f);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: TypeAliasUsedAsAnnotation,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: React Class Component with Invalid useState Hook Usage\nDESCRIPTION: This code demonstrates an attempt to use the `useState` hook within a class component's `render` method. React hooks can only be used inside functional components or custom hooks, not within class components. This code is expected to fail in a proper React environment.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.invalid.invalid-rules-of-hooks-8303403b8e4c.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// @skip\n// Passed but should have failed\n\nclass ClassComponentWithHook extends React.Component {\n  render() {\n    React.useState();\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Optimized Memoization (JavaScript)\nDESCRIPTION: This snippet shows the compiled version of the React component with optimized memoization. It uses the _c function from react/compiler-runtime to create a memoization cache and implements efficient re-rendering logic for various computations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-missing-memoization-lack-of-phi-types-explicit-types.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useMemo } from \"react\";\nimport { useFragment } from \"shared-runtime\";\n\nfunction Component() {\n  const $ = _c(11);\n  const data = useFragment();\n  let t0;\n  if ($[0] !== data.nodes) {\n    t0 = data.nodes ?? [];\n    $[0] = data.nodes;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const nodes = t0;\n  let t1;\n  if ($[2] !== nodes) {\n    t1 = nodes.flatMap(_temp);\n    $[2] = nodes;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  const flatMap = t1;\n  let t2;\n  if ($[4] !== flatMap) {\n    t2 = flatMap.filter(_temp2);\n    $[4] = flatMap;\n    $[5] = t2;\n  } else {\n    t2 = $[5];\n  }\n  const filtered = t2;\n  let t3;\n  let t4;\n  if ($[6] !== filtered) {\n    t4 = filtered.map();\n    $[6] = filtered;\n    $[7] = t4;\n  } else {\n    t4 = $[7];\n  }\n  t3 = t4;\n  const map = t3;\n  const index = filtered.findIndex(_temp3);\n  let t5;\n  if ($[8] !== index || $[9] !== map) {\n    t5 = (\n      <div>\n        {map}\n        {index}\n      </div>\n    );\n    $[8] = index;\n    $[9] = map;\n    $[10] = t5;\n  } else {\n    t5 = $[10];\n  }\n  return t5;\n}\nfunction _temp3(x) {\n  return x === null;\n}\nfunction _temp2(item) {\n  return item != null;\n}\nfunction _temp(node) {\n  return node.items;\n}\n```\n\n----------------------------------------\n\nTITLE: React Component with Compiler Runtime Optimization\nDESCRIPTION: This code defines a React component that utilizes the `react/compiler-runtime` to optimize rendering. The component calculates 'z' similarly to the first snippet, but then it uses the compiler runtime's `_c` function to memoize the returned array `[z]`. This optimization prevents unnecessary re-renders when 'z' hasn't changed, improving performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-do-while-indirect.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  let x = 0;\n  let y = 0;\n  let z;\n  do {\n    x = x + 1;\n    y = y + 1;\n    z = y;\n  } while (x < props.limit);\n  let t0;\n  if ($[0] !== z) {\n    t0 = [z];\n    $[0] = z;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  sequentialRenders: [\n    { limit: 10 },\n    { limit: 10 },\n    { limit: 1 },\n    { limit: 1 },\n    { limit: 10 },\n    { limit: 1 },\n    { limit: 10 },\n    { limit: 1 },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Invalid Hook Method Invocation in JavaScript Class\nDESCRIPTION: Demonstrates a class method with potentially incorrect references to 'This' and 'Super' hook methods, which may violate React hook usage rules\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.invalid.invalid-rules-of-hooks-acb56658fe7e.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nclass C {\n  m() {\n    This.useHook();\n    Super.useHook();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Test Fixture for Sequential Rendering (JavaScript)\nDESCRIPTION: This snippet exports a test fixture object named FIXTURE_ENTRYPOINT. It includes the Component function, initial parameters, and a series of sequential renders with different prop values for testing purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/ssa-leave-case.expect.md#2025-04-22_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ p0: false, p1: 2 }],\n  sequentialRenders: [\n    { p0: false, p1: 2 },\n    { p0: false, p1: 2 },\n    { p0: true, p1: 2 },\n    { p0: true, p1: 3 },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Build Error for Computed Property Key\nDESCRIPTION: The error message from the build process indicates that the computed property key [mutateAndReturn(key)] is causing a problem. The build system expected an Identifier but received a CallExpression in the object key position.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-object-expression-computed-key-mutate-key-while-constructing-object.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n  4 |   const key = {};\n  5 |   const context = {\n> 6 |     [mutateAndReturn(key)]: identity([props.value]),\n    |      ^^^^^^^^^^^^^^^^^^^^ Todo: (BuildHIR::lowerExpression) Expected Identifier, got CallExpression key in ObjectExpression (6:6)\n  7 |   };\n  8 |   return context;\n  9 | }\n```\n\n----------------------------------------\n\nTITLE: Defining a Component Function in React\nDESCRIPTION: This snippet defines a simple React component function that utilizes an auxiliary function to create an object from props and then calls an optional method if it exists. It accepts props as an argument and returns the result of the method call.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-method-call.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const x = makeObject(props);\n  const y = makeObject(props);\n  const z = x.optionalMethod?.(y.a, props.a, foo(y.b), bar(props.b));\n  return z;\n}\n```\n\n----------------------------------------\n\nTITLE: Compiler-Transformed useKeyCommand Hook with Reactive Scope Optimization\nDESCRIPTION: The React compiler-transformed version of the useKeyCommand hook that implements reactive scope optimization. It uses compiler runtime features to memoize function results and avoid unnecessary recalculations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/original-reactive-scopes-fork/capture-ref-for-later-mutation.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @enableReactiveScopesInHIR:false\nimport { useRef } from \"react\";\nimport { addOne } from \"shared-runtime\";\n\nfunction useKeyCommand() {\n  const $ = _c(1);\n  const currentPosition = useRef(0);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const handleKey = (direction) => () => {\n      const position = currentPosition.current;\n      const nextPosition = direction === \"left\" ? addOne(position) : position;\n      currentPosition.current = nextPosition;\n    };\n\n    const moveLeft = { handler: handleKey(\"left\") };\n\n    const moveRight = { handler: handleKey(\"right\") };\n\n    t0 = [moveLeft, moveRight];\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useKeyCommand,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: Running a Local Server\nDESCRIPTION: This snippet shows how to run a local server to serve the fixtures. It uses `npx pushstate-server .` to start a server in the current directory, making the fixtures accessible through a browser.\nSOURCE: https://github.com/facebook/react/blob/main/fixtures/packaging/README.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nnpx pushstate-server .\n```\n\n----------------------------------------\n\nTITLE: React Component Input\nDESCRIPTION: This snippet defines a simple React component that takes `props` as input, calls `makeObject` with these props, and returns a value from the resulting object based on `props.key`. It assumes `makeObject` is defined elsewhere. This is the initial, unoptimized version of the component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-computed-member-expression.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const object = makeObject(props);\n  return object?.[props.key];\n}\n```\n\n----------------------------------------\n\nTITLE: React Component with Object Property Iteration\nDESCRIPTION: A React component that takes a props object, uses a for...in loop to iterate over props.value properties, and returns the first property key encountered. If no properties exist, returns null. Includes test fixture setup.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-in-statement-body-always-returns.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  for (const x in props.value) {\n    return x;\n  }\n  return null;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{value: {a: 'A!'}}],\n};\n```\n\n----------------------------------------\n\nTITLE: Git Push for Patch Release\nDESCRIPTION: This command pushes the patch release branch to the remote repository. This allows CI systems to build the release. `origin 16.8.3` pushes branch `16.8.3` to remote `origin`.\nSOURCE: https://github.com/facebook/react/blob/main/scripts/release/README.md#2025-04-21_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\ngit push origin 16.8.3\n```\n\n----------------------------------------\n\nTITLE: Defining a test fixture for React component (compiled)\nDESCRIPTION: This JavaScript code defines a `FIXTURE_ENTRYPOINT` object, after compilation. It contains the `useFoo` function (compiled), an array of `params` with sample inputs, and a `sequentialRenders` array for testing different scenarios with varying input values and conditions, including null and empty objects.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-unpoisoned/jump-target-within-scope-label.expect.md#2025-04-21_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ input: { a: { b: 2 } }, cond: false }],\n  sequentialRenders: [\n    { input: { a: { b: 2 } }, cond: false },\n    // preserve nullthrows\n    { input: null, cond: false },\n    { input: null, cond: true },\n    { input: {}, cond: false },\n    { input: { a: { b: null } }, cond: false },\n    { input: { a: null }, cond: false },\n    { input: { a: { b: 3 } }, cond: false },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Mutation Function\nDESCRIPTION: This snippet shows a React component that creates an object from props and mutates it. It defines a mutate function that adds an 'updated' flag and sets a key-value pair on the object.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/function-expression-with-store-to-parameter.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const mutate = (object, key, value) => {\n    object.updated = true;\n    object[key] = value;\n  };\n  const x = makeObject(props);\n  mutate(x);\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Initial React Fixture Implementation\nDESCRIPTION: Original implementation of a test fixture demonstrating block fallthrough behavior with mutable state. Shows conditional logic and mutation patterns across different execution blocks.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/align-scopes-nested-block-structure.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {mutate} from 'shared-runtime';\n\nfunction useFoo({cond1, cond2}) {\n  let s = null;\n  if (cond1) {\n    s = {};\n  } else {\n    return null;\n  }\n\n  if (cond2) {\n    mutate(s);\n  }\n\n  return s;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{cond1: true, cond2: false}],\n  sequentialRenders: [\n    {cond1: true, cond2: false},\n    {cond1: true, cond2: false},\n    {cond1: true, cond2: true},\n    {cond1: true, cond2: true},\n    {cond1: false, cond2: true},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Running ESLint Tests with Yarn\nDESCRIPTION: This shell script snippet provides commands to set up and test the eslint-plugin-react-hooks with ESLint version 7. It includes changing the directory to the appropriate fixture and uses yarn to install dependencies, build the project, and run the linter. There are no specific dependencies mentioned outside of yarn and an appropriate ESLint version.\nSOURCE: https://github.com/facebook/react/blob/main/fixtures/eslint-v7/README.md#2025-04-21_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ncd fixtures/eslint-v7\nyarn\nyarn build\nyarn lint\n```\n\n----------------------------------------\n\nTITLE: Input Component with Initial State and Callback\nDESCRIPTION: Initial implementation of a React component with variable reassignment and a callback function referencing a context variable\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/incompatible-destructuring-kinds.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useMemo} from 'react';\nimport {Stringify} from 'shared-runtime';\n\nfunction Component({}) {\n  let a = 'a';\n  let b = '';\n  [a, b] = [null, null];\n  // NOTE: reference `a` in a callback to force a context variable\n  return <Stringify a={a} b={b} onClick={() => a} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a Hook Function and Entry Point - JavaScript\nDESCRIPTION: This snippet defines a hook function 'useHook' that takes an object with parameters 'a' and 'b'. It utilizes the 'mutate' function from 'shared-runtime' to perform actions with these parameters. The output is a mutated object that contains the original 'a' value as the return value, while 'b' is mutated separately. The snippet also includes a fixture 'FIXTURE_ENTRYPOINT' for testing the hook with predefined parameters and sequential renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-renamed-ref.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {mutate} from 'shared-runtime';\n\nfunction useHook({a, b}) {\n  let z = {a};\n  {\n    let z = {b};\n    (function () {\n      mutate(z);\n    })();\n  }\n  return z;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useHook,\n  params: [{a: 2, b: 3}],\n  sequentialRenders: [\n    {a: 2, b: 3},\n    {a: 2, b: 3},\n    {a: 2, b: 4},\n    {a: 3, b: 4},\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiled useFoo Function with Memoization (React Compiler)\nDESCRIPTION: This JavaScript code shows the compiled version of the `useFoo` function, optimized by the React compiler. It imports the `_c` function for memoization. The compiled function uses an array `$` to store previous input values and the result of the function. If the inputs `input.a.b` and `max` have not changed, it retrieves the previously computed result from `$`. Otherwise, it re-executes the logic and stores the new inputs and result in `$` for future memoization. It includes the same `FIXTURE_ENTRYPOINT` object for testing purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-unpoisoned/jump-target-within-scope-loop-break.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction useFoo(t0) {\n  const $ = _c(3);\n  const { input, max } = t0;\n  let x;\n  if ($[0] !== input.a.b || $[1] !== max) {\n    x = [];\n    let i = 0;\n    while (true) {\n      i = i + 1;\n      if (i > max) {\n        break;\n      }\n    }\n\n    x.push(i);\n    x.push(input.a.b);\n    $[0] = input.a.b;\n    $[1] = max;\n    $[2] = x;\n  } else {\n    x = $[2];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ input: { a: { b: 2 } }, max: 8 }],\n  sequentialRenders: [\n    { input: { a: { b: 2 } }, max: 8 },\n    // preserve nullthrows\n    { input: null, max: 8 },\n    { input: {}, max: 8 },\n    { input: { a: { b: null } }, max: 8 },\n    { input: { a: null }, max: 8 },\n    { input: { a: { b: 3 } }, max: 8 },\n  ],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining React Component with Mathematical Operations in JavaScript\nDESCRIPTION: This snippet defines a React component that uses the Stringify component to display an array of values resulting from various mathematical and bitwise operations. It demonstrates operations like bitwise OR, AND, XOR, left shift, right shift, unsigned right shift, exponentiation, and modulus.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/constant-propagation-bit-ops.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {Stringify} from 'shared-runtime';\n\nfunction foo() {\n  return (\n    <Stringify\n      value={[\n        123.45 | 0,\n        123.45 & 0,\n        123.45 ^ 0,\n        123 << 0,\n        123 >> 0,\n        123 >>> 0,\n        123.45 | 1,\n        123.45 & 1,\n        123.45 ^ 1,\n        123 << 1,\n        123 >> 1,\n        123 >>> 1,\n        3 ** 2,\n        3 ** 2.5,\n        3.5 ** 2,\n        2 ** (3 ** 0.5),\n        4 % 2,\n        4 % 2.5,\n        4 % 3,\n        4.5 % 2,\n      ]}\n    />\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Optimization\nDESCRIPTION: Compiled version of the component showing how the React compiler optimizes the useMemo implementation. It includes cache checking and updating logic using compiler runtime utilities.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useMemo-with-no-depslist.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @validatePreserveExistingMemoizationGuarantees\nimport { useMemo } from \"react\";\n\n// Compiler can produce any memoization it finds valid if the\n// source listed no memo deps\nfunction Component(t0) {\n  const $ = _c(2);\n  const { propA } = t0;\n  let t1;\n  let t2;\n  if ($[0] !== propA) {\n    t2 = [propA];\n    $[0] = propA;\n    $[1] = t2;\n  } else {\n    t2 = $[1];\n  }\n  t1 = t2;\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ propA: 2 }],\n};\n```\n\n----------------------------------------\n\nTITLE: React Compiler Optimized Dependency Tracking Function\nDESCRIPTION: Compiled version of the function with runtime dependency tracking and memoization using React compiler runtime\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/uncond-subpath-order3.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction TestDepsSubpathOrder3(props) {\n  const $ = _c(2);\n  let x;\n  if ($[0] !== props.a) {\n    x = {};\n    x.c = props.a.b.c;\n    x.a = props.a;\n    x.b = props.a.b;\n    $[0] = props.a;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: React Compiler Error Message for Memoization Preservation Failure\nDESCRIPTION: This error message shows the React Compiler's diagnostic output when it fails to preserve existing memoization guarantees. It points to line 11 where useMemo is used within a mutable range created by a context variable.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-repro-unmemoized-callback-captured-in-context-variable.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n   9 |   const a = useHook();\n  10 |   // Because b is also part of that same mutable range, it can't be memoized either\n> 11 |   const b = useMemo(() => ({}), []);\n     |             ^^^^^^^^^^^^^^^^^^^^^^^ CannotPreserveMemoization: React Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. This value was memoized in source but not in compilation output. (11:11)\n  12 |\n  13 |   // Conditional assignment without a subsequent mutation normally doesn't create a mutable\n  14 |   // range, but in this case we're reassigning a context variable\n```\n\n----------------------------------------\n\nTITLE: Defining a Function and Exporting as Fixture Entrypoint in JavaScript\nDESCRIPTION: This snippet defines a JavaScript function named foo which changes the value of a variable and throws it, and then exports it within an object named FIXTURE_ENTRYPOINT. The function initially sets a variable x to 1, changes it to 2 if it equals 1, and throws the value. The FIXTURE_ENTRYPOINT object uses the function foo, has an empty params array, and a boolean indicating it is not a component. There are no additional dependencies, but the function's behavior is straightforward and could result in an exception within certain environments.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-throw.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo() {\n  let x = 1;\n  if (x === 1) {\n    x = 2;\n  }\n  throw x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled Output of Array Length Manipulation Test in JavaScript for React\nDESCRIPTION: This snippet shows the compiled version of the 'useFoo' function, optimized by React's compiler. It includes caching mechanisms and conditional checks to improve performance while maintaining the original functionality.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/evaluation-order-mutate-store-after-dependency-load.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; /**\n * Test that we preserve order of evaluation on the following case scope@0\n * ```js\n * // simplified HIR\n * scope@0\n *    ...\n *    $0 = arr.length\n *    $1 = arr.length = 0\n *\n * scope@1 <-- here we should depend on $0 (the value of the property load before the\n *             property store)\n *   [$0, $1]\n * ```\n */\nfunction useFoo(source) {\n  const $ = _c(6);\n  let t0;\n  let t1;\n  if ($[0] !== source) {\n    const arr = [1, 2, 3, ...source];\n    t0 = arr.length;\n    t1 = arr.length = 0;\n    $[0] = source;\n    $[1] = t0;\n    $[2] = t1;\n  } else {\n    t0 = $[1];\n    t1 = $[2];\n  }\n  let t2;\n  if ($[3] !== t0 || $[4] !== t1) {\n    t2 = [t0, t1];\n    $[3] = t0;\n    $[4] = t1;\n    $[5] = t2;\n  } else {\n    t2 = $[5];\n  }\n  return t2;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [[5, 6]],\n};\n```\n\n----------------------------------------\n\nTITLE: Input React Component with Mutable State\nDESCRIPTION: A React component that initializes an array, transforms it to an object via a function call, and returns it. This represents the source code before React compiler optimizations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reassign-object-in-context.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let x = [];\n  let foo = () => {\n    x = {};\n  };\n  foo();\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Type Alias Parameter Annotation Input\nDESCRIPTION: Original TypeScript code showing type alias usage for function parameter annotation. Defines a Bar type alias as string and uses it through another type alias Foo as a parameter type.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-alias-used-as-annotation.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enableAssumeHooksFollowRulesOfReact @enableTransitivelyFreezeFunctionExpressions\ntype Bar = string;\nfunction TypeAliasUsedAsParamAnnotation() {\n  type Foo = Bar;\n  const fun = (f: Foo) => {\n    console.log(f);\n  };\n  fun('hello, world');\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: TypeAliasUsedAsParamAnnotation,\n  params: [],\n};\n```\n\n----------------------------------------\n\nTITLE: React Component Definition with Simple Destructuring\nDESCRIPTION: Defines a React functional component `t` that takes props as input and destructures it to extract the first value using simple destructuring. It returns the extracted value `foo`. The component is then exported as part of a fixture entry point, which includes the component function, parameters and isComponent property.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/holey-array-pattern-dce-2.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction t(props) {\n  const [foo] = props;\n  return foo;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: t,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiler-Transformed Component\nDESCRIPTION: This snippet shows the compiler-transformed version of the React component. The compiler introduces memoization using `_c` from `react/compiler-runtime` to optimize rendering. It checks if the input 'a' has changed since the last render and reuses the previously computed value if it hasn't, avoiding unnecessary re-computations. This optimizes performance by caching results.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capture_mutate-across-fns-iife.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction component(a) {\n  const $ = _c(2);\n  let z;\n  if ($[0] !== a) {\n    z = { a };\n\n    (function () {\n      z.b = 1;\n    })();\n    $[0] = a;\n    $[1] = z;\n  } else {\n    z = $[1];\n  }\n  return z;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: [2],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Fixture Entry Point with Sample Data\nDESCRIPTION: Defines a constant named `FIXTURE_ENTRYPOINT` that provides sample data for the `Component2` component.  It includes a `params` array containing an object with an `items` array, which holds sample item data (id and name). This is a common pattern for providing initial data to React components for testing or demonstration purposes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/outlining-in-func-expr.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component2,\n  params: [\n    {\n      items: [\n        {id: 2, name: 'foo'},\n        {id: 3, name: 'bar'},\n      ],\n    },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component with Implicit Effect Dependencies\nDESCRIPTION: A React component function demonstrating useEffect with no dependency array specified. The effect calls a 'print' function with a string literal. The comment indicates this is a test case for the effect dependencies inference system.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/outlined-function.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @inferEffectDependencies\nimport {useEffect} from 'react';\nimport {print} from 'shared-runtime';\n/**\n * This compiled output is technically incorrect but this is currently the same\n * case as a bailout (an effect that overfires).\n *\n * To ensure an empty deps array is passed, we need special case\n * `InferEffectDependencies` for outlined functions (likely easier) or run it\n * before OutlineFunctions\n */\nfunction OutlinedFunctionInEffect() {\n  useEffect(() => print('hello world!'));\n}\n```\n\n----------------------------------------\n\nTITLE: Compiler-Transformed React Component with Memoization\nDESCRIPTION: The compiler-transformed version of the input code with memoization. It uses React's compiler runtime to optimize rendering, but still contains the fundamental issue of creating components during render.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/static-components/invalid-dynamically-constructed-component-new.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @logger @validateStaticComponents\nfunction Example(props) {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const Component = new ComponentFactory();\n    t0 = <Component />;\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n```\n\n----------------------------------------\n\nTITLE: Optimizing Loop Function in JavaScript\nDESCRIPTION: This snippet shows an optimized version of the 'foo' function. The infinite loop is replaced with a false condition, effectively removing the loop. The function now always returns 0.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/constant-propagation-while.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo() {\n  let y = 0;\n  while (false) {\n    y = y + 1;\n  }\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: [],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Optimized React Component with Compiler Runtime\nDESCRIPTION: This snippet shows the compiled and optimized version of the React component using React's compiler runtime. It includes memoization checks and optimized array operations, improving performance by reducing unnecessary re-computations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-missing-memoization-lack-of-phi-types.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useMemo } from \"react\";\nimport { useFragment } from \"shared-runtime\";\n\nfunction Component() {\n  const $ = _c(11);\n  const data = useFragment();\n  let t0;\n  if ($[0] !== data.nodes) {\n    t0 = data.nodes ?? [];\n    $[0] = data.nodes;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const nodes = t0;\n  let t1;\n  if ($[2] !== nodes) {\n    t1 = nodes.flatMap(_temp);\n    $[2] = nodes;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  const flatMap = t1;\n  let t2;\n  if ($[4] !== flatMap) {\n    t2 = flatMap.filter(_temp2);\n    $[4] = flatMap;\n    $[5] = t2;\n  } else {\n    t2 = $[5];\n  }\n  const filtered = t2;\n  let t3;\n  let t4;\n  if ($[6] !== filtered) {\n    t4 = filtered.map();\n    $[6] = filtered;\n    $[7] = t4;\n  } else {\n    t4 = $[7];\n  }\n  t3 = t4;\n  const map = t3;\n  const index = filtered.findIndex(_temp3);\n  let t5;\n  if ($[8] !== index || $[9] !== map) {\n    t5 = (\n      <div>\n        {map}\n        {index}\n      </div>\n    );\n    $[8] = index;\n    $[9] = map;\n    $[10] = t5;\n  } else {\n    t5 = $[10];\n  }\n  return t5;\n}\nfunction _temp3(x) {\n  return x === null;\n}\nfunction _temp2(item) {\n  return item != null;\n}\nfunction _temp(node) {\n  return node.items;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining and Exporting a Component Function in JavaScript with React\nDESCRIPTION: The function `component` defines a simple JavaScript object `z` with a property `a` passed as an argument. It uses nested functions to modify the object's property `b` and returns the updated object. The component is exported as part of `FIXTURE_ENTRYPOINT`. No dependencies beyond standard JavaScript syntax are required.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capture_mutate-across-fns.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component(a) {\n  let z = {a};\n  const f0 = function () {\n    const f1 = function () {\n      z.b = 1;\n    };\n    f1();\n  };\n  f0();\n  return z;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Web Crawler Access in robots.txt\nDESCRIPTION: This robots.txt configuration allows all web crawlers to access the entire website without restrictions. It specifies the User-agent wildcard (*) to target all crawlers and includes an empty Disallow directive.\nSOURCE: https://github.com/facebook/react/blob/main/fixtures/owner-stacks/public/robots.txt#2025-04-21_snippet_0\n\nLANGUAGE: robotstxt\nCODE:\n```\nUser-agent: *\nDisallow:\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component\nDESCRIPTION: Presents the compiled version of the React component. It utilizes `react/compiler-runtime` for optimization. It memoizes the result using the `_c` function to avoid unnecessary re-renders if the 'name' prop hasn't changed. The `FIXTURE_ENTRYPOINT` exports the component and a set of params used when evaluating the component.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-lowercase-memberexpr.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport * as SharedRuntime from \"shared-runtime\";\nfunction Component(t0) {\n  const $ = _c(2);\n  const { name } = t0;\n  let t1;\n  if ($[0] !== name) {\n    t1 = <SharedRuntime.Stringify>hello world {name}</SharedRuntime.Stringify>;\n    $[0] = name;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ name: \"sathya\" }],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Error Handling for Async Component\nDESCRIPTION: The code includes a syntax error message for unhandled cases in the 'for await' loop, indicating that the loop needs proper handling to work correctly within the component's context. This is crucial for improving error management and code robustness.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-for-await-loops.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n  1 | async function Component({items}) {\n  2 |   const x = [];\n> 3 |   for await (const item of items) {\n    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 4 |     x.push(item);\n    | ^^^^^^^^^^^^^^^^^\n  5 |   }\n    | ^^^^ Todo: (BuildHIR::lowerStatement) Handle for-await loops (3:5)\n  6 |   return x;\n  7 | }\n  8 |\n\n```\n\n----------------------------------------\n\nTITLE: Compiled FBT Component Output\nDESCRIPTION: Shows the compiled JavaScript output of the FBT component with runtime optimization for parameter caching and internationalization handling.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-preserve-whitespace-subtree.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport fbt from \"fbt\";\n\n/**\n * Note that fbt whitespace rules apply to the entire fbt subtree,\n * not just direct children of fbt elements.\n * (e.g. here, the JSXText children of the span element also use\n * fbt whitespace rules)\n */\n\nfunction Foo(props) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== props.name) {\n    t0 = fbt._(\n      \"{=m0}\",\n      [\n        fbt._implicitParam(\n          \"=m0\",\n          <span key={props.name}>\n            {fbt._(\n              \"{user name really long description for prettier} !\",\n              [\n                fbt._param(\n                  \"user name really long description for prettier\",\n\n                  props.name,\n                ),\n              ],\n              { hk: \"rdgIJ\" },\n            )}\n          </span>,\n        ),\n      ],\n      { hk: \"32Ufy5\" },\n    );\n    $[0] = props.name;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{ name: \"Jason\" }],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization\nDESCRIPTION: Compiled version of the component with React compiler runtime optimizations, including memoization cache implementation and value comparison checks for performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/global-types/repro-array-filter-known-nonmutate-Boolean.expect.md#2025-04-22_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { Stringify, useIdentity } from \"shared-runtime\";\n\n/**\n * Also see repro-array-map-known-mutate-shape, which calls a global function\n * that mutates its operands.\n */\nfunction Component(t0) {\n  const $ = _c(13);\n  const { value } = t0;\n  let t1;\n  let t2;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = { value: \"foo\" };\n    t2 = { value: \"bar\" };\n    $[0] = t1;\n    $[1] = t2;\n  } else {\n    t1 = $[0];\n    t2 = $[1];\n  }\n  let t3;\n  if ($[2] !== value) {\n    t3 = [t1, t2, { value }];\n    $[2] = value;\n    $[3] = t3;\n  } else {\n    t3 = $[3];\n  }\n  const arr = t3;\n  useIdentity(null);\n  let t4;\n  if ($[4] !== arr) {\n    t4 = arr.filter(Boolean);\n    $[4] = arr;\n    $[5] = t4;\n  } else {\n    t4 = $[5];\n  }\n  const derived = t4;\n  let t5;\n  if ($[6] !== derived) {\n    t5 = derived.at(0);\n    $[6] = derived;\n    $[7] = t5;\n  } else {\n    t5 = $[7];\n  }\n  let t6;\n  if ($[8] !== derived) {\n    t6 = derived.at(-1);\n    $[8] = derived;\n    $[9] = t6;\n  } else {\n    t6 = $[9];\n  }\n  let t7;\n  if ($[10] !== t5 || $[11] !== t6) {\n    t7 = (\n      <Stringify>\n        {t5}\n        {t6}\n      </Stringify>\n    );\n    $[10] = t5;\n    $[11] = t6;\n    $[12] = t7;\n  } else {\n    t7 = $[12];\n  }\n  return t7;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ value: 5 }],\n  sequentialRenders: [{ value: 5 }, { value: 6 }, { value: 6 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component with Mutable State\nDESCRIPTION: A simple React component that initializes a variable, modifies it through a closure, and returns it. This represents the code before React compiler transformation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reassign-primitive-in-context.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let x = 5;\n  let foo = () => {\n    x = {};\n  };\n  foo();\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Advanced Ref Management in React Component\nDESCRIPTION: This snippet enhances the custom ref usage by integrating it with a more complex logic structure using _c from the 'react/compiler-runtime'. It tracks whether the ref has changed and executes a function to print the ref when it does, demonstrating a pattern for conditional side effects based on ref changes in functional components.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/helper-nonreactive.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @inferEffectDependencies\nimport { useEffect, useRef } from \"react\";\nfunction useCustomRef() {\n  const ref = useRef();\n  return ref;\n}\n\nfunction NonReactiveWrapper() {\n  const $ = _c(2);\n  const ref = useCustomRef();\n  let t0;\n  if ($[0] !== ref) {\n    t0 = () => {\n      print(ref);\n    };\n    $[0] = ref;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  useEffect(t0, [ref]);\n}\n```\n\n----------------------------------------\n\nTITLE: React Component Definition with fire function\nDESCRIPTION: This code defines a React component that utilizes the `fire` function from the `react` library within a `useEffect` hook to trigger side effects. The component also uses `print` from `shared-runtime` to print the current value of a ref. It demonstrates how side effects were previously handled before the introduction of `useFire`.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/bailout-retry/bailout-validate-ref-current-access.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @flow @enableFire @panicThreshold(none)\nimport {fire} from 'react';\nimport {print} from 'shared-runtime';\n\ncomponent Component(prop1, ref) {\n  const foo = () => {\n    console.log(prop1);\n  };\n  useEffect(() => {\n    fire(foo(prop1));\n    bar();\n    fire(foo());\n  });\n\n  print(ref.current);\n  return null;\n}\n\n```\n\n----------------------------------------\n\nTITLE: React Compiler Memoization Error\nDESCRIPTION: This error message indicates that the React Compiler skipped optimizing the component because the inferred dependencies for `useMemo` did not match the manually specified dependencies (`[propA?.a, propB.x.y]`). This mismatch could cause the memoized value to change more or less frequently than expected.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.useMemo-infer-less-specific-conditional-access.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n   4 |\n   5 | function Component({propA, propB}) {\n>  6 |   return useMemo(() => {\n     |                  ^^^^^^^\n>  7 |     const x = {};\n     | ^^^^^^^^^^^^^^^^^\n>  8 |     if (propA?.a) {\n     | ^^^^^^^^^^^^^^^^^\n>  9 |       mutate(x);\n     | ^^^^^^^^^^^^^^^^^\n> 10 |       return {\n     | ^^^^^^^^^^^^^^^^^\n> 11 |         value: propB.x.y,\n     | ^^^^^^^^^^^^^^^^^\n> 12 |       };\n     | ^^^^^^^^^^^^^^^^^\n> 13 |     }\n     | ^^^^^^^^^^^^^^^^^\n> 14 |   }, [propA?.a, propB.x.y]);\n     | ^^^^ CannotPreserveMemoization: React Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. The inferred dependencies did not match the manually specified dependencies, which could cause the value to change more or less frequently than expected (6:14)\n  15 | }\n  16 |\n\n```\n\n----------------------------------------\n\nTITLE: Defining a ForwardRef Component with Conditional Hook Call in React JavaScript\nDESCRIPTION: This code snippet defines a React component using forwardRef that incorrectly calls a custom hook conditionally inside the component. The main focus is on showcasing improper usage of hooks, violating the rules of hooks by introducing conditional logic. There are no explicit dependencies listed in the code snippet except 'forwardRef' and potential custom hooks.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.error.invalid-rules-of-hooks-368024110a58.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @skip\n// Passed but should have failed\n\n// Invalid because it\\'s dangerous and might not warn otherwise.\n// This *must* be invalid.\nconst FancyButton = forwardRef(function (props, ref) {\n  if (props.fancy) {\n    useCustomHook();\n  }\n  return <button ref={ref}>{props.children}</button>;\n});\n\n```\n\n----------------------------------------\n\nTITLE: Using GraphQL Fragment in React Component\nDESCRIPTION: This snippet defines a React functional component that utilizes the 'useFragment' hook to fetch a GraphQL fragment for an item. It maps over the fetched items and renders each item using the 'renderItem' function. The component expects props containing an 'item' with GraphQL data.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-call-logical.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {useFragment} from 'shared-runtime';\n\nfunction Component(props) {\n  const item = useFragment(\n    graphql`\n      fragment F on T {\n        id\n      }\n    `,\n    props.item\n  );\n  return item.items?.map(item => renderItem(item)) ?? [];\n}\n\n```\n\n----------------------------------------\n\nTITLE: React Hook Implementation With Compiler Memoization Applied\nDESCRIPTION: The optimized version of useFoo hook with React Compiler's memoization. It uses the _c runtime function to create a cache array and only recalculates values when dependencies change, demonstrating React's optimization strategy for reducing redundant computations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-renaming-ternary-destruction-with-mutation.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { mutate } from \"shared-runtime\";\n\nfunction useFoo(props) {\n  const $ = _c(4);\n  let x;\n  if ($[0] !== props.bar || $[1] !== props.cond || $[2] !== props.foo) {\n    x = [];\n    x.push(props.bar);\n    props.cond ? (([x] = [[]]), x.push(props.foo)) : null;\n    mutate(x);\n    $[0] = props.bar;\n    $[1] = props.cond;\n    $[2] = props.foo;\n    $[3] = x;\n  } else {\n    x = $[3];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ cond: false, foo: 2, bar: 55 }],\n  sequentialRenders: [\n    { cond: false, foo: 2, bar: 55 },\n    { cond: false, foo: 3, bar: 55 },\n    { cond: true, foo: 3, bar: 55 },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Original Conditional Object Creation in React\nDESCRIPTION: Input code showing a function that conditionally creates objects based on a condition. The function takes multiple parameters and returns an object containing either parameter b or c.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/obj-literal-cached-in-if-else.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(a, b, c, d) {\n  let x = {};\n  if (someVal) {\n    x = {b};\n  } else {\n    x = {c};\n  }\n\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Memoized React Component with Invalid Hook Condition\nDESCRIPTION: A memo component that demonstrates an incorrect implementation of hooks by conditionally calling a custom hook, which violates React's core hook usage rules\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.error.invalid-rules-of-hooks-8566f9a360e2.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst MemoizedButton = memo(function (props) {\n  if (props.fancy) {\n    useCustomHook();\n  }\n  return <button>{props.children}</button>;\n});\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Memoization and Function Extraction\nDESCRIPTION: Compiler output showing how React transforms the component. The compiler extracts the arrow function to a separate _temp function and implements memoization using Symbol.for(\"react.memo_cache_sentinel\") to optimize rendering performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-nested-object-method.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // @compilationMode(infer)\n\nimport { Stringify } from \"shared-runtime\";\n\nfunction Test() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const context = {\n      testFn() {\n        return _temp;\n      },\n    };\n\n    t0 = <Stringify value={context} shouldInvokeFns={true} />;\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\nfunction _temp() {\n  return \"test\";\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Test,\n  params: [{}],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a test fixture for React component in JavaScript\nDESCRIPTION: This JavaScript code defines a `FIXTURE_ENTRYPOINT` object. It contains the `useFoo` function, an array of `params` with sample inputs, and a `sequentialRenders` array for testing different scenarios with varying input values and conditions, including null and empty objects.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-unpoisoned/jump-target-within-scope-label.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{input: {a: {b: 2}}, cond: false}],\n  sequentialRenders: [\n    {input: {a: {b: 2}}, cond: false},\n    // preserve nullthrows\n    {input: null, cond: false},\n    {input: null, cond: true},\n    {input: { }, cond: false},\n    {input: {a: {b: null}}, cond: false},\n    {input: {a: null}, cond: false},\n    {input: {a: {b: 3}}, cond: false},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Evaluating React Component with Sequential Renders in JavaScript\nDESCRIPTION: This JavaScript snippet defines a function `Component` that processes `props.values` and assigns values to `x` based on conditions. The component is associated with `FIXTURE_ENTRYPOINT`, allowing sequential renders to evaluate the component behavior when different prop values are passed. The focus is on how `x` is computed reactively through multiple renders.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-forin-collection.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  let x;\n  for (const key in props.values) {\n    const i = parseInt(key, 10);\n    if (i > 10) {\n      x = 10;\n    } else {\n      x = 1;\n    }\n  }\n  // The values assigned to `x` are non-reactive, but the value of `x`\n  // depends on the \"control\" variable `i`, whose value is derived from\n  // `props.values` which is reactive.\n  // Therefore x should be treated as reactive too.\n  return [x];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [],\n  sequentialRenders: [\n    {values: {'12': true}},\n    {values: {'12': true}},\n    {values: {'1': true}},\n    {values: {'1': true}},\n    {values: {'12': true}},\n    {values: {'1': true}},\n    {values: {'12': true}},\n    {values: {'1': true}},\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Initializing Component with JavaScript\nDESCRIPTION: This snippet defines a simple JavaScript function named 'component' which initializes and manipulates an object. The function exports 'FIXTURE_ENTRYPOINT', indicating its use in a React context. The code requires no external dependencies, focusing solely on object manipulation. Input 'a' is expected, modifying the component's state internally.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capture-indirect-mutate-alias.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component(a) {\n  let x = {a};\n  const f0 = function () {\n    let q = x;\n    const f1 = function () {\n      q.b = 1;\n    };\n    f1();\n  };\n  f0();\n\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Calculating Sum with Conditional Increments in JavaScript\nDESCRIPTION: This function 'foo' takes props as input, performs a loop with conditional increments, and returns a calculated sum. It uses props.min, props.max, props.cond, and props.increment for loop control.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-logical.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(props) {\n  let y = 0;\n  for (\n    let x = 0;\n    x > props.min && x < props.max;\n    x += props.cond ? props.increment : 2\n  ) {\n    x *= 2;\n    y += x;\n  }\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Router Component in JavaScript\nDESCRIPTION: This code defines a Router function that takes a title and a mapping as parameters. It creates an array of [title, entry] pairs from the mapping values. The function is designed to be used with React.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-of-iterator-of-immutable-collection.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Router({title, mapping}) {\n  const array = [];\n  for (let entry of mapping.values()) {\n    array.push([title, entry]);\n  }\n  return array;\n}\n\nconst routes = new Map([\n  ['about', '/about'],\n  ['contact', '/contact'],\n]);\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Router,\n  params: [],\n  sequentialRenders: [\n    {\n      title: 'Foo',\n      mapping: routes,\n    },\n    {\n      title: 'Bar',\n      mapping: routes,\n    },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Sequence Component Definition (Input)\nDESCRIPTION: Defines a simple JavaScript function component named `sequence` that utilizes the comma operator within expressions and a `while` loop. The function `foo` is also defined, though it does nothing.  The function returns a value that is computed using the comma operator. It shows the original component before any transformation or optimization is applied.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/sequence-expression.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction sequence(props) {\n  let x = (null, Math.max(1, 2), foo());\n  while ((foo(), true)) {\n    x = (foo(), 2);\n  }\n  return x;\n}\n\nfunction foo() {}\n\n```\n\n----------------------------------------\n\nTITLE: React Hooks Validation Error Output\nDESCRIPTION: Shows the error messages produced when attempting to use React Hooks inside loops and conditions. The errors indicate violations of React's Rules of Hooks, specifically the rule about consistent hook calling order.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-rules-of-hooks-1b9527f967f3.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n   5 | function useHookInLoops() {\n   6 |   while (a) {\n>  7 |     useHook1();\n     |     ^^^^^^^^ InvalidReact: Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning) (7:7)\n\nInvalidReact: Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning) (9:9)\n\nInvalidReact: Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning) (12:12)\n\nInvalidReact: Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning) (14:14)\n   8 |     if (b) return;\n   9 |     useHook2();\n  10 |   }\n```\n\n----------------------------------------\n\nTITLE: Input Implementation of useFoo Function with Conditional Object Creation\nDESCRIPTION: The input version of a useFoo function that conditionally creates objects with different property values based on a condition parameter. This demonstrates an edge case where the compiler could optimize by merging re-orderability across phi nodes.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/todo-merge-ssa-phi-access-nodes.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {\n  identity,\n  makeObject_Primitives,\n  setPropertyByKey,\n} from 'shared-runtime';\n\n/**\n * A bit of an edge case, but we could further optimize here by merging\n * re-orderability of nodes across phis.\n */\nfunction useFoo(cond) {\n  let x;\n  if (cond) {\n    /** start of scope for x_@0 */\n    x = {};\n    setPropertyByKey(x, 'a', {b: 2});\n    /** end of scope for x_@0 */\n    Math.max(x.a.b, 0);\n  } else {\n    /** start of scope for x_@1 */\n    x = makeObject_Primitives();\n    setPropertyByKey(x, 'a', {b: 3});\n    /** end of scope for x_@1 */\n    Math.max(x.a.b, 0);\n  }\n  /**\n   * At this point, we have a phi node.\n   * x_@2 = phi(x_@0, x_@1)\n   *\n   * We can assume that both x_@0 and x_@1 both have non-null `x.a` properties,\n   * so we can infer that x_@2 does as well.\n   */\n\n  // Here, y should take a dependency on `x.a.b`\n  const y = [];\n  if (identity(cond)) {\n    y.push(x.a.b);\n  }\n  return y;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [true],\n};\n```\n\n----------------------------------------\n\nTITLE: React Error Message for Invalid Ref Access during Render\nDESCRIPTION: This error message is triggered by the React component when it tries to access ref.current during render. It specifically points to the reset() function call which violates React's rule about not accessing ref values during render.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.useCallback-accesses-ref-mutated-later-via-function-preserve-memoization.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n  15 |     ref.current.inner = null;\n  16 |   };\n> 17 |   reset();\n     |   ^^^^^ InvalidReact: This function accesses a ref value (the `current` property), which may not be accessed during render. (https://react.dev/reference/react/useRef) (17:17)\n\nInvalidReact: Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef) (17:17)\n  18 |\n  19 |   return <input onChange={onChange} />;\n  20 | }\n```\n\n----------------------------------------\n\nTITLE: Initializing React Component with Props - JavaScript\nDESCRIPTION: This function defines a simple React component that initializes an array and pushes a prop value into it. It demonstrates basic prop handling in function components. The expected input is a 'props' object containing a key 'a', and it outputs an array containing the value of 'a'.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/iife-return-modified-later.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const items = (() => {\n    return [];\n  })();\n  items.push(props.a);\n  return items;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{a: {}}],\n};\n```\n\n----------------------------------------\n\nTITLE: Rendering Components with Prop-based Conditional Logic in React JavaScript\nDESCRIPTION: The code defines two components, ComponentA and ComponentB, using JavaScript within a React framework to manage conditional rendering based on props. Both components utilize arrays and a conditional logic via a comparison array `_c` to optimize re-renders when specific props change. ComponentA and ComponentB share similar logic, with ComponentB further allowing mutation checks via `mayMutate()` for more granular control.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/conditional-on-mutable.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @enablePropagateDepsInHIR\nfunction ComponentA(props) {\n  const a = [];\n  const b = [];\n  if (b) {\n    a.push(props.p0);\n  }\n  if (props.p1) {\n    b.push(props.p2);\n  }\n  return <Foo a={a} b={b} />;\n}\n\nfunction ComponentB(props) {\n  const a = [];\n  const b = [];\n  if (mayMutate(b)) {\n    a.push(props.p0);\n  }\n  if (props.p1) {\n    b.push(props.p2);\n  }\n  return <Foo a={a} b={b} />;\n}\n\nfunction Foo() {}\nfunction mayMutate() {}\n```\n\n----------------------------------------\n\nTITLE: React Component Implementation\nDESCRIPTION: Duplicate implementation of the React component with debugger statements and fixture export, but with double quotes in the export object.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/debugger.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  debugger;\n  if (props.cond) {\n    debugger;\n  } else {\n    while (props.cond) {\n      debugger;\n    }\n  }\n  debugger;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [\"TodoAdd\"],\n  isComponent: \"TodoAdd\",\n};\n```\n\n----------------------------------------\n\nTITLE: Using Conditional Dependencies in JavaScript\nDESCRIPTION: The function `useCondDepInConditionalExpr` takes in props and a condition to return a computed value based on the condition's outcome. It ensures that `props.a.b` is appropriately used as an unconditional dependency, impacting the reactive scope's output. Requirements include `identity` and `addOne` from 'shared-runtime' for functionality, while inputs are `props` and `cond`, with outputs returning the computed value `x`.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/cfg-condexpr.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// props.a.b should be added as a unconditional dependency to the reactive\n// scope that produces x, since it is accessed unconditionally in all cfg\n// paths\n\nimport {identity, addOne} from 'shared-runtime';\n\nfunction useCondDepInConditionalExpr(props, cond) {\n  const x = identity(cond) ? addOne(props.a.b) : identity(props.a.b);\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useCondDepInConditionalExpr,\n  params: [{a: {b: 2}}, true],\n};\n\n```\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\"; // props.a.b should be added as a unconditional dependency to the reactive\n// scope that produces x, since it is accessed unconditionally in all cfg\n// paths\n\nimport { identity, addOne } from \"shared-runtime\";\n\nfunction useCondDepInConditionalExpr(props, cond) {\n  const $ = _c(3);\n  let t0;\n  if ($[0] !== cond || $[1] !== props.a.b) {\n    t0 = identity(cond) ? addOne(props.a.b) : identity(props.a.b);\n    $[0] = cond;\n    $[1] = props.a.b;\n    $[2] = t0;\n  } else {\n    t0 = $[2];\n  }\n  const x = t0;\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useCondDepInConditionalExpr,\n  params: [{ a: { b: 2 } }, true],\n};\n\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component with Optimizations\nDESCRIPTION: Compiled version of the component with added memoization and optimization. Uses compiler-runtime utilities to cache computed values and conditional renders for better performance.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-separate-scopes-for-divs.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nimport { identity } from \"shared-runtime\";\n\nconst DISPLAY = true;\nfunction Component(t0) {\n  const $ = _c(9);\n  const { cond: t1, id } = t0;\n  const cond = t1 === undefined ? false : t1;\n  let t2;\n  if ($[0] !== id) {\n    t2 = identity(styles.a, id !== null ? styles.b : {});\n    $[0] = id;\n    $[1] = t2;\n  } else {\n    t2 = $[1];\n  }\n  let t3;\n  if ($[2] !== t2) {\n    t3 = <div className={t2} />;\n    $[2] = t2;\n    $[3] = t3;\n  } else {\n    t3 = $[3];\n  }\n  let t4;\n  if ($[4] !== cond) {\n    t4 = cond === false && (\n      <div className={identity(styles.c, DISPLAY ? styles.d : {})} />\n    );\n    $[4] = cond;\n    $[5] = t4;\n  } else {\n    t4 = $[5];\n  }\n  let t5;\n  if ($[6] !== t3 || $[7] !== t4) {\n    t5 = (\n      <>\n        {t3}\n        {t4}\n      </>\n    );\n    $[6] = t3;\n    $[7] = t4;\n    $[8] = t5;\n  } else {\n    t5 = $[8];\n  }\n  return t5;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ cond: false, id: 42 }],\n  sequentialRenders: [\n    { cond: false, id: 4 },\n    { cond: true, id: 4 },\n    { cond: true, id: 42 },\n  ],\n};\n\nconst styles = {\n  a: \"a\",\n  b: \"b\",\n  c: \"c\",\n  d: \"d\",\n};\n```\n\n----------------------------------------\n\nTITLE: Input React Component with Unary Operators\nDESCRIPTION: Original React component implementation that tests various unary operators (+, -, void, delete, !, ~, typeof) on an object property. Returns an object containing the results of these operations.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unary-expr.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction component(a) {\n  let t = {t: a};\n  let z = +t.t;\n  let q = -t.t;\n  let p = void t.t;\n  let n = delete t.t;\n  let m = !t.t;\n  let e = ~t.t;\n  let f = typeof t.t;\n  return {z, p, q, n, m, e, f};\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: component,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Base Component in React - JavaScript\nDESCRIPTION: This snippet defines a simple React component that updates items in an array to indicate they have been updated. It utilizes props and returns two arrays, one original and one updated, but doesn't utilize the props in this implementation. Expected inputs are the component's props, while the outputs are an array of original and updated items.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-map-mutable-array-mutating-lambda-noAlias.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const x = [];\n  const y = x.map(item => {\n    item.updated = true;\n    return item;\n  });\n  return [x, y];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n  isComponent: false,\n};\n```\n\n----------------------------------------\n\nTITLE: React Component Input Implementation\nDESCRIPTION: Original source code showing a React component that conditionally reassigns a variable based on a shouldReassign prop using conditionalInvoke utility.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/context-variable-reactive-implicit-control-flow.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {conditionalInvoke} from 'shared-runtime';\n\n// same as context-variable-reactive-explicit-control-flow.js, but make\n// the control flow implicit\n\nfunction Component({shouldReassign}) {\n  let x = null;\n  const reassign = () => {\n    x = 2;\n  };\n  conditionalInvoke(shouldReassign, reassign);\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{shouldReassign: true}],\n  sequentialRenders: [{shouldReassign: false}, {shouldReassign: true}],\n};\n```\n\n----------------------------------------\n\nTITLE: Original React Component Implementation\nDESCRIPTION: This snippet shows the original implementation of a React component. It creates an array with objects and the prop value, joins it with a closure, and returns the result.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-join.expect.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component(props) {\n  const x = [{}, [], props.value];\n  const y = x.join(() => 'this closure gets stringified, not called');\n  foo(y);\n  return [x, y];\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing FBT with Multiple Plural Tags in React\nDESCRIPTION: A React component demonstrating the use of multiple fbt:plural tags within a single fbt component. The component displays text about rewrites and months, with pluralization based on count parameters. The implementation includes detailed comments about inconsistencies between standard fbt and 'Forget' evaluation.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/error.todo-multiple-fbt-plural.expect.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport fbt from 'fbt';\n\n/**\n * Forget + fbt inconsistency. Evaluator errors with the following\n *   Found differences in evaluator results\n *   Non-forget (expected):\n *   (kind: ok) 1 rewrite to Rust  2 months traveling\n *   Forget:\n *   (kind: ok) 1 rewrites to Rust  2 months traveling\n *\n * The root issue here is that fbt:plural/enum/pronoun read `.start` and `.end` from\n * babel nodes to slice into source strings for some complex dedupe logic\n * (see [_getStringVariationCombinations](https://github.com/facebook/fbt/blob/main/packages/babel-plugin-fbt/src/JSFbtBuilder.js#L297))\n *\n *\n * Since Forget does not add `.start` and `.end` for babel nodes it synthesizes,\n * [getRawSource](https://github.com/facebook/fbt/blob/main/packages/babel-plugin-fbt/src/FbtUtil.js#L666-L673)\n * simply returns the whole source code string. As a result, all fbt nodes dedupe together\n * and _getStringVariationCombinations ends up early exiting (before adding valid candidate values).\n *\n *\n *\n * For fbt:plural tags specifically, the `count` node require that a `.start/.end`\n * (see [code in FbtPluralNode](https://github.com/facebook/fbt/blob/main/packages/babel-plugin-fbt/src/fbt-nodes/FbtPluralNode.js#L87-L90))\n */\nfunction Foo({rewrites, months}) {\n  return (\n    <fbt desc=\"Test fbt description\">\n      <fbt:plural count={rewrites} name=\"number of rewrites\" showCount=\"yes\">\n        rewrite\n      </fbt:plural>\n      to Rust \n      <fbt:plural count={months} name=\"number of months\" showCount=\"yes\">\n        month\n      </fbt:plural>\n      traveling\n    </fbt>\n  );\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{rewrites: 1, months: 2}],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled React Component\nDESCRIPTION: This is the compiled version of the React component using React's compiler. The code memoizes the rendering based on `props.cond` and uses a compiler runtime helper `_c`. The `onChange` handler and conditional rendering logic are preserved within the memoized block.\nSOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/todo-function-expression-captures-value-later-frozen.expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] !== props.cond) {\n    const x = {};\n\n    const onChange = (e) => {\n      maybeMutate(x, e.target.value);\n    };\n    if (props.cond) {\n    }\n\n    onChange();\n    t0 = <Foo value={x} />;\n    $[0] = props.cond;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n\n```"
  }
]