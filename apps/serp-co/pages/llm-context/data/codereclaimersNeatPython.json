[
  {
    "owner": "codereclaimers",
    "repo": "neat-python",
    "content": "TITLE: Implementing Population Class for NEAT Algorithm in Python\nDESCRIPTION: This class implements the core evolution algorithm for NEAT. It handles fitness evaluation, generation creation, and species partitioning. The run method executes the algorithm for a specified number of generations or until a solution is found.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/module_summaries.rst#2025-04-23_snippet_39\n\nLANGUAGE: python\nCODE:\n```\nclass Population(config, initial_state=None):\n    \"\"\"\n    This class implements the core evolution algorithm:\n    1. Evaluate fitness of all genomes.\n    2. Check to see if the termination criterion is satisfied; exit if it is.\n    3. Generate the next generation from the current population.\n    4. Partition the new generation into species based on genetic similarity.\n    5. Go to 1.\n    \"\"\"\n\n    def run(fitness_function, n=None):\n        \"\"\"\n        Runs NEAT's genetic algorithm for at most n generations.  If n\n        is None, run until a solution is found or total extinction occurs.\n        \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Running NEAT for XOR Problem in Python\nDESCRIPTION: Demonstrates the steps to run NEAT for solving the XOR problem, including creating a Config object, initializing a Population, and running the evolution process.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/xor_example.rst#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nconfig = neat.Config(neat.DefaultGenome, neat.DefaultReproduction,\n                     neat.DefaultSpeciesSet, neat.DefaultStagnation,\n                     config_path)\n\npop = neat.Population(config)\npop.add_reporter(neat.StdOutReporter(True))\nstats = neat.StatisticsReporter()\npop.add_reporter(stats)\npop.add_reporter(neat.Checkpointer(5))\n\nwinner = pop.run(eval_genomes, 300)\n```\n\n----------------------------------------\n\nTITLE: Fitness Function Implementation for XOR using NEAT-Python\nDESCRIPTION: Implements the fitness function for evaluating genomes in the XOR problem. It creates a feed-forward neural network, computes outputs for each input case, and calculates fitness based on the error between expected and actual outputs.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/xor_example.rst#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef eval_genomes(genomes, config):\n    for genome_id, genome in genomes:\n        net = neat.nn.FeedForwardNetwork.create(genome, config)\n        genome.fitness = 4.0\n        for xi, xo in zip(xor_inputs, xor_outputs):\n            output = net.activate(xi)\n            genome.fitness -= (output[0] - xo[0]) ** 2\n```\n\n----------------------------------------\n\nTITLE: Implementing DefaultGenomeConfig Class in Python for NEAT\nDESCRIPTION: Defines the DefaultGenomeConfig class which handles configuration for the DefaultGenome class. It manages parameters for genome structure, mutation rates, and includes methods for adding activation and aggregation functions.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/module_summaries.rst#2025-04-23_snippet_29\n\nLANGUAGE: python\nCODE:\n```\nclass DefaultGenomeConfig(params):\n    def add_activation(self, name, func):\n        # Adds a new activation function\n        pass\n\n    def add_aggregation(self, name, func):\n        # Adds a new aggregation function\n        pass\n\n    def save(self, f):\n        # Saves the initial_connection configuration and writes out other parameters\n        pass\n\n    def get_new_node_key(self, node_dict):\n        # Finds the next unused node key\n        pass\n```\n\n----------------------------------------\n\nTITLE: Implementing Parallel Evaluation in NEAT-Python\nDESCRIPTION: The ParallelEvaluator class runs evaluation functions in parallel subprocesses to evaluate multiple genomes simultaneously, improving performance for computationally intensive fitness evaluations.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/module_summaries.rst#2025-04-23_snippet_38\n\nLANGUAGE: Python\nCODE:\n```\nclass ParallelEvaluator(num_workers, eval_function, timeout=None, maxtasksperchild=None):\n    \"\"\"\n    Runs evaluation functions in parallel subprocesses in order to evaluate multiple genomes at once.\n    \"\"\"\n    # Implementation not shown in documentation\n```\n\n----------------------------------------\n\nTITLE: Defining the FeedForwardNetwork class in NEAT-Python\nDESCRIPTION: A feed-forward neural network implementation for NEAT that takes inputs, outputs and node evaluations. It includes methods for activation and creating networks from genomes.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/module_summaries.rst#2025-04-23_snippet_34\n\nLANGUAGE: Python\nCODE:\n```\nclass FeedForwardNetwork(inputs, outputs, node_evals):\n    \"\"\"\n    A straightforward (no pun intended) feed-forward neural network NEAT implementation.\n    \"\"\"\n    \n    def activate(inputs):\n        \"\"\"\n        Feeds the inputs into the network and returns the resulting outputs.\n        \"\"\"\n        # Implementation not shown in documentation\n        \n    @staticmethod\n    def create(genome, config):\n        \"\"\"\n        Receives a genome and returns its phenotype.\n        \"\"\"\n        # Implementation not shown in documentation\n```\n\n----------------------------------------\n\nTITLE: Defining a CTRNN Class for Continuous-Time Recurrent Neural Networks in Python\nDESCRIPTION: This code snippet defines the CTRNN class for continuous-time recurrent neural networks, including methods for resetting the network, advancing the simulation, and creating a CTRNN phenotype from a genome.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/module_summaries.rst#2025-04-23_snippet_19\n\nLANGUAGE: Python\nCODE:\n```\nclass CTRNN(inputs, outputs, node_evals):\n\n  Sets up the ctrnn network itself.\n\n  .. index:: recurrent\n\n  def reset():\n    Resets the time and all node activations to 0 (necessary due to otherwise retaining state via recurrent connections).\n\n  .. index:: ! continuous-time\n\n  def advance(inputs, advance_time, time_step=None):\n    Advance the simulation by the given amount of time, assuming that inputs are\n    constant at the given values during the simulated time.\n\n    :param inputs: The values for the input nodes.\n    :type inputs: list(float)\n    :param advance_time: How much time to advance the network before returning the resulting outputs.\n    :type advance_time: float\n    :param time_step: How much time per step to advance the network; the default of ``None`` will currently result in an error, but it is planned to determine it automatically.\n    :type time_step: float or None\n    :return: The values for the output nodes.\n    :rtype: list(float)\n    :raises NotImplementedError: If a ``time_step`` is not given.\n    :raises RuntimeError: If the number of ``inputs`` does not match the number of input nodes\n\n  @staticmethod\n  def create(genome, config, time_constant):\n    Receives a genome and returns its phenotype (a CTRNN with CTRNNNodeEval nodes).\n\n    :param genome: A genome.DefaultGenome instance.\n    :type genome: instance\n    :param config: A config.Config instance.\n    :type config: instance\n    :param time_constant: Used for the CTRNNNodeEval initializations.\n    :type time_constant: float\n```\n\n----------------------------------------\n\nTITLE: Implementing RecurrentNetwork class in NEAT-Python\nDESCRIPTION: A recurrent neural network implementation for NEAT that maintains state between activations. It includes methods for activation, reset, and creating networks from genomes.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/module_summaries.rst#2025-04-23_snippet_35\n\nLANGUAGE: Python\nCODE:\n```\nclass RecurrentNetwork(inputs, outputs, node_evals):\n    \"\"\"\n    A recurrent (but otherwise straightforward) neural network NEAT implementation.\n    \"\"\"\n    \n    def reset():\n        \"\"\"\n        Resets all node activations to 0 (necessary due to otherwise retaining state via recurrent connections).\n        \"\"\"\n        # Implementation not shown in documentation\n        \n    def activate(inputs):\n        \"\"\"\n        Feeds the inputs into the network and returns the resulting outputs.\n        \"\"\"\n        # Implementation not shown in documentation\n        \n    @staticmethod\n    def create(genome, config):\n        \"\"\"\n        Receives a genome and returns its phenotype.\n        \"\"\"\n        # Implementation not shown in documentation\n```\n\n----------------------------------------\n\nTITLE: Defining DefaultReproduction Class in Python\nDESCRIPTION: Implements the default NEAT-Python reproduction scheme with explicit fitness sharing and fixed-time species stagnation. This class handles the creation and reproduction of genomes during the evolutionary process.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/module_summaries.rst#2025-04-23_snippet_44\n\nLANGUAGE: python\nCODE:\n```\nclass DefaultReproduction(config, reporters, stagnation):\n    \"\"\"Implements the default NEAT-python reproduction scheme.\"\"\"\n\n    @classmethod\n    def parse_config(param_dict):\n        \"\"\"Parses configuration for reproduction parameters.\"\"\"\n        pass\n\n    def create_new(genome_type, genome_config, num_genomes):\n        \"\"\"Creates new genomes.\"\"\"\n        pass\n\n    @staticmethod\n    def compute_spawn(adjusted_fitness, previous_sizes, pop_size, min_species_size):\n        \"\"\"Computes the number of offspring for each species.\"\"\"\n        pass\n\n    def reproduce(config, species, pop_size, generation):\n        \"\"\"Creates the next generation of the population.\"\"\"\n        pass\n```\n\n----------------------------------------\n\nTITLE: Visualizing NEAT Results for XOR Problem in Python\nDESCRIPTION: Shows how to use the visualize module to create plots of fitness and species over generations, as well as visualizing the structure of the winning network.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/xor_example.rst#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nvisualize.plot_stats(stats, ylog=False, view=True)\nvisualize.plot_species(stats, view=True)\n\nnode_names = {-1:'A', -2: 'B', 0:'A XOR B'}\nvisualize.draw_net(config, winner, True, node_names=node_names)\n```\n\n----------------------------------------\n\nTITLE: DefaultStagnation Class for Managing Stagnant Species\nDESCRIPTION: Implements stagnation detection to identify and remove species that fail to improve over a configurable number of generations. This class helps maintain evolutionary progress by eliminating unproductive species.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/module_summaries.rst#2025-04-23_snippet_48\n\nLANGUAGE: python\nCODE:\n```\nclass DefaultStagnation(config, reporters):\n\n  Keeps track of whether species are making progress and helps remove ones that, for a\n  :ref:`configurable number of generations <max-stagnation-label>`, are not. Inherits from :py:class:`config.DefaultClassConfig` the required class\n  method :py:meth:`write_config <config.DefaultClassConfig.write_config>`.\n\n  :param config: Configuration object; in this implementation, a :py:class:`config.DefaultClassConfig` instance, but should be treated as opaque outside this class.\n  :type config: :datamodel:`instance <index-48>`\n  :param reporters: A :py:class:`ReporterSet <reporting.ReporterSet>` instance with reporters that may need activating; not currently used.\n  :type reporters: :datamodel:`instance <index-48>`\n\n  .. versionchanged:: 0.92\n    Configuration changed to use DefaultClassConfig, instead of a dictionary, and inherit write_config.\n\n  .. py:classmethod:: parse_config(param_dict)\n\n    Required interface method. Provides defaults for :ref:`species_fitness_func <species-fitness-func-label>`,\n    :ref:`max_stagnation <max-stagnation-label>`, and :ref:`species_elitism <species-elitism-label>` parameters and updates them\n    from the configuration file, in this implementation using :py:class:`config.DefaultClassConfig`.\n\n    :param param_dict: Dictionary of parameters from configuration file.\n    :type param_dict: dict(str, str)\n    :return: Stagnation configuration object; considered opaque by rest of code, so current type returned is not required for interface.\n    :rtype: DefaultClassConfig :datamodel:`instance <index-48>`\n\n    .. versionchanged:: 0.92\n```\n\n----------------------------------------\n\nTITLE: DefaultSpeciesSet Class for Population Speciation\nDESCRIPTION: Implements the default speciation scheme by grouping genomes into species based on genetic similarity. This class manages species creation, placement of genomes, and provides methods to retrieve species information.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/module_summaries.rst#2025-04-23_snippet_47\n\nLANGUAGE: python\nCODE:\n```\nclass DefaultSpeciesSet(config, reporters):\n\n  Encapsulates the default speciation scheme by configuring it and performing the speciation function (placing genomes into species by genetic similarity).\n  :py:class:`reproduction.DefaultReproduction` currently depends on this having a ``species`` attribute consisting of a dictionary of species keys to species.\n  Inherits from :py:class:`config.DefaultClassConfig` the required class method :py:meth:`write_config <config.DefaultClassConfig.write_config>`.\n\n  :param config: A configuration object, in this implementation a :py:class:`config.Config` :datamodel:`instance <index-48>`.\n  :type config: :datamodel:`instance <index-48>`\n  :param reporters: A :py:class:`ReporterSet <reporting.ReporterSet>` instance giving reporters to be notified about :term:`genomic distance` statistics.\n  :type reporters: :datamodel:`instance <index-48>`\n\n  .. versionchanged:: 0.92\n    Configuration changed to use DefaultClassConfig, instead of a dictionary, and inherit write_config.\n\n  .. py:classmethod:: parse_config(param_dict)\n\n    Required interface method. Currently, the only configuration parameter is the :ref:`compatibility_threshold <compatibility-threshold-label>`; this\n    method provides a default for it and updates it from the configuration file, in this implementation using :py:class:`config.DefaultClassConfig`.\n\n    :param param_dict: Dictionary of parameters from configuration file.\n    :type param_dict: dict(str, str)\n    :return: SpeciesSet configuration object; considered opaque by rest of code, so current type returned is not required for interface.\n    :rtype: DefaultClassConfig :datamodel:`instance <index-48>`\n\n    .. versionchanged:: 0.92\n      Configuration changed to use DefaultClassConfig instead of a dictionary.\n\n  .. index:: ! genomic distance\n  .. index:: compatibility_threshold\n  .. index:: info()\n\n  .. py:method:: speciate(config, population, generation)\n\n    Required interface method. Place genomes into species by genetic similarity (:term:`genomic distance`). TODO: The current code has a `docstring`\n    stating that there may be a problem if all old species representatives are not dropped for each generation; it is not clear how this is consistent with the\n    code in :py:meth:`reproduction.DefaultReproduction.reproduce`, such as for :ref:`elitism <elitism-label>`. TODO: Check if sorting the unspeciated\n    genomes by fitness will improve speciation (by making the highest-fitness member of a species its representative).\n\n    :param config: :py:class:`Config <config.Config>` instance.\n    :type config: :datamodel:`instance <index-48>`\n    :param population: Population as per the output of :py:meth:`DefaultReproduction.reproduce <reproduction.DefaultReproduction.reproduce>`.\n    :type population: dict(int, :datamodel:`instance <index-48>`)\n    :param int generation: Current :term:`generation` number.\n\n  .. py:method:: get_species_id(individual_id)\n\n    Required interface method (used by :py:class:`reporting.StdOutReporter`). Retrieves species :term:`id/key <key>` for a given genome id/key.\n\n    :param int individual_id: Genome id/:term:`key`.\n    :return: Species id/:term:`key`.\n    :rtype: :pytypes:`int <typesnumeric>`\n\n  .. py:method:: get_species(individual_id)\n\n    Retrieves species object for a given genome :term:`id/key <key>`. May become a required interface method, and useful for some fitness\n    functions already.\n\n    :param int individual_id: Genome id/:term:`key`.\n    :return: :py:class:`Species <species.Species>` containing the genome corresponding to the id/key.\n    :rtype: :datamodel:`instance <index-48>`\n```\n\n----------------------------------------\n\nTITLE: Defining BaseGene Class in Python for NEAT\nDESCRIPTION: Defines the BaseGene class which handles common functions for node and connection genes, including crossover and mutation methods. It manages gene attributes and provides methods for initialization, mutation, copying, and crossover operations.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/module_summaries.rst#2025-04-23_snippet_26\n\nLANGUAGE: python\nCODE:\n```\nclass BaseGene(key):\n    def __str__(self):\n        # Converts gene attributes into a printable format\n        pass\n\n    def __lt__(self, other):\n        # Allows sorting genes by keys\n        pass\n\n    @classmethod\n    def parse_config(cls, config, param_dict):\n        # Placeholder; parameters are entirely in gene attributes\n        pass\n\n    @classmethod\n    def get_config_params(cls):\n        # Fetches configuration parameters from each gene class' _gene_attributes list\n        pass\n\n    def init_attributes(self, config):\n        # Initializes its gene attributes using the supplied configuration object\n        pass\n\n    def mutate(self, config):\n        # Mutates (possibly) its gene attributes using the supplied configuration object\n        pass\n\n    def copy(self):\n        # Makes a copy of itself, including its subclass, key, and all gene attributes\n        pass\n\n    def crossover(self, gene2):\n        # Creates a new gene via crossover - randomly inheriting attributes from its parents\n        pass\n```\n\n----------------------------------------\n\nTITLE: Implementing DefaultGenome Class Constructor\nDESCRIPTION: Class definition for DefaultGenome that represents a genome for generalized neural networks. Takes a key parameter as identifier for the individual genome.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/module_summaries.rst#2025-04-23_snippet_30\n\nLANGUAGE: python\nCODE:\n```\nclass DefaultGenome(key):\n    \"\"\"A genome for generalized neural networks\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Population Reproduction Method in NEAT-Python\nDESCRIPTION: Method to generate the next generation's population based on current species, configuration, and stagnation criteria.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/reproduction-interface.rst#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nreproduce(self, config, species, pop_size, generation)\n```\n\n----------------------------------------\n\nTITLE: Implementing DefaultConnectionGene Class in Python for NEAT\nDESCRIPTION: Defines the DefaultConnectionGene class which extends BaseGene and is specific to connection genes. It includes methods for calculating genetic distances between homologous connection genes.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/module_summaries.rst#2025-04-23_snippet_28\n\nLANGUAGE: python\nCODE:\n```\nclass DefaultConnectionGene(BaseGene):\n    def distance(self, other, config):\n        # Determines the degree of differences between connection genes\n        pass\n```\n\n----------------------------------------\n\nTITLE: Saving Checkpoint in NEAT-Python\nDESCRIPTION: Saves the current simulation state, including population, species, and generation information, to a checkpoint file. The filename is constructed using a prefix and the generation number.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/module_summaries.rst#2025-04-23_snippet_15\n\nLANGUAGE: python\nCODE:\n```\ndef save_checkpoint(config, population, species, generation):\n  Saves the current simulation (including randomization) state to (if using the default ``neat-checkpoint-`` for ``filename_prefix``)\n  :file:`neat-checkpoint-{generation}`, with ``generation`` being the generation number.\n```\n\n----------------------------------------\n\nTITLE: Implementing IZNN class for Izhikevich neural model\nDESCRIPTION: The IZNN class sets up and simulates a network of Izhikevich neurons. It includes methods for advancing simulation time, resetting neurons, and creating networks from genomes.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/module_summaries.rst#2025-04-23_snippet_36\n\nLANGUAGE: Python\nCODE:\n```\nclass IZNN(neurons, inputs, outputs):\n    \"\"\"\n    Sets up the network itself and simulates it using the connections and neurons.\n    \"\"\"\n    \n    def set_inputs(inputs):\n        \"\"\"\n        Assigns input voltages.\n        \"\"\"\n        # Implementation not shown in documentation\n        \n    def reset():\n        \"\"\"\n        Resets all neurons to their default state.\n        \"\"\"\n        # Implementation not shown in documentation\n        \n    def get_time_step_msec():\n        \"\"\"\n        Returns a suggested time step; currently hardwired to 0.05.\n        \"\"\"\n        # Implementation not shown in documentation\n        \n    def advance(dt_msec):\n        \"\"\"\n        Advances simulation time for all neurons in the network by the input number of milliseconds.\n        \"\"\"\n        # Implementation not shown in documentation\n        \n    @staticmethod\n    def create(genome, config):\n        \"\"\"\n        Receives a genome and returns its phenotype (a neural network).\n        \"\"\"\n        # Implementation not shown in documentation\n```\n\n----------------------------------------\n\nTITLE: Implementing Connection Addition Method\nDESCRIPTION: Method to add a new connection between nodes with specified input/output keys, weight, and enabled status.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/module_summaries.rst#2025-04-23_snippet_32\n\nLANGUAGE: python\nCODE:\n```\ndef add_connection(config, input_key, output_key, weight, enabled):\n    \"\"\"Adds a specified new connection with given parameters\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Statistics Reporter Interface\nDESCRIPTION: Gathers and reports statistics about genome fitness, species sizes and best performing genomes across generations. Includes methods for saving data to CSV files.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/module_summaries.rst#2025-04-23_snippet_50\n\nLANGUAGE: python\nCODE:\n```\nclass StatisticsReporter(BaseReporter):\n    \"\"\"Gathers and provides statistical information about genomes and species\"\"\"\n\n    def post_evaluate(config, population, species, best_genome):\n        \"\"\"Called after evaluation of each generation\"\"\"\n\n    def get_fitness_stat(f):\n        \"\"\"Returns list of fitness statistics using provided function\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Calculating Genome Distance in Python for NEAT\nDESCRIPTION: Method to compute the genomic distance between this genome and another, used for determining genome compatibility in speciation.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/genome-interface.rst#2025-04-23_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\ndistance(self, other, config)\n```\n\n----------------------------------------\n\nTITLE: Registering Custom Activation Function in NEAT-Python\nDESCRIPTION: Demonstrates how to add a custom activation function (sinc) to the genome configuration. This allows the new function to be used in the NEAT algorithm.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/customization.rst#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef sinc(x):\n    return 1.0 if x == 0 else sin(x) / x\n\nconfig.genome_config.add_activation('my_sinc_function', sinc)\n```\n\n----------------------------------------\n\nTITLE: Implementing Structural Mutation Check Method\nDESCRIPTION: Method to determine if structural mutations should occur under extended circumstances based on configuration parameters.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/module_summaries.rst#2025-04-23_snippet_31\n\nLANGUAGE: python\nCODE:\n```\ndef check_structural_mutation_surer():\n    \"\"\"Checks vs structural_mutation_surer and single_structural_mutation to decide if changes should happen.\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Registering Custom Aggregation Function in NEAT-Python\nDESCRIPTION: Shows how to add a custom aggregation function (L2 norm) to the genome configuration. This allows the new function to be used for aggregating inputs in the NEAT algorithm.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/customization.rst#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef l2norm(x):\n    return sqrt(sum(i**2 for i in x))\n\nconfig.genome_config.add_activation('my_l2norm_function', l2norm)\n```\n\n----------------------------------------\n\nTITLE: Implementing DefaultNodeGene Class in Python for NEAT\nDESCRIPTION: Defines the DefaultNodeGene class which extends BaseGene and is specific to node genes. It includes methods for calculating genetic distances between homologous node genes.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/module_summaries.rst#2025-04-23_snippet_27\n\nLANGUAGE: python\nCODE:\n```\nclass DefaultNodeGene(BaseGene):\n    def distance(self, other, config):\n        # Determines the degree of differences between node genes\n        pass\n```\n\n----------------------------------------\n\nTITLE: Mutating Genome in Python for NEAT\nDESCRIPTION: Method to apply mutation operations to the genome using the given configuration, introducing genetic variations.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/genome-interface.rst#2025-04-23_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\nmutate(self, config)\n```\n\n----------------------------------------\n\nTITLE: Defining Reporter Interface Methods in Python\nDESCRIPTION: Defines several methods that comprise the reporter interface in NEAT-Python. These methods are called at various points during the evolutionary process to report on the state and progress of the algorithm.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/module_summaries.rst#2025-04-23_snippet_42\n\nLANGUAGE: python\nCODE:\n```\ndef post_evaluate(config, population, species, best_genome):\n    \"\"\"Called after fitness evaluation.\"\"\"\n    pass\n\ndef post_reproduction(config, population, species):\n    \"\"\"Called after reproduction (currently unused).\"\"\"\n    pass\n\ndef complete_extinction():\n    \"\"\"Called when complete extinction occurs.\"\"\"\n    pass\n\ndef found_solution(config, generation, best):\n    \"\"\"Called when a solution is found.\"\"\"\n    pass\n\ndef species_stagnant(sid, species):\n    \"\"\"Called for each stagnant species.\"\"\"\n    pass\n\ndef info(msg):\n    \"\"\"Handles miscellaneous informational messages.\"\"\"\n    pass\n```\n\n----------------------------------------\n\nTITLE: Configuring Genome Crossover in Python for NEAT\nDESCRIPTION: Method to configure the genome as a child of the given parent genomes, implementing genetic crossover.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/genome-interface.rst#2025-04-23_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\nconfigure_crossover(self, genome1, genome2, config)\n```\n\n----------------------------------------\n\nTITLE: GenomeDistanceCache Class for Genomic Distance Calculation\nDESCRIPTION: Implements a caching mechanism for genomic distance calculations to avoid repeated lookups. This class improves performance by memoizing distance calculations between genome pairs.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/module_summaries.rst#2025-04-23_snippet_46\n\nLANGUAGE: python\nCODE:\n```\nclass GenomeDistanceCache(config):\n\n  Caches (indexing by :term:`genome` :term:`key`/id) :term:`genomic distance` information to avoid repeated lookups. (The\n  :py:meth:`distance function <genome.DefaultGenome.distance>`, memoized by this class, is among the most time-consuming parts of the\n  library, although many fitness functions are likely to far outweigh this for moderate-size populations.)\n\n  :param config: A genome configuration instance; later used by the genome distance function.\n  :type config: :datamodel:`instance <index-48>`\n\n  .. py:method:: __call__(genome0, genome1)\n\n    GenomeDistanceCache is called as a method with a pair of genomes to retrieve the distance.\n\n    :param genome0: The first genome instance.\n    :type genome0: :datamodel:`instance <index-48>`\n    :param genome1: The second genome instance.\n    :type genome1: :datamodel:`instance <index-48>`\n    :return: The :term:`genomic distance`.\n    :rtype: :pytypes:`float <typesnumeric>`\n```\n\n----------------------------------------\n\nTITLE: Species Class Definition in NEAT-Python\nDESCRIPTION: Defines the Species class which represents a species in the NEAT algorithm. It maintains information about members, fitness, and stagnation time. The class includes methods for updating members and retrieving fitness values.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/module_summaries.rst#2025-04-23_snippet_45\n\nLANGUAGE: python\nCODE:\n```\nclass Species(key, generation):\n\n  Represents a :term:`species` and contains data about it such as members, fitness, and time stagnating.\n  Note: :py:class:`stagnation.DefaultStagnation` manipulates many of these.\n\n  :param int key: :term:`Identifier/key <key>`\n  :param int generation: Initial :term:`generation` of appearance\n\n  .. index:: genomic distance\n\n  .. py:method:: update(representative, members)\n\n    Required interface method. Updates a species instance with the current members and most-representative member (from which\n    :term:`genomic distances <genomic distance>` are measured).\n\n    :param representative: A genome instance.\n    :type representative: :datamodel:`instance <index-48>`\n    :param members: A `dictionary <dict>` of genome :term:`id <key>` vs genome instance.\n    :type members: dict(int, :datamodel:`instance <index-48>`)\n\n  .. py:method:: get_fitnesses()\n\n    Required interface method (used by :py:class:`stagnation.DefaultStagnation`, for instance). Retrieves the fitnesses of each member genome.\n\n    :return: List of fitnesses of member genomes.\n    :rtype: list(:pytypes:`float <typesnumeric>`)\n```\n\n----------------------------------------\n\nTITLE: Species Stagnation Update Method\nDESCRIPTION: Updates species fitness history and marks stagnant species for removal while respecting species elitism settings. Returns list of species with stagnation status.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/module_summaries.rst#2025-04-23_snippet_49\n\nLANGUAGE: python\nCODE:\n```\ndef update(species_set, generation):\n    \"\"\"Required interface method. Updates species fitness history information\n    :param species_set: A species.DefaultSpeciesSet or compatible object\n    :param generation: The current generation\n    :return: List of tuples (species id, Species instance, is_stagnant)\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Mathematical Utility Functions for NEAT-Python\nDESCRIPTION: A collection of mathematical utility functions for NEAT-Python, including statistical functions like mean, median, variance, standard deviation, and softmax.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/module_summaries.rst#2025-04-23_snippet_37\n\nLANGUAGE: Python\nCODE:\n```\ndef mean(values):\n    \"\"\"\n    Returns the arithmetic mean.\n    \"\"\"\n    # Implementation not shown in documentation\n\ndef median(values):\n    \"\"\"\n    Returns the median for odd numbers of values; returns the higher of the middle two values for even numbers of values.\n    \"\"\"\n    # Implementation not shown in documentation\n\ndef median2(values):\n    \"\"\"\n    Returns the median for odd numbers of values; returns the mean of the middle two values for even numbers of values.\n    \"\"\"\n    # Implementation not shown in documentation\n\ndef variance(values):\n    \"\"\"\n    Returns the (population) variance.\n    \"\"\"\n    # Implementation not shown in documentation\n\ndef stdev(values):\n    \"\"\"\n    Returns the (population) standard deviation. *Note spelling.*\n    \"\"\"\n    # Implementation not shown in documentation\n\ndef softmax(values):\n    \"\"\"\n    Compute the softmax (a differentiable/smooth approximization of the maximum function) of the given value set.\n    \"\"\"\n    # Implementation not shown in documentation\n```\n\n----------------------------------------\n\nTITLE: Defining ActivationFunctionSet Class in Python\nDESCRIPTION: Defines a class to manage a set of activation functions. It includes methods to add, get, and validate activation functions.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/module_summaries.rst#2025-04-23_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nclass ActivationFunctionSet:\n    def add(self, name, function):\n        # Implementation not shown\n    \n    def get(self, name):\n        # Implementation not shown\n    \n    def is_valid(self, name):\n        # Implementation not shown\n```\n\n----------------------------------------\n\nTITLE: Reproduction Class Initialization in NEAT-Python\nDESCRIPTION: Constructor that initializes a reproduction instance with configuration, reporters, and stagnation objects.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/reproduction-interface.rst#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n__init__(self, config, reporters, stagnation)\n```\n\n----------------------------------------\n\nTITLE: Initializing FloatAttribute in NEAT-Python\nDESCRIPTION: Initializes a FloatAttribute value using either a gaussian or uniform distribution, based on configuration settings. The method uses clamp to ensure the value stays within the desired range.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/module_summaries.rst#2025-04-23_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ndef init_value(config):\n  Initializes the attribute's value, using either a gaussian distribution with the configured mean and standard deviation, followed by `clamp` to\n  keep the result within the desired range, or a uniform distribution, depending on the configuration setting of ``init_type``.\n\n  :param config: The configuration object from which the mean, standard deviation, and initialization distribution type values are to be retrieved.\n  :type config: :datamodel:`instance <index-48>`\n  :return: The new value.\n  :rtype: :pytypes:`float <typesnumeric>`\n\n  .. versionchanged:: 0.92\n    Uniform distribution initialization option added.\n```\n\n----------------------------------------\n\nTITLE: Configuring Structural Mutation in NEAT-Python\nDESCRIPTION: This snippet shows the configuration parameters for structural mutation in NEAT-Python. It includes options for limiting structural mutations per generation and handling special cases in node and connection additions.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/config_file.rst#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nsingle_structural_mutation = False\nstructural_mutation_surer = \"default\"\n```\n\n----------------------------------------\n\nTITLE: Initializing StringAttribute in NEAT-Python\nDESCRIPTION: Initializes a StringAttribute value either using a configured default or randomly choosing from a list of options. The method allows for a default value that may not be in the options list.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/module_summaries.rst#2025-04-23_snippet_14\n\nLANGUAGE: python\nCODE:\n```\ndef init_value(config):\n  Initializes the attribute's value, either using a configured ``default`` or (if the default is \"random\") with a\n  randomly-chosen member of the ``options`` (each having an equal chance). Note: It is possible for the default value, if specifically configured, to\n  **not** be one of the options.\n\n  .. deprecated:: 0.92\n    While it is possible to use \"None\" as an equivalent to \"random\", this is too easily confusable with an actual `None`.\n\n  :param config: The configuration object from which the default and, if necessary, ``options`` parameters are to be retrieved.\n  :type config: :datamodel:`instance <index-48>`\n  :return: The new value.\n  :rtype: str\n```\n\n----------------------------------------\n\nTITLE: Configuring Mutation Parameters in NEAT-Python\nDESCRIPTION: This snippet demonstrates the configuration parameters for mutation in NEAT-Python. It includes settings for mutation rates, power, and replacement probabilities for both connection weights and node response multipliers.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/config_file.rst#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nweight_mutate_power = 0.5\nweight_mutate_rate = 0.8\nweight_replace_rate = 0.1\n\nresponse_mutate_power = 0.5\nresponse_mutate_rate = 0.8\nresponse_replace_rate = 0.1\n```\n\n----------------------------------------\n\nTITLE: Validating Activation Functions in Python\nDESCRIPTION: Defines a function to validate if an object is a valid activation function. It checks if the input is a function that takes a single argument.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/module_summaries.rst#2025-04-23_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\ndef validate_activation(function):\n    # Implementation not shown\n```\n\n----------------------------------------\n\nTITLE: Implementing ReporterSet Class for NEAT Reporting in Python\nDESCRIPTION: This class manages a set of reporters for the NEAT algorithm. It provides methods to add, remove, and dispatch reporters at various points during the evolution process, such as start/end of generations and post-evaluation.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/module_summaries.rst#2025-04-23_snippet_40\n\nLANGUAGE: python\nCODE:\n```\nclass ReporterSet:\n    def add(reporter):\n        \"\"\"Adds a reporter to those to be called via ReporterSet methods.\"\"\"\n\n    def remove(reporter):\n        \"\"\"Removes a reporter from those to be called via ReporterSet methods.\"\"\"\n\n    def start_generation(gen):\n        \"\"\"Calls start_generation on each reporter in the set.\"\"\"\n\n    def end_generation(config, population, species):\n        \"\"\"Calls end_generation on each reporter in the set.\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Sum Aggregation Function in Python\nDESCRIPTION: Defines a function that sums all numbers in an iterable input. It is described as the most commonly used aggregation function.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/module_summaries.rst#2025-04-23_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\ndef sum_aggregation(x):\n    # Implementation not shown\n```\n\n----------------------------------------\n\nTITLE: Configuring NEAT Parameters with ConfigParameter Class\nDESCRIPTION: Class for handling individual configuration parameters with type checking and parsing capabilities. Supports string, integer, boolean, float and list parameter types with optional default values.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/module_summaries.rst#2025-04-23_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nclass ConfigParameter(name, value_type, default=None):\n    \"\"\"Does initial handling of a particular configuration parameter.\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Max and Min Aggregation Functions in Python\nDESCRIPTION: Defines functions to find the maximum and minimum values in an iterable input.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/module_summaries.rst#2025-04-23_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\ndef max_aggregation(x):\n    # Implementation not shown\n\ndef min_aggregation(x):\n    # Implementation not shown\n```\n\n----------------------------------------\n\nTITLE: CTRNN Node Evaluation Class\nDESCRIPTION: Class for setting up continuous-time recurrent neural network nodes with parameters for time constant, activation, aggregation, bias, response and links.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/module_summaries.rst#2025-04-23_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nclass CTRNNNodeEval(time_constant, activation, aggregation, bias, response, links):\n    \"\"\"Sets up the basic ctrnn nodes.\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Genome Creation Method in NEAT-Python\nDESCRIPTION: Method to create multiple new genomes of a specified type using given configuration settings.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/reproduction-interface.rst#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ncreate_new(self, genome_type, genome_config, num_genomes)\n```\n\n----------------------------------------\n\nTITLE: Configuring New Genome in Python for NEAT\nDESCRIPTION: Method to configure a genome as a new random genome based on the given configuration from the top-level Config object.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/genome-interface.rst#2025-04-23_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nconfigure_new(self, config)\n```\n\n----------------------------------------\n\nTITLE: Measuring Genome Size in Python for NEAT\nDESCRIPTION: Method to return a measure of genome complexity, typically used by reporters to indicate the complexity of the highest-fitness genome.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/genome-interface.rst#2025-04-23_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\nsize(self)\n```\n\n----------------------------------------\n\nTITLE: Mutating BoolAttribute in NEAT-Python\nDESCRIPTION: Mutates a BoolAttribute value based on configuration parameters. The method may replace the value with a 50/50 chance of True or False, depending on mutation rates and additional parameters.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/module_summaries.rst#2025-04-23_snippet_13\n\nLANGUAGE: python\nCODE:\n```\ndef mutate_value(value, config):\n  With a frequency determined by the ``mutate_rate`` and ``rate_to_false_add`` or\n  ``rate_to_true_add`` configuration parameters, replaces the value with a 50/50 chance of ``True`` or ``False``; note that this has a\n  50% chance of leaving the value unchanged.\n\n  :param bool value: The current value of the attribute.\n  :param config: The configuration object from which the ``mutate_rate`` and other parameters are to be extracted.\n  :type config: :datamodel:`instance <index-48>`\n  :return: Either the original value, if unchanged, or the new value.\n  :rtype: :pytypes:`bool <typesnumeric>`\n\n  .. versionchanged:: 0.92\n    Added the ``rate_to_false_add`` and ``rate_to_true_add`` parameters.\n```\n\n----------------------------------------\n\nTITLE: Threaded Evaluation Module\nDESCRIPTION: Provides parallel genome evaluation using Python threading for implementations without GIL. Allows concurrent evaluation of multiple genomes.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/module_summaries.rst#2025-04-23_snippet_51\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Runs evaluation functions in parallel threads to evaluate multiple genomes at once.\nPreferable for Python implementations without GIL.\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Using uniform distribution for bias initialization in NEAT-Python\nDESCRIPTION: Example of how the uniform distribution is calculated for bias initialization. The distribution range is determined by the bias_init_mean and bias_init_stdev parameters with clamping to min/max values.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/config_file.rst#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom math import max, min\n\n# When bias_init_type = \"uniform\", distribution range is:\nlow = max(bias_min_value, (bias_init_mean-(bias_init_stdev*2)))\nhigh = min(bias_max_value, (bias_init_mean+(bias_init_stdev*2)))\n```\n\n----------------------------------------\n\nTITLE: Parallel Feed-Forward Neural Network Evolution\nDESCRIPTION: Implementation showing how to utilize multiple processors for parallel network evaluation. Demonstrated in evolve-feedforward-parallel.py.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/examples/xor/README.md#2025-04-23_snippet_2\n\n\n\n----------------------------------------\n\nTITLE: Configuring Weight Initialization in NEAT-Python\nDESCRIPTION: This snippet shows the configuration parameters for initializing connection weights in NEAT-Python. It includes options for setting the distribution type, mean, standard deviation, and value limits for weight initialization.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/config_file.rst#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nweight_init_mean = 0.0\nweight_init_stdev = 1.0\nweight_init_type = \"gaussian\"\nweight_max_value = 30\nweight_min_value = -30\n```\n\n----------------------------------------\n\nTITLE: Spiking Neural Network Evolution\nDESCRIPTION: Evolution of spiking neural networks using Izhikevich's neuron model. Implemented in evolve-spiking.py, based on the 2003 paper 'Simple model of spiking neurons'.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/examples/xor/README.md#2025-04-23_snippet_3\n\n\n\n----------------------------------------\n\nTITLE: Population Checkpoint Restoration\nDESCRIPTION: Static method for resuming simulation from a saved checkpoint. Loads state and returns a Population object for continuing simulation.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/module_summaries.rst#2025-04-23_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n@staticmethod\ndef restore_checkpoint(filename):\n    \"\"\"Resumes the simulation from a previous saved point.\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Minimal Feed-Forward Neural Network Evolution\nDESCRIPTION: Demonstrates the basic implementation of evolving a feed-forward neural network with sigmoidal neurons, stripped down to essential components. Located in evolve-minimal.py.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/examples/xor/README.md#2025-04-23_snippet_0\n\n\n\n----------------------------------------\n\nTITLE: Implementing MaxAbs Aggregation Function in Python\nDESCRIPTION: Defines a function that returns the maximum value by absolute value from an iterable input. It can return positive or negative values.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/module_summaries.rst#2025-04-23_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\ndef maxabs_aggregation(x):\n    # Implementation not shown\n```\n\n----------------------------------------\n\nTITLE: Standard Feed-Forward Neural Network Evolution\nDESCRIPTION: Enhanced version of the minimal example with improved output formatting and better coding practices. Found in evolve-feedforward.py.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/examples/xor/README.md#2025-04-23_snippet_1\n\n\n\n----------------------------------------\n\nTITLE: Defining AggregationFunctionSet Class in Python\nDESCRIPTION: Defines a class to manage a set of aggregation functions. It includes methods to add, get, and validate aggregation functions.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/module_summaries.rst#2025-04-23_snippet_10\n\nLANGUAGE: Python\nCODE:\n```\nclass AggregationFunctionSet:\n    def add(self, name, function):\n        # Implementation not shown\n    \n    def get(self, name):\n        # Implementation not shown\n    \n    def __getitem__(self, index):\n        # Implementation not shown\n    \n    def is_valid(self, name):\n        # Implementation not shown\n```\n\n----------------------------------------\n\nTITLE: DistributedEvaluator Class Method Signatures\nDESCRIPTION: Core method signatures for the DistributedEvaluator class including initialization, start/stop functionality, and queue management. Includes parameter documentation for distributed evaluation setup.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/module_summaries.rst#2025-04-23_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nclass DistributedEvaluator:\n    def __init__(self, addr, authkey, eval_function, secondary_chunksize=1, num_workers=None, worker_timeout=60, mode=MODE_AUTO):\n        pass\n\n    def start(self, exit_on_stop=True, secondary_wait=0, reconnect=False):\n        pass\n        \n    def stop(self, wait=1, shutdown=True, force_secondary_shutdown=False):\n        pass\n        \n    def evaluate(self, genomes, config):\n        pass\n        \n    def get_inqueue(self):\n        pass\n        \n    def get_outqueue(self):\n        pass\n        \n    def get_namespace(self):\n        pass\n```\n\n----------------------------------------\n\nTITLE: Implementing Median and Mean Aggregation Functions in Python\nDESCRIPTION: Defines functions to calculate the median and arithmetic mean of an iterable input.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/module_summaries.rst#2025-04-23_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\ndef median_aggregation(x):\n    # Implementation not shown\n\ndef mean_aggregation(x):\n    # Implementation not shown\n```\n\n----------------------------------------\n\nTITLE: DistributedEvaluator State Management Methods\nDESCRIPTION: Methods for managing distributed evaluator state and determining node roles. Includes functionality for checking primary/secondary status and managing shared state.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/module_summaries.rst#2025-04-23_snippet_25\n\nLANGUAGE: python\nCODE:\n```\ndef is_primary(self):\n    pass\n\ndef is_master(self):\n    pass\n    \ndef set_secondary_state(self, value):\n    pass\n\n@property\ndef secondary_state(self):\n    pass\n```\n\n----------------------------------------\n\nTITLE: Implementing Product Aggregation Function in Python\nDESCRIPTION: Defines a function that multiplies all numbers in an iterable input. It adapts the multiplication operation for iterables.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/module_summaries.rst#2025-04-23_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\ndef product_aggregation(x):\n    # Implementation not shown\n```\n\n----------------------------------------\n\nTITLE: Defining Extended Manager Class for Distributed Evaluation in Python\nDESCRIPTION: A class that manages the multiprocessing SyncManager instance for distributed evaluation. It initializes the secondary state to a running state.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/module_summaries.rst#2025-04-23_snippet_23\n\nLANGUAGE: Python\nCODE:\n```\nclass _ExtendedManager(addr, authkey, mode, start=False):\n  Manages the multiprocessing.managers.SyncManager instance. Initializes\n  ``self._secondary_state`` to _STATE_RUNNING.\n```\n\n----------------------------------------\n\nTITLE: Defining BaseReporter Abstract Class for NEAT in Python\nDESCRIPTION: This abstract class defines the reporter interface expected by ReporterSet. It provides dummy methods for various reporting events that can be overridden by concrete implementations.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/module_summaries.rst#2025-04-23_snippet_41\n\nLANGUAGE: python\nCODE:\n```\nclass BaseReporter:\n    def start_generation(generation):\n        \"\"\"Called at the start of each generation.\"\"\"\n\n    def end_generation(config, population, species):\n        \"\"\"Called at the end of each generation.\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Parsing Configuration Method in NEAT-Python\nDESCRIPTION: Class method that processes configuration dictionary and returns an opaque configuration object used by write_config.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/reproduction-interface.rst#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nparse_config(cls, param_dict)\n```\n\n----------------------------------------\n\nTITLE: Implementing StdOutReporter Class in Python\nDESCRIPTION: Defines a StdOutReporter class that uses print to output information about the evolutionary run. This is an example implementation of the reporter interface.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/module_summaries.rst#2025-04-23_snippet_43\n\nLANGUAGE: python\nCODE:\n```\nclass StdOutReporter(show_species_detail):\n    \"\"\"Uses `print` to output information about the run; an example reporter class.\"\"\"\n\n    def __init__(self, show_species_detail):\n        self.show_species_detail = show_species_detail\n```\n\n----------------------------------------\n\nTITLE: Writing Configuration Method in NEAT-Python\nDESCRIPTION: Class method that writes configuration definitions to a file-like object using the configuration object from parse_config.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/reproduction-interface.rst#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nwrite_config(cls, f, config)\n```\n\n----------------------------------------\n\nTITLE: Defining BaseAttribute Class in Python\nDESCRIPTION: Defines a base class for attribute types used in genes. It handles configuration and naming of attributes.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/module_summaries.rst#2025-04-23_snippet_11\n\nLANGUAGE: Python\nCODE:\n```\nclass BaseAttribute(name, **default_dict):\n    # Implementation not shown\n```\n\n----------------------------------------\n\nTITLE: CTRNN Differential Equation in LaTeX\nDESCRIPTION: The main differential equation governing the CTRNN model, expressing the rate of change of neuron potential over time. It includes terms for time constant, current potential, activation function, bias, and weighted inputs from connected neurons.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/ctrnn.rst#2025-04-23_snippet_0\n\nLANGUAGE: latex\nCODE:\n```\n\\tau_i \\frac{d y_i}{dt} = -y_i + f_i\\left(\\beta_i + \\sum\\limits_{j \\in A_i} w_{ij} y_j\\right)\n```\n\n----------------------------------------\n\nTITLE: Parsing Genome Configuration in Python for NEAT\nDESCRIPTION: Class method to parse a dictionary of configuration items and return an opaque configuration object for later use.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/genome-interface.rst#2025-04-23_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nparse_config(cls, param_dict)\n```\n\n----------------------------------------\n\nTITLE: Installing NEAT-Python via PyPI\nDESCRIPTION: This command installs version 0.92 of NEAT-Python from PyPI using pip. It requires root privileges or sudo depending on your system configuration.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/installation.rst#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install neat-python\n```\n\n----------------------------------------\n\nTITLE: Initializing Genome in Python for NEAT\nDESCRIPTION: Initializer method for genome objects, creating key attributes such as connections, nodes, and fitness. Takes a unique genome instance identifier as input.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/genome-interface.rst#2025-04-23_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\n__init__(self, key)\n```\n\n----------------------------------------\n\nTITLE: Citing NEAT-Python in APA Format\nDESCRIPTION: An APA citation format for referencing the NEAT-Python project in academic publications. It includes the main contributors to the project.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/README.md#2025-04-23_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nMcIntyre, A., Kallada, M., Miguel, C. G., Feher de Silva, C., & Netto, M. L. neat-python [Computer software]\n```\n\n----------------------------------------\n\nTITLE: Validating Aggregation Functions in Python\nDESCRIPTION: Defines a function to validate if an object is a valid aggregation function. It checks if the input is a function that takes at least one argument.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/module_summaries.rst#2025-04-23_snippet_9\n\nLANGUAGE: Python\nCODE:\n```\ndef validate_aggregation(function):\n    # Implementation not shown\n```\n\n----------------------------------------\n\nTITLE: Writing Genome Configuration in Python for NEAT\nDESCRIPTION: Class method to write configuration item definitions to a file-like object using the opaque configuration object created by parse_config.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/genome-interface.rst#2025-04-23_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nwrite_config(cls, f, config)\n```\n\n----------------------------------------\n\nTITLE: XOR Truth Table in Python\nDESCRIPTION: Defines the expected input-output pairs for the XOR function as a table.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/xor_example.rst#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n=======  =======  ======\nInput 1  Input 2  Output\n=======  =======  ======\n0        0        0\n0        1        1\n1        0        1\n1        1        0\n=======  =======  ======\n```\n\n----------------------------------------\n\nTITLE: Neural Network Node Output Mathematical Formula\nDESCRIPTION: Mathematical formula showing how a node's output is calculated in NEAT. It combines the bias, response, aggregation function, and activation function to produce the node's output value.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/glossary.rst#2025-04-23_snippet_0\n\nLANGUAGE: tex\nCODE:\n```\n\\begin{equation}\\operatorname{activation}(bias + (response * \\operatorname{aggregation}(inputs)))\\end{equation}\n```\n\n----------------------------------------\n\nTITLE: Determining Node Mode for Distributed NEAT Evaluation in Python\nDESCRIPTION: A function that determines the operational mode (primary or secondary) of a compute node based on the provided address and mode parameter. This facilitates the distributed evaluation setup.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/module_summaries.rst#2025-04-23_snippet_21\n\nLANGUAGE: Python\nCODE:\n```\ndef _determine_mode(addr, mode):\n  Returns the mode that should be used.  If ``mode`` is MODE_AUTO, this is determined by checking (via host_is_local()) if ``addr`` points\n  to the localhost; if it does, it returns MODE_PRIMARY, else it returns MODE_SECONDARY. If mode is either MODE_PRIMARY or\n  MODE_SECONDARY, it returns the ``mode`` argument. Otherwise, a ValueError is raised.\n\n  :param addr: Either a tuple of (hostname, port) pointing to the machine that has the primary node, or the hostname (as ``bytes`` if on 3.X).\n  :type addr: tuple(str, int) or bytes\n  :param int mode: Specifies the mode to run in - must be one of MODE_AUTO, MODE_PRIMARY, or MODE_SECONDARY.\n  :raises ValueError: If the mode is not one of the above.\n```\n\n----------------------------------------\n\nTITLE: Implementing Host Validation Function for Distributed Evaluation in Python\nDESCRIPTION: A utility function to check if a given hostname points to the localhost. This is used in the distributed evaluation module to determine node roles.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/module_summaries.rst#2025-04-23_snippet_20\n\nLANGUAGE: Python\nCODE:\n```\ndef host_is_local(hostname, port=22):\n  Returns True if the hostname points to the localhost (including shares addresses), otherwise False.\n\n  :param str hostname: The hostname to be checked; will be put through `socket.getfqdn`.\n  :param port: The optional port for `socket` functions requiring one. Defaults to 22, the ssh port.\n  :type port: int\n  :return: Whether the hostname appears to be equivalent to that of the localhost.\n  :rtype: bool\n```\n\n----------------------------------------\n\nTITLE: Implementing Data Chunking for Distributed Processing in Python\nDESCRIPTION: A utility function that splits data into chunks of specified size. This is used in the distributed evaluation module to distribute workloads across compute nodes.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/module_summaries.rst#2025-04-23_snippet_22\n\nLANGUAGE: Python\nCODE:\n```\ndef chunked(data, chunksize):\n   Splits up ``data`` and returns it as a list of chunks containing at most ``chunksize`` elements of data.\n\n  :param data: The data to split up; takes any iterable.\n  :type data: list(object) or tuple(object) or set(object)\n  :param chunksize: The maximum number of elements per chunk.\n  :type chunksize: int\n  :return: A list of chunks containing (as a list) at most ``chunksize`` elements of data.\n  :rtype: list(list(object))\n  :raises ValueError: If ``chunksize`` is not 1+ or is not an integer\n```\n\n----------------------------------------\n\nTITLE: Evolving Networks for Variable-length Sequence Memory in Python\nDESCRIPTION: The 'evolve.py' script is designed to generate neural networks that can reproduce a variable-length sequence of binary inputs. This implementation uses NEAT (NeuroEvolution of Augmenting Topologies) for evolving the network structure. However, it is noted that the current implementation is not working as intended.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/examples/memory-variable/README.md#2025-04-23_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nevolve.py\n```\n\n----------------------------------------\n\nTITLE: CTRNN Time Evolution Equation in LaTeX\nDESCRIPTION: The equation for computing the time evolution of the CTRNN using the forward Euler method. It calculates the neuron potential at the next time step based on the current potential and its rate of change.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/ctrnn.rst#2025-04-23_snippet_1\n\nLANGUAGE: latex\nCODE:\n```\ny_i(t+\\Delta t) = y_i(t) + \\Delta t \\frac{d y_i}{dt}\n```\n\n----------------------------------------\n\nTITLE: Installing NEAT-Python from Source\nDESCRIPTION: This command installs NEAT-Python from source code. It should be run from the directory containing setup.py after either cloning the repository or downloading the source archive.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/installation.rst#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npython setup.py install\n```\n\n----------------------------------------\n\nTITLE: Cloning the NEAT-Python Repository\nDESCRIPTION: This command clones the NEAT-Python source code repository from GitHub. This gives access to the latest version of the code, though it may not be as stable as released versions.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/installation.rst#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/CodeReclaimers/neat-python.git\n```\n\n----------------------------------------\n\nTITLE: Defining InvalidAggregationFunction Exception in Python\nDESCRIPTION: Defines an exception class for invalid aggregation functions. It inherits from TypeError and is raised when an aggregation function is invalid or unknown.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/module_summaries.rst#2025-04-23_snippet_8\n\nLANGUAGE: Python\nCODE:\n```\nclass InvalidAggregationFunction(TypeError):\n    pass\n```\n\n----------------------------------------\n\nTITLE: Defining InvalidActivationFunction Exception in Python\nDESCRIPTION: Defines an exception class for invalid activation functions. It inherits from TypeError and is raised when an activation function is invalid or unknown.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/module_summaries.rst#2025-04-23_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nclass InvalidActivationFunction(TypeError):\n    pass\n```\n\n----------------------------------------\n\nTITLE: Izhikevich Neural Network Citation Reference\nDESCRIPTION: Citation and reference information for the Izhikevich spiking neural network model implementation\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/docs/module_summaries.rst#2025-04-23_snippet_33\n\nLANGUAGE: text\nCODE:\n```\nIzhikevich, E. M.\nSimple Model of Spiking Neurons\nIEEE TRANSACTIONS ON NEURAL NETWORKS, VOL. 14, NO. 6, NOVEMBER 2003\n```\n\n----------------------------------------\n\nTITLE: Citing NEAT-Python in BibTeX Format\nDESCRIPTION: A BibTeX entry for citing the NEAT-Python project in academic publications. It includes the main contributors and the project title.\nSOURCE: https://github.com/codereclaimers/neat-python/blob/master/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bibtex\nCODE:\n```\n@software{McIntyre_neat-python,\nauthor = {McIntyre, Alan and Kallada, Matt and Miguel, Cesar G. and Feher de Silva, Carolina and Netto, Marcio Lobo},\ntitle = {{neat-python}}\n}\n```"
  }
]