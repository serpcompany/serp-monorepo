TITLE: Writing a Basic Vitest Test (JavaScript)
DESCRIPTION: A Vitest test file that imports the sum function and uses `test` and `expect` to verify its output.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/index.md#_snippet_2

LANGUAGE: js
CODE:
```
import { expect, test } from 'vitest'
import { sum } from './sum.js'

test('adds 1 + 2 to equal 3', () => {
  expect(sum(1, 2)).toBe(3)
})
```

----------------------------------------

TITLE: Creating and Using Mock Functions with vi.fn
DESCRIPTION: This snippet demonstrates how to create a mock function using `vi.fn` and track its execution. It shows how to invoke the mock function and access the arguments it was called with via the `mock.calls` property. This provides basic mocking functionality for tests.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/mock.md#_snippet_0

LANGUAGE: javascript
CODE:
```
import { vi } from 'vitest'

const fn = vi.fn()
fn('hello world')
fn.mock.calls[0] === ['hello world']
```

----------------------------------------

TITLE: Passing custom timeout to tests in Vitest
DESCRIPTION: This snippet demonstrates how to set a custom timeout in milliseconds for individual tests and hooks, overriding the default 5-second timeout to accommodate longer or shorter test executions.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/filtering.md#_snippet_3

LANGUAGE: typescript
CODE:
```
import { test } from 'vitest'

test('name', async () => { /* ... */ }, 1000)
```

----------------------------------------

TITLE: Asserting Deep Inclusion in Arrays or Objects using Vitest (TypeScript)
DESCRIPTION: Illustrates `assert.deepInclude` in Vitest tests for checking the presence of values in arrays or objects using deep equality comparison. Depends on `assert` and `test`.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_44

LANGUAGE: typescript
CODE:
```
import { assert, test } from 'vitest'

const obj1 = { a: 1 }
const obj2 = { b: 2 }

test('assert.deepInclude', () => {
  assert.deepInclude([obj1, obj2], { a: 1 })
  assert.deepInclude({ foo: obj1, bar: obj2 }, { foo: { a: 1 } })
})
```

----------------------------------------

TITLE: Matching Inline Snapshot in Vitest (Shape)
DESCRIPTION: Shows how to use `toMatchInlineSnapshot` with a shape object to match only specific properties or types within a value, rather than the exact value. Useful for partial matching. Requires `expect` and `test` from 'vitest'.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_40

LANGUAGE: ts
CODE:
```
import { expect, test } from 'vitest'

test('matches snapshot', () => {
  const data = { foo: new Set(['bar', 'snapshot']) }
  expect(data).toMatchInlineSnapshot(
    { foo: expect.any(Set) },
    `
    {
      "foo": Any<Set>,
    }
  `
  )
})
```

----------------------------------------

TITLE: Configuring Vitest in Separate Config File - TypeScript
DESCRIPTION: Illustrates creating a dedicated Vitest configuration file (`vitest.config.js`) by importing `defineConfig` directly from `vitest/config`. This approach is suitable when the main application doesn't use Vite or requires a distinct test configuration. Vitest options are placed in the `test` property.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_2

LANGUAGE: TypeScript
CODE:
```
import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    // ... Specify options here.
  },
})
```

----------------------------------------

TITLE: Running Concurrent Tests with Vitest (TypeScript)
DESCRIPTION: Demonstrates marking tests with `test.concurrent` to allow them to run in parallel. This method accepts the test name, an async function containing the test logic, and an optional timeout. It can be combined with `skip`, `only`, and `todo`.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/index.md#_snippet_15

LANGUAGE: TypeScript
CODE:
```
import { describe, test } from 'vitest'

// The two tests marked with concurrent will be run in parallel
describe('suite', () => {
  test('serial test', async () => { /* ... */ })
  test.concurrent('concurrent test 1', async () => { /* ... */ })
  test.concurrent('concurrent test 2', async () => { /* ... */ })
})
```

----------------------------------------

TITLE: Base Directory Configuration
DESCRIPTION: Specifies the base directory to scan for test files. Can be set via the CLI using `--dir <path>` or in the configuration file using the `dir` property.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/cli-generated.md#_snippet_5



----------------------------------------

TITLE: Installing Vitest as a Dev Dependency
DESCRIPTION: Add Vitest as a development dependency to your project using various package managers.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/index.md#_snippet_0

LANGUAGE: bash
CODE:
```
npm install -D vitest
```

LANGUAGE: bash
CODE:
```
yarn add -D vitest
```

LANGUAGE: bash
CODE:
```
pnpm add -D vitest
```

LANGUAGE: bash
CODE:
```
bun add -D vitest
```

----------------------------------------

TITLE: Running Vitest Tests from CLI
DESCRIPTION: Provides the command-line instruction to execute tests using the Vitest runner via npx.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/README.md#_snippet_1

LANGUAGE: Bash
CODE:
```
$ npx vitest
```

----------------------------------------

TITLE: Organizing Tests with Vitest describe (TypeScript)
DESCRIPTION: Demonstrates how to use `describe` to group related `test` blocks within a file, creating a test suite for better organization and reporting.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/index.md#_snippet_34

LANGUAGE: TypeScript
CODE:
```
// basic.spec.ts
// organizing tests

import { describe, expect, test } from 'vitest'

const person = {
  isActive: true,
  age: 32,
}

describe('person', () => {
  test('person is defined', () => {
    expect(person).toBeDefined()
  })

  test('is active', () => {
    expect(person.isActive).toBeTruthy()
  })

  test('age limit', () => {
    expect(person.age).toBeLessThanOrEqual(32)
  })
})
```

----------------------------------------

TITLE: Configuring Vitest in Vite Config (New Reference) - TypeScript
DESCRIPTION: Shows how to include Vitest configuration within a Vite configuration file (`vite.config.js`), utilizing the newer `/// <reference types="vitest/config" />` directive for improved type checking, recommended for Vitest v4+. Vitest options reside within the `test` property.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_1

LANGUAGE: TypeScript
CODE:
```
/// <reference types="vitest/config" />
import { defineConfig } from 'vite'

export default defineConfig({
  test: {
    // ... Specify options here.
  },
})
```

----------------------------------------

TITLE: Assertion for Numerical Proximity in Vitest (TypeScript)
DESCRIPTION: Defines `assert.closeTo` (alias `approximately`) to check if a number `actual` is within `delta` of `expected`. Useful for floating-point comparisons. The snippet demonstrates its usage in a test.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_82

LANGUAGE: TypeScript
CODE:
```
import { assert, test } from 'vitest'

 test('assert.closeTo', () => {
  assert.closeTo(1.5, 1, 0.5, 'numbers are close')
})
```

----------------------------------------

TITLE: Asserting Instance with toBeInstanceOf in Vitest (TypeScript)
DESCRIPTION: The `toBeInstanceOf` matcher asserts if a value is an instance of a specific class. This is used to verify the class or constructor of an object.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_20

LANGUAGE: TypeScript
CODE:
```
import { expect, test } from 'vitest'
import { Stocks } from './stocks.js'

const stocks = new Stocks()

test('stocks are instance of Stocks', () => {
  expect(stocks).toBeInstanceOf(Stocks)
})
```

----------------------------------------

TITLE: Manually Install Vitest Browser Mode (Default)
DESCRIPTION: Install the core `vitest` and `@vitest/browser` packages manually. This setup is sufficient for running tests locally by reusing your existing browser without requiring an additional E2E provider.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/index.md#_snippet_1

LANGUAGE: npm
CODE:
```
npm install -D vitest @vitest/browser
```

LANGUAGE: yarn
CODE:
```
yarn add -D vitest @vitest/browser
```

LANGUAGE: pnpm
CODE:
```
pnpm add -D vitest @vitest/browser
```

LANGUAGE: bun
CODE:
```
bun add -D vitest @vitest/browser
```

----------------------------------------

TITLE: Running Only Specific File with Vitest (Shell)
DESCRIPTION: Shows how to execute only the tests contained within a specific file by passing the file path as an argument to the `vitest` command. This is helpful when focusing on tests marked with `only` within a single file.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/index.md#_snippet_14

LANGUAGE: Shell
CODE:
```
# vitest interesting.test.ts
```

----------------------------------------

TITLE: Sharding Test Runs with Vitest CLI - SH
DESCRIPTION: Demonstrates how to use the --shard option to divide test execution into multiple shards, enabling distributed or parallel test runs. The format is <index>/<count>, and each command runs the part of the suite corresponding to its index. Input: --shard parameter with values like 1/3, 2/3, etc. Output: Only the subset of tests for each shard is executed. Limitation: Cannot be combined with --watch mode; --reporter=blob output defaults to separate files per shard unless overridden.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/cli.md#_snippet_9

LANGUAGE: sh
CODE:
```
vitest run --shard=1/3
vitest run --shard=2/3
vitest run --shard=3/3

```

----------------------------------------

TITLE: Installing Vitest Coverage Providers (Bash)
DESCRIPTION: Commands to manually install the required packages for the v8 or istanbul coverage providers as dev dependencies.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/coverage.md#_snippet_1

LANGUAGE: bash
CODE:
```
npm i -D @vitest/coverage-v8
```

LANGUAGE: bash
CODE:
```
npm i -D @vitest/coverage-istanbul
```

----------------------------------------

TITLE: afterEach Basic Usage (TypeScript)
DESCRIPTION: Registers a callback function to be executed after each test within the current scope completes. It can be asynchronous and is useful for tearing down test environments, like clearing testing data.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/index.md#_snippet_52

LANGUAGE: TypeScript
CODE:
```
import { afterEach } from 'vitest'

afterEach(async () => {
  await clearTestingData() // clear testing data after each test run
})
```

----------------------------------------

TITLE: Testing Database Interaction with Mocked Client (Vitest/JS)
DESCRIPTION: Demonstrates how to test a function that uses a PostgreSQL client (`pg`). It shows how to mock the `pg` client and custom handler functions (`success`, `failure`) using `vi.fn()` and `vi.mock()`, and write test cases covering successful query execution and error handling.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/mocking.md#_snippet_9

LANGUAGE: javascript
CODE:
```
import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest'
import { Client } from 'pg'
import { failure, success } from './handlers.js'

// get todos
export async function getTodos(event, context) {
  const client = new Client({
    // ...clientOptions
  })

  await client.connect()

  try {
    const result = await client.query('SELECT * FROM todos;')

    client.end()

    return success({
      message: `${result.rowCount} item(s) returned`,
      data: result.rows,
      status: true,
    })
  }
  catch (e) {
    console.error(e.stack)

    client.end()

    return failure({ message: e, status: false })
  }
}

vi.mock('pg', () => {
  const Client = vi.fn()
  Client.prototype.connect = vi.fn()
  Client.prototype.query = vi.fn()
  Client.prototype.end = vi.fn()

  return { Client }
})

vi.mock('./handlers.js', () => {
  return {
    success: vi.fn(),
    failure: vi.fn(),
  }
})

describe('get a list of todo items', () => {
  let client

  beforeEach(() => {
    client = new Client()
  })

  afterEach(() => {
    vi.clearAllMocks()
  })

  it('should return items successfully', async () => {
    client.query.mockResolvedValueOnce({ rows: [], rowCount: 0 })

    await getTodos()

    expect(client.connect).toBeCalledTimes(1)
    expect(client.query).toBeCalledWith('SELECT * FROM todos;')
    expect(client.end).toBeCalledTimes(1)

    expect(success).toBeCalledWith({
      message: '0 item(s) returned',
      data: [],
      status: true,
    })
  })

  it('should throw an error', async () => {
    const mError = new Error('Unable to retrieve rows')
    client.query.mockRejectedValueOnce(mError)

    await getTodos()

    expect(client.connect).toBeCalledTimes(1)
    expect(client.query).toBeCalledWith('SELECT * FROM todos;')
    expect(client.end).toBeCalledTimes(1)
    expect(failure).toBeCalledWith({ message: mError, status: false })
  })
})
```

----------------------------------------

TITLE: User Event Handler in Vitest Browser Mode (TypeScript)
DESCRIPTION: Defines the `userEvent` handler for simulating user interactions in Vitest browser tests. It leverages the browser provider (Playwright or WebdriverIO) for implementation, falling back to simulated events via `@testing-library/user-event` with the `preview` provider. Provides methods for common user actions like click, double-click, typing, and drag-and-drop.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/context.md#_snippet_0

LANGUAGE: typescript
CODE:
```
/**
 * Handler for user interactions. The support is implemented by the browser provider (`playwright` or `webdriverio`).
 * If used with `preview` provider, fallbacks to simulated events via `@testing-library/user-event`.
 * @experimental
 */
export const userEvent: {
  setup: () => UserEvent
  cleanup: () => Promise<void>
  click: (element: Element, options?: UserEventClickOptions) => Promise<void>
  dblClick: (element: Element, options?: UserEventDoubleClickOptions) => Promise<void>
  tripleClick: (element: Element, options?: UserEventTripleClickOptions) => Promise<void>
  selectOptions: (
    element: Element,
    values: HTMLElement | HTMLElement[] | string | string[],
    options?: UserEventSelectOptions,
  ) => Promise<void>
  keyboard: (text: string) => Promise<void>
  type: (element: Element, text: string, options?: UserEventTypeOptions) => Promise<void>
  clear: (element: Element) => Promise<void>
  tab: (options?: UserEventTabOptions) => Promise<void>
  hover: (element: Element, options?: UserEventHoverOptions) => Promise<void>
  unhover: (element: Element, options?: UserEventHoverOptions) => Promise<void>
  fill: (element: Element, text: string, options?: UserEventFillOptions) => Promise<void>
  dragAndDrop: (source: Element, target: Element, options?: UserEventDragAndDropOptions) => Promise<void>
}
```

----------------------------------------

TITLE: Asserting Object Subset Match with Vitest toMatchObject (TypeScript)
DESCRIPTION: Demonstrates how to use `toMatchObject` to check if a received object contains at least the properties of an expected object. It also shows its use with arrays to ensure an exact number of elements and matching properties.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_33

LANGUAGE: TypeScript
CODE:
```
import { expect, test } from 'vitest'

const johnInvoice = {
  isActive: true,
  customer: {
    first_name: 'John',
    last_name: 'Doe',
    location: 'China',
  },
  total_amount: 5000,
  items: [
    {
      type: 'apples',
      quantity: 10,
    },
    {
      type: 'oranges',
      quantity: 5,
    },
  ],
}

const johnDetails = {
  customer: {
    first_name: 'John',
    last_name: 'Doe',
    location: 'China',
  },
}

test('invoice has john personal details', () => {
  expect(johnInvoice).toMatchObject(johnDetails)
})

test('the number of elements must match exactly', () => {
  // Assert that an array of object matches
  expect([{ foo: 'bar' }, { baz: 1 }]).toMatchObject([
    { foo: 'bar' },
    { baz: 1 },
  ])
})
```

----------------------------------------

TITLE: Using and Asserting on Mocked Instance (TypeScript)
DESCRIPTION: Demonstrates creating an instance of the mocked `Dog` class and calling its mocked methods (`speak`, `greet`). Shows how to use Vitest assertions (`toHaveBeenCalled`, `not.toHaveBeenCalled`) to verify method calls on the instance.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/mocking.md#_snippet_23

LANGUAGE: ts
CODE:
```
const Cooper = new Dog('Cooper')
Cooper.speak() // loud bark!
Cooper.greet() // Hi! My name is Cooper!

// you can use built-in assertions to check the validity of the call
expect(Cooper.speak).toHaveBeenCalled()
expect(Cooper.greet).toHaveBeenCalled()

const Max = new Dog('Max')

// methods assigned to the prototype are shared between instances
expect(Max.speak).toHaveBeenCalled()
expect(Max.greet).not.toHaveBeenCalled()
```

----------------------------------------

TITLE: Coverage Exclude Patterns Configuration
DESCRIPTION: Specifies glob patterns for files to be excluded from coverage. Can be set via the CLI using `--coverage.exclude <pattern>` or in the configuration file using the `coverage.exclude` property. May be specified multiple times.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/cli-generated.md#_snippet_19



----------------------------------------

TITLE: Configuring Vitest Test Options Using Object Argument
DESCRIPTION: Shows how to provide test configuration options, such as skipping a test or enabling concurrency, by passing an options object as the second argument to the `test` function.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/index.md#_snippet_2

LANGUAGE: TypeScript
CODE:
```
import { test } from 'vitest'

test('skipped test', { skip: true }, () => {
  // some logic that fails right now
})

test('skipped concurrent test', { skip: true, concurrent: true }, () => {
  // some logic that fails right now
})
```

----------------------------------------

TITLE: Defining Vitest Test Script in package.json
DESCRIPTION: Configures the 'test' script in package.json to use the 'vitest' command, allowing tests to be run via package manager commands like 'npm run test'.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/projects.md#_snippet_4

LANGUAGE: json
CODE:
```
{
  "scripts": {
    "test": "vitest"
  }
}
```

----------------------------------------

TITLE: Using expect for Basic Assertions in Vitest
DESCRIPTION: Demonstrates how to use the `expect` function in Vitest to create basic assertions. It shows examples using both the Chai API (`to.equal`) and the Jest API (`toBe`) to assert that a calculated value is equal to 2.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_2

LANGUAGE: TypeScript
CODE:
```
import { expect } from 'vitest'

const input = Math.sqrt(4)

expect(input).to.equal(2) // chai API
expect(input).toBe(2) // jest API
```

----------------------------------------

TITLE: Running Vitest Tests with Package Managers
DESCRIPTION: Executes the 'test' script defined in package.json using various package managers (npm, yarn, pnpm, bun) to start the Vitest test runner.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/projects.md#_snippet_5

LANGUAGE: bash
CODE:
```
npm run test
```

LANGUAGE: bash
CODE:
```
yarn test
```

LANGUAGE: bash
CODE:
```
pnpm run test
```

LANGUAGE: bash
CODE:
```
bun run test
```

----------------------------------------

TITLE: Defining a Test Case with Vitest test Function in TypeScript
DESCRIPTION: This example shows how to define a basic Vitest test case using the test() function, passing a descriptive string name and a callback as parameters. The snippet requires Vitest as a dependency and expects a test environment configured accordingly. The input is no argument (other than the name and test function), and there is no explicit output; the test will appear in Vitest's results. Useful for simple validation and demonstration purposes.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/test-case.md#_snippet_1

LANGUAGE: typescript
CODE:
```
import { test } from 'vitest'

test('the validation works correctly', () => {
  // ...
})
```

----------------------------------------

TITLE: Adding Vitest Test Script to package.json (JSON)
DESCRIPTION: Configure the `package.json` file to add a script named 'test' that executes Vitest.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/index.md#_snippet_3

LANGUAGE: json
CODE:
```
{
  "scripts": {
    "test": "vitest"
  }
}
```

----------------------------------------

TITLE: Defining Nested Tests with describe and test in Vitest Using TypeScript
DESCRIPTION: This snippet illustrates grouping related test cases within a describe block in Vitest using TypeScript. It helps organize large test suites and constructs a hierarchical full name for nested tests, aiding in better reporting. Requires importing both test() and describe() functions from Vitest. Inputs are test and suite names; outputs are properly nested test results. There are no external constraints, aside from the Vitest setup.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/test-case.md#_snippet_2

LANGUAGE: typescript
CODE:
```
import { describe, test } from 'vitest'

describe('the validation logic', () => {
  test('the validation works correctly', () => {
    // ...
  })
})
```

----------------------------------------

TITLE: Basic Vitest Test Definition
DESCRIPTION: Demonstrates the fundamental usage of the `test` function (or its alias `it`) to define a test case with a name and a callback function containing expectations using `expect`.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/index.md#_snippet_6

LANGUAGE: TypeScript
CODE:
```
import { expect, test } from 'vitest'

test('should work as expected', () => {
  expect(Math.sqrt(4)).toBe(2)
})
```

----------------------------------------

TITLE: Testing Types with expectTypeOf and assertType in Vitest (TS)
DESCRIPTION: This snippet demonstrates how to write type tests in Vitest using `expectTypeOf` and `assertType`. It checks if a function `mount` is callable, validates the type of its first parameter, and uses `@ts-expect-error` with `assertType` to confirm that a specific invalid usage correctly triggers a TypeScript error.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/testing-types.md#_snippet_0

LANGUAGE: ts
CODE:
```
import { assertType, expectTypeOf } from 'vitest'
import { mount } from './mount.js'

test('my types work properly', () => {
  expectTypeOf(mount).toBeFunction()
  expectTypeOf(mount).parameter(0).toMatchTypeOf<{ name: string }>()

  // @ts-expect-error name is a string
  assertType(mount({ name: 42 }))
})
```

----------------------------------------

TITLE: Asserting Deep Equality with toEqual in Vitest (TypeScript)
DESCRIPTION: The `toEqual` matcher asserts if the actual value is equal to the received value, performing a deep comparison for objects and arrays. It checks if they have the same structure and values recursively.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_25

LANGUAGE: TypeScript
CODE:
```
import { expect, test } from 'vitest'

const stockBill = {
  type: 'apples',
  count: 13,
}

const stockMary = {
  type: 'apples',
  count: 13,
}

test('stocks have the same properties', () => {
  expect(stockBill).toEqual(stockMary)
})
```

----------------------------------------

TITLE: Using Reporters via Command Line
DESCRIPTION: This snippet demonstrates how to specify the reporter using the command line interface (CLI) when running Vitest tests.  It uses the `--reporter` option followed by the reporter name (e.g., `verbose`). This is a quick way to change the reporting style without modifying the configuration file.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/reporters.md#_snippet_0

LANGUAGE: bash
CODE:
```
npx vitest --reporter=verbose
```

----------------------------------------

TITLE: Asserting Rejected Promise Error with Vitest rejects.toThrowError (TypeScript)
DESCRIPTION: Shows how to use `await expect(promise).rejects.toThrowError()` to test if an asynchronous promise rejects with an error. This is the correct way to handle error assertions for promises in Vitest.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_34

LANGUAGE: TypeScript
CODE:
```
test('expect rejects toThrow', async ({ expect }) => {
  const promise = Promise.reject(new Error('Test'))
  await expect(promise).rejects.toThrowError()
})
```

----------------------------------------

TITLE: TSX example demonstrating `exact` option for `getByRole`
DESCRIPTION: This TSX snippet illustrates the usage of the `exact` option with `getByRole`. It highlights the difference between case-insensitive substring matching (default) and case-sensitive whole-string matching when locating elements by ARIA role. Requires a TSX environment that supports JSX syntax. No external dependencies needed other than a rendering context for the TSX.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_2

LANGUAGE: tsx
CODE:
```
<button>Hello World</button>

page.getByRole('button', { name: 'hello world' }) // ✅
page.getByRole('button', { name: 'hello world', exact: true }) // ❌
page.getByRole('button', { name: 'Hello World', exact: true }) // ✅
```

----------------------------------------

TITLE: Mocking Class with vi.fn and Prototype (TypeScript)
DESCRIPTION: Demonstrates how to mock a class using `vi.fn` for the constructor, assigning static mocks directly to the function, and assigning instance method mocks to the prototype. Instance methods defined as arrow functions in the original class are mocked within the constructor to ensure each instance has its own spy.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/mocking.md#_snippet_18

LANGUAGE: ts
CODE:
```
const Dog = vi.fn(function (name) {
  this.name = name
  // mock instance methods in the constructor, each instance will have its own spy
  this.greet = vi.fn(() => `Hi! My name is ${this.name}!`)
})

// notice that static methods are mocked directly on the function,
// not on the instance of the class
Dog.getType = vi.fn(() => 'mocked animal')

// mock the "speak" and "feed" methods on every instance of a class
// all `new Dog()` instances will inherit and share these spies
Dog.prototype.speak = vi.fn(() => 'loud bark!')
Dog.prototype.feed = vi.fn()
```

----------------------------------------

TITLE: Asserting Element Visibility in Vitest Tests (JavaScript)
DESCRIPTION: Checks if a DOM element is considered visible to the user based on its bounding box, display style, and visibility style. Useful for verifying that UI elements are rendered and interactable. Requires `expect.element` and locator methods like `page.getByText` or `page.getByTestId`.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_9

LANGUAGE: TypeScript
CODE:
```
function toBeVisible(): Promise<void>
```

LANGUAGE: JavaScript
CODE:
```
// A specific element is visible.
await expect.element(page.getByText('Welcome')).toBeVisible()

// At least one item in the list is visible.
await expect.element(page.getByTestId('todo-item').first()).toBeVisible()

// At least one of the two elements is visible, possibly both.
await expect.element(
  page.getByRole('button', { name: 'Sign in' })
    .or(page.getByRole('button', { name: 'Sign up' }))
    .first()
).toBeVisible()
```

----------------------------------------

TITLE: Silent Console Output Configuration
DESCRIPTION: Silences console output from tests. Can be configured via the CLI using `--silent [value]` or in the configuration file using the `silent` property. Use `'passed-only'` to see logs only from failing tests.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/cli-generated.md#_snippet_11



----------------------------------------

TITLE: Enabling Global APIs in Vitest Configuration (TypeScript)
DESCRIPTION: Shows how to configure Vitest to expose its APIs globally by setting the `globals` option to `true` within the `test` configuration object in a TypeScript config file.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_9

LANGUAGE: ts
CODE:
```
import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    globals: true,
  },
})
```

----------------------------------------

TITLE: Mocking Exported Function with vi.spyOn (TypeScript)
DESCRIPTION: Shows an alternative way to mock an exported function using `vi.spyOn`. It spies on the function property of the imported module object and replaces its implementation using `mockImplementation`.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/mocking.md#_snippet_30

LANGUAGE: ts
CODE:
```
import * as exports from './example.js'

vi.spyOn(exports, 'method').mockImplementation(() => {})
```

----------------------------------------

TITLE: Testing with Mocked Class Instance (TypeScript)
DESCRIPTION: A Vitest test example demonstrating how to create a mocked `Dog` class using `vi.fn`, mock its prototype methods, create an instance, pass it to the `feed` function, and assert that the mocked method (`feed`) was called.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/mocking.md#_snippet_22

LANGUAGE: ts
CODE:
```
import { expect, test, vi } from 'vitest'
import { feed } from '../src/feed.js'

const Dog = vi.fn()
Dog.prototype.feed = vi.fn()

test('can feed dogs', () => {
  const dogMax = new Dog('Max')

  feed(dogMax)

  expect(dogMax.feed).toHaveBeenCalled()
  expect(dogMax.isHungry()).toBe(false)
})
```

----------------------------------------

TITLE: Setting a Mock to Reject with mockRejectedValue
DESCRIPTION: This snippet demonstrates how to configure a mock function to reject with a specific error using `mockRejectedValue`. This is useful for testing asynchronous code that handles rejections.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/mock.md#_snippet_7

LANGUAGE: typescript
CODE:
```
const asyncMock = vi.fn().mockRejectedValue(new Error('Async error'))

await asyncMock() // throws Error<'Async error'>
```

----------------------------------------

TITLE: Testing React Components with Vitest Browser Mode (TSX)
DESCRIPTION: Demonstrates testing a React component using `vitest-browser-react`. It covers rendering the component, simulating a button click, waiting for an element to appear, and asserting its text content and the button's disabled state using `expect.element`.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/index.md#_snippet_17

LANGUAGE: tsx
CODE:
```
import { render } from 'vitest-browser-react'
import Fetch from './fetch'

test('loads and displays greeting', async () => {
  // Render a React element into the DOM
  const screen = render(<Fetch url="/greeting" />)

  await screen.getByText('Load Greeting').click()
  // wait before throwing an error if it cannot find an element
  const heading = screen.getByRole('heading')

  // assert that the alert message is correct
  await expect.element(heading).toHaveTextContent('hello there')
  await expect.element(screen.getByRole('button')).toBeDisabled()
})
```

----------------------------------------

TITLE: Registering beforeAll Hook in Vitest (TypeScript)
DESCRIPTION: This snippet demonstrates registering a basic `beforeAll` hook in Vitest. The asynchronous callback function is executed once before all tests in the current context begin, ensuring necessary setup like mocking is completed beforehand.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/index.md#_snippet_53

LANGUAGE: ts
CODE:
```
import { beforeAll } from 'vitest'

beforeAll(async () => {
  await startMocking() // called once before all tests run
})
```

----------------------------------------

TITLE: Vitest Test Sharding GitHub Actions Workflow (YAML)
DESCRIPTION: Provides a complete GitHub Actions workflow example demonstrating how to run sharded Vitest tests in parallel across multiple jobs using a matrix strategy. It includes steps for checkout, node setup, dependency installation, running sharded tests, uploading reports, downloading reports, and merging them.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/improving-performance.md#_snippet_5

LANGUAGE: yaml
CODE:
```
# Inspired from https://playwright.dev/docs/test-sharding
name: Tests
on:
  push:
    branches:
      - main
jobs:
  tests:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        shardIndex: [1, 2, 3, 4]
        shardTotal: [4]
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install pnpm
        uses: pnpm/action-setup@a7487c7e89a18df4991f7f222e4898a00d66ddda # v4.1.0

      - name: Install dependencies
        run: pnpm i

      - name: Run tests
        run: pnpm run test --reporter=blob --shard=${{ matrix.shardIndex }}/${{ matrix.shardTotal }}

      - name: Upload blob report to GitHub Actions Artifacts
        if: ${{ !cancelled() }}
        uses: actions/upload-artifact@v4
        with:
          name: blob-report-${{ matrix.shardIndex }}
          path: .vitest-reports/*
          include-hidden-files: true
          retention-days: 1

  merge-reports:
    if: ${{ !cancelled() }}
    needs: [tests]

    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install pnpm
        uses: pnpm/action-setup@a7487c7e89a18df4991f7f222e4898a00d66ddda # v4.1.0

      - name: Install dependencies
        run: pnpm i

      - name: Download blob reports from GitHub Actions Artifacts
        uses: actions/download-artifact@v4
        with:
          path: .vitest-reports
          pattern: blob-report-*
          merge-multiple: true

      - name: Merge reports
        run: npx vitest --merge-reports
```

----------------------------------------

TITLE: Defining Test and Coverage Scripts with Vitest in package.json
DESCRIPTION: This JSON snippet adds 'test' and 'coverage' scripts to package.json for project automation. The 'test' script runs all tests with Vitest, and the 'coverage' script collects code coverage using 'vitest run --coverage'. Vitest must be included in 'devDependencies'. These scripts standardize testing workflows and integrate with CI systems. No parameters are needed to run; triggering is done via 'npm run test' or 'npm run coverage'.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/features.md#_snippet_8

LANGUAGE: json
CODE:
```
{
  "scripts": {
    "test": "vitest",
    "coverage": "vitest run --coverage"
  }
}

```

----------------------------------------

TITLE: Partial Mocking with vi.importActual in Vitest (TypeScript)
DESCRIPTION: Demonstrates how to use vi.importActual within a vi.mock factory function to obtain the original module's exports, allowing for partial mocking by spreading the original exports and overriding specific properties.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_10

LANGUAGE: ts
CODE:
```
vi.mock('./example.js', async () => {
  const originalModule = await vi.importActual('./example.js')

  return { ...originalModule, get: vi.fn() }
})
```

----------------------------------------

TITLE: Spying on Object Method Vitest TypeScript
DESCRIPTION: Illustrates how to use `vi.spyOn` to create a spy on a method of an object. The example shows how to mock the implementation of the spied method and assert if it was called and what it returned.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_17

LANGUAGE: typescript
CODE:
```
let apples = 0
const cart = {
  getApples: () => 42,
}

const spy = vi.spyOn(cart, 'getApples').mockImplementation(() => apples)
apples = 1

expect(cart.getApples()).toBe(1)

expect(spy).toHaveBeenCalled()
expect(spy).toHaveReturnedWith(1)
```

----------------------------------------

TITLE: Testing DOM Interaction with Vitest Browser Mode (JS)
DESCRIPTION: Demonstrates a basic browser mode test for DOM interaction. It shows rendering elements, asserting initial state, getting an input element using `page.getByLabelText`, filling it using the `fill` method, and asserting the updated state using `expect.element` and `toBeInTheDocument`.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/index.md#_snippet_12

LANGUAGE: js
CODE:
```
import { expect, test } from 'vitest'
import { page } from '@vitest/browser/context'
import { render } from './my-render-function.js'

test('properly handles form inputs', async () => {
  render() // mount DOM elements

  // Asserts initial state.
  await expect.element(page.getByText('Hi, my name is Alice')).toBeInTheDocument()

  // Get the input DOM node by querying the associated label.
  const usernameInput = page.getByLabelText(/username/i)

  // Type the name into the input. This already validates that the input
  // is filled correctly, no need to check the value manually.
  await usernameInput.fill('Bob')

  await expect.element(page.getByText('Hi, my name is Bob')).toBeInTheDocument()
})
```

----------------------------------------

TITLE: Mocking HTTP Requests with MSW in Vitest
DESCRIPTION: This snippet demonstrates how to set up Mock Service Worker (MSW) in a Vitest setup file to intercept and mock HTTP GET requests. It shows how to define request handlers using `http.get` and manage the MSW server lifecycle using Vitest's `beforeAll`, `afterAll`, and `afterEach` hooks.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/mocking.md#_snippet_13

LANGUAGE: js
CODE:
```
import { afterAll, afterEach, beforeAll } from 'vitest'
import { setupServer } from 'msw/node'
import { http, HttpResponse } from 'msw'

const posts = [
  {
    userId: 1,
    id: 1,
    title: 'first post title',
    body: 'first post body',
  },
  // ...
]

export const restHandlers = [
  http.get('https://rest-endpoint.example/path/to/posts', () => {
    return HttpResponse.json(posts)
  }),
]

const server = setupServer(...restHandlers)

// Start server before all tests
beforeAll(() => server.listen({ onUnhandledRequest: 'error' }))

// Close server after all tests
afterAll(() => server.close())

// Reset handlers after each test for test isolation
afterEach(() => server.resetHandlers())
```

----------------------------------------

TITLE: Using expect.objectContaining with Vitest
DESCRIPTION: This asymmetric matcher checks if an object has a similar shape or contains specific properties with matching values when used in an equality check.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_70

LANGUAGE: TypeScript
CODE:
```
import { expect, test } from 'vitest'

test('basket has empire apples', () => {
  const basket = {
    varieties: [
      {
        name: 'Empire',
        count: 1,
      }
    ],
  }
  expect(basket).toEqual({
    varieties: [
      expect.objectContaining({ name: 'Empire' }),
    ]
  })
})
```

----------------------------------------

TITLE: Configuring Vitest Environment for happy-dom or jsdom in TypeScript
DESCRIPTION: This TypeScript configuration snippet demonstrates how to set the environment for Vitest to 'happy-dom', 'jsdom', or 'node' by editing the 'vitest.config.ts' file. It uses 'defineConfig' from 'vitest/config'. Prerequisites include installing the selected environment package ('happy-dom' or 'jsdom'). The 'test.environment' field should match the intended environment. The config determines how Vitest interprets APIs during testing.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/features.md#_snippet_7

LANGUAGE: typescript
CODE:
```
import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    environment: 'happy-dom', // or 'jsdom', 'node'
  },
})

```

----------------------------------------

TITLE: Specifying test file and line number in Vitest CLI
DESCRIPTION: This snippet shows how to run a specific test in a file by specifying the filename and line number, requiring the full filename for accuracy.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/filtering.md#_snippet_2

LANGUAGE: bash
CODE:
```
$ vitest basic/foo.test.ts:10
```

----------------------------------------

TITLE: Creating Basic Snapshot with Vitest toMatchSnapshot (TypeScript)
DESCRIPTION: Demonstrates the fundamental usage of `toMatchSnapshot` to create a snapshot of a value during the first test run and compare subsequent test runs against that stored snapshot.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_37

LANGUAGE: TypeScript
CODE:
```
import { expect, test } from 'vitest'

test('matches snapshot', () => {
  const data = { foo: new Set(['bar', 'snapshot']) }
  expect(data).toMatchSnapshot()
})
```

----------------------------------------

TITLE: Type Text into Element using Vitest userEvent (ts)
DESCRIPTION: Simulates typing text into an input, textarea, or contenteditable element using `userEvent.type`. This method is based on `@testing-library/user-event`'s `type` utility and supports its keyboard syntax, including special characters. For better performance when not using special characters, consider `userEvent.fill`.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/interactivity-api.md#_snippet_15

LANGUAGE: ts
CODE:
```
import { page, userEvent } from '@vitest/browser/context'

test('update input', async () => {
  const input = page.getByRole('input')

  await userEvent.type(input, 'foo') // input.value == foo
  await userEvent.type(input, '{{a[[') // input.value == foo{a[
  await userEvent.type(input, '{Shift}') // input.value == foo{a[
})
```

----------------------------------------

TITLE: Mocking Dates with Vitest
DESCRIPTION: This snippet shows how to mock the system date and time in Vitest tests using vi.useFakeTimers and vi.setSystemTime. It includes setup (beforeEach) and teardown (afterEach) for managing fake timers and tests a function whose behavior depends on the current hour.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/mocking.md#_snippet_0

LANGUAGE: javascript
CODE:
```
import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest'

const businessHours = [9, 17]

function purchase() {
  const currentHour = new Date().getHours()
  const [open, close] = businessHours

  if (currentHour > open && currentHour < close) {
    return { message: 'Success' }
  }

  return { message: 'Error' }
}

describe('purchasing flow', () => {
  beforeEach(() => {
    // tell vitest we use mocked time
    vi.useFakeTimers()
  })

  afterEach(() => {
    // restoring date after each test run
    vi.useRealTimers()
  })

  it('allows purchases within business hours', () => {
    // set hour within business hours
    const date = new Date(2000, 1, 1, 13)
    vi.setSystemTime(date)

    // access Date.now() will result in the date set above
    expect(purchase()).toEqual({ message: 'Success' })
  })

  it('disallows purchases outside of business hours', () => {
    // set hour outside business hours
    const date = new Date(2000, 1, 1, 19)
    vi.setSystemTime(date)

    // access Date.now() will result in the date set above
    expect(purchase()).toEqual({ message: 'Error' })
  })
})
```

----------------------------------------

TITLE: Setting a Mock to Resolve with mockResolvedValue
DESCRIPTION: This snippet demonstrates how to configure a mock function to resolve with a specific value using `mockResolvedValue`. TypeScript ensures that the provided value matches the return type of the original function. This is particularly useful for testing asynchronous functions that return promises.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/mock.md#_snippet_11

LANGUAGE: typescript
CODE:
```
const asyncMock = vi.fn().mockResolvedValue(42)

await asyncMock() // 42
```

----------------------------------------

TITLE: Configuring Vitest Browser Mode with Framework Plugins
DESCRIPTION: These snippets demonstrate how to integrate common framework plugins (React, Vue, Svelte, Solid, Marko) into the Vitest configuration while enabling browser mode. The framework plugin is added to the `plugins` array, and the `test.browser` configuration remains consistent.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/index.md#_snippet_5

LANGUAGE: ts
CODE:
```
import { defineConfig } from 'vitest/config'
import react from '@vitejs/plugin-react'

export default defineConfig({
  plugins: [react()],
  test: {
    browser: {
      enabled: true,
      provider: 'playwright',
      instances: [
        { browser: 'chromium' },
      ],
    }
  }
})
```

LANGUAGE: ts
CODE:
```
import { defineConfig } from 'vitest/config'
import vue from '@vitejs/plugin-vue'

export default defineConfig({
  plugins: [vue()],
  test: {
    browser: {
      enabled: true,
      provider: 'playwright',
      instances: [
        { browser: 'chromium' },
      ],
    }
  }
})
```

LANGUAGE: ts
CODE:
```
import { defineConfig } from 'vitest/config'
import { svelte } from '@sveltejs/vite-plugin-svelte'

export default defineConfig({
  plugins: [svelte()],
  test: {
    browser: {
      enabled: true,
      provider: 'playwright',
      instances: [
        { browser: 'chromium' },
      ],
    }
  }
})
```

LANGUAGE: ts
CODE:
```
import { defineConfig } from 'vitest/config'
import solidPlugin from 'vite-plugin-solid'

export default defineConfig({
  plugins: [solidPlugin()],
  test: {
    browser: {
      enabled: true,
      provider: 'playwright',
      instances: [
        { browser: 'chromium' },
      ],
    }
  }
})
```

LANGUAGE: ts
CODE:
```
import { defineConfig } from 'vitest/config'
import marko from '@marko/vite'

export default defineConfig({
  plugins: [marko()],
  test: {
    browser: {
      enabled: true,
      provider: 'playwright',
      instances: [
        { browser: 'chromium' },
      ],
    }
  }
})
```

----------------------------------------

TITLE: Using Fake Timers in Vitest
DESCRIPTION: This example demonstrates how to use Vitest's fake timers (`vi.useFakeTimers`) to test functions that use `setTimeout` and `setInterval`. It shows how to advance time using `vi.runAllTimers` and `vi.advanceTimersByTime` to avoid actual waiting, and how to manage timer mocks using `beforeEach` and `afterEach`.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/mocking.md#_snippet_16

LANGUAGE: js
CODE:
```
import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest'

function executeAfterTwoHours(func) {
  setTimeout(func, 1000 * 60 * 60 * 2) // 2 hours
}

function executeEveryMinute(func) {
  setInterval(func, 1000 * 60) // 1 minute
}

const mock = vi.fn(() => console.log('executed'))

describe('delayed execution', () => {
  beforeEach(() => {
    vi.useFakeTimers()
  })
  afterEach(() => {
    vi.restoreAllMocks()
  })
  it('should execute the function', () => {
    executeAfterTwoHours(mock)
    vi.runAllTimers()
    expect(mock).toHaveBeenCalledTimes(1)
  })
  it('should not execute the function', () => {
    executeAfterTwoHours(mock)
    // advancing by 2ms won't trigger the func
    vi.advanceTimersByTime(2)
    expect(mock).not.toHaveBeenCalled()
  })
  it('should execute every minute', () => {
    executeEveryMinute(mock)
    vi.advanceTimersToNextTimer()
    expect(mock).toHaveBeenCalledTimes(1)
    vi.advanceTimersToNextTimer()
    expect(mock).toHaveBeenCalledTimes(2)
  })
})
```

----------------------------------------

TITLE: Asserting Strict Equality with Vitest's toStrictEqual (TypeScript)
DESCRIPTION: Uses Vitest's `toStrictEqual` matcher to assert if two values are strictly equal, considering type, undefined properties, and array sparseness. This differs from `toEqual` by enforcing stricter type and structure checks. The example demonstrates how `toStrictEqual` distinguishes between a class instance and a literal object with the same properties.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_27

LANGUAGE: TypeScript
CODE:
```
import { expect, test } from 'vitest'

class Stock {
  constructor(type) {
    this.type = type
  }
}

test('structurally the same, but semantically different', () => {
  expect(new Stock('apples')).toEqual({ type: 'apples' })
  expect(new Stock('apples')).not.toStrictEqual({ type: 'apples' })
})
```

----------------------------------------

TITLE: Asserting Function Return Value with Vitest
DESCRIPTION: Verifies that a spy function has successfully returned a specific value at least once. Requires a spy function.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_52

LANGUAGE: typescript
CODE:
```
import { expect, test, vi } from 'vitest'

test('spy function returns a product', () => {
  const sell = vi.fn((product: string) => ({ product }))

  sell('apples')

  expect(sell).toHaveReturnedWith({ product: 'apples' })
})
```

----------------------------------------

TITLE: Asserting Value is One of Options with toBeOneOf in Vitest (TypeScript)
DESCRIPTION: The `toBeOneOf` matcher asserts if a value matches any of the values present in the provided array. This is useful for checking if a value belongs to a specific set of allowed options.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_17

LANGUAGE: TypeScript
CODE:
```
import { expect, test } from 'vitest'

test('fruit is one of the allowed values', () => {
  expect(fruit).toBeOneOf(['apple', 'banana', 'orange'])
})
```

----------------------------------------

TITLE: Mocking the current date using vi.setSystemTime in Vitest
DESCRIPTION: Demonstrates how to mock the system time for `Date` objects using the `vi.setSystemTime` helper function. Note that this mock persists until explicitly reset, for example, with `vi.useRealTimers()`.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/mocking.md#_snippet_35

LANGUAGE: ts
CODE:
```
const mockDate = new Date(2022, 0, 1)
vi.setSystemTime(mockDate)
const now = new Date()
expect(now.valueOf()).toBe(mockDate.valueOf())
// reset mocked time
vi.useRealTimers()
```

----------------------------------------

TITLE: Spying on Object Methods with vi.spyOn
DESCRIPTION: This snippet demonstrates the use of `vi.spyOn` to track calls to a method on an existing object. It shows how to spy on a method, call the method, and then assert that the method was called using the `mock.calls.length` property. This is useful for verifying that a method was called during a test.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/mock.md#_snippet_1

LANGUAGE: javascript
CODE:
```
const market = {
  getApples: () => 100
}

const getApplesSpy = vi.spyOn(market, 'getApples')
market.getApples()
getApplesSpy.mock.calls.length === 1
```

----------------------------------------

TITLE: Locating elements by ARIA role with `getByRole` in Vitest (TS)
DESCRIPTION: This snippet demonstrates how to locate elements by their ARIA role using the `getByRole` method in Vitest. It shows how to find elements by role, accessible name, and other ARIA attributes. The example also uses `expect.element` to assert the visibility of an element and `fill` to populate textboxes. Requires the Vitest environment to be configured for browser mode testing. Returns a Locator object.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_0

LANGUAGE: typescript
CODE:
```
function getByRole(
  role: ARIARole | string,
  options?: LocatorByRoleOptions,
): Locator
```

LANGUAGE: typescript
CODE:
```
await expect.element(
  page.getByRole('heading', { name: 'Sign up' })
).toBeVisible()

await page.getByRole('textbox', { name: 'Login' }).fill('admin')
await page.getByRole('textbox', { name: 'Password' }).fill('admin')

await page.getByRole('button', { name: /submit/i }).click()
```

----------------------------------------

TITLE: Filtering Vitest Tests by File and Line Number
DESCRIPTION: Demonstrates how to use the new filtering capability in Vitest 3 to run tests located at a specific line number within a file. This feature allows for more granular test execution.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/blog/vitest-3.md#_snippet_2

LANGUAGE: shell
CODE:
```
$ vitest basic/foo.js:10
$ vitest ./basic/foo.js:10
```

----------------------------------------

TITLE: Configuring Fake Timers in Vitest with TypeScript
DESCRIPTION: Illustrates new default behavior for fake timers and how to configure them explicitly in Vitest. The first snippet calls vi.useFakeTimers, showing performance.now() is now mocked. The second snippet exports a configuration object with fakeTimers.toFake set to a list of timer-related API names. Dependencies: 'vi.useFakeTimers', defineConfig. Input: none. Output: overridden/simulated timers during test runs.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/migration.md#_snippet_4

LANGUAGE: TypeScript
CODE:
```
vi.useFakeTimers()

performance.now() // original
performance.now() // fake
```

LANGUAGE: TypeScript
CODE:
```
export default defineConfig({
  test: {
    fakeTimers: {
      toFake: [
        'setTimeout',
        'clearTimeout',
        'setInterval',
        'clearInterval',
        'setImmediate',
        'clearImmediate',
        'Date',
      ]
    },
  },
})
```

----------------------------------------

TITLE: toHaveResolvedWith - Vitest Assertion (TypeScript)
DESCRIPTION: You can call this assertion to check if a function has successfully resolved a certain value at least once. Requires a spy function to be passed to `expect`. If the function returned a promise, but it was not resolved yet, this will fail.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_57

LANGUAGE: ts
CODE:
```
import { expect, test, vi } from 'vitest'

test('spy function resolved a product', async () => {
  const sell = vi.fn((product: string) => Promise.resolve({ product }))

  await sell('apples')

  expect(sell).toHaveResolvedWith({ product: 'apples' })
})
```

----------------------------------------

TITLE: Installing happy-dom for Browser Mocking using Bash
DESCRIPTION: This bash command snippet shows how to install 'happy-dom' as a development dependency for use with Vitest. The package is required when using browser or DOM APIs for mocking during testing, but must be installed separately as it is not bundled. Executing this command adds 'happy-dom' to the project's 'devDependencies'.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/features.md#_snippet_5

LANGUAGE: bash
CODE:
```
$ npm i -D happy-dom

```

----------------------------------------

TITLE: Configuring Vitest Pool to 'forks'
DESCRIPTION: This code snippet illustrates how to configure the test pool option in `vitest.config.js` to use the 'forks' pool.  The 'forks' pool executes tests in separate `node:child_process` instances, which can be used as a workaround for issues like NodeJS's `fetch` failing to terminate or native code errors when using the default 'threads' pool. Using 'forks' provides process-level isolation for tests.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/common-errors.md#_snippet_3

LANGUAGE: typescript
CODE:
```
import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    pool: 'forks',
  },
})
```

----------------------------------------

TITLE: Mocking Exported Function with vi.mock (TypeScript)
DESCRIPTION: Demonstrates mocking an exported function using `vi.mock` with a module factory. The factory returns an object containing the function name mapped to a `vi.fn()` mock. Note that `vi.mock` is hoisted.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/mocking.md#_snippet_29

LANGUAGE: ts
CODE:
```
import { method } from './example.js'

vi.mock('./example.js', () => ({
  method: vi.fn()
}))
```

----------------------------------------

TITLE: Using toMatchSnapshot() in Vitest (TypeScript)
DESCRIPTION: This code snippet demonstrates how to use `toMatchSnapshot()` in Vitest to create a snapshot of a function's output. The test will fail if the current output doesn't match the stored snapshot. Dependencies: vitest. Input: none. Output: A snapshot file is created or updated.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/snapshot.md#_snippet_0

LANGUAGE: typescript
CODE:
```
import { expect, it } from 'vitest'

it('toUpperCase', () => {
  const result = toUpperCase('foobar')
  expect(result).toMatchSnapshot()
})
```

----------------------------------------

TITLE: Setting Return Value with mockReturnValue
DESCRIPTION: This snippet demonstrates how to configure a mock function to return a specific value using `mockReturnValue`.  TypeScript checks that the return value type matches that of the original function.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/mock.md#_snippet_14

LANGUAGE: typescript
CODE:
```
const mock = vi.fn()
mock.mockReturnValue(42)
mock() // 42
mock.mockReturnValue(43)
mock() // 43
```

----------------------------------------

TITLE: Checking Call Order of Mocks in Vitest (Before)
DESCRIPTION: Illustrates using `toHaveBeenCalledBefore` to assert that one mock function was called prior to another mock function. Requires mocks created with `vi.fn()`. Requires `expect` and `test` from 'vitest'.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_45

LANGUAGE: ts
CODE:
```
test('calls mock1 before mock2', () => {
  const mock1 = vi.fn()
  const mock2 = vi.fn()

  mock1()
  mock2()
  mock1()

  expect(mock1).toHaveBeenCalledBefore(mock2)
})
```

----------------------------------------

TITLE: Configuring Vitest Browser Mode with Playwright
DESCRIPTION: This snippet shows the basic configuration required to enable Vitest's browser mode using Playwright as the provider. It sets `browser.enabled` to true and specifies a 'chromium' instance.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/index.md#_snippet_4

LANGUAGE: ts
CODE:
```
import { defineConfig } from 'vitest/config'
export default defineConfig({
  test: {
    browser: {
      provider: 'playwright', // or 'webdriverio'
      enabled: true,
      // at least one instance is required
      instances: [
        { browser: 'chromium' },
      ],
    },
  }
})
```

----------------------------------------

TITLE: Testing File System Interaction with Mocked fs (Vitest/TS)
DESCRIPTION: Provides test cases for the `readHelloWorld` function when the `node:fs` module is mocked using `memfs`. It shows how to use `vi.mock('node:fs')`, reset the `memfs` volume (`vol.reset()`) before each test, and populate the in-memory file system (`fs.writeFileSync`, `vol.fromJSON`) to set up test conditions.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/mocking.md#_snippet_12

LANGUAGE: typescript
CODE:
```
import { beforeEach, expect, it, vi } from 'vitest'
import { fs, vol } from 'memfs'
import { readHelloWorld } from './read-hello-world.js'

// tell vitest to use fs mock from __mocks__ folder
// this can be done in a setup file if fs should always be mocked
vi.mock('node:fs')
vi.mock('node:fs/promises')

beforeEach(() => {
  // reset the state of in-memory fs
  vol.reset()
})

it('should return correct text', () => {
  const path = '/hello-world.txt'
  fs.writeFileSync(path, 'hello world')

  const text = readHelloWorld(path)
  expect(text).toBe('hello world')
})

it('can return a value multiple times', () => {
  // you can use vol.fromJSON to define several files
  vol.fromJSON(
    {
      './dir1/hw.txt': 'hello dir1',
      './dir2/hw.txt': 'hello dir2',
    },
    // default cwd
    '/tmp',
  )

  expect(readHelloWorld('/tmp/dir1/hw.txt')).toBe('hello dir1')
  expect(readHelloWorld('/tmp/dir2/hw.txt')).toBe('hello dir2')
})

```

----------------------------------------

TITLE: Mocking and Spying on Functions with Vitest
DESCRIPTION: This example illustrates the use of vi.spyOn for observing function calls and vi.fn for creating mock functions with custom implementations in Vitest. It demonstrates checking call counts and temporarily overriding mock behavior using mockImplementationOnce. Mocks are restored using vi.restoreAllMocks after each test.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/mocking.md#_snippet_1

LANGUAGE: javascript
CODE:
```
import { afterEach, describe, expect, it, vi } from 'vitest'

const messages = {
  items: [
    { message: 'Simple test message', from: 'Testman' },
    // ...
  ],
  getLatest, // can also be a `getter or setter if supported`
}

function getLatest(index = messages.items.length - 1) {
  return messages.items[index]
}

describe('reading messages', () => {
  afterEach(() => {
    vi.restoreAllMocks()
  })

  it('should get the latest message with a spy', () => {
    const spy = vi.spyOn(messages, 'getLatest')
    expect(spy.getMockName()).toEqual('getLatest')

    expect(messages.getLatest()).toEqual(
      messages.items[messages.items.length - 1],
    )

    expect(spy).toHaveBeenCalledTimes(1)

    spy.mockImplementationOnce(() => 'access-restricted')
    expect(messages.getLatest()).toEqual('access-restricted')

    expect(spy).toHaveBeenCalledTimes(2)
  })

  it('should get with a mock', () => {
    const mock = vi.fn().mockImplementation(getLatest)

    expect(mock()).toEqual(messages.items[messages.items.length - 1])
    expect(mock).toHaveBeenCalledTimes(1)

    mock.mockImplementationOnce(() => 'access-restricted')
    expect(mock()).toEqual('access-restricted')

    expect(mock).toHaveBeenCalledTimes(2)

    expect(mock()).toEqual(messages.items[messages.items.length - 1])
    expect(mock).toHaveBeenCalledTimes(3)
  })
})
```

----------------------------------------

TITLE: Waiting for DOM Element with vi.waitFor (TypeScript)
DESCRIPTION: Illustrates using vi.waitFor with an asynchronous callback to wait for an element to appear in the DOM and have a specific data attribute. Uses jsdom environment. Requires Vitest and async DOM manipulation functions.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_36

LANGUAGE: TypeScript
CODE:
```
// @vitest-environment jsdom

import { expect, test, vi } from 'vitest';
import { getDOMElementAsync, populateDOMAsync } from './dom.js';

test('Element exists in a DOM', async () => {
  // start populating DOM
  populateDOMAsync();

  const element = await vi.waitFor(async () => {
    // try to get the element until it exists
    const element = await getDOMElementAsync() as HTMLElement | null;
    expect(element).toBeTruthy();
    expect(element.dataset.initialized).toBeTruthy();
    return element;
  }, {
    timeout: 500, // default is 1000
    interval: 20, // default is 50
  });
  expect(element).toBeInstanceOf(HTMLElement);
});
```

----------------------------------------

TITLE: Checking How Many Times a Spy Function Was Called in Vitest
DESCRIPTION: Illustrates using `toHaveBeenCalledTimes` to assert that a spy function has been called a specific number of times. Requires a spy created with `vi.spyOn`. Requires `expect`, `test`, and `vi` from 'vitest'.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_43

LANGUAGE: ts
CODE:
```
import { expect, test, vi } from 'vitest'

const market = {
  buy(subject: string, amount: number) {
    // ...
  },
}

test('spy function called two times', () => {
  const buySpy = vi.spyOn(market, 'buy')

  market.buy('apples', 10)
  market.buy('apples', 20)

  expect(buySpy).toHaveBeenCalledTimes(2)
})
```

----------------------------------------

TITLE: Mocking Global Variable with vi.stubGlobal (TypeScript)
DESCRIPTION: Demonstrates how to create a mock implementation for a global variable like `IntersectionObserver` and attach it to `globalThis` using `vi.stubGlobal` in Vitest. This is useful for testing code that relies on browser APIs in a Node.js environment.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/mocking.md#_snippet_2

LANGUAGE: ts
CODE:
```
import { vi } from 'vitest'

const IntersectionObserverMock = vi.fn(() => ({
  disconnect: vi.fn(),
  observe: vi.fn(),
  takeRecords: vi.fn(),
  unobserve: vi.fn(),
}))

vi.stubGlobal('IntersectionObserver', IntersectionObserverMock)

// now you can access it as `IntersectionObserver` or `window.IntersectionObserver`
```

----------------------------------------

TITLE: Using test.each with Array Data and Printf Formatting (Vitest, TypeScript)
DESCRIPTION: Demonstrates how to use `test.each` with an array of test cases, where each inner array represents a single test's parameters. It utilizes printf-style formatting (`%i`) in the test name string to dynamically include the parameter values.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/index.md#_snippet_20

LANGUAGE: TypeScript
CODE:
```
import { expect, test } from 'vitest'

test.each([
  [1, 1, 2],
  [1, 2, 3],
  [2, 1, 3]
])('add(%i, %i) -> %i', (a, b, expected) => {
  expect(a + b).toBe(expected)
})
```

----------------------------------------

TITLE: Testing Vue Components with Vitest Browser Mode (TS)
DESCRIPTION: Demonstrates testing a Vue component using `vitest-browser-vue`. It covers rendering the component, asserting initial state, interacting with an input using `screen.getByLabelText` and `fill`, and asserting the updated state.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/index.md#_snippet_15

LANGUAGE: ts
CODE:
```
import { render } from 'vitest-browser-vue'
import Component from './Component.vue'

test('properly handles v-model', async () => {
  const screen = render(Component)

  // Asserts initial state.
  await expect.element(screen.getByText('Hi, my name is Alice')).toBeInTheDocument()

  // Get the input DOM node by querying the associated label.
  const usernameInput = screen.getByLabelText(/username/i)

  // Type the name into the input. This already validates that the input
  // is filled correctly, no need to check the value manually.
  await usernameInput.fill('Bob')

  await expect.element(screen.getByText('Hi, my name is Bob')).toBeInTheDocument()
})
```

----------------------------------------

TITLE: Accessing Task Context in Vitest
DESCRIPTION: Demonstrates how to access the built-in 'task' property from the test context to retrieve metadata about the current test, such as its name.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/test-context.md#_snippet_0

LANGUAGE: TypeScript
CODE:
```
import { it } from 'vitest'

it('should work', ({ task }) => {
  // prints name of the test
  console.log(task.name)
})
```

----------------------------------------

TITLE: Asserting Type Equality with Vitest TypeScript Matcher
DESCRIPTION: Uses `expectTypeOf` to check if the runtime value type matches the expected TypeScript type using `.toEqualTypeOf`. Requires the `vitest` testing framework and enabling type-checking with the `--typecheck` flag. Accepts any value or object as input and performs compile-time type equality assertions, ignoring runtime values.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect-typeof.md#_snippet_0

LANGUAGE: TypeScript
CODE:
```
import { expectTypeOf } from 'vitest'

expectTypeOf({ a: 1 }).toEqualTypeOf<{ a: number }>()
expectTypeOf({ a: 1 }).toEqualTypeOf({ a: 1 })
expectTypeOf({ a: 1 }).toEqualTypeOf({ a: 2 })
expectTypeOf({ a: 1, b: 1 }).not.toEqualTypeOf<{ a: number }>()
```

----------------------------------------

TITLE: Configuring Vitest Projects for Mixed Environments
DESCRIPTION: This snippet demonstrates how to use the `test.projects` option to define separate configurations for different testing environments within a single Vitest config file. It shows configurations for a 'unit' project using the 'node' environment and a 'browser' project using browser mode with Playwright.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/index.md#_snippet_6

LANGUAGE: ts
CODE:
```
import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    projects: [
      {
        test: {
          // an example of file based convention,
          // you don't have to follow it
          include: [
            'tests/unit/**/*.{test,spec}.ts',
            'tests/**/*.unit.{test,spec}.ts',
          ],
          name: 'unit',
          environment: 'node',
        },
      },
      {
        test: {
          // an example of file based convention,
          // you don't have to follow it
          include: [
            'tests/browser/**/*.{test,spec}.ts',
            'tests/**/*.browser.{test,spec}.ts',
          ],
          name: 'browser',
          browser: {
            enabled: true,
            instances: [
              { browser: 'chromium' },
            ],
          },
        },
      },
    ],
  },
})
```

----------------------------------------

TITLE: Asserting Last Call Arguments with Vitest
DESCRIPTION: Verifies that a spy function's most recent invocation was made with the given parameters. This assertion requires a spy function.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_48

LANGUAGE: typescript
CODE:
```
import { expect, test, vi } from 'vitest'

const market = {
  buy(subject: string, amount: number) {
    // ...
  },
}

test('spy function', () => {
  const buySpy = vi.spyOn(market, 'buy')

  market.buy('apples', 10)
  market.buy('apples', 20)

  expect(buySpy).not.toHaveBeenLastCalledWith('apples', 10)
  expect(buySpy).toHaveBeenLastCalledWith('apples', 20)
})
```

----------------------------------------

TITLE: Using vi.hoisted to Define Mocked Values for vi.mock (Vitest, TypeScript)
DESCRIPTION: Demonstrates a common pattern where `vi.hoisted` is used to define a value (like a mock function) that needs to be available before imports are processed, and then using that value in a `vi.mock` factory.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_40

LANGUAGE: TypeScript
CODE:
```
import { expect, vi } from 'vitest'
import { originalMethod } from './path/to/module.js'

const { mockedMethod } = vi.hoisted(() => {
  return { mockedMethod: vi.fn() }
})

vi.mock('./path/to/module.js', () => {
  return { originalMethod: mockedMethod }
})

mockedMethod.mockReturnValue(100)
expect(originalMethod()).toBe(100)
```

----------------------------------------

TITLE: Waiting for DOM Element with vi.waitUntil (TypeScript)
DESCRIPTION: Shows how to use vi.waitUntil to wait for a truthy value (an element) to be returned by the callback. Unlike waitFor, errors immediately interrupt execution. Includes options for timeout and interval. Requires Vitest.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_37

LANGUAGE: TypeScript
CODE:
```
import { expect, test, vi } from 'vitest';

test('Element render correctly', async () => {
  const element = await vi.waitUntil(
    () => document.querySelector('.element'),
    {
      timeout: 500, // default is 1000
      interval: 20, // default is 50
    }
  );

  // do something with the element
  expect(element.querySelector('.element-child')).toBeTruthy();
});
```

----------------------------------------

TITLE: Integrating Vitest Related Command in Lint-Staged - JavaScript
DESCRIPTION: Example lint-staged configuration that runs Vitest with the related command and --run flag on changed JavaScript or TypeScript files. Shows how to set up lint-staged to use Vitest as a test runner. Input: JS/TS filenames from staged changes. Output: Vitest is invoked for related tests in non-watch mode. Dependency: lint-staged package must be installed.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/cli.md#_snippet_4

LANGUAGE: js
CODE:
```
export default {
  '*.{js,ts}': 'vitest related --run',
}

```

----------------------------------------

TITLE: Extending Vitest Test Context with Custom Fixtures
DESCRIPTION: Demonstrates how to use `test.extend` to create a custom test collector with defined fixtures ('todos' and 'archive'). Fixtures can have setup and teardown logic executed before and after each test.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/test-context.md#_snippet_6

LANGUAGE: TypeScript
CODE:
```
import { test as baseTest } from 'vitest'

const todos = []
const archive = []

export const test = baseTest.extend({
  todos: async ({}, use) => {
    // setup the fixture before each test function
    todos.push(1, 2, 3)

    // use the fixture value
    await use(todos)

    // cleanup the fixture after each test function
    todos.length = 0
  },
  archive
})
```

----------------------------------------

TITLE: Testing Lit Components with Vitest Browser Mode (TS)
DESCRIPTION: Demonstrates testing a Lit component using `vitest-browser-lit`. It shows rendering the component using `render(html<...>)`, simulating a button click using `screen.getByRole` and `click`, and asserting the presence of a greeting element using `screen.getByText` and `toBeInTheDocument`.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/index.md#_snippet_18

LANGUAGE: ts
CODE:
```
import { render } from 'vitest-browser-lit'
import { html } from 'lit'
import './greeter-button'

test('greeting appears on click', async () => {
  const screen = render(html`<greeter-button name="World"></greeter-button>`)

  const button = screen.getByRole('button')
  await button.click()
  const greeting = screen.getByText(/hello world/iu)

  await expect.element(greeting).toBeInTheDocument()
})
```

----------------------------------------

TITLE: Using onTestFinished Hook in Reusable Logic in Vitest (TypeScript)
DESCRIPTION: This snippet demonstrates how `onTestFinished` can be used within a helper function to encapsulate setup and teardown logic. The `getTestDb` function connects to a database and registers a cleanup hook, allowing tests to simply call the function and rely on automatic cleanup after each test.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/index.md#_snippet_58

LANGUAGE: ts
CODE:
```
// this can be in a separate file
function getTestDb() {
  const db = connectMockedDb()
  onTestFinished(() => db.close())
  return db
}

test('performs a user query', async () => {
  const db = getTestDb()
  expect(
    await db.query('SELECT * from users').perform()
  ).toEqual([])
})

test('performs an organization query', async () => {
  const db = getTestDb()
  expect(
    await db.query('SELECT * from organizations').perform()
  ).toEqual([])
})
```

----------------------------------------

TITLE: Filtering test files by name using Vitest CLI
DESCRIPTION: This snippet demonstrates how to filter test files by a substring within their filename using the Vitest CLI, enabling selective test execution based on filename patterns.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/filtering.md#_snippet_0

LANGUAGE: bash
CODE:
```
$ vitest basic

Will only execute test files that contain `basic`, e.g.

```
basic.test.ts
basic-foo.test.ts
basic/foo.test.ts
```
```

----------------------------------------

TITLE: Defining and Using toHaveTextContent Matcher in Vitest - TypeScript
DESCRIPTION: Defines the toHaveTextContent matcher for asserting the text content of elements, text nodes, or fragments. Accepts a string (for partial, case-sensitive match) or RegExp (for flexible, possibly case-insensitive match) as parameters, as well as an options object (normalizeWhitespace). Outputs assertion pass/fail based on text content match. Requires the element to be available in the DOM. Limitation: partial matching for strings, all other custom logic via RegExp.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_24

LANGUAGE: TypeScript
CODE:
```
function toHaveTextContent(
  text: string | RegExp,
  options?: { normalizeWhitespace: boolean }
): Promise<void>
```

LANGUAGE: TypeScript
CODE:
```
const element = getByTestId('text-content')

await expect.element(element).toHaveTextContent('Content')
// to match the whole content
await expect.element(element).toHaveTextContent(/^Text Content$/)
// to use case-insensitive match
await expect.element(element).toHaveTextContent(/content$/i)
await expect.element(element).not.toHaveTextContent('content')
```

----------------------------------------

TITLE: Coverage Enabled Configuration
DESCRIPTION: Enables coverage collection. Can be enabled via the CLI using `--coverage.enabled` or in the configuration file using the `coverage.enabled` property. Defaults to `false` and can be overridden by the `--coverage` CLI option.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/cli-generated.md#_snippet_17



----------------------------------------

TITLE: Checking if a Spy Function Was Called in Vitest
DESCRIPTION: Demonstrates using `toHaveBeenCalled` to assert that a spy function created with `vi.spyOn` has been invoked at least once. Shows checking both `not.toHaveBeenCalled` and `toHaveBeenCalled`. Requires `expect`, `test`, and `vi` from 'vitest'.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_42

LANGUAGE: ts
CODE:
```
import { expect, test, vi } from 'vitest'

const market = {
  buy(subject: string, amount: number) {
    // ...
  },
}

test('spy function', () => {
  const buySpy = vi.spyOn(market, 'buy')

  expect(buySpy).not.toHaveBeenCalled()

  market.buy('apples', 10)

  expect(buySpy).toHaveBeenCalled()
})
```

----------------------------------------

TITLE: Checking Array/String Containment with Vitest's toContain (TypeScript)
DESCRIPTION: Uses Vitest's `toContain` matcher to assert if an item is present in an array or if a string is a substring of another. In browser environments, it can also check for class containment in `classList` or element containment within another element. The example shows checks for array elements, class names, and nested elements.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_28

LANGUAGE: TypeScript
CODE:
```
import { expect, test } from 'vitest'
import { getAllFruits } from './stocks.js'

test('the fruit list contains orange', () => {
  expect(getAllFruits()).toContain('orange')

  const element = document.querySelector('#el')
  // element has a class
  expect(element.classList).toContain('flex')
  // element is inside another one
  expect(document.querySelector('#wrapper')).toContain(element)
})
```

----------------------------------------

TITLE: Basic Vitest Configuration TypeScript
DESCRIPTION: Configures Vitest using a dedicated `vitest.config.ts` file when not using Vite as the primary build tool. All Vitest-specific options are placed within the `test` property of the configuration object.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/index.md#_snippet_5

LANGUAGE: TypeScript
CODE:
```
import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    // ...
  },
})
```

----------------------------------------

TITLE: Using userEvent.click in Vitest Browser Mode
DESCRIPTION: Demonstrates importing `userEvent` from the browser context and performing a click action on a selected element using the API.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/interactivity-api.md#_snippet_0

LANGUAGE: ts
CODE:
```
import { userEvent } from '@vitest/browser/context'

await userEvent.click(document.querySelector('.button'))
```

----------------------------------------

TITLE: beforeEach Basic Usage (TypeScript)
DESCRIPTION: Registers a callback function to be executed before each test within the current scope. It can be asynchronous and is useful for setting up test environments, like clearing mocks or adding initial data.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/index.md#_snippet_50

LANGUAGE: TypeScript
CODE:
```
import { beforeEach } from 'vitest'

beforeEach(async () => {
  // Clear mocks and add some testing data after before each test run
  await stopMocking()
  await addUser({ name: 'John' })
})
```

----------------------------------------

TITLE: Asserting Equality and Reference with toBe (Vitest, TypeScript)
DESCRIPTION: Demonstrates using `toBe` to assert primitive equality and object reference equality in Vitest tests. It highlights that `toBe` is equivalent to `Object.is` and suggests `toEqual` for structural comparison of objects. It also advises against using `toBe` for floating-point numbers.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_9

LANGUAGE: typescript
CODE:
```
import { expect, test } from 'vitest'

const stock = {
  type: 'apples',
  count: 13,
}

test('stock has 13 apples', () => {
  expect(stock.type).toBe('apples')
  expect(stock.count).toBe(13)
})

test('stocks are the same', () => {
  const refStock = stock // same reference

  expect(stock).toBe(refStock)
})
```

----------------------------------------

TITLE: Testing Element Click with userEvent or Locator
DESCRIPTION: Shows how to use `userEvent.click` or the locator's direct `click` method within a Vitest test to simulate clicking an element found using `page.getByRole`.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/interactivity-api.md#_snippet_5

LANGUAGE: ts
CODE:
```
import { page, userEvent } from '@vitest/browser/context'

test('clicks on an element', async () => {
  const logo = page.getByRole('img', { name: /logo/ })

  await userEvent.click(logo)
  // or you can access it directly on the locator
  await logo.click()
})
```

----------------------------------------

TITLE: Skipping Vitest Tests Dynamically via Context
DESCRIPTION: Demonstrates how to dynamically skip a test from within its execution function by calling the `context.skip()` method provided as an argument to the test callback.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/index.md#_snippet_9

LANGUAGE: TypeScript
CODE:
```
import { assert, test } from 'vitest'

test('skipped test', (context) => {
  context.skip()
  // Test skipped, no error
  assert.equal(Math.sqrt(4), 3)
})
```

----------------------------------------

TITLE: beforeEach with Cleanup Function (TypeScript)
DESCRIPTION: Shows how `beforeEach` can return an asynchronous function that acts as a cleanup hook, equivalent to `afterEach`. This cleanup function is executed after each test completes.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/index.md#_snippet_51

LANGUAGE: TypeScript
CODE:
```
import { beforeEach } from 'vitest'

beforeEach(async () => {
  // called once before each test run
  await prepareSomething()

  // clean up function, called once after each test run
  return async () => {
    await resetSomething()
  }
})
```

----------------------------------------

TITLE: Creating and Using Mock Functions with vi.fn in Vitest (TypeScript)
DESCRIPTION: Illustrates the basic usage of vi.fn to create a mock function (spy). It shows how to call the mock, assert that it was called, check its return value, and modify its behavior using mockReturnValueOnce.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_15

LANGUAGE: ts
CODE:
```
const getApples = vi.fn(() => 0)

getApples()

expect(getApples).toHaveBeenCalled()
expect(getApples).toHaveReturnedWith(0)

getApples.mockReturnValueOnce(5)

const res = getApples()
expect(res).toBe(5)
expect(getApples).toHaveNthReturnedWith(2, 5)
```

----------------------------------------

TITLE: Adding Vitest Global Types to tsconfig.json
DESCRIPTION: Illustrates how to update the `tsconfig.json` file to include the `vitest/globals` type definition in the `types` array, enabling TypeScript support for Vitest's global APIs.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_10

LANGUAGE: json
CODE:
```
{
  "compilerOptions": {
    "types": ["vitest/globals"]
  }
}
```

----------------------------------------

TITLE: Setting Mock Implementation with mockImplementation
DESCRIPTION: This example demonstrates how to set a custom implementation for a mock function using `mockImplementation`. This allows you to define the behavior of the mock function when it is called.  TypeScript expects the arguments and return type to match those of the original function.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/mock.md#_snippet_3

LANGUAGE: typescript
CODE:
```
const mockFn = vi.fn().mockImplementation((apples: number) => apples + 1)
// or: vi.fn(apples => apples + 1);

const NelliesBucket = mockFn(0)
const BobsBucket = mockFn(1)

NelliesBucket === 1 // true
BobsBucket === 2 // true

mockFn.mock.calls[0][0] === 0 // true
mockFn.mock.calls[1][0] === 1 // true
```

----------------------------------------

TITLE: Clear Input Element Content using Vitest userEvent (ts)
DESCRIPTION: Clears the content of an input element using `userEvent.clear`. This provides a convenient way to reset input fields in tests. An alternative is to use the `clear()` method directly on the locator object.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/interactivity-api.md#_snippet_16

LANGUAGE: ts
CODE:
```
import { page, userEvent } from '@vitest/browser/context'

test('clears input', async () => {
  const input = page.getByRole('input')

  await userEvent.fill(input, 'foo')
  expect(input).toHaveValue('foo')

  await userEvent.clear(input)
  // or you can access it directly on the locator
  await input.clear()

  expect(input).toHaveValue('')
})
```

----------------------------------------

TITLE: Mocking Node.js File System with memfs (Vitest/TS)
DESCRIPTION: Shows how to replace the standard Node.js `fs` and `fs/promises` modules with `memfs`, an in-memory file system. This is achieved by creating mock files in the `__mocks__` directory that export the `memfs` instance. This allows tests to perform file operations without touching the actual disk.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/mocking.md#_snippet_10

LANGUAGE: typescript
CODE:
```
// we can also use `import`, but then
// every export should be explicitly defined

const { fs } = require('memfs')
module.exports = fs
```

LANGUAGE: typescript
CODE:
```
// we can also use `import`, but then
// every export should be explicitly defined

const { fs } = require('memfs')
module.exports = fs.promises
```

----------------------------------------

TITLE: Define Vitest Scripts in package.json JSON
DESCRIPTION: Shows example npm scripts in a `package.json` file for running Vitest tests. The `test` script runs Vitest in watch mode by default, while the `coverage` script runs tests once and generates a coverage report.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/index.md#_snippet_11

LANGUAGE: JSON
CODE:
```
{
  "scripts": {
    "test": "vitest",
    "coverage": "vitest run --coverage"
  }
}
```

----------------------------------------

TITLE: Asserting Element Presence in Vitest Browser Mode (TS)
DESCRIPTION: Shows how to use the `expect.element` assertion with `page.getByText` and the `toBeInTheDocument` matcher to verify that a specific text element exists within the rendered DOM in Vitest's Browser Mode.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/index.md#_snippet_13

LANGUAGE: ts
CODE:
```
import { expect } from 'vitest'
import { page } from '@vitest/browser/context'
// element is rendered correctly
await expect.element(page.getByText('Hello World')).toBeInTheDocument()
```

----------------------------------------

TITLE: Mocking Module with Spy in Vitest (TypeScript)
DESCRIPTION: Shows how to use `vi.mock` with the `spy: true` option to track calls and returns of the original module exports without replacing their implementation. This allows testing interactions with the original function.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_1

LANGUAGE: ts
CODE:
```
import { calculator } from './src/calculator.ts'

vi.mock('./src/calculator.ts', { spy: true })

// calls the original implementation,
// but allows asserting the behaviour later
const result = calculator(1, 2)

expect(result).toBe(3)
expect(calculator).toHaveBeenCalledWith(1, 2)
expect(calculator).toHaveReturned(3)
```

----------------------------------------

TITLE: Config File Path Configuration
DESCRIPTION: Specifies the path to the Vitest configuration file. Can be set via the CLI using `-c, --config <path>`.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/cli-generated.md#_snippet_1



----------------------------------------

TITLE: Using test.each with Object Data and $ Prefix Formatting (Vitest, TypeScript)
DESCRIPTION: Shows how to use `test.each` with an array of objects, where each object provides the data for one test case. It uses the `$` prefix followed by property names (`$a`, `$b`, `$expected`) in the test name string to access object properties.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/index.md#_snippet_21

LANGUAGE: TypeScript
CODE:
```
test.each([
  { a: 1, b: 1, expected: 2 },
  { a: 1, b: 2, expected: 3 },
  { a: 2, b: 1, expected: 3 }
])('add($a, $b) -> $expected', ({ a, b, expected }) => {
  expect(a + b).toBe(expected)
})
```

----------------------------------------

TITLE: Resetting Mock Function State with mockReset
DESCRIPTION: This snippet demonstrates the `mockReset` method, which clears call history and resets the implementation to its original state. For mocks created with `vi.fn()`, the implementation is set to an empty function. For mocks created with `vi.fn(impl)`, the implementation is restored to `impl`.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/mock.md#_snippet_9

LANGUAGE: typescript
CODE:
```
const person = {
  greet: (name: string) => `Hello ${name}`,
}
const spy = vi.spyOn(person, 'greet').mockImplementation(() => 'mocked')
expect(person.greet('Alice')).toBe('mocked')
expect(spy.mock.calls).toEqual([['Alice']])

// clear call history and reset implementation, but method is still spied
spy.mockReset()
expect(spy.mock.calls).toEqual([])
expect(person.greet).toBe(spy)
expect(person.greet('Bob')).toBe('Hello Bob')
expect(spy.mock.calls).toEqual([['Bob']])
```

----------------------------------------

TITLE: Assert Value is True with Vitest
DESCRIPTION: This demonstrates `assert.isTrue`, which asserts that a given value is true. It utilizes the `vitest` testing framework. The input is a boolean value and the assertion passes if the value is strictly true.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_13

LANGUAGE: TypeScript
CODE:
```
import { assert, test } from 'vitest'

const testPassed = true

test('assert.isTrue', () => {
  assert.isTrue(testPassed)
})
```

----------------------------------------

TITLE: Registering afterAll Hook in Vitest (TypeScript)
DESCRIPTION: This snippet illustrates registering an `afterAll` hook in Vitest. The asynchronous callback function is executed once after all tests in the current context have completed, typically used for teardown operations like stopping mocks or closing connections.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/index.md#_snippet_55

LANGUAGE: ts
CODE:
```
import { afterAll } from 'vitest'

afterAll(async () => {
  await stopMocking() // this method is called after all tests run
})
```

----------------------------------------

TITLE: Skipping Test Execution Using Skip Context
DESCRIPTION: Demonstrates how to use the 'skip' function from the test context to unconditionally skip the subsequent execution of the current test.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/test-context.md#_snippet_3

LANGUAGE: TypeScript
CODE:
```
import { expect, it } from 'vitest'

it('math is hard', ({ skip }) => {
  skip()
  expect(2 + 2).toBe(5)
})
```

----------------------------------------

TITLE: Assert Value is At Most with Vitest
DESCRIPTION: This demonstrates the `assert.isAtMost` method to assert that a value is less than or equal to another. It uses the `vitest` testing framework. The input consists of two numbers, where the assertion passes if the first is less than or equal to the second.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_12

LANGUAGE: TypeScript
CODE:
```
import { assert, test } from 'vitest'

test('assert.isAtMost', () => {
  assert.isAtMost(3, 6, '3 is less than or equal to 6')
  assert.isAtMost(4, 4, '4 is less than or equal to 4')
})
```

----------------------------------------

TITLE: Using screenshot with Locator in Vitest (TypeScript)
DESCRIPTION: Illustrates capturing screenshots using a button locator: saving to file path only, or retrieving both file path and base64 content. Requires @vitest/browser/context for page object; accepts LocatorScreenshotOptions for output customization, including output directory and encoding choice. Useful for visual regression or image comparisons; resolves asynchronously, outputs screenshot file and/or base64 string.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_45

LANGUAGE: typescript
CODE:
```
import { page } from '@vitest/browser/context'

const button = page.getByRole('button', { name: 'Click Me!' })

const path = await button.screenshot()

const { path, base64 } = await button.screenshot({
  path: './button-click-me.png',
  base64: true, // also return base64 string
})
// path - fullpath to the screenshot
// bas64 - base64 encoded string of the screenshot
```

----------------------------------------

TITLE: Asserting Element Contains Another in Vitest Tests (JavaScript)
DESCRIPTION: Verifies if one DOM element is a descendant of another element. Useful for testing parent-child structural relationships in the rendered DOM. Requires `expect.element` and locator methods like `getByTestId`.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_10

LANGUAGE: TypeScript
CODE:
```
function toContainElement(element: HTMLElement | SVGElement | null): Promise<void>
```

LANGUAGE: HTML
CODE:
```
<span data-testid="ancestor"><span data-testid="descendant"></span></span>
```

LANGUAGE: JavaScript
CODE:
```
const ancestor = getByTestId('ancestor')
const descendant = getByTestId('descendant')
const nonExistantElement = getByTestId('does-not-exist')

await expect.element(ancestor).toContainElement(descendant)
await expect.element(descendant).not.toContainElement(ancestor)
await expect.element(ancestor).not.toContainElement(nonExistantElement)
```

----------------------------------------

TITLE: Skipping Vitest Tests Using Chained .skip
DESCRIPTION: Shows how to use the chained `.skip` method on the `test` function to unconditionally skip the execution of a specific test case.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/index.md#_snippet_8

LANGUAGE: TypeScript
CODE:
```
import { assert, test } from 'vitest'

test.skip('skipped test', () => {
  // Test skipped, no error
  assert.equal(Math.sqrt(4), 3)
})
```

----------------------------------------

TITLE: Specify File Environment with Comment (JS)
DESCRIPTION: Shows setting the test environment for a file to 'happy-dom' using a single-line comment at the top. This is an alternative syntax to the docblock method for file-level environment configuration.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_13

LANGUAGE: js
CODE:
```
// @vitest-environment happy-dom

test('use happy-dom in this test file', () => {
  const element = document.createElement('div')
  expect(element).not.toBeNull()
})
```

----------------------------------------

TITLE: Asserting Sync Function Error with Vitest toThrowError (TypeScript)
DESCRIPTION: Demonstrates how to use `expect(() => syncFunction()).toThrowError()` to test if a synchronous function throws an error when called. Examples show matching the error using a RegExp, a substring, an exact string, an Error object, and an object containing properties.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_35

LANGUAGE: TypeScript
CODE:
```
import { expect, test } from 'vitest'

function getFruitStock(type: string) {
  if (type === 'pineapples') {
    throw new Error('Pineapples are not in stock')
  }

  // Do some other stuff
}

test('throws on pineapples', () => {
  // Test that the error message says "stock" somewhere: these are equivalent
  expect(() => getFruitStock('pineapples')).toThrowError(/stock/)
  expect(() => getFruitStock('pineapples')).toThrowError('stock')

  // Test the exact error message
  expect(() => getFruitStock('pineapples')).toThrowError(
    /^Pineapples are not in stock$/,
  )

  expect(() => getFruitStock('pineapples')).toThrowError(
    new Error('Pineapples are not in stock'),
  )
  expect(() => getFruitStock('pineapples')).toThrowError(expect.objectContaining({
    message: 'Pineapples are not in stock',
  }))
})
```

----------------------------------------

TITLE: Resetting Module Cache with vi.resetModules in Vitest (TypeScript)
DESCRIPTION: Demonstrates using vi.resetModules within a beforeEach hook to clear the module registry cache. This ensures that modules imported dynamically (using await import) are re-evaluated for each test, while top-level imports remain unaffected.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_13

LANGUAGE: ts
CODE:
```
import { vi } from 'vitest'

import { data } from './data.js' // Will not get reevaluated beforeEach test

beforeEach(() => {
  vi.resetModules()
})

test('change state', async () => {
  const mod = await import('./some/path.js') // Will get reevaluated
  mod.changeLocalState('new value')
  expect(mod.getLocalState()).toBe('new value')
})

test('module has old state', async () => {
  const mod = await import('./some/path.js') // Will get reevaluated
  expect(mod.getLocalState()).toBe('old value')
})
```

----------------------------------------

TITLE: Page Utilities in Vitest Browser Mode (TypeScript)
DESCRIPTION: Defines the `page` export, which offers utilities to interact with the current page within the Vitest browser environment. Includes functions for viewport manipulation, taking screenshots, extending the default `page` object with custom methods, creating element locators, and using locator APIs like `getByRole`, `getByLabelText`, and `getByTestId`.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/context.md#_snippet_2

LANGUAGE: typescript
CODE:
```
export const page: {
  /**
   * Change the size of iframe's viewport.
   */
  viewport(width: number, height: number): Promise<void>
  /**
   * Make a screenshot of the test iframe or a specific element.
   * @returns Path to the screenshot file or path and base64.
   */
  screenshot(options: Omit<ScreenshotOptions, 'base64'> & { base64: true }): Promise<{
    path: string
    base64: string
  }>
  screenshot(options?: ScreenshotOptions): Promise<string>
  /**
   * Extend default `page` object with custom methods.
   */
  extend(methods: Partial<BrowserPage>): BrowserPage
  /**
   * Wrap an HTML element in a `Locator`. When querying for elements, the search will always return this element.
   */
  elementLocator(element: Element): Locator

  /**
   * Locator APIs. See its documentation for more details.
   */
  getByRole(role: ARIARole | string, options?: LocatorByRoleOptions): Locator
  getByLabelText(text: string | RegExp, options?: LocatorOptions): Locator
  getByTestId(text: string | RegExp): Locator
  getByAltText(text: string | RegExp, options?: LocatorOptions): Locator
  getByPlaceholder(text: string | RegExp, options?: LocatorOptions): Locator
  getByText(text: string | RegExp, options?: LocatorOptions): Locator
  getByTitle(text: string | RegExp, options?: LocatorOptions): Locator
}
```

----------------------------------------

TITLE: Asserting Async Function Error with Vitest rejects.toThrowError (JavaScript)
DESCRIPTION: Illustrates how to test if an asynchronous function throws an error using `await expect(() => asyncFunction()).rejects.toThrowError()`. This specific example shows matching the error message with a string.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_36

LANGUAGE: JavaScript
CODE:
```
function getAsyncFruitStock() {
  return Promise.reject(new Error('empty'))
}

test('throws on pineapples', async () => {
  await expect(() => getAsyncFruitStock()).rejects.toThrowError('empty')
})
```

----------------------------------------

TITLE: Configure Basic Coverage Thresholds (TypeScript)
DESCRIPTION: This snippet demonstrates how to set basic global coverage thresholds for functions and lines within the `coverage.thresholds` object. It shows how to use positive numbers for minimum percentage requirements and negative numbers for maximum allowed uncovered items.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_39

LANGUAGE: typescript
CODE:
```
{
  coverage: {
    thresholds: {
      // Requires 90% function coverage
      functions: 90,

      // Require that no more than 10 lines are uncovered
      lines: -10,
    }
  }
}
```

----------------------------------------

TITLE: Basic Browser Configuration Setup in Vitest
DESCRIPTION: A minimal configuration example showing how to enable browser testing with Playwright as the provider and setting up a single Chromium instance with a custom setup file.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/config.md#_snippet_0

LANGUAGE: typescript
CODE:
```
import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    browser: {
      enabled: true,
      provider: 'playwright',
      instances: [
        {
          browser: 'chromium',
          setupFile: './chromium-setup.js',
        },
      ],
    },
  },
})
```

----------------------------------------

TITLE: Skipping Vitest Tests Using Chained Options
DESCRIPTION: Demonstrates how to skip individual tests or concurrent tests using chained properties like `.skip` directly on the `test` or `test.concurrent` function.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/index.md#_snippet_1

LANGUAGE: TypeScript
CODE:
```
import { test } from 'vitest'

test.skip('skipped test', () => {
  // some logic that fails right now
})

test.concurrent.skip('skipped concurrent test', () => {
  // some logic that fails right now
})
```

----------------------------------------

TITLE: Using expect.closeTo for Floating Point Comparison in Vitest
DESCRIPTION: Use `expect.closeTo` to compare floating point numbers within object properties or array items in Vitest. An optional precision argument specifies the number of digits to check after the decimal point.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_68

LANGUAGE: JavaScript
CODE:
```
test('compare float in object properties', () => {
  expect({
    title: '0.1 + 0.2',
    sum: 0.1 + 0.2,
  }).toEqual({
    title: '0.1 + 0.2',
    sum: expect.closeTo(0.3, 5),
  })
})
```

----------------------------------------

TITLE: Verifying Assertion Count with expect.assertions in Vitest
DESCRIPTION: Use `expect.assertions(count)` to verify that a specific number of assertions were called during a test execution. This is particularly useful for ensuring that asynchronous callbacks containing assertions are actually invoked.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_63

LANGUAGE: ts
CODE:
```
import { expect, test } from 'vitest'

async function doAsync(...cbs) {
  await Promise.all(
    cbs.map((cb, index) => cb({ index })),
  )
}

test('all assertions are called', async () => {
  expect.assertions(2)
  function callback1(data) {
    expect(data).toBeTruthy()
  }
  function callback2(data) {
    expect(data).toBeTruthy()
  }

  await doAsync(callback1, callback2)
})
```

----------------------------------------

TITLE: Merge Vite and Vitest Configs (Vitest Side) TypeScript
DESCRIPTION: Demonstrates how to merge a separate Vite configuration file (`vite.config.mjs`) with a Vitest configuration file (`vitest.config.mjs`) using the `mergeConfig` utility from `vitest/config`. This allows keeping Vite and Vitest configurations separate while combining them for the test run.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/index.md#_snippet_8

LANGUAGE: TypeScript
CODE:
```
import { defineConfig, mergeConfig } from 'vitest/config'
import viteConfig from './vite.config.mjs'

export default mergeConfig(viteConfig, defineConfig({
  test: {
    // ...
  },
}))
```

----------------------------------------

TITLE: Function Mocking with Vitest, Tinyspy, and Jest APIs in TypeScript
DESCRIPTION: This TypeScript snippet demonstrates mocking functions using Vitest’s built-in 'vi' object, which provides Jest-compatible mock and assertion APIs via Tinyspy. It shows creating a mock function, tracking its calls and results, and implementing custom behavior dynamically. Dependencies include Vitest and TypeScript. Expected input is function invocations; expected output includes assertions on call arguments and mock results. Some matchers may require enabling global test variables for third-party integrations.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/features.md#_snippet_4

LANGUAGE: typescript
CODE:
```
import { expect, vi } from 'vitest'

const fn = vi.fn()

fn('hello', 1)

expect(vi.isMockFunction(fn)).toBe(true)
expect(fn.mock.calls[0]).toEqual(['hello', 1])

fn.mockImplementation((arg: string) => arg)

fn('world', 2)

expect(fn.mock.results[1].value).toBe('world')

```

----------------------------------------

TITLE: Asserting Falsiness with toBeFalsy (Vitest, TypeScript)
DESCRIPTION: Describes the `toBeFalsy` assertion in Vitest, which checks if a value evaluates to `false` when converted to a boolean. It lists common falsy values in JavaScript and provides a test example.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_14

LANGUAGE: typescript
CODE:
```
import { expect, test } from 'vitest'
import { Stocks } from './stocks.js'

const stocks = new Stocks()

test('if Bill stock hasn't failed, sell apples to him', () => {
  stocks.syncStocks('Bill')
  expect(stocks.stockFailed('Bill')).toBeFalsy()
})
```

----------------------------------------

TITLE: TypeScript Reference for Browser Context
DESCRIPTION: Shows how to add a TypeScript reference for Vitest browser context to get correct type hints in your tests.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_0

LANGUAGE: typescript
CODE:
```
/// <reference types="@vitest/browser/context" />
```

----------------------------------------

TITLE: Mocking an exported class using vi.mock in Vitest
DESCRIPTION: Demonstrates how to mock an exported class using `vi.mock` and defining the mock implementation with a spy function and mocking its prototype methods. Requires the original class definition.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/mocking.md#_snippet_31

LANGUAGE: ts
CODE:
```
export class SomeClass {}
```

LANGUAGE: ts
CODE:
```
import { SomeClass } from './example.js'

vi.mock(import('./example.js'), () => {
  const SomeClass = vi.fn()
  SomeClass.prototype.someMethod = vi.fn()
  return { SomeClass }
})
// SomeClass.mock.instances will have SomeClass
```

----------------------------------------

TITLE: Running Only Specific Tests with Vitest (TypeScript)
DESCRIPTION: Illustrates the use of `test.only` to limit the test execution to only the tests marked with this method. This is particularly useful for debugging specific test cases. An optional timeout can be provided.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/index.md#_snippet_13

LANGUAGE: TypeScript
CODE:
```
import { assert, test } from 'vitest'

test.only('test', () => {
  // Only this test (and others marked with only) are run
  assert.equal(Math.sqrt(4), 2)
})
```

----------------------------------------

TITLE: describe.each with Object Array (TypeScript)
DESCRIPTION: Demonstrates how to use `describe.each` with an array of objects to run multiple test suites with different data. Each object provides named properties that are destructured in the test suite callback.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/index.md#_snippet_47

LANGUAGE: TypeScript
CODE:
```
import { describe, expect, test } from 'vitest'

describe.each([
  { a: 1, b: 1, expected: 2 },
  { a: 1, b: 2, expected: 3 },
  { a: 2, b: 1, expected: 3 },
])('describe object add($a, $b)', ({ a, b, expected }) => {
  test(`returns ${expected}`, () => {
    expect(a + b).toBe(expected)
  })

  test(`returned value not be greater than ${expected}`, () => {
    expect(a + b).not.toBeGreaterThan(expected)
  })

  test(`returned value not be less than ${expected}`, () => {
    expect(a + b).not.toBeLessThan(expected)
  })
})
```

----------------------------------------

TITLE: Matching Inline Snapshot in Vitest (Basic)
DESCRIPTION: Demonstrates using `toMatchInlineSnapshot` in Vitest to assert that a value matches a snapshot stored directly within the test file. Vitest automatically updates the snapshot string when needed. Requires `expect` and `test` from 'vitest'.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_39

LANGUAGE: ts
CODE:
```
import { expect, test } from 'vitest'

test('matches inline snapshot', () => {
  const data = { foo: new Set(['bar', 'snapshot']) }
  // Vitest will update following content when updating the snapshot
  expect(data).toMatchInlineSnapshot(`
    {
      "foo": Set {
        "bar",
        "snapshot",
      },
    }
  `)
})
```

----------------------------------------

TITLE: Matching File Snapshot in Vitest
DESCRIPTION: Illustrates using `toMatchFileSnapshot` to compare a value against the content of a specified file path. This assertion is asynchronous and requires `await`. Requires `expect` and `it` from 'vitest'.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_41

LANGUAGE: ts
CODE:
```
import { expect, it } from 'vitest'

it('render basic', async () => {
  const result = renderHTML(h('div', { class: 'foo' }))
  await expect(result).toMatchFileSnapshot('./test/basic.output.html')
})
```

----------------------------------------

TITLE: Matching Strings with Regex or Substring using Vitest's toMatch (TypeScript)
DESCRIPTION: Uses Vitest's `toMatch` matcher to assert if a string matches a given regular expression or contains a specific substring. The example shows how to use `toMatch` with both a regular expression and a simple string.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_32

LANGUAGE: TypeScript
CODE:
```
import { expect, test } from 'vitest'

test('top fruits', () => {
  expect('top fruits include apple, orange and grape').toMatch(/apple/)
  expect('applefruits').toMatch('fruit') // toMatch also accepts a string
})
```

----------------------------------------

TITLE: Using vi.mocked Type Helper in Vitest (TypeScript)
DESCRIPTION: Shows how to use the vi.mocked type helper in Vitest tests to provide better type safety when mocking modules. It demonstrates mocking function return values and using the partial option for partial type checking.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_9

LANGUAGE: typescript
CODE:
```
import * as example from './example'

vi.mock('./example')

test('1 + 1 equals 10', async () => {
  vi.mocked(example.add).mockReturnValue(10)
  expect(example.add(1, 1)).toBe(10)
})

test('mock return value with only partially correct typing', async () => {
  vi.mocked(example.fetchSomething).mockResolvedValue(new Response('hello'))
  vi.mocked(example.fetchSomething, { partial: true }).mockResolvedValue({ ok: false })
  // vi.mocked(example.someFn).mockResolvedValue({ ok: false }) // this is a type error
})
```

----------------------------------------

TITLE: Asserting Rejected Promises with Vitest
DESCRIPTION: Use `expect(...).rejects` to assert that a promise is rejected and to check the rejection reason. This removes boilerplate for testing asynchronous code that is expected to fail. The assertion must be awaited.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_62

LANGUAGE: ts
CODE:
```
import { expect, test } from 'vitest'

async function buyApples(id) {
  if (!id) {
    throw new Error('no id')
  }
}

test('buyApples throws an error when no id provided', async () => {
  // toThrow returns a promise now, so you HAVE to await it
  await expect(buyApples()).rejects.toThrow('no id')
})
```

----------------------------------------

TITLE: Calling element with Locator in Vitest (TypeScript and HTML)
DESCRIPTION: Demonstrates element() usage with various locators, including valid and invalid cases. Covers scenarios where one, none, or multiple elements match. Requires accurate DOM structure; success returns Element, failure throws. Illustrates key differences with query() and elements() methods.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_49

LANGUAGE: html
CODE:
```
<div>Hello <span>World</span></div>
<div>Hello Germany</div>
<div>Hello</div>
```

LANGUAGE: typescript
CODE:
```
page.getByText('Hello World').element() // ✅
page.getByText('Hello Germany').element() // ✅
page.getByText('World').element() // ✅
page.getByText('Hello', { exact: true }).element() // ✅
```

LANGUAGE: typescript
CODE:
```
// returns multiple elements
page.getByText('Hello').element() // ❌
page.getByText(/^Hello/).element() // ❌

// returns no elements
page.getByText('Hello USA').element() // ❌
```

----------------------------------------

TITLE: Asserting Array Types with Vitest in TypeScript
DESCRIPTION: Applies `.toBeArray` matcher to check if the provided type is an array. Requires Vitest and works with array literals or initializers. Prevents type errors where array structures are expected.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect-typeof.md#_snippet_18

LANGUAGE: TypeScript
CODE:
```
import { expectTypeOf } from 'vitest'

expectTypeOf(42).not.toBeArray()
expectTypeOf([]).toBeArray()
expectTypeOf([1, 2]).toBeArray()
expectTypeOf([{}, 42]).toBeArray()
```

----------------------------------------

TITLE: Example Vitest Setup File Logic (TypeScript)
DESCRIPTION: This example illustrates common patterns in a Vitest setup file, including conditional global setup using a flag, applying configuration, and using test hooks like `afterEach` for cleanup. Setup files run before each test file.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_27

LANGUAGE: ts
CODE:
```
import { config } from '@some-testing-lib'

if (!globalThis.defined) {
  config.plugins = [myCoolPlugin]
  computeHeavyThing()
  globalThis.defined = true
}

// hooks are reset before each suite
afterEach(() => {
  cleanup()
})

globalThis.resetBeforeEachTest = true
```

----------------------------------------

TITLE: Mocking Class in Module Factory (TypeScript)
DESCRIPTION: Shows how to mock a class when it's exported from another module using `vi.mock`. The module factory returns an object containing the mocked class, allowing specific methods like `feed` to be mocked on the prototype.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/mocking.md#_snippet_20

LANGUAGE: ts
CODE:
```
import { Dog } from './dog.js'

vi.mock(import('./dog.js'), () => {
  const Dog = vi.fn()
  Dog.prototype.feed = vi.fn()
  // ... other mocks
  return { Dog }
})
```

----------------------------------------

TITLE: Advancing Fake Timers to Next Timer with Vitest vi.advanceTimersToNextTimer (TypeScript)
DESCRIPTION: This snippet shows how to use `vi.advanceTimersToNextTimer` in Vitest's fake timer environment. It advances the fake clock just enough to trigger the next scheduled timer, allowing for step-by-step execution and assertions between timer calls.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_27

LANGUAGE: typescript
CODE:
```
let i = 0
setInterval(() => console.log(++i), 50)

vi.advanceTimersToNextTimer() // log: 1
  .advanceTimersToNextTimer() // log: 2
  .advanceTimersToNextTimer() // log: 3
```

----------------------------------------

TITLE: Running Vitest Tests for a Single Project
DESCRIPTION: Executes the 'test' script and uses the '--project' CLI option to filter and run tests specifically within the 'e2e' project directory.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/projects.md#_snippet_6

LANGUAGE: bash
CODE:
```
npm run test --project e2e
```

LANGUAGE: bash
CODE:
```
yarn test --project e2e
```

LANGUAGE: bash
CODE:
```
pnpm run test --project e2e
```

LANGUAGE: bash
CODE:
```
bun run test --project e2e
```

----------------------------------------

TITLE: Configuring Test Setup Files in Vite for Vitest and Vue Snapshots with JavaScript
DESCRIPTION: Demonstrates how to specify test setup files in vite.config.js to support custom setup logic, such as snapshot serializers for Vue components. Requires Vite, Vitest, and the jest-serializer-vue package installed. Input: relative path to setup file; Output: test setup properly configured in Vite/Vitest.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/migration.md#_snippet_16

LANGUAGE: javascript
CODE:
```
import { defineConfig } from 'vite'

export default defineConfig({
  test: {
    setupFiles: ['./tests/unit/setup.js']
  }
})
```

----------------------------------------

TITLE: Nesting Vitest describe Blocks (TypeScript)
DESCRIPTION: Illustrates how to create nested test suites using `describe` blocks to organize tests hierarchically, often used for different scenarios or inputs of a function.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/index.md#_snippet_36

LANGUAGE: TypeScript
CODE:
```
import { describe, expect, test } from 'vitest'

function numberToCurrency(value: number | string) {
  if (typeof value !== 'number') {
    throw new TypeError('Value must be a number')
  }

  return value.toFixed(2).toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',')
}

describe('numberToCurrency', () => {
  describe('given an invalid number', () => {
    test('composed of non-numbers to throw error', () => {
      expect(() => numberToCurrency('abc')).toThrowError()
    })
  })

  describe('given a valid number', () => {
    test('returns the correct currency format', () => {
      expect(numberToCurrency(10000)).toBe('10,000.00')
    })
  })
})
```

----------------------------------------

TITLE: Asserting Non-Inclusion in Strings, Arrays, or Objects using Vitest (TypeScript)
DESCRIPTION: Shows how to use `assert.notInclude` in Vitest tests to verify the absence of a value in an array, a substring in a string, or properties in an object (shallow check). Requires `assert` and `test`.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_43

LANGUAGE: typescript
CODE:
```
import { assert, test } from 'vitest'

test('assert.notInclude', () => {
  assert.notInclude([1, 2, 3], 4, 'array doesn\'t contain 4')
  assert.notInclude('foobar', 'baz', 'foobar doesn\'t contain baz')
  assert.notInclude({ foo: 'bar', hello: 'universe' }, { foo: 'baz' }, 'object doesn\'t contain property')
})
```

----------------------------------------

TITLE: Asserting Element Attributes in Vitest Tests (JavaScript)
DESCRIPTION: Checks for the existence of a specific attribute on a DOM element, and optionally verifies its value. Useful for testing element state or configuration defined by attributes. Supports exact value match or partial matches using `expect.stringContaining`.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_15

LANGUAGE: TypeScript
CODE:
```
function toHaveAttribute(attribute: string, value?: unknown): Promise<void>
```

LANGUAGE: HTML
CODE:
```
<button data-testid="ok-button" type="submit" disabled>ok</button>
```

LANGUAGE: JavaScript
CODE:
```
const button = getByTestId('ok-button')

await expect.element(button).toHaveAttribute('disabled')
await expect.element(button).toHaveAttribute('type', 'submit')
await expect.element(button).not.toHaveAttribute('type', 'button')

await expect.element(button).toHaveAttribute(
  'type',
  expect.stringContaining('sub')
)
await expect.element(button).toHaveAttribute(
  'type',
  expect.not.stringContaining('but')
)
```

----------------------------------------

TITLE: Asserting Inclusion in Strings, Arrays, or Objects using Vitest (TypeScript)
DESCRIPTION: Demonstrates using `assert.include` in Vitest tests to check if an array contains a value, a string contains a substring, or an object contains specific properties (shallow check). Imports `assert` and `test`.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_42

LANGUAGE: typescript
CODE:
```
import { assert, test } from 'vitest'

test('assert.include', () => {
  assert.include([1, 2, 3], 2, 'array contains value')
  assert.include('foobar', 'foo', 'string contains substring')
  assert.include({ foo: 'bar', hello: 'universe' }, { foo: 'bar' }, 'object contains property')
})
```

----------------------------------------

TITLE: TSX example demonstrating `pressed` option for `getByRole`
DESCRIPTION: This TSX snippet demonstrates how to use the `pressed` option with `getByRole` to filter elements based on their pressed state (aria-pressed). It includes an example using a button with the aria-pressed attribute. Requires a TSX environment that supports JSX syntax. No external dependencies needed other than a rendering context for the TSX.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_9

LANGUAGE: tsx
CODE:
```
<button aria-pressed="true">👍</button>

page.getByRole('button', { pressed: true }) // ✅
page.getByRole('button', { pressed: false }) // ❌
```

----------------------------------------

TITLE: Mocking GraphQL Requests with MSW in Vitest
DESCRIPTION: This snippet illustrates how to configure Mock Service Worker (MSW) to intercept and mock GraphQL queries in a Vitest setup file. It uses `graphql.query` to define handlers and integrates the MSW server lifecycle with Vitest's `beforeAll`, `afterAll`, and `afterEach` hooks.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/mocking.md#_snippet_14

LANGUAGE: js
CODE:
```
import { afterAll, afterEach, beforeAll } from 'vitest'
import { setupServer } from 'msw/node'
import { graphql, HttpResponse } from 'msw'

const posts = [
  {
    userId: 1,
    id: 1,
    title: 'first post title',
    body: 'first post body',
  },
  // ...
]

const graphqlHandlers = [
  graphql.query('ListPosts', () => {
    return HttpResponse.json({
      data: { posts },
    })
  }),
]

const server = setupServer(...graphqlHandlers)

// Start server before all tests
beforeAll(() => server.listen({ onUnhandledRequest: 'error' }))

// Close server after all tests
afterAll(() => server.close())

// Reset handlers after each test for test isolation
afterEach(() => server.resetHandlers())
```

----------------------------------------

TITLE: resolves - Vitest Utility (TypeScript)
DESCRIPTION: `resolves` is intended to remove boilerplate when asserting asynchronous code. Use it to unwrap value from the pending promise and assert its value with usual assertions. If the promise rejects, the assertion will fail. It returns the same `Assertions` object, but all matchers now return `Promise`, so you would need to `await` it. Also works with `chai` assertions.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_61

LANGUAGE: ts
CODE:
```
import { expect, test } from 'vitest'

async function buyApples() {
  return fetch('/buy/apples').then(r => r.json())
}

test('buyApples returns new stock id', async () => {
  // toEqual returns a promise now, so you HAVE to await it
  await expect(buyApples()).resolves.toEqual({ id: 1 }) // jest API
  await expect(buyApples()).resolves.to.equal({ id: 1 }) // chai API
})
```

----------------------------------------

TITLE: describe.each with Template String Table (TypeScript)
DESCRIPTION: Shows how to use `describe.each` with a template string table for data-driven test suites. The first row defines column names, and subsequent rows provide data using template literal expressions.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/index.md#_snippet_48

LANGUAGE: TypeScript
CODE:
```
import { describe, expect, test } from 'vitest'

describe.each`
  a               | b      | expected
  ${1}            | ${1}   | ${2}
  ${'a'}          | ${'b'} | ${'ab'}
  ${[]}           | ${'b'} | ${'b'}
  ${{}}           | ${'b'} | ${'[object Object]b'}
  ${{ asd: 1 }}   | ${'b'} | ${'[object Object]b'}
`('describe template string add($a, $b)', ({ a, b, expected }) => {
  test(`returns ${expected}`, () => {
    expect(a + b).toBe(expected)
  })
})
```

----------------------------------------

TITLE: Testing userEvent.keyboard in Vitest (TypeScript)
DESCRIPTION: Shows how to use `userEvent.keyboard` to simulate various keyboard inputs within a Vitest browser test. It demonstrates typing simple strings and using the specific user-event keyboard syntax for special keys and sequences.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/interactivity-api.md#_snippet_13

LANGUAGE: typescript
CODE:
```
import { userEvent } from '@vitest/browser/context'

test('trigger keystrokes', async () => {
  await userEvent.keyboard('foo') // translates to: f, o, o
  await userEvent.keyboard('{{a[[') // translates to: {, a, [
  await userEvent.keyboard('{Shift}{f}{o}{o}') // translates to: Shift, f, o, o
  await userEvent.keyboard('{a>5}') // press a without releasing it and trigger 5 keydown
  await userEvent.keyboard('{a>5/}') // press a for 5 keydown and then release it
})
```

----------------------------------------

TITLE: Asserting Length with Vitest's toHaveLength (TypeScript)
DESCRIPTION: Uses Vitest's `toHaveLength` matcher to assert that an object (like a string, array, or object with a `.length` property) has a specific numeric length. The example demonstrates checking the length of strings, arrays, and a plain object with a `length` property.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_30

LANGUAGE: TypeScript
CODE:
```
import { expect, test } from 'vitest'

test('toHaveLength', () => {
  expect('abc').toHaveLength(3)
  expect([1, 2, 3]).toHaveLength(3)

  expect('').not.toHaveLength(3) // doesn't have .length of 3
  expect({ length: 3 }).toHaveLength(3)
})
```

----------------------------------------

TITLE: Locating elements by label text with `getByLabelText` in Vitest (TS)
DESCRIPTION: This snippet demonstrates how to locate elements associated with a label using the `getByLabelText` method in Vitest. Requires the Vitest environment to be configured for browser mode testing. Returns a Locator object.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_13

LANGUAGE: typescript
CODE:
```
function getByLabelText(
  text: string | RegExp,
  options?: LocatorOptions,
): Locator
```

----------------------------------------

TITLE: TSX example using `getByPlaceholder`
DESCRIPTION: This TSX snippet demonstrates locating an input element using `getByPlaceholder`.  It includes positive and negative examples. Requires a TSX environment that supports JSX syntax. No external dependencies needed other than a rendering context for the TSX.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_16

LANGUAGE: tsx
CODE:
```
<input placeholder="Username" />

page.getByPlaceholder('Username') // ✅
page.getByPlaceholder('not found') // ❌
```

----------------------------------------

TITLE: Asserting a Value is a Boolean using Vitest (TypeScript)
DESCRIPTION: Demonstrates the use of `assert.isBoolean` within a Vitest test to check if a variable holds a boolean value. Imports `assert` and `test` from 'vitest'.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_36

LANGUAGE: typescript
CODE:
```
import { assert, test } from 'vitest'

const isReady = true

test('assert.isBoolean', () => {
  assert.isBoolean(isReady, 'isReady is a boolean')
})
```

----------------------------------------

TITLE: Testing Svelte Components with Vitest Browser Mode (TS)
DESCRIPTION: Demonstrates testing a Svelte component using `vitest-browser-svelte`. It shows rendering the component with props, simulating a button click using `screen.getByRole` and `click`, and asserting the presence of a greeting element using `screen.getByText` and `toBeInTheDocument`.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/index.md#_snippet_16

LANGUAGE: ts
CODE:
```
import { render } from 'vitest-browser-svelte'
import { expect, test } from 'vitest'

import Greeter from './greeter.svelte'

test('greeting appears on click', async () => {
  const screen = render(Greeter, { name: 'World' })

  const button = screen.getByRole('button')
  await button.click()
  const greeting = screen.getByText(/hello world/iu)

  await expect.element(greeting).toBeInTheDocument()
})
```

----------------------------------------

TITLE: Configuring Inline Workspace in Vitest 3.0 (JS/TS)
DESCRIPTION: This configuration snippet demonstrates how to define your Vitest workspace directly within the `vitest.config` file using the `workspace` array. This eliminates the need for separate workspace definition files. It specifies that packages within the 'packages/*' directory should be included in the workspace.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/blog/vitest-3.md#_snippet_0

LANGUAGE: JavaScript
CODE:
```
import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    workspace: ['packages/*'],
  },
})
```

----------------------------------------

TITLE: Running All Pending Timers with Vitest
DESCRIPTION: Invokes all initiated timers in the queue until empty. Useful for synchronously executing all scheduled `setTimeout` and `setInterval` calls. Be cautious with infinite intervals, as it has a loop limit configurable via `fakeTimers.loopLimit`.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_30

LANGUAGE: typescript
CODE:
```
let i = 0
setTimeout(() => console.log(++i))
const interval = setInterval(() => {
  console.log(++i)
  if (i === 3) {
    clearInterval(interval)
  }
}, 50)

vi.runAllTimers()

// log: 1
// log: 2
// log: 3
```

----------------------------------------

TITLE: Defining Vitest Global Setup with Provide (TS, v2.0.0+)
DESCRIPTION: Shows how to define a global setup file for Vitest version 2.0.0 and above. The default exported function receives a 'GlobalSetupContext' object, which is destructured to access the 'provide' method for passing data ('wsPort') to tests.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_32

LANGUAGE: ts
CODE:
```
import type { GlobalSetupContext } from 'vitest/node'

export default function setup({ provide }: GlobalSetupContext) {
  provide('wsPort', 3000)
}

declare module 'vitest' {
  export interface ProvidedContext {
    wsPort: number
  }
}
```

----------------------------------------

TITLE: Conditionally Skipping Vitest Tests Using test.skipIf
DESCRIPTION: Explains how to use the `test.skipIf` method to define a test that will only run if the provided condition is falsy, allowing environment-specific tests without explicit `if` statements around the test definition.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/index.md#_snippet_11

LANGUAGE: TypeScript
CODE:
```
import { assert, test } from 'vitest'

const isDev = process.env.NODE_ENV === 'development'

test.skipIf(isDev)('prod only test', () => {
  // this test only runs in production
})
```

----------------------------------------

TITLE: Merging Vitest Config with Vite Config File - TypeScript
DESCRIPTION: Demonstrates merging a separate Vitest configuration (`vitest.config.js`) with options from an existing Vite configuration file (`vite.config.js`) using the `mergeConfig` utility from `vitest/config`. This allows combining settings from both files.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_4

LANGUAGE: TypeScript
CODE:
```
import { defineConfig, mergeConfig } from 'vitest/config'
import viteConfig from './vite.config'

export default mergeConfig(viteConfig, defineConfig({
  test: {
    exclude: ['packages/template/*'],
  },
}))
```

----------------------------------------

TITLE: Running Only a Specific Vitest describe Suite (TypeScript)
DESCRIPTION: Explains how to use `describe.only` to mark a specific test suite for exclusive execution, skipping all other suites in the file or project unless they are also marked with `.only`.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/index.md#_snippet_40

LANGUAGE: TypeScript
CODE:
```
import { assert, describe, test } from 'vitest'

// Only this suite (and others marked with only) are run
describe.only('suite', () => {
  test('sqrt', () => {
    assert.equal(Math.sqrt(4), 3)
  })
})

describe('other suite', () => {
  // ... will be skipped
})
```

----------------------------------------

TITLE: Advancing Async Fake Timers by Time with Vitest vi.advanceTimersByTimeAsync (TypeScript)
DESCRIPTION: This snippet demonstrates using `vi.advanceTimersByTimeAsync` with Vitest's fake timers. It advances the fake clock by a specified duration, similar to `advanceTimersByTime`, but specifically handles and awaits asynchronously set timers.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_26

LANGUAGE: typescript
CODE:
```
let i = 0
setInterval(() => Promise.resolve().then(() => console.log(++i)), 50)

await vi.advanceTimersByTimeAsync(150)

// log: 1
// log: 2
// log: 3
```

----------------------------------------

TITLE: Using expect.not for Negated Assertions in Vitest
DESCRIPTION: Shows how to use the `.not` property with `expect` to negate an assertion. This example asserts that a calculated value is *not* equal to 2, demonstrating the negation pattern for both Chai (`not.to.equal`) and Jest (`not.toBe`) compatible matchers.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_8

LANGUAGE: TypeScript
CODE:
```
import { expect, test } from 'vitest'

const input = Math.sqrt(16)

expect(input).not.to.equal(2) // chai API
expect(input).not.toBe(2) // jest API
```

----------------------------------------

TITLE: Using Asymmetric Matcher expect.anything in Vitest
DESCRIPTION: Use `expect.anything()` as an asymmetric matcher within equality checks (like `toEqual`) to assert that a property exists and has any value, without needing to know or specify the exact value.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_66

LANGUAGE: ts
CODE:
```
import { expect, test } from 'vitest'

test('object has "apples" key', () => {
  expect({ apples: 22 }).toEqual({ apples: expect.anything() })
})
```

----------------------------------------

TITLE: Configure Global and Pattern-Specific Coverage Thresholds (TypeScript)
DESCRIPTION: This snippet illustrates how to define global coverage thresholds and also set specific thresholds for files matching glob patterns. Thresholds defined for a pattern override the global settings for matching files, and global thresholds are not inherited by pattern-specific configurations.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_40

LANGUAGE: typescript
CODE:
```
{
  coverage: {
    thresholds: {
      // Thresholds for all files
      functions: 95,
      branches: 70,

      // Thresholds for matching glob pattern
      'src/utils/**.ts': {
        statements: 95,
        functions: 90,
        branches: 85,
        lines: 80,
      },

      // Files matching this pattern will only have lines thresholds set.
      // Global thresholds are not inherited.
      '**/math.ts': {
        lines: 100,
      }
    }
  }
}
```

----------------------------------------

TITLE: Defining and Using toHaveValue Matcher in Vitest - TypeScript
DESCRIPTION: Defines the toHaveValue matcher for verifying the value of form elements, including input, select, textarea, and elements with certain ARIA roles. Supports string, string array, number, or null as the value parameter and outputs assertion pass/fail. Requires a compatible DOM element and a Vitest testing environment. Does not support input type="checkbox" or type="radio" (use toBeChecked or toHaveFormValues instead). For other elements, follows the normalization rules of toHaveFormValues.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_26

LANGUAGE: TypeScript
CODE:
```
function toHaveValue(value: string | string[] | number | null): Promise<void>
```

LANGUAGE: TypeScript
CODE:
```
const textInput = getByTestId('input-text')
const numberInput = getByTestId('input-number')
const emptyInput = getByTestId('input-empty')
const selectInput = getByTestId('select-number')

await expect.element(textInput).toHaveValue('text')
await expect.element(numberInput).toHaveValue(5)
await expect.element(emptyInput).not.toHaveValue()
await expect.element(selectInput).toHaveValue(['second', 'third'])
```

----------------------------------------

TITLE: Using test.each with Template String Table and Mixed Data (Vitest, TypeScript)
DESCRIPTION: Shows the template string table syntax for `test.each` with various data types (numbers, strings, objects, arrays) in the data rows. The test name uses `$` followed by the column name (`$a`, `$b`, `$expected`) to reference the data.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/index.md#_snippet_24

LANGUAGE: TypeScript
CODE:
```
import { expect, test } from 'vitest'

test.each`
  a               | b      | expected
  ${1}            | ${1}   | ${2}
  ${'a'}          | ${'b'} | ${'ab'}
  ${[]}           | ${'b'} | ${'b'}
  ${{}}           | ${'b'} | ${'[object Object]b'}
  ${{ asd: 1 }}   | ${'b'} | ${'[object Object]b'}
`('returns $expected when $a is added $b', ({ a, b, expected }) => {
  expect(a + b).toBe(expected)
})
```

----------------------------------------

TITLE: Using test.each with Template String Table and Object Property Access (Vitest, TypeScript)
DESCRIPTION: Demonstrates the template string table syntax for providing test data to `test.each`. It shows how to access nested object properties using dot notation (`$a.val`) directly within the template string test name.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/index.md#_snippet_23

LANGUAGE: TypeScript
CODE:
```
test.each`
a               | b      | expected
${{ val: 1 }}   | ${'b'} | ${'1b'}
${{ val: 2 }}   | ${'b'} | ${'2b'}
${{ val: 3 }}   | ${'b'} | ${'3b'}
`('add($a.val, $b) -> $expected', ({ a, b, expected }) => {
  expect(a.val + b).toBe(expected)
})
```

----------------------------------------

TITLE: Selecting Options with userEvent in Vitest (TypeScript)
DESCRIPTION: Demonstrates how to use `userEvent.selectOptions` to select values in a `<select>` element within a Vitest browser test. It shows selecting a single option by string or locator, and selecting multiple options using an array of locators. Note that if the select element lacks the `multiple` attribute, only the first value in an array will be selected. The `webdriverio` provider does not support selecting multiple elements.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/interactivity-api.md#_snippet_17

LANGUAGE: TypeScript
CODE:
```
import { page, userEvent } from '@vitest/browser/context'

test('clears input', async () => {
  const select = page.getByRole('select')

  await userEvent.selectOptions(select, 'Option 1')
  // or you can access it directly on the locator
  await select.selectOptions('Option 1')

  expect(select).toHaveValue('option-1')

  await userEvent.selectOptions(select, 'option-1')
  expect(select).toHaveValue('option-1')

  await userEvent.selectOptions(select, [
    page.getByRole('option', { name: 'Option 1' }),
    page.getByRole('option', { name: 'Option 2' })
  ])
  expect(select).toHaveValue(['option-1', 'option-2'])
})
```

----------------------------------------

TITLE: Assert Value is Not String with Vitest
DESCRIPTION: This demonstrates `assert.isNotString`, which asserts that a value is not a string.  It utilizes the `vitest` framework.  The input is a value, and the assertion passes if the value is not a string.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_32

LANGUAGE: TypeScript
CODE:
```
import { assert, test } from 'vitest'

const color = ['red', 'green', 'yellow']

test('assert.isNotString', () => {
  assert.isNotString(color, 'color is not string but array')
})
```

----------------------------------------

TITLE: Setting Mocked System Time in Vitest
DESCRIPTION: Simulates changing the system clock when fake timers are enabled, affecting date-related APIs like `hrtime`, `performance.now`, and `new Date()`. It does not trigger timers. Useful for testing code dependent on the current date and accepts string, number, or Date arguments.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_34

LANGUAGE: typescript
CODE:
```
const date = new Date(1998, 11, 19)

vi.useFakeTimers()
vi.setSystemTime(date)

expect(Date.now()).toBe(date.valueOf())

vi.useRealTimers()
```

----------------------------------------

TITLE: Injecting Provided Values in Tests (test.spec.js)
DESCRIPTION: Demonstrates how to use the `inject` function within a test file (`test.spec.js`) to retrieve values that were previously provided to the project using the `project.provide` method.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/test-project.md#_snippet_5

LANGUAGE: javascript
CODE:
```
import { inject } from 'vitest'
const value = inject('key')
```

----------------------------------------

TITLE: Rewriting beforeEach Hooks with TypeScript for Proper Vitest Teardown
DESCRIPTION: Demonstrates recommended patterns for using beforeEach hooks in Vitest, especially when initializing library state like Pinia. To ensure Vitest teardown compatibility, use a block body even for single statements. Requires Pinia and Vitest, with createTestingPinia and setActivePinia functions. Input: none; Output: Pinia state setup for each test.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/migration.md#_snippet_12

LANGUAGE: typescript
CODE:
```
beforeEach(() => setActivePinia(createTestingPinia())) // [!code --]
beforeEach(() => { setActivePinia(createTestingPinia()) }) // [!code ++]
```

----------------------------------------

TITLE: Testing Vitest Options: Deprecated Third Argument Syntax in TypeScript
DESCRIPTION: This snippet illustrates the deprecated and new recommended signature for the test function in Vitest 3.0. The old pattern of using an options object as a third argument to test is shown alongside the updated syntax that places the options as the second argument. Requires Vitest 3.0+. The function accepts the test name, callback, and retry options. Deprecated: object as third argument will cause errors in future versions.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/migration.md#_snippet_0

LANGUAGE: TypeScript
CODE:
```
test('validation works', () => {
  // ...
}, { retry: 3 })

test('validation works', { retry: 3 }, () => {
  // ...
})
```

----------------------------------------

TITLE: Assert Value Does Not Exist with Vitest
DESCRIPTION: This demonstrates `assert.notExists`, which asserts that a value is either null or undefined.  It uses the `vitest` framework. The input is a value, and the assertion passes if the value is either null or undefined.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_22

LANGUAGE: TypeScript
CODE:
```
import { assert, test } from 'vitest'

const foo = null
const bar = undefined

test('assert.notExists', () => {
  assert.notExists(foo, 'foo is null so not exist')
  assert.notExists(bar, 'bar is undefined so not exist')
})
```

----------------------------------------

TITLE: Running Vitest from the Command Line (Bash)
DESCRIPTION: This snippet shows the command for running all tests (including in-source tests) using npx and the Vitest CLI. It assumes that Vitest is installed as a development dependency. No additional arguments are needed for basic operation. All matching files based on configuration will be discovered and executed.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/in-source.md#_snippet_2

LANGUAGE: Bash
CODE:
```
$ npx vitest
```

----------------------------------------

TITLE: toBeInTheDocument Assertion Example
DESCRIPTION: Demonstrates how to use the toBeInTheDocument assertion to check if an element is present in the document.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_5

LANGUAGE: html
CODE:
```
<svg data-testid="svg-element"></svg>
```

LANGUAGE: typescript
CODE:
```
await expect.element(getByTestId('svg-element')).toBeInTheDocument()
await expect.element(getByTestId('does-not-exist')).not.toBeInTheDocument()
```

----------------------------------------

TITLE: Configuring Vitest Test Pool (CLI & Config)
DESCRIPTION: Demonstrates switching the test execution pool, typically from the default `forks` to `threads`, which might be faster for large projects. This can be done via the `--pool` CLI option or the `test.pool` config property.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/improving-performance.md#_snippet_2

LANGUAGE: bash
CODE:
```
vitest --pool=threads
```

LANGUAGE: ts
CODE:
```
import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    pool: 'threads',
  },
})
```

----------------------------------------

TITLE: Asserting Exact Call Count and Arguments with Vitest
DESCRIPTION: Checks if a spy function was called exactly one time with the specified arguments. Requires passing a spy function to `expect`.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_47

LANGUAGE: typescript
CODE:
```
import { expect, test, vi } from 'vitest'

const market = {
  buy(subject: string, amount: number) {
    // ...
  },
}

test('spy function', () => {
  const buySpy = vi.spyOn(market, 'buy')

  market.buy('apples', 10)

  expect(buySpy).toHaveBeenCalledExactlyOnceWith('apples', 10)
})
```

----------------------------------------

TITLE: Checking Property Existence and Value with Vitest's toHaveProperty (TypeScript)
DESCRIPTION: Uses Vitest's `toHaveProperty` matcher to assert the existence of a property at a given key path on an object. It can optionally check if the property's value is deeply equal to an expected value using `toEqual` logic. The example covers checking existence, existence and value, non-existence, deep referencing using dot and array notation, and handling keys with special characters.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_31

LANGUAGE: TypeScript
CODE:
```
import { expect, test } from 'vitest'

const invoice = {
  'isActive': true,
  'P.O': '12345',
  'customer': {
    first_name: 'John',
    last_name: 'Doe',
    location: 'China',
  },
  'total_amount': 5000,
  'items': [
    {
      type: 'apples',
      quantity: 10,
    },
    {
      type: 'oranges',
      quantity: 5,
    },
  ],
}

test('John Doe Invoice', () => {
  expect(invoice).toHaveProperty('isActive') // assert that the key exists
  expect(invoice).toHaveProperty('total_amount', 5000) // assert that the key exists and the value is equal

  expect(invoice).not.toHaveProperty('account') // assert that this key does not exist

  // Deep referencing using dot notation
  expect(invoice).toHaveProperty('customer.first_name')
  expect(invoice).toHaveProperty('customer.last_name', 'Doe')
  expect(invoice).not.toHaveProperty('customer.location', 'India')

  // Deep referencing using an array containing the key
  expect(invoice).toHaveProperty('items[0].type', 'apples')
  expect(invoice).toHaveProperty('items.0.type', 'apples') // dot notation also works

  // Deep referencing using an array containing the keyPath
  expect(invoice).toHaveProperty(['items', 0, 'type'], 'apples')
  expect(invoice).toHaveProperty(['items', '0', 'type'], 'apples') // string notation also works

  // Wrap your key in an array to avoid the key from being parsed as a deep reference
  expect(invoice).toHaveProperty(['P.O'], '12345')
})
```

----------------------------------------

TITLE: Asserting Null Types with Vitest in TypeScript
DESCRIPTION: Asserts that a value or type is null using `.toBeNull`. Requires Vitest and works with null literals and assignments. Supports positive and negative assertions on possible nullable values.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect-typeof.md#_snippet_23

LANGUAGE: TypeScript
CODE:
```
import { expectTypeOf } from 'vitest'

expectTypeOf(null).toBeNull()
expectTypeOf<null>().toBeNull()
expectTypeOf(undefined).not.toBeNull()
```

----------------------------------------

TITLE: Testing userEvent.fill in Vitest (TypeScript)
DESCRIPTION: Illustrates how to use `userEvent.fill` to set the value of an input element in a Vitest browser test. It shows filling with different string values and the alternative direct locator syntax. This method clears existing text and triggers an input event.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/interactivity-api.md#_snippet_11

LANGUAGE: typescript
CODE:
```
import { page, userEvent } from '@vitest/browser/context'

test('update input', async () => {
  const input = page.getByRole('input')

  await userEvent.fill(input, 'foo') // input.value == foo
  await userEvent.fill(input, '{{a[[') // input.value == {{a[[
  await userEvent.fill(input, '{Shift}') // input.value == {Shift}

  // or you can access it directly on the locator
  await input.fill('foo') // input.value == foo
})
```

----------------------------------------

TITLE: Asserting ARIA Role Presence on Elements with Vitest - TypeScript
DESCRIPTION: The `toHaveRole` function asserts asynchronously that an element has a specific ARIA role, either explicit via `role` attribute or implicit through HTML semantics. It is useful for accessibility validation. The role must match exactly as a string without inheritance, and only the first valid custom role is considered. The snippet includes sample HTML with various role usages and test examples asserting roles of elements.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_37

LANGUAGE: ts
CODE:
```
function toHaveRole(role: ARIARole): Promise<void>
```

----------------------------------------

TITLE: Using test.each with Array Data and $ Index Formatting (Vitest, TypeScript)
DESCRIPTION: Illustrates using `test.each` with array data and accessing array elements by their 0-based index using the `$` prefix (`$0`, `$1`, `$2`) within the test name string. This provides an alternative formatting method to printf-style.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/index.md#_snippet_22

LANGUAGE: TypeScript
CODE:
```
test.each([
  [1, 1, 2],
  [1, 2, 3],
  [2, 1, 3]
])('add($0, $1) -> $2', (a, b, expected) => {
  expect(a + b).toBe(expected)
})
```

----------------------------------------

TITLE: getByText Function - Find Elements by Text Content
DESCRIPTION: Creates a locator to find elements containing specific text, matching against nodeValue or input's value. Supports exact and regex matching with whitespace normalization. Useful for non-interactive element selection.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_17

LANGUAGE: TypeScript
CODE:
```
function getByText(
  text: string | RegExp,
  options?: LocatorOptions,
): Locator
```

----------------------------------------

TITLE: Setting One-Time Return Value with mockReturnValueOnce
DESCRIPTION: This example showcases how to use `mockReturnValueOnce` to set different return values for consecutive calls to a mock function. After the `mockReturnValueOnce` values are exhausted, the default return value (if any) is used. TypeScript ensures that the provided value matches the return type of the original function.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/mock.md#_snippet_15

LANGUAGE: typescript
CODE:
```
const myMockFn = vi
  .fn()
  .mockReturnValue('default')
  .mockReturnValueOnce('first call')
  .mockReturnValueOnce('second call')

// 'first call', 'second call', 'default', 'default'
console.log(myMockFn(), myMockFn(), myMockFn(), myMockFn())
```

----------------------------------------

TITLE: TSX example demonstrating `name` option for `getByRole`
DESCRIPTION: This TSX snippet demonstrates how to use the `name` option with `getByRole` to filter elements based on their accessible name.  It showcases the default case-insensitive substring matching. Requires a TSX environment that supports JSX syntax. No external dependencies needed other than a rendering context for the TSX.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_8

LANGUAGE: tsx
CODE:
```
<button>Click Me!</button>

page.getByRole('button', { name: 'Click Me!' }) // ✅
page.getByRole('button', { name: 'click me!' }) // ✅
page.getByRole('button', { name: 'Click Me?' }) // ❌
```

----------------------------------------

TITLE: Mocking Specific Instance Method Return Value (TypeScript)
DESCRIPTION: Shows how to use `vi.mocked` (a type helper) and `mockReturnValue` to change the return value of a specific method on a particular instance of the mocked class.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/mocking.md#_snippet_24

LANGUAGE: ts
CODE:
```
const dog = new Dog('Cooper')

// "vi.mocked" is a type helper, since
// TypeScript doesn't know that Dog is a mocked class,
// it wraps any function in a MockInstance<T> type
// without validating if the function is a mock
vi.mocked(dog.speak).mockReturnValue('woof woof')

dog.speak() // woof woof
```

----------------------------------------

TITLE: Setting One-Time Mock Implementation with mockImplementationOnce
DESCRIPTION: This snippet illustrates the use of `mockImplementationOnce` to provide different implementations for consecutive calls to a mock function. It allows chaining multiple `mockImplementationOnce` calls. After all `mockImplementationOnce` implementations are exhausted, the default implementation (if any) is used.  TypeScript expects the arguments and return type to match those of the original function.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/mock.md#_snippet_4

LANGUAGE: typescript
CODE:
```
const myMockFn = vi
  .fn()
  .mockImplementationOnce(() => true) // 1st call
  .mockImplementationOnce(() => false) // 2nd call

myMockFn() // 1st call: true
myMockFn() // 2nd call: false
```

LANGUAGE: typescript
CODE:
```
const myMockFn = vi
  .fn(() => 'default')
  .mockImplementationOnce(() => 'first call')
  .mockImplementationOnce(() => 'second call')

// 'first call', 'second call', 'default', 'default'
console.log(myMockFn(), myMockFn(), myMockFn(), myMockFn())
```

----------------------------------------

TITLE: Checking for Null Values with toBeNull (Vitest, TypeScript)
DESCRIPTION: Explains the `toBeNull` assertion in Vitest, which simply checks if a value is strictly `null`. It is noted as an alias for `.toBe(null)`. A simple test example is provided.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_15

LANGUAGE: typescript
CODE:
```
import { expect, test } from 'vitest'

function apples() {
  return null
}

test('we don't have apples', () => {
  expect(apples()).toBeNull()
})
```

----------------------------------------

TITLE: Assert Strict Equality with Vitest
DESCRIPTION: This demonstrates `assert.strictEqual`, which tests for strict equality (===).  It requires the `vitest` testing framework. The input consists of two values, and the assertion passes only if both value and type are the same.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_6

LANGUAGE: TypeScript
CODE:
```
import { assert, test } from 'vitest'

test('assert.strictEqual', () => {
  assert.strictEqual(Math.sqrt(4), 2)
})
```

----------------------------------------

TITLE: Using vi.waitFor with expect in Vitest
DESCRIPTION: Provides an alternative pattern for handling flaky asynchronous conditions before making a standard assertion. It uses `vi.waitFor` to wait for a value to become stable or available, and then uses a standard `expect` assertion on the resolved value.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_7

LANGUAGE: TypeScript
CODE:
```
import { expect, vi } from 'vitest'

const flakyValue = await vi.waitFor(() => getFlakyValue())
expect(flakyValue).toMatchSnapshot()
```

----------------------------------------

TITLE: Advancing Fake Timers by Time with Vitest vi.advanceTimersByTime (TypeScript)
DESCRIPTION: This snippet shows how to use `vi.advanceTimersByTime` in Vitest's fake timer environment. It advances the fake clock by a specified number of milliseconds, triggering any timers (like `setInterval`) that would have fired within that duration.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_25

LANGUAGE: typescript
CODE:
```
let i = 0
setInterval(() => console.log(++i), 50)

vi.advanceTimersByTime(150)

// log: 1
// log: 2
// log: 3
```

----------------------------------------

TITLE: Starting Vitest Tests with UI via Command Line
DESCRIPTION: This command starts the Vitest tests and enables the UI.  The `--ui` flag instructs Vitest to launch the UI along with the test execution, utilizing the Vite server under the hood.  The tests run in watch mode by default. The output is the test results displayed in the terminal and the UI running in the browser.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/ui.md#_snippet_1

LANGUAGE: bash
CODE:
```
vitest --ui
```

----------------------------------------

TITLE: Correctly Accessing Context with Destructuring
DESCRIPTION: Highlights the requirement to use object destructuring (`{ fixtureName }`) to access fixtures and context properties when using `test.extend`, showing the correct pattern.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/test-context.md#_snippet_10

LANGUAGE: TypeScript
CODE:
```
test('context must be destructured', ({ todos }) => {
  expect(todos.length).toBe(2)
})
```

----------------------------------------

TITLE: Integrate Vitest Types in Vite Config (New) TypeScript
DESCRIPTION: Adds Vitest type definitions to a `vite.config.ts` file by referencing the types from 'vitest/config' using a triple slash directive. This is the recommended approach for integrating Vitest configuration within your Vite config for improved TypeScript support.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/index.md#_snippet_7

LANGUAGE: TypeScript
CODE:
```
/// <reference types="vitest/config" />
import { defineConfig } from 'vite'

export default defineConfig({
  test: {
    // ... Specify options here.
  },
})
```

----------------------------------------

TITLE: Assert Value is Not Null with Vitest
DESCRIPTION: This snippet demonstrates `assert.isNotNull`, which asserts that a value is not null. It requires the `vitest` framework.  The input is a value, and the assertion passes when the value is not null.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_18

LANGUAGE: TypeScript
CODE:
```
import { assert, test } from 'vitest'

const error = { message: 'error was occurred' }

test('assert.isNotNull', () => {
  assert.isNotNull(error, 'error is not null but object')
})
```

----------------------------------------

TITLE: toBeDisabled Assertion Example
DESCRIPTION: Demonstrates how to use the toBeDisabled assertion to check if an element is disabled from the user's perspective.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_2

LANGUAGE: html
CODE:
```
<button
  data-testid="button"
  type="submit"
  disabled
>
  submit
</button>
```

LANGUAGE: typescript
CODE:
```
await expect.element(getByTestId('button')).toBeDisabled() // ✅
await expect.element(getByTestId('button')).not.toBeDisabled() // ❌
```

----------------------------------------

TITLE: Accessing Last Mock Call Arguments with mock.lastCall (TypeScript)
DESCRIPTION: The `mock.lastCall` property provides convenient access to the arguments of the most recent call made to the mock function. It returns an array of arguments similar to an element in `mock.calls`, or `undefined` if the mock function has not been called yet.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/mock.md#_snippet_17

LANGUAGE: typescript
CODE:
```
const lastCall: Parameters<T> | undefined
```

----------------------------------------

TITLE: Coverage Reporter Configuration
DESCRIPTION: Specifies the coverage reporters to use. Can be set via the CLI using `--coverage.reporter <name>` or in the configuration file using the `coverage.reporter` property. Defaults to `["text", "html", "clover", "json"]`.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/cli-generated.md#_snippet_24



----------------------------------------

TITLE: Using toHaveRole Assertion to Validate Element Roles - TypeScript
DESCRIPTION: This snippet demonstrates how to assert roles on elements found by test IDs, including checking for explicit and implicit roles. It also covers negative assertions when an element does not have a given role, including fallback to 'generic' if no valid role applies.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_39

LANGUAGE: ts
CODE:
```
await expect.element(getByTestId('button')).toHaveRole('button')
await expect.element(getByTestId('button-explicit')).toHaveRole('button')
await expect.element(getByTestId('button-explicit-multiple')).toHaveRole('button')
await expect.element(getByTestId('button-explicit-multiple')).toHaveRole('switch')
await expect.element(getByTestId('link')).toHaveRole('link')
await expect.element(getByTestId('link-invalid')).not.toHaveRole('link')
await expect.element(getByTestId('link-invalid')).toHaveRole('generic')
```

----------------------------------------

TITLE: Assert Value is String with Vitest
DESCRIPTION: This snippet uses `assert.isString`, which asserts that a value is a string. It uses the `vitest` framework. The input is a value, and the assertion passes if the value is a string.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_31

LANGUAGE: TypeScript
CODE:
```
import { assert, test } from 'vitest'

const color = 'red'

test('assert.isString', () => {
  assert.isString(color, 'color is string')
})
```

----------------------------------------

TITLE: Checking Array Containment with Deep Equality using Vitest's toContainEqual (TypeScript)
DESCRIPTION: Uses Vitest's `toContainEqual` matcher to assert if an array contains an item that is deeply equal to the expected value. It applies the same comparison logic as the `toEqual` matcher to each element in the array. The example verifies if an array of objects contains an object matching a specific structure and values.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_29

LANGUAGE: TypeScript
CODE:
```
import { expect, test } from 'vitest'
import { getFruitStock } from './stocks.js'

test('apple available', () => {
  expect(getFruitStock()).toContainEqual({ fruit: 'apple', count: 5 })
})
```

----------------------------------------

TITLE: Comparing test.each and test.for Array Handling (Vitest, TypeScript)
DESCRIPTION: Highlights the key difference between `test.each` and `test.for` when using array test cases. `test.each` spreads the array elements into separate function parameters, while `test.for` passes the array as a single argument.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/index.md#_snippet_25

LANGUAGE: TypeScript
CODE:
```
// `each` spreads array case
test.each([
  [1, 1, 2],
  [1, 2, 3],
  [2, 1, 3]
])('add(%i, %i) -> %i', (a, b, expected) => { // [!code --]
  expect(a + b).toBe(expected)
})

// `for` doesn't spread array case
test.for([
  [1, 1, 2],
  [1, 2, 3],
  [2, 1, 3]
])('add(%i, %i) -> %i', ([a, b, expected]) => { // [!code ++]
  expect(a + b).toBe(expected)
})
```

----------------------------------------

TITLE: Mocking a global variable using vi.stubGlobal in Vitest
DESCRIPTION: Explains how to mock a global variable using the `vi.stubGlobal` helper. The mock persists between tests unless `unstubGlobals` is enabled in the config or `vi.unstubAllGlobals` is called.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/mocking.md#_snippet_36

LANGUAGE: ts
CODE:
```
vi.stubGlobal('__VERSION__', '1.0.0')
expect(__VERSION__).toBe('1.0.0')
```

----------------------------------------

TITLE: Assert Value is Null with Vitest
DESCRIPTION: This snippet uses `assert.isNull`, which asserts that a value is null. It uses the `vitest` framework. The input is a value, and the assertion passes only when the value is null.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_17

LANGUAGE: TypeScript
CODE:
```
import { assert, test } from 'vitest'

const error = null

test('assert.isNull', () => {
  assert.isNull(error, 'error is null')
})
```

----------------------------------------

TITLE: Using JSON Reporter - Configuration
DESCRIPTION: This snippet demonstrates configuring the `json` reporter within the `vitest.config.ts` file.  It sets the `reporters` array to `['json']`. The JSON reporter generates a report of the test results in a JSON format compatible with Jest's `--json` option.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/reporters.md#_snippet_16

LANGUAGE: ts
CODE:
```
export default defineConfig({
  test: {
    reporters: ['json']
  },
})

```

----------------------------------------

TITLE: Specify File Environment with Jest Docblock (JS)
DESCRIPTION: Illustrates using the Jest-compatible `@jest-environment` docblock to set the test environment to 'jsdom' for a file. This aids migration from Jest or maintaining compatibility.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_14

LANGUAGE: js
CODE:
```
/**
 * @jest-environment jsdom
 */

test('use jsdom in this test file', () => {
  const element = document.createElement('div')
  expect(element).not.toBeNull()
})
```

----------------------------------------

TITLE: Assert Value is Not NaN with Vitest
DESCRIPTION: This demonstrates `assert.isNotNaN`, which asserts that a value is not NaN.  It uses the `vitest` framework.  The input is a value, and the assertion passes if the value is not NaN.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_20

LANGUAGE: TypeScript
CODE:
```
import { assert, test } from 'vitest'

const calculation = 1 * 2

test('assert.isNotNaN', () => {
  assert.isNotNaN(calculation, '1 * 2 is Not NaN but 2')
})
```

----------------------------------------

TITLE: Assert Value is Undefined with Vitest
DESCRIPTION: This snippet showcases `assert.isUndefined`, which asserts that a value is undefined. It utilizes the `vitest` testing framework. The assertion passes only when the input is undefined.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_23

LANGUAGE: TypeScript
CODE:
```
import { assert, test } from 'vitest'

const name = undefined

test('assert.isUndefined', () => {
  assert.isUndefined(name, 'name is undefined')
})
```

----------------------------------------

TITLE: Assert Value is Defined with Vitest
DESCRIPTION: This snippet demonstrates `assert.isDefined`, which asserts that a value is not undefined. It uses the `vitest` framework.  The input is a value, and the test passes if the value is not undefined.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_24

LANGUAGE: TypeScript
CODE:
```
import { assert, test } from 'vitest'

const name = 'foo'

test('assert.isDefined', () => {
  assert.isDefined(name, 'name is not undefined')
})
```

----------------------------------------

TITLE: Configuring Multiple Browsers with Playwright in Vitest
DESCRIPTION: This configuration snippet demonstrates how to set up Vitest to run tests concurrently in multiple browsers (Chromium, Firefox, and Webkit) using the Playwright provider and the `browser.instances` array.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/multiple-setups.md#_snippet_0

LANGUAGE: ts
CODE:
```
import { defineConfig } from 'vitest/config'
export default defineConfig({
  test: {
    browser: {
      enabled: true,
      provider: 'playwright',
      headless: true,
      instances: [
        { browser: 'chromium' },
        { browser: 'firefox' },
        { browser: 'webkit' },
      ],
    },
  },
})
```

----------------------------------------

TITLE: Stubbing Vitest Suites with describe.todo (TS)
DESCRIPTION: The `describe.todo` (or `suite.todo`) method is used to create placeholder entries for test suites that are planned but not yet implemented. This helps track pending work by displaying the stubbed suite in the test report.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/index.md#_snippet_46

LANGUAGE: typescript
CODE:
```
// An entry will be shown in the report for this suite
describe.todo('unimplemented suite')
```

----------------------------------------

TITLE: Resetting Spies with mockReset in Vitest using TypeScript
DESCRIPTION: Shows how the 'mockReset' function on a spy resets the implementation to the original function rather than to a noop, as of Vitest 3.0. Demonstrates spying on a method, replacing its implementation, and restoring it via mockReset. Dependencies: 'vi.spyOn'. Input: object with function property. Output: function returns original result after reset.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/migration.md#_snippet_2

LANGUAGE: TypeScript
CODE:
```
const foo = {
  bar: () => 'Hello, world!'
}

vi.spyOn(foo, 'bar').mockImplementation(() => 'Hello, mock!')

foo.bar() // 'Hello, mock!'

foo.bar.mockReset()

foo.bar() // undefined
foo.bar() // 'Hello, world!'
```

----------------------------------------

TITLE: Configuring tsconfig-paths Plugin in Vitest
DESCRIPTION: This code snippet demonstrates how to configure the `vite-tsconfig-paths` plugin in a Vitest configuration file.  The plugin resolves module paths based on the `baseUrl` setting in the `tsconfig.json` file, which is not automatically handled by Vite.  This allows for importing modules using paths defined in `tsconfig.json`.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/common-errors.md#_snippet_0

LANGUAGE: typescript
CODE:
```
import { defineConfig } from 'vitest/config'
import tsconfigPaths from 'vite-tsconfig-paths'

export default defineConfig({
  plugins: [tsconfigPaths()]
})
```

----------------------------------------

TITLE: Mocking Module with Default Export in Vitest (TypeScript)
DESCRIPTION: Explains the requirement to explicitly include a `default` key in the object returned by the `vi.mock` factory function when the mocked module has a default export, adhering to ES module standards.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_4

LANGUAGE: ts
CODE:
```
vi.mock('./path/to/module.js', () => {
  return {
    default: { myDefaultKey: vi.fn() },
    namedExport: vi.fn(),
    // etc...
  }
})
```

----------------------------------------

TITLE: Asserting Last Function Return Value with Vitest
DESCRIPTION: Checks if a spy function successfully returned a specific value during its last invocation. Requires a spy function.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_53

LANGUAGE: typescript
CODE:
```
import { expect, test, vi } from 'vitest'

test('spy function returns bananas on a last call', () => {
  const sell = vi.fn((product: string) => ({ product }))

  sell('apples')
  sell('bananas')

  expect(sell).toHaveLastReturnedWith({ product: 'bananas' })
})
```

----------------------------------------

TITLE: Checking Object Properties with Vitest
DESCRIPTION: The `toHaveProperty()` matcher checks if a specific property exists on an object. It imports `expectTypeOf` from 'vitest'. If the property exists, it allows further type assertions on the property's type by chaining other matchers like `toBeNumber()` and `toBeString()`. It demonstrates asserting existence of a property and chaining matchers.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect-typeof.md#_snippet_28

LANGUAGE: ts
CODE:
```
import { expectTypeOf } from 'vitest'

const obj = { a: 1, b: '' }

expectTypeOf(obj).toHaveProperty('a')
expectTypeOf(obj).not.toHaveProperty('c')

expectTypeOf(obj).toHaveProperty('a').toBeNumber()
expectTypeOf(obj).toHaveProperty('b').toBeString()
expectTypeOf(obj).toHaveProperty('a').not.toBeString()
```

----------------------------------------

TITLE: Asserting Object Contains Specific Keys with Vitest (TypeScript)
DESCRIPTION: Demonstrates using `assert.containsAllKeys` in Vitest to verify that an object (or Map/Set) includes all specified keys, potentially having additional keys. Keys can be provided as an array of strings/objects or as the keys of another object. Includes examples with plain objects, Maps, and Sets.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_71

LANGUAGE: typescript
CODE:
```
import { assert, test } from 'vitest'

test('assert.containsAllKeys', () => {
  assert.containsAllKeys({ foo: 1, bar: 2, baz: 3 }, ['foo', 'baz'])
  assert.containsAllKeys({ foo: 1, bar: 2, baz: 3 }, ['foo', 'bar', 'baz'])
  assert.containsAllKeys({ foo: 1, bar: 2, baz: 3 }, { foo: 30, baz: 1337 })
  assert.containsAllKeys({ foo: 1, bar: 2, baz: 3 }, { foo: 30, bar: 99, baz: 1337 })
  assert.containsAllKeys(new Map([[{ foo: 1 }, 'bar'], ['key', 'value']]), [{ foo: 1 }])
  assert.containsAllKeys(new Map([[{ foo: 1 }, 'bar'], ['key', 'value']]), [{ foo: 1 }, 'key'])
  assert.containsAllKeys(new Set([{ foo: 'bar' }, 'anotherKey'], [{ foo: 'bar' }]))
  assert.containsAllKeys(new Set([{ foo: 'bar' }, 'anotherKey'], [{ foo: 'bar' }, 'anotherKey']))
})
```

----------------------------------------

TITLE: Simulating User Input with Vitest Browser Mode (TS)
DESCRIPTION: Illustrates two methods for simulating user input (typing text) into an element: using the `userEvent.fill` utility from `@vitest/browser/context` or directly calling the `fill` method on a locator obtained via `page.getByLabelText`.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/index.md#_snippet_14

LANGUAGE: ts
CODE:
```
import { page, userEvent } from '@vitest/browser/context'
await userEvent.fill(page.getByLabelText(/username/i), 'Alice')
// or just locator.fill
await page.getByLabelText(/username/i).fill('Alice')
```

----------------------------------------

TITLE: Stubbing Tests with Vitest (TypeScript)
DESCRIPTION: Shows how to use `test.todo` to create placeholder entries for tests that are planned but not yet implemented. These entries appear in the test report, providing a clear overview of pending work.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/index.md#_snippet_18

LANGUAGE: TypeScript
CODE:
```
// An entry will be shown in the report for this test
test.todo('unimplemented test')
```

----------------------------------------

TITLE: Adding Vue Snapshot Serializer in Test Setup File with JavaScript
DESCRIPTION: Shows how to add the jest-serializer-vue serializer in a Vitest test setup file to enable proper snapshot testing for Vue components. Requires Vitest and jest-serializer-vue package. Input: none; Output: snapshot serializer registered so Vue snapshots render correctly.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/migration.md#_snippet_17

LANGUAGE: javascript
CODE:
```
import vueSnapshotSerializer from 'jest-serializer-vue'

expect.addSnapshotSerializer(vueSnapshotSerializer)
```

----------------------------------------

TITLE: Deeply Mocking Object Properties Vitest TypeScript
DESCRIPTION: Demonstrates how to use `vi.mockObject` to deeply mock properties and methods of a given object, similar to how `vi.mock()` mocks module exports. It shows how to access and change the mock implementations.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_16

LANGUAGE: typescript
CODE:
```
const original = {
  simple: () => 'value',
  nested: {
    method: () => 'real'
  },
  prop: 'foo',
}

const mocked = vi.mockObject(original)
expect(mocked.simple()).toBe(undefined)
expect(mocked.nested.method()).toBe(undefined)
expect(mocked.prop).toBe('foo')

mocked.simple.mockReturnValue('mocked')
mocked.nested.method.mockReturnValue('mocked nested')

expect(mocked.simple()).toBe('mocked')
expect(mocked.nested.method()).toBe('mocked nested')
```

----------------------------------------

TITLE: Checking Checked State of Checkbox and Radio Inputs with Vitest - TypeScript
DESCRIPTION: The `toBeChecked` function asynchronously asserts whether an element is checked. It supports input elements of type checkbox and radio, and elements with roles 'checkbox', 'radio', or 'switch' having a valid `aria-checked` attribute. This snippet also demonstrates HTML examples of such elements in checked and unchecked states and how to assert using test IDs in Vitest.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_31

LANGUAGE: ts
CODE:
```
function toBeChecked(): Promise<void>
```

----------------------------------------

TITLE: Using Extended Test Context with Custom Fixtures
DESCRIPTION: Shows how to import and use the custom test collector created with `test.extend`. The defined fixtures ('todos', 'archive') are available in the test callback via object destructuring.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/test-context.md#_snippet_7

LANGUAGE: TypeScript
CODE:
```
import { expect } from 'vitest'
import { test } from './my-test.js'

test('add items to todos', ({ todos }) => {
  expect(todos.length).toBe(3)

  todos.push(4)
  expect(todos.length).toBe(4)
})

test('move items from todos to archive', ({ todos, archive }) => {
  expect(todos.length).toBe(3)
  expect(archive.length).toBe(0)

  archive.push(todos.pop())
  expect(todos.length).toBe(2)
  expect(archive.length).toBe(1)
})
```

----------------------------------------

TITLE: Assert Value Exists with Vitest
DESCRIPTION: This demonstrates `assert.exists`, asserting that a value is neither null nor undefined. It utilizes the `vitest` testing framework. The assertion passes if the input value is neither null nor undefined.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_21

LANGUAGE: TypeScript
CODE:
```
import { assert, test } from 'vitest'

const name = 'foo'

test('assert.exists', () => {
  assert.exists(name, 'foo is neither null nor undefined')
})
```

----------------------------------------

TITLE: Assert Value is Array with Vitest
DESCRIPTION: This snippet demonstrates `assert.isArray`, which asserts that a value is an array. It uses the `vitest` testing framework.  The input is a value, and the assertion passes if the value is an array.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_29

LANGUAGE: TypeScript
CODE:
```
import { assert, test } from 'vitest'

const color = ['red', 'green', 'yellow']

test('assert.isArray', () => {
  assert.isArray(color, 'color is array')
})
```

----------------------------------------

TITLE: Module with Injected Function Parameter (JavaScript)
DESCRIPTION: A modified version of the `foobar.js` module where the `foobar` function now accepts an `injectedFoo` parameter. This allows tests to pass a mocked or spied-on version of `foo` and compare it to the original `foo` function reference used internally.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/mocking.md#_snippet_8

LANGUAGE: js
CODE:
```
export function foo() {
  return 'foo'
}

export function foobar(injectedFoo) {
  return injectedFoo === foo // false
}
```

----------------------------------------

TITLE: Configuring Headless Mode in vitest.config.ts
DESCRIPTION: Provides an example configuration object for `vitest.config.ts` that enables browser testing with the Playwright provider and sets the `headless` option to `true`. This configures Vitest to run browser tests in the background without a visible UI.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/index.md#_snippet_11

LANGUAGE: ts
CODE:
```
import { defineConfig } from 'vitest/config'
export default defineConfig({
  test: {
    browser: {
      provider: 'playwright',
      enabled: true,
      headless: true,
    },
  }
})
```

----------------------------------------

TITLE: Conditionally Skipping Vitest Tests via Context
DESCRIPTION: Shows how to dynamically skip a test based on a condition by passing a boolean value as the first argument to the `context.skip()` method, optionally including a message.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/index.md#_snippet_10

LANGUAGE: TypeScript
CODE:
```
import { assert, test } from 'vitest'

test('skipped test', (context) => {
  context.skip(Math.random() < 0.5, 'optional message')
  // Test skipped, no error
  assert.equal(Math.sqrt(4), 3)
})
```

----------------------------------------

TITLE: Extracting Function Parameter Types with Vitest in TypeScript
DESCRIPTION: Uses `.parameters` to extract and assert the argument types of a function, returning them as an array. Requires Vitest and works with function types, supporting detailed assertions about expected function signatures in unit tests.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect-typeof.md#_snippet_5

LANGUAGE: TypeScript
CODE:
```
import { expectTypeOf } from 'vitest'

type NoParam = () => void
type HasParam = (s: string) => void

expectTypeOf<NoParam>().parameters.toEqualTypeOf<[]>()
expectTypeOf<HasParam>().parameters.toEqualTypeOf<[string]>()
```

----------------------------------------

TITLE: Configure Custom Snapshot Path in Vitest
DESCRIPTION: Overrides the default snapshot path behavior in Vitest configuration. This example shows how to store snapshot files next to the test files instead of in the default __snapshots__ directory.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_46

LANGUAGE: ts
CODE:
```
import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    resolveSnapshotPath: (testPath, snapExtension) => testPath + snapExtension,
  },
})
```

----------------------------------------

TITLE: Using assert.notMatch in Vitest (TypeScript)
DESCRIPTION: Provides an example of `assert.notMatch` in Vitest. This assertion verifies that a string value does not match the provided regular expression. The code imports from `vitest` and demonstrates the assertion within a test function, including an optional message.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_55

LANGUAGE: typescript
CODE:
```
import { assert, test } from 'vitest'

test('assert.notMatch', () => {
  assert.notMatch('foobar', /^foo/, 'regexp does not match')
})
```

----------------------------------------

TITLE: Updating Snapshots using CLI (Bash)
DESCRIPTION: This shows how to update snapshots using the `--update` or `-u` flag in the Vitest CLI. This will update all failing snapshots to match the current output. Dependencies: vitest CLI. Input: none. Output: Updated snapshot files.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/snapshot.md#_snippet_3

LANGUAGE: bash
CODE:
```
vitest -u
```

----------------------------------------

TITLE: Extending coverage.exclude in Vitest Configuration (TypeScript)
DESCRIPTION: Example demonstrating how to extend the default coverage.exclude list in a Vitest configuration file using TypeScript. It shows how to import coverageConfigDefaults and spread its exclude property along with custom patterns.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_37

LANGUAGE: typescript
CODE:
```
import { coverageConfigDefaults, defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    coverage: {
      exclude: ['**/custom-pattern/**', ...coverageConfigDefaults.exclude]
    },
  },
})
```

----------------------------------------

TITLE: Asserting Greater Than with toBeGreaterThan in Vitest (TypeScript)
DESCRIPTION: The `toBeGreaterThan` matcher asserts if the actual value is strictly greater than the received value. Equality will cause the test to fail.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_21

LANGUAGE: TypeScript
CODE:
```
import { expect, test } from 'vitest'
import { getApples } from './stocks.js'

test('have more then 10 apples', () => {
  expect(getApples()).toBeGreaterThan(10)
})
```

----------------------------------------

TITLE: Coverage Reports Directory Configuration
DESCRIPTION: Specifies the directory to write coverage reports to. Can be set via the CLI using `--coverage.reportsDirectory <path>` or in the configuration file using the `coverage.reportsDirectory` property. Defaults to `./coverage`.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/cli-generated.md#_snippet_23



----------------------------------------

TITLE: Mocking Exported Variable with vi.spyOn (TypeScript)
DESCRIPTION: Shows how to mock an exported variable from another module using `vi.spyOn`. It spies on the getter of the property on the imported module object and mocks its return value.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/mocking.md#_snippet_27

LANGUAGE: ts
CODE:
```
import * as exports from './example.js'

vi.spyOn(exports, 'getter', 'get').mockReturnValue('mocked')
```

----------------------------------------

TITLE: Configuring Virtual Module Alias in Vitest (JavaScript)
DESCRIPTION: Configures Vitest to resolve a virtual module identifier (`$app/forms`) to a specific local file (`./mocks/forms.js`) using the `alias` option in the test configuration. This allows Vitest to recognize the virtual module during parsing.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/mocking.md#_snippet_3

LANGUAGE: js
CODE:
```
import { defineConfig } from 'vitest/config'
import { resolve } from 'node:path'
export default defineConfig({
  test: {
    alias: {
      '$app/forms': resolve('./mocks/forms.js'),
    },
  },
})
```

----------------------------------------

TITLE: Testing Preact Components with Vitest Browser and Testing Library
DESCRIPTION: Demonstrates how to test Preact components in Vitest Browser using `@testing-library/preact`. It shows rendering a component, locating elements using `page.elementLocator`, asserting element presence, and simulating user interaction with `click`. It highlights the use of `page.elementLocator` for interacting with elements in the browser context.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/index.md#_snippet_19

LANGUAGE: tsx
CODE:
```
// based on @testing-library/preact example
// https://testing-library.com/docs/preact-testing-library/example

import { h } from 'preact'
import { page } from '@vitest/browser/context'
import { render } from '@testing-library/preact'

import HiddenMessage from '../hidden-message'

test('shows the children when the checkbox is checked', async () => {
  const testMessage = 'Test Message'

  const { baseElement } = render(
    <HiddenMessage>{testMessage}</HiddenMessage>,
  )

  const screen = page.elementLocator(baseElement)

  // .query() will return the element or null if it cannot be found.
  // .element() will return the element or throw an error if it cannot be found.
  expect(screen.getByText(testMessage).query()).not.toBeInTheDocument()

  // The queries can accept a regex to make your selectors more
  // resilient to content tweaks and changes.
  await screen.getByLabelText(/show/i).click()

  await expect.element(screen.getByText(testMessage)).toBeInTheDocument()
})
```

----------------------------------------

TITLE: Mocking an exported class using vi.spyOn in Vitest
DESCRIPTION: Shows how to mock an exported class using `vi.spyOn` on the module and providing a mock implementation that is a spy function with mocked prototype methods. Requires the original class definition.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/mocking.md#_snippet_32

LANGUAGE: ts
CODE:
```
export class SomeClass {}
```

LANGUAGE: ts
CODE:
```
import * as mod from './example.js'

const SomeClass = vi.fn()
SomeClass.prototype.someMethod = vi.fn()

vi.spyOn(mod, 'SomeClass').mockImplementation(SomeClass)
```

----------------------------------------

TITLE: Snapshot Testing with Vitest in TypeScript
DESCRIPTION: This snippet shows how to implement snapshot testing with Vitest using its Jest-compatible API. It requires vitest to be installed and proper configuration for snapshot storage. The function 'render' is called, and its output is asserted to match an existing or new snapshot. Expected input is a result from the 'render' function; expected output is a comparison against a stored reference. Testers should ensure their environment supports file I/O for saving and comparing snapshots.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/features.md#_snippet_3

LANGUAGE: typescript
CODE:
```
import { expect, it } from 'vitest'

it('renders correctly', () => {
  const result = render()
  expect(result).toMatchSnapshot()
})

```

----------------------------------------

TITLE: Mocking part of a module using vi.mock in Vitest
DESCRIPTION: Shows how to selectively mock specific exports from a module while retaining the original behavior of others using `vi.mock` with an async factory function that imports the original module.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/mocking.md#_snippet_34

LANGUAGE: ts
CODE:
```
import { mocked, original } from './some-path.js'

vi.mock(import('./some-path.js'), async (importOriginal) => {
  const mod = await importOriginal()
  return {
    ...mod,
    mocked: vi.fn()
  }
})
original() // has original behaviour
mocked() // is a spy function
```

----------------------------------------

TITLE: Sharding Tests in Parallel Environments using Bash
DESCRIPTION: This set of bash commands demonstrates running and merging Vitest tests in parallel shards, then merging results for reporting. The 'vitest --shard=1/2' and 'vitest --shard=2/2' commands split the test suite across two processes, reporting with the 'blob' reporter and generating coverage data. The final command uses 'vitest --merge-reports' to aggregate results and output them in the 'junit' format with final coverage stats. This is commonly used in CI pipelines for large projects.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/features.md#_snippet_12

LANGUAGE: bash
CODE:
```
vitest --shard=1/2 --reporter=blob --coverage
vitest --shard=2/2 --reporter=blob --coverage
vitest --merge-reports --reporter=junit --coverage

```

----------------------------------------

TITLE: Configuring Alias with URL in Vitest
DESCRIPTION: This code snippet shows how to configure aliases in the Vitest configuration file using `URL` constructor to resolve the path correctly. Using `URL` ensures that the alias resolves to an absolute path, preventing issues where aliases are treated as relative to the importing file. This configuration maps the `@/` alias to the `./src/` directory.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/common-errors.md#_snippet_1

LANGUAGE: typescript
CODE:
```
import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    alias: {
      '@/': new URL('./src/', import.meta.url).pathname, // [!code ++]
    }
  }
})
```

----------------------------------------

TITLE: Extending Vitest Test Context with Fixtures
DESCRIPTION: Illustrates how to use `test.extend` to create a new test instance with a customized context, allowing the injection of fixtures (like `todos` and `archive` in this example) that can be set up and torn down for each test.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/index.md#_snippet_7

LANGUAGE: TypeScript
CODE:
```
import { expect, test } from 'vitest'

const todos = []
const archive = []

const myTest = test.extend({
  todos: async ({ task }, use) => {
    todos.push(1, 2, 3)
    await use(todos)
    todos.length = 0
  },
  archive
})

myTest('add item', ({ todos }) => {
  expect(todos.length).toBe(3)

  todos.push(4)
  expect(todos.length).toBe(4)
})
```

----------------------------------------

TITLE: Disabling Vitest Test Isolation (CLI & Config)
DESCRIPTION: Explains how to disable test isolation per file using the `--no-isolate` flag or the `test.isolate` config option. Disabling isolation can improve speed for projects without side effects, though it's not supported for the `vmThreads` pool. It also shows how to disable isolation specifically for the `forks` pool.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/improving-performance.md#_snippet_0

LANGUAGE: bash
CODE:
```
vitest --no-isolate
```

LANGUAGE: ts
CODE:
```
import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    isolate: false,
    // you can also disable isolation only for specific pools
    poolOptions: {
      forks: {
        isolate: false,
      },
    },
  },
})
```

----------------------------------------

TITLE: Placing Vitest Options in Test Property - TypeScript
DESCRIPTION: A simple example reinforcing that all Vitest-specific configuration options should be nested within the `test` property of the configuration object, whether using `vite.config.js` or `vitest.config.js`.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_6

LANGUAGE: TypeScript
CODE:
```
export default defineConfig({
  test: {
    exclude: [],
  },
})
```

----------------------------------------

TITLE: Using fill via Locator API in Vitest (TypeScript)
DESCRIPTION: Shows an example of filling an input element by locating it with page.getByRole and invoking fill, entering specified user text. Depends on @vitest/browser/context; assumes the located element supports value assignment. The function is async and resolves when the entered value and all events (change, input) are dispatched.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_39

LANGUAGE: typescript
CODE:
```
import { page } from '@vitest/browser/context'

await page.getByRole('input', { name: 'Full Name' }).fill('Mr. Bean')
```

----------------------------------------

TITLE: Defining unimplemented suites and tests with .todo in Vitest
DESCRIPTION: This snippet shows how to create placeholders for suites and tests not yet implemented using `.todo`, which appear in reports and remind developers of pending work.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/filtering.md#_snippet_7

LANGUAGE: typescript
CODE:
```
import { describe, it } from 'vitest'

describe.todo('unimplemented suite')

// Placeholder for an unimplemented test

describe('suite', () => {
  it.todo('unimplemented test')
})
```

----------------------------------------

TITLE: Running Related Tests With Vitest CLI - Bash
DESCRIPTION: Runs tests that cover specific source files identified by their relative path, using Vitest's static import analysis. Useful for pre-commit hooks like lint-staged or automation in CI. Input: list of source file paths. Output: Runs tests related to the supplied files. Limitation: Only tests for files with static imports are detected, not dynamic ones.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/cli.md#_snippet_3

LANGUAGE: bash
CODE:
```
vitest related /src/index.ts /src/hello-world.js

```

----------------------------------------

TITLE: Asynchronously Running All Pending Timers with Vitest
DESCRIPTION: Asynchronously invokes all initiated timers, including asynchronous ones, until the queue is empty. Similar to `runAllTimers` but handles promises and async operations within timers. Has a configurable loop limit for infinite intervals.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_31

LANGUAGE: typescript
CODE:
```
setTimeout(async () => {
  console.log(await Promise.resolve('result'))
}, 100)

await vi.runAllTimersAsync()

// log: result
```

----------------------------------------

TITLE: HTML examples demonstrating various label associations with `getByLabelText`
DESCRIPTION: This HTML snippet provides examples of different ways labels can be associated with form elements, including using `for`/`id`, `aria-labelledby`, wrapper labels, and `aria-label` attributes.  These examples serve as context for demonstrating how `getByLabelText` can locate the associated input elements.  No external dependencies required.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_14

LANGUAGE: html
CODE:
```
// for/htmlFor relationship between label and form element id
<label for="username-input">Username</label>
<input id="username-input" />

// The aria-labelledby attribute with form elements
<label id="username-label">Username</label>
<input aria-labelledby="username-label" />

// Wrapper labels
<label>Username <input /></label>

// Wrapper labels where the label text is in another child element
<label>
  <span>Username</span>
  <input />
</label>

// aria-label attributes
// Take care because this is not a label that users can see on the page,
// so the purpose of your input must be obvious to visual users.
<input aria-label="Username" />
```

----------------------------------------

TITLE: Configure Vitest Projects TypeScript
DESCRIPTION: Defines multiple test projects within the `vitest.config.ts` file. This allows running different sets of tests or the same tests with varying configurations (e.g., different environments like 'happy-dom' or 'node') within a single Vitest command.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/index.md#_snippet_10

LANGUAGE: TypeScript
CODE:
```
import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    projects: [
      // you can use a list of glob patterns to define your projects
      // Vitest expects a list of config files
      // or directories where there is a config file
      'packages/*',
      'tests/*/vitest.config.{e2e,unit}.ts',
      // you can even run the same tests,
      // but with different configs in the same "vitest" process
      {
        test: {
          name: 'happy-dom',
          root: './shared_tests',
          environment: 'happy-dom',
          setupFiles: ['./setup.happy-dom.ts'],
        },
      },
      {
        test: {
          name: 'node',
          root: './shared_tests',
          environment: 'node',
          setupFiles: ['./setup.node.ts'],
        },
      },
    ],
  },
})
```

----------------------------------------

TITLE: Asserting Function Throws Errors with Vitest (TypeScript)
DESCRIPTION: Illustrates using `assert.throws` (aliased as `throw`, `Throw`) in Vitest to check if a function throws an error. It can assert the error type (constructor or instance) and optionally match the error message against a string or RegExp. Requires the function (`fn`) to be tested and optional error/message matchers.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_79

LANGUAGE: typescript
CODE:
```
import { assert, test } from 'vitest'

test('assert.throws', () => {
  // Assume 'fn' and 'errorInstance' are defined elsewhere for these examples
  assert.throws(fn, 'Error thrown must have this msg')
  assert.throws(fn, /Error thrown must have a msg that matches this/)
  assert.throws(fn, ReferenceError)
  assert.throws(fn, errorInstance)
  assert.throws(fn, ReferenceError, 'Error thrown must be a ReferenceError and have this msg')
  assert.throws(fn, errorInstance, 'Error thrown must be the same errorInstance and have this msg')
  assert.throws(fn, ReferenceError, /Error thrown must be a ReferenceError and match this/)
  assert.throws(fn, errorInstance, /Error thrown must be the same errorInstance and match this/)
})
```

----------------------------------------

TITLE: Asserting Target is Empty with Vitest - TypeScript
DESCRIPTION: Tests whether the provided target is empty, handling arrays, strings, Maps, Sets, and plain objects as appropriate. Uses Vitest; takes the target and optional message. Passes if the collection or object contains no items, using the correct property (length, size, or own keys) for each.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_120

LANGUAGE: TypeScript
CODE:
```
import { assert, test } from 'vitest'

test('assert.isEmpty', () => {
  assert.isEmpty([])
  assert.isEmpty('')
  assert.isEmpty(new Map())
  assert.isEmpty({})
})
```

----------------------------------------

TITLE: Inheriting Root Vitest Configuration (TypeScript)
DESCRIPTION: Defines a root-level Vitest configuration in TypeScript, demonstrating how projects can inherit options using the 'extends' property. Projects with 'extends: true' inherit options like plugins and pool, while 'extends: false' prevents inheritance.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/projects.md#_snippet_9

LANGUAGE: typescript
CODE:
```
import { defineConfig } from 'vitest/config'
import react from '@vitejs/plugin-react'

export default defineConfig({
  plugins: [react()],
  test: {
    pool: 'threads',
    projects: [
      {
        // will inherit options from this config like plugins and pool
        extends: true,
        test: {
          name: 'unit',
          include: ['**/*.unit.test.ts'],
        },
      },
      {
        // won't inherit any options from this config
        // this is the default behaviour
        extends: false,
        test: {
          name: 'integration',
          include: ['**/*.integration.test.ts'],
        },
      },
    ],
  },
})
```

----------------------------------------

TITLE: Conditionally Skipping Test Execution
DESCRIPTION: Shows how to use the 'skip' function with a boolean condition to conditionally skip the current test based on a specific state or value.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/test-context.md#_snippet_4

LANGUAGE: TypeScript
CODE:
```
it('math is hard', ({ skip, mind }) => {
  skip(mind === 'foggy')
  expect(2 + 2).toBe(5)
})
```

----------------------------------------

TITLE: Skipping a Vitest describe Suite (TypeScript)
DESCRIPTION: Explains how to use `describe.skip` to prevent a specific test suite and all its contained tests from being executed during a test run.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/index.md#_snippet_37

LANGUAGE: TypeScript
CODE:
```
import { assert, describe, test } from 'vitest'

describe.skip('skipped suite', () => {
  test('sqrt', () => {
    // Suite skipped, no error
    assert.equal(Math.sqrt(4), 3)
  })
})
```

----------------------------------------

TITLE: Using assertType and @ts-expect-error - TypeScript
DESCRIPTION: Illustrates the use of the simpler `assertType` API for type checking. Shows a passing assertion and a failing one marked with `@ts-expect-error`. The second snippet highlights a potential pitfall with `@ts-expect-error` where a typo can mask a real error.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/testing-types.md#_snippet_3

LANGUAGE: ts
CODE:
```
const answer = 42

assertType<number>(answer)
// @ts-expect-error answer is not a string
assertType<string>(answer)
```

LANGUAGE: ts
CODE:
```
// @ts-expect-error answer is not a string
assertType<string>(answr)
```

----------------------------------------

TITLE: Checking for Undefined Values with toBeUndefined (Vitest, TypeScript)
DESCRIPTION: Describes and shows the `toBeUndefined` assertion in Vitest, which verifies that a value is strictly `undefined`. This is helpful for testing scenarios where a function is expected not to return an explicit value.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_12

LANGUAGE: typescript
CODE:
```
import { expect, test } from 'vitest'

function getApplesFromStock(stock: string) {
  if (stock === 'Bill') {
    return 13
  }
}

test('mary doesn't have a stock', () => {
  expect(getApplesFromStock('Mary')).toBeUndefined()
})
```

----------------------------------------

TITLE: Defining Vitest Projects with Specific Config File Glob
DESCRIPTION: Demonstrates using a glob pattern in `vitest.config.ts` to include only specific project configuration files (e.g., `vitest.config.e2e.ts`, `vitest.config.unit.ts`) located within subdirectories.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/projects.md#_snippet_1

LANGUAGE: ts
CODE:
```
import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    projects: ['packages/*/vitest.config.{e2e,unit}.ts'],
  },
})
```

----------------------------------------

TITLE: Running Vitest Tests for Multiple Projects
DESCRIPTION: Executes the 'test' script and uses the '--project' CLI option multiple times to filter and run tests within both the 'e2e' and 'unit' project directories.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/projects.md#_snippet_7

LANGUAGE: bash
CODE:
```
npm run test --project e2e --project unit
```

LANGUAGE: bash
CODE:
```
yarn run test --project e2e --project unit
```

LANGUAGE: bash
CODE:
```
pnpm run test --project e2e --project unit
```

LANGUAGE: bash
CODE:
```
bun run test --project e2e --project unit
```

----------------------------------------

TITLE: Asserting Less Than with toBeLessThan in Vitest (TypeScript)
DESCRIPTION: The `toBeLessThan` matcher asserts if the actual value is strictly less than the received value. Equality will cause the test to fail.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_23

LANGUAGE: TypeScript
CODE:
```
import { expect, test } from 'vitest'
import { getApples } from './stocks.js'

test('have less then 20 apples', () => {
  expect(getApples()).toBeLessThan(20)
})
```

----------------------------------------

TITLE: filter Method - Narrow Down Locator with Various Options
DESCRIPTION: Refines a locator based on provided filtering options such as has, hasNot, hasText, and hasNotText. Allows chaining to create highly specific element queries, including filtering by nested elements or text content.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_25

LANGUAGE: TypeScript
CODE:
```
function filter(options: LocatorOptions): Locator
```

----------------------------------------

TITLE: Constructor Return Value Pitfall (TypeScript)
DESCRIPTION: Illustrates a potential issue when mocking constructors: returning a non-primitive value from the `vi.fn` constructor function can prevent `instanceof` from working correctly. Shows a correct approach using `this` assignment and an incorrect approach returning an object literal.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/mocking.md#_snippet_19

LANGUAGE: ts
CODE:
```
const CorrectDogClass = vi.fn(function (name) {
  this.name = name
})

const IncorrectDogClass = vi.fn(name => ({
  name
}))

const Marti = new CorrectDogClass('Marti')
const Newt = new IncorrectDogClass('Newt')

Marti instanceof CorrectDogClass // ✅ true
Newt instanceof IncorrectDogClass // ❌ false!
```

----------------------------------------

TITLE: Coverage Include Patterns Configuration
DESCRIPTION: Specifies glob patterns for files to be included in coverage. Can be set via the CLI using `--coverage.include <pattern>` or in the configuration file using the `coverage.include` property. May be specified multiple times.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/cli-generated.md#_snippet_18



----------------------------------------

TITLE: toHaveLastResolvedWith - Vitest Assertion (TypeScript)
DESCRIPTION: You can call this assertion to check if a function has successfully resolved a certain value when it was last invoked. Requires a spy function to be passed to `expect`. If the function returned a promise, but it was not resolved yet, this will fail.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_58

LANGUAGE: ts
CODE:
```
import { expect, test, vi } from 'vitest'

test('spy function resolves bananas on a last call', async () => {
  const sell = vi.fn((product: string) => Promise.resolve({ product }))

  await sell('apples')
  await sell('bananas')

  expect(sell).toHaveLastResolvedWith({ product: 'bananas' })
})
```

----------------------------------------

TITLE: Assert Falsy Value with Vitest
DESCRIPTION: This snippet demonstrates `assert.isNotOk`, which asserts that a given value is falsy. It requires `vitest` for the testing framework. It takes a value as input, and expects it to be falsy to pass. It fails the test if the input is truthy. Also demonstrates the alias `notOk`.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_3

LANGUAGE: TypeScript
CODE:
```
import { assert, test } from 'vitest'

test('assert.isNotOk', () => {
  assert.isNotOk('foo', 'this will fail, every truthy is not ok')
  assert.isNotOk(false, 'this will pass since false is falsy')
})
```

----------------------------------------

TITLE: Augmenting Vitest TestContext Type in TypeScript
DESCRIPTION: This snippet demonstrates how to globally augment the `TestContext` interface provided by Vitest. By declaring a module augmentation for 'vitest', you can add custom properties like `foo` with optional string type, making them available and type-checked in all test contexts.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/test-context.md#_snippet_16

LANGUAGE: TypeScript
CODE:
```
declare module 'vitest' {
  export interface TestContext {
    foo?: string
  }
}
```

----------------------------------------

TITLE: Specifying Browser via CLI Flag
DESCRIPTION: Shows the command-line interface flag `--browser` used to specify which browser Vitest should use for running tests. The example demonstrates running tests specifically in Chrome.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/index.md#_snippet_9

LANGUAGE: sh
CODE:
```
npx vitest --browser=chrome
```

----------------------------------------

TITLE: Assert Value is Function with Vitest
DESCRIPTION: This snippet uses `assert.isFunction` (and its alias `isCallable`) to verify if a value is a function.  It requires the `vitest` framework.  The input is a value and the assertion passes if the value is a function.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_25

LANGUAGE: TypeScript
CODE:
```
import { assert, test } from 'vitest'

function name() { return 'foo' };

test('assert.isFunction', () => {
  assert.isFunction(name, 'name is function')
})
```

----------------------------------------

TITLE: Asserting Element Accessible Name in Vitest Tests (JavaScript)
DESCRIPTION: Verifies that a DOM element has a specific accessible name, which is the primary way assistive technologies identify interactive elements. Derived from various sources like `alt`, `title`, or content. Supports exact string match or regular expressions.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_14

LANGUAGE: TypeScript
CODE:
```
function toHaveAccessibleName(name?: string | RegExp): Promise<void>
```

LANGUAGE: HTML
CODE:
```
<img data-testid="img-alt" src="" alt="Test alt" />
<img data-testid="img-empty-alt" src="" alt="" />
<svg data-testid="svg-title"><title>Test title</title></svg>
<button data-testid="button-img-alt"><img src="" alt="Test" /></button>
<p><img data-testid="img-paragraph" src="" alt="" /> Test content</p>
<button data-testid="svg-button"><svg><title>Test</title></svg></p>
<div><svg data-testid="svg-without-title"></svg></div>
<input data-testid="input-title" title="test" />
```

LANGUAGE: JavaScript
CODE:
```
await expect.element(getByTestId('img-alt')).toHaveAccessibleName('Test alt')
await expect.element(getByTestId('img-empty-alt')).not.toHaveAccessibleName()
await expect.element(getByTestId('svg-title')).toHaveAccessibleName('Test title')
await expect.element(getByTestId('button-img-alt')).toHaveAccessibleName()
await expect.element(getByTestId('img-paragraph')).not.toHaveAccessibleName()
await expect.element(getByTestId('svg-button')).toHaveAccessibleName()
await expect.element(getByTestId('svg-without-title')).not.toHaveAccessibleName()
await expect.element(getByTestId('input-title')).toHaveAccessibleName()
```

----------------------------------------

TITLE: Setting One-Time Resolution with mockResolvedValueOnce
DESCRIPTION: This example shows how to use `mockResolvedValueOnce` to make a mock function resolve with a value only on its next call. Subsequent calls will resolve or reject according to other configurations. Chaining allows setting different return values for consecutive calls. TypeScript ensures that the provided value matches the return type of the original function.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/mock.md#_snippet_12

LANGUAGE: typescript
CODE:
```
const asyncMock = vi
  .fn()
  .mockResolvedValue('default')
  .mockResolvedValueOnce('first call')
  .mockResolvedValueOnce('second call')

await asyncMock() // first call
await asyncMock() // second call
await asyncMock() // default
await asyncMock() // default
```

----------------------------------------

TITLE: Using selectOptions for Select Elements in Vitest (TypeScript)
DESCRIPTION: Demonstrates selection of one or more options from a <select> element using a locator. Shows usage with single string, multiple strings, and option locators. Requires page instance and access to locator hierarchy; ensures options are valid within the select. Handles UserEventSelectOptions for extra behaviors and executes asynchronously.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_43

LANGUAGE: typescript
CODE:
```
import { page } from '@vitest/browser/context'

const languages = page.getByRole('select', { name: 'Languages' })

await languages.selectOptions('EN')
await languages.selectOptions(['ES', 'FR'])
await languages.selectOptions([
  languages.getByRole('option', { name: 'Spanish' }),
  languages.getByRole('option', { name: 'French' }),
])
```

----------------------------------------

TITLE: Type Testing and Assertions using expect-type and Vitest in TypeScript (.d.ts files)
DESCRIPTION: This TypeScript declaration file snippet shows how to test type correctness using Vitest's 'expectTypeOf', 'assertType', and 'test' APIs alongside user modules. It requires Vitest and the 'expect-type' package and should be placed in a '.test-d.ts' file for type checking in the editor and build processes. Inputs are types and expected types; outputs are compile-time errors or passes. It's useful for catching regressions in type definitions. Not all JavaScript environments support type assertion tests, which are primarily intended for TypeScript.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/features.md#_snippet_11

LANGUAGE: typescript
CODE:
```
import { assertType, expectTypeOf, test } from 'vitest'
import { mount } from './mount.js'

test('my types work properly', () => {
  expectTypeOf(mount).toBeFunction()
  expectTypeOf(mount).parameter(0).toMatchTypeOf<{ name: string }>()

  // @ts-expect-error name is a string
  assertType(mount({ name: 42 }))
})

```

----------------------------------------

TITLE: Using expect.stringMatching with Vitest
DESCRIPTION: This asymmetric matcher checks if a string value contains a specified substring or matches a regular expression when used in an equality check.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_72

LANGUAGE: TypeScript
CODE:
```
import { expect, test } from 'vitest'

test('variety ends with "re"', () => {
  const variety = {
    name: 'Empire',
    count: 1,
  }
  expect(variety).toEqual({
    name: expect.stringMatching(/re$/),
    count: 1,
  })
})
```

----------------------------------------

TITLE: Using expect.arrayContaining with Vitest
DESCRIPTION: This asymmetric matcher verifies if an array contains specific items when used in an equality check. It returns true if the value is an array and includes the specified elements.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_69

LANGUAGE: TypeScript
CODE:
```
import { expect, test } from 'vitest'

test('basket includes fuji', () => {
  const basket = {
    varieties: [
      'Empire',
      'Fuji',
      'Gala',
    ],
    count: 3
  }
  expect(basket).toEqual({
    count: 3,
    varieties: expect.arrayContaining(['Fuji'])
  })
})
```

----------------------------------------

TITLE: Running Vitest Typechecking Tests - Bash
DESCRIPTION: Provides examples of how to execute the Vitest test script with the `--typecheck` flag using common Node.js package managers: npm, yarn, pnpm, and bun.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/testing-types.md#_snippet_5

LANGUAGE: bash
CODE:
```
npm run test
```

LANGUAGE: bash
CODE:
```
yarn test
```

LANGUAGE: bash
CODE:
```
pnpm run test
```

LANGUAGE: bun
CODE:
```
bun test
```

----------------------------------------

TITLE: Mocking import.meta.env by direct assignment in Vitest
DESCRIPTION: Shows how to mock `import.meta.env` variables by directly assigning new values. This method requires manual resetting between tests, typically in a `beforeEach` hook.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/mocking.md#_snippet_37

LANGUAGE: ts
CODE:
```
import { beforeEach, expect, it } from 'vitest'

// you can reset it in beforeEach hook manually
const originalViteEnv = import.meta.env.VITE_ENV

beforeEach(() => {
  import.meta.env.VITE_ENV = originalViteEnv
})

it('changes value', () => {
  import.meta.env.VITE_ENV = 'staging'
  expect(import.meta.env.VITE_ENV).toBe('staging')
})
```

----------------------------------------

TITLE: Update Snapshots Option
DESCRIPTION: Updates snapshots during test runs. Can be enabled via the CLI using `-u, --update` or in the configuration file using the `update` property.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/cli-generated.md#_snippet_2



----------------------------------------

TITLE: Enabling Vitest Coverage via CLI (Shell)
DESCRIPTION: Shows how to enable and configure Vitest code coverage collection directly from the command line using dot notation for coverage options. It specifies enabling coverage, selecting the 'istanbul' provider, and collecting coverage for all files.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_35

LANGUAGE: sh
CODE:
```
npx vitest --coverage.enabled --coverage.provider=istanbul --coverage.all
```

----------------------------------------

TITLE: Defining Vitest Global Setup with Provide (TS, v3.0.0+)
DESCRIPTION: Provides an example of a global setup file for Vitest version 3.0.0 and above. The default exported function receives a 'TestProject' object, which is used to provide serializable data ('wsPort') to tests.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_31

LANGUAGE: ts
CODE:
```
import type { TestProject } from 'vitest/node'

export default function setup(project: TestProject) {
  project.provide('wsPort', 3000)
}

declare module 'vitest' {
  export interface ProvidedContext {
    wsPort: number
  }
}
```

----------------------------------------

TITLE: Testing Solid Components with Vitest Browser and Testing Library
DESCRIPTION: Shows how to test Solid components in Vitest Browser using `@testing-library/solid`. It demonstrates rendering a Solid component that uses Solid Router's `useParams` and asserting the presence of text content based on the route parameters. It also uses `page.elementLocator` for element interaction/assertion.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/index.md#_snippet_20

LANGUAGE: tsx
CODE:
```
// baed on @testing-library/solid API
// https://testing-library.com/docs/solid-testing-library/api

import { render } from '@testing-library/solid'

it('uses params', async () => {
  const App = () => (
    <>
      <Route
        path="/ids/:id"
        component={() => (
          <p>
            Id:
            {useParams()?.id}
          </p>
        )}
      />
      <Route path="/" component={() => <p>Start</p>} />
    </>
  )
  const { baseElement } = render(() => <App />, { location: 'ids/1234' })
  const screen = page.elementLocator(baseElement)

  await expect.screen(screen.getByText('Id: 1234')).toBeInTheDocument()
})
```

----------------------------------------

TITLE: Default coverage.exclude Array in JavaScript
DESCRIPTION: The default list of glob patterns used by Vitest to exclude files from code coverage reports. This list includes common directories like node_modules, test files, configuration files, and build outputs.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_36

LANGUAGE: javascript
CODE:
```
[
  'coverage/**',
  'dist/**',
  '**/node_modules/**',
  '**/[.]**',
  'packages/*/test?(s)/**',
  '**/*.d.ts',
  '**/virtual:*',
  '**/__x00__*',
  '**/�*',
  'cypress/**',
  'test?(s)/**',
  'test?(-*).?(c|m)[jt]s?(x)',
  '**/*{.,-}{test,spec,bench,benchmark}?(-d).?(c|m)[jt]s?(x)',
  '**/__tests__/**',
  '**/{karma,rollup,webpack,vite,vitest,jest,ava,babel,nyc,cypress,tsup,build,eslint,prettier}.config.*',
  '**/vitest.{workspace,projects}.[jt]s?(on)',
  '**/.{eslint,mocha,prettier}rc.{?(c|m)js,yml}',
]
```

----------------------------------------

TITLE: Skipping tests and suites with .skip in Vitest
DESCRIPTION: This snippet shows how to exclude specific suites or tests from execution using `.skip`, useful for temporarily disabling tests or suites without deleting code.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/filtering.md#_snippet_5

LANGUAGE: typescript
CODE:
```
import { assert, describe, it } from 'vitest'

describe.skip('skipped suite', () => {
  it('test', () => {
    // Suite skipped, no error
    assert.equal(Math.sqrt(4), 3)
  })
})

// Skip individual test

describe('suite', () => {
  it.skip('skipped test', () => {
    // Test skipped, no error
    assert.equal(Math.sqrt(4), 3)
  })
})
```

----------------------------------------

TITLE: toBeValid Assertion Example
DESCRIPTION: Shows how to use the toBeValid assertion to check if an element is currently valid based on aria-invalid attribute and form validation.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_8

LANGUAGE: html
CODE:
```
<input data-testid="no-aria-invalid" />
<input data-testid="aria-invalid" aria-invalid />
<input data-testid="aria-invalid-value" aria-invalid="true" />
<input data-testid="aria-invalid-false" aria-invalid="false" />

<form data-testid="valid-form">
  <input />
</form>

<form data-testid="invalid-form">
  <input required />
</form>
```

LANGUAGE: typescript
CODE:
```
await expect.element(getByTestId('no-aria-invalid')).toBeValid()
await expect.element(getByTestId('aria-invalid')).not.toBeValid()
await expect.element(getByTestId('aria-invalid-value')).not.toBeValid()
await expect.element(getByTestId('aria-invalid-false')).toBeValid()

await expect.element(getByTestId('valid-form')).toBeValid()
await expect.element(getByTestId('invalid-form')).not.toBeValid()
```

----------------------------------------

TITLE: Customizing Environment Variables Loading in Vitest Configuration (TypeScript)
DESCRIPTION: This TypeScript configuration snippet demonstrates how to use Vite's 'loadEnv' function inside a Vitest config to load all environment variables (not just those prefixed with 'VITE_') from .env files. Requires 'vite' and 'vitest/config' as dependencies. The code provides access to custom '.env.{mode}' files determined by the current test mode. The 'env' property under 'test' enables Vitest to utilize tailored environment setups during testing. Proper directory context should be ensured when executing.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/features.md#_snippet_13

LANGUAGE: typescript
CODE:
```
import { loadEnv } from 'vite'
import { defineConfig } from 'vitest/config'

export default defineConfig(({ mode }) => ({
  test: {
    // mode defines what ".env.{mode}" file to choose if exists
    env: loadEnv(mode, process.cwd(), ''),
  },
}))

```

----------------------------------------

TITLE: Conditionally Defining Web Workers with Options (JavaScript)
DESCRIPTION: Illustrates how to conditionally enable and configure Web Worker simulation using the `defineWebWorkers` function imported from '@vitest/web-worker/pure'. This example enables workers based on an environment variable and specifies the cloning behavior (`clone: 'none'`). Options include 'native' (requires Node 17+), 'ponyfill', or 'none'.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/packages/web-worker/README.md#_snippet_2

LANGUAGE: javascript
CODE:
```
import { defineWebWorkers } from '@vitest/web-worker/pure'

if (process.env.SUPPORT_WORKERS) {
  defineWebWorkers({ clone: 'none' })
}
```

----------------------------------------

TITLE: Restoring Original Descriptors with mockRestore
DESCRIPTION: This example showcases `mockRestore`, which resets call history, resets the implementation to its original state, and restores the original descriptors of spied-on objects. This effectively removes the spy. Mocks created with `vi.fn()` will have their implementation set to an empty function.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/mock.md#_snippet_10

LANGUAGE: typescript
CODE:
```
const person = {
  greet: (name: string) => `Hello ${name}`,
}
const spy = vi.spyOn(person, 'greet').mockImplementation(() => 'mocked')
expect(person.greet('Alice')).toBe('mocked')
expect(spy.mock.calls).toEqual([['Alice']])

// clear call history and restore spied object method
spy.mockRestore()
expect(spy.mock.calls).toEqual([])
expect(person.greet).not.toBe(spy)
expect(person.greet('Bob')).toBe('Hello Bob')
expect(spy.mock.calls).toEqual([])
```

----------------------------------------

TITLE: Using Local Expect in Vitest Concurrent Tests (TS)
DESCRIPTION: When running tests concurrently with `describe.concurrent`, it is crucial to use the `expect` object provided via the local test context (`async ({ expect }) => { ... }`). This ensures that snapshots and assertions are correctly associated with the specific concurrent test instance.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/index.md#_snippet_43

LANGUAGE: typescript
CODE:
```
describe.concurrent('suite', () => {
  test('concurrent test 1', async ({ expect }) => {
    expect(foo).toMatchSnapshot()
  })
  test('concurrent test 2', async ({ expect }) => {
    expect(foo).toMatchSnapshot()
  })
})
```

----------------------------------------

TITLE: Using AbortSignal Context for Resource Cleanup
DESCRIPTION: Illustrates how to use the 'signal' property (an AbortSignal) from the test context to abort asynchronous operations like network requests when the test is cancelled or times out.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/test-context.md#_snippet_5

LANGUAGE: TypeScript
CODE:
```
it('stop request when test times out', async ({ signal }) => {
  await fetch('/resource', { signal })
}, 2000)
```

----------------------------------------

TITLE: Using expect.poll for Polling Assertions in Vitest
DESCRIPTION: Demonstrates using `expect.poll` to repeatedly run an assertion until it succeeds or a timeout is reached. This is useful for testing asynchronous conditions, such as waiting for an element to appear in the DOM, and requires awaiting the result.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_6

LANGUAGE: TypeScript
CODE:
```
import { expect, test } from 'vitest'

test('element exists', async () => {
  asyncInjectElement()

  await expect.poll(() => document.querySelector('.element')).toBeTruthy()
})
```

----------------------------------------

TITLE: Using vi.hoisted with vi.mock for Referencing Variables in Vitest (TypeScript)
DESCRIPTION: Shows how to use `vi.hoisted` to create variables (like mock functions) that are available within the scope of a hoisted `vi.mock` factory. This allows defining mock behavior outside the factory and referencing it inside.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_3

LANGUAGE: ts
CODE:
```
import { namedExport } from './path/to/module.js'

const mocks = vi.hoisted(() => {
  return {
    namedExport: vi.fn(),
  }
})

vi.mock('./path/to/module.js', () => {
  return {
    namedExport: mocks.namedExport,
  }
})

vi.mocked(namedExport).mockReturnValue(100)

expect(namedExport()).toBe(100)
expect(namedExport).toBe(mocks.namedExport)
```

----------------------------------------

TITLE: Adding Vitest Coverage Script (JSON)
DESCRIPTION: Adds a script to the package.json file to run Vitest tests with coverage enabled from the command line using the `--coverage` flag.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/coverage.md#_snippet_2

LANGUAGE: json
CODE:
```
{
  "scripts": {
    "test": "vitest",
    "coverage": "vitest run --coverage"
  }
}
```

----------------------------------------

TITLE: Comparing Types with expectTypeOf (Concrete vs Typearg) - TypeScript
DESCRIPTION: Demonstrates using `expectTypeOf` to compare types. Shows that comparing against a concrete object (`{ a: '' }`) provides less helpful error messages than comparing against a type argument (`<{ a: string }>`) because the compiler infers the type in the former case.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/testing-types.md#_snippet_1

LANGUAGE: ts
CODE:
```
expectTypeOf({ a: 1 }).toEqualTypeOf({ a: '' })
```

LANGUAGE: ts
CODE:
```
expectTypeOf({ a: 1 }).toEqualTypeOf<{ a: string }>()
```

----------------------------------------

TITLE: Combining Reporters with Multiple Output Files
DESCRIPTION: This snippet shows how to direct the output of multiple reporters to distinct files.  It demonstrates configuring the `reporters` array to include 'junit', 'json', and 'verbose' reporters, and using the `outputFile` option with an object that maps reporter names to file paths. This allows for generating reports in different formats and saving them in separate files.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/reporters.md#_snippet_6

LANGUAGE: ts
CODE:
```
export default defineConfig({
  test: {
    reporters: ['junit', 'json', 'verbose'],
    outputFile: {
      junit: './junit-report.xml',
      json: './json-report.json',
    },
  },
})

```

----------------------------------------

TITLE: Using dropTo for Drag-and-Drop Operations in Vitest (TypeScript)
DESCRIPTION: Provides an example where two elements are selected using page.getByText, and one is dropped onto the other using dropTo. Requires @vitest/browser/context and properly chained locator calls. Demonstrates how to structure source and destination locators for UI drag-and-drop automation; resolves the action as a Promise.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_41

LANGUAGE: typescript
CODE:
```
import { page } from '@vitest/browser/context'

const paris = page.getByText('Paris')
const france = page.getByText('France')

await paris.dropTo(france)
```

----------------------------------------

TITLE: Configuring Global Web Worker Support in Vitest (TypeScript)
DESCRIPTION: Shows how to configure global Web Worker support in Vitest by adding '@vitest/web-worker' to the `setupFiles` array within the `vitest.config.ts` file using `defineConfig`. This ensures the worker simulation environment is available in all test suites.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/packages/web-worker/README.md#_snippet_1

LANGUAGE: typescript
CODE:
```
import { defineConfig } from 'vitest/node'

export default defineConfig({
  test: {
    setupFiles: ['@vitest/web-worker'],
  },
})
```

----------------------------------------

TITLE: Testing Element Double Click with userEvent or Locator
DESCRIPTION: Shows how to use `userEvent.dblClick` or the locator's direct `dblClick` method within a Vitest test to simulate double-clicking an element found using `page.getByRole`.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/interactivity-api.md#_snippet_7

LANGUAGE: ts
CODE:
```
import { page, userEvent } from '@vitest/browser/context'

test('triggers a double click on an element', async () => {
  const logo = page.getByRole('img', { name: /logo/ })

  await userEvent.dblClick(logo)
  // or you can access it directly on the locator
  await logo.dblClick()
})
```

----------------------------------------

TITLE: Setting File Environment with Control Comment | Vitest | TypeScript
DESCRIPTION: This snippet shows how to specify the test environment for a single file using the `@vitest-environment` control comment at the top of the file. This overrides the global environment setting for this specific test file.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/environment.md#_snippet_0

LANGUAGE: TypeScript
CODE:
```
// @vitest-environment jsdom

import { expect, test } from 'vitest'

test('test', () => {
  expect(typeof window).not.toBe('undefined')
})
```

----------------------------------------

TITLE: Augmenting Vitest ProvidedContext Type (TS)
DESCRIPTION: Shows how to augment the 'ProvidedContext' type in TypeScript to ensure type-safe access when using the 'inject' function with values defined via the 'provide' configuration option. This is necessary for correct type checking.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_29

LANGUAGE: ts
CODE:
```
declare module 'vitest' {
  export interface ProvidedContext {
    API_KEY: string
  }
}

// mark this file as a module so augmentation works correctly
export {}
```

----------------------------------------

TITLE: Making a Vite Node Script Executable (Shell)
DESCRIPTION: Uses the `chmod +x` command in a Unix-like shell to grant execute permissions to a script file (`./file.ts`), enabling it to be run directly when using a hashbang.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/packages/vite-node/README.md#_snippet_4

LANGUAGE: sh
CODE:
```
chmod +x ./file.ts
```

----------------------------------------

TITLE: CLI Commands for Debugging Vitest Without IDEs
DESCRIPTION: These bash commands launch Vitest with debugging enabled, forcing single-threaded or single-process execution to avoid parallelism. They use `--inspect-brk` to pause execution for debugging. Requires Vitest to be installed.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/debugging.md#_snippet_5

LANGUAGE: sh
CODE:
```
# To run in a single worker
vitest --inspect-brk --pool threads --poolOptions.threads.singleThread

# To run in a single child process
vitest --inspect-brk --pool forks --poolOptions.forks.singleFork

# To run in browser mode
vitest --inspect-brk --browser --no-file-parallelism
```

----------------------------------------

TITLE: Mocking import.meta.env using vi.stubEnv in Vitest
DESCRIPTION: Demonstrates how to mock `import.meta.env` variables using the `vi.stubEnv` helper. This method can automatically reset values between tests if the `unstubEnvs` config option is enabled.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/mocking.md#_snippet_38

LANGUAGE: ts
CODE:
```
import { expect, it, vi } from 'vitest'

// before running tests "VITE_ENV" is "test"
import.meta.env.VITE_ENV === 'test'

it('changes value', () => {
  vi.stubEnv('VITE_ENV', 'staging')
  expect(import.meta.env.VITE_ENV).toBe('staging')
})

it('the value is restored before running an other test', () => {
  expect(import.meta.env.VITE_ENV).toBe('test')
})
```

LANGUAGE: ts
CODE:
```
export default defineConfig({
  test: {
    unstubEnvs: true,
  },
})
```

----------------------------------------

TITLE: Using expect.element with Locators
DESCRIPTION: Demonstrates how to use expect.element with Playwright locators to create retry-able assertions in browser tests.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_1

LANGUAGE: typescript
CODE:
```
import { expect, test } from 'vitest'
import { page } from '@vitest/browser/context'

test('error banner is rendered', async () => {
  triggerError()

  // This creates a locator that will try to find the element
  // when any of its methods are called.
  // This call by itself doesn't check the existence of the element.
  const banner = page.getByRole('alert', {
    name: /error/i,
  })

  // Vitest provides `expect.element` with built-in retry-ability
  // It will repeatedly check that the element exists in the DOM and that
  // the content of `element.textContent` is equal to "Error!"
  // until all the conditions are met
  await expect.element(banner).toHaveTextContent('Error!')
})
```

----------------------------------------

TITLE: Checking Undefined Types with Vitest
DESCRIPTION: This snippet uses the `toBeUndefined()` matcher to assert if a type is undefined. It imports `expectTypeOf` from 'vitest'. The matcher checks if the provided type is undefined. It shows positive and negative tests.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect-typeof.md#_snippet_24

LANGUAGE: ts
CODE:
```
import { expectTypeOf } from 'vitest'

expectTypeOf(undefined).toBeUndefined()
expectTypeOf<undefined>().toBeUndefined()
expectTypeOf(null).not.toBeUndefined()
```

----------------------------------------

TITLE: Running Browser Tests during Development (Bash)
DESCRIPTION: This snippet provides Bash commands to navigate to the browser test directory within the project and execute specific test suites. It shows commands for running relevant tests (`pnpm test`) to verify functionality and running tests directly in browser mode (`pnpm test-fixtures`) for active development. It assumes `pnpm` is used as the package manager.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/packages/browser/README.md#_snippet_0

LANGUAGE: bash
CODE:
```
cd test/browser
# runs relevant tests for the browser mode
# useful to confirm everything works fine
pnpm test
# runs tests as the browser mode
# useful during development
pnpm test-fixtures
```

----------------------------------------

TITLE: VS Code Launch Configuration for Debugging
DESCRIPTION: This JSON configuration allows debugging the current test file in VS Code. It uses the 'node' debugger, specifies the Vitest entry point, and passes the 'run' command with the relative file path as arguments.  It skips internal node and node_modules files. Requires VS Code and Vitest to be installed.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/debugging.md#_snippet_0

LANGUAGE: json
CODE:
```
{
  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
  "version": "0.2.0",
  "configurations": [
    {
      "type": "node",
      "request": "launch",
      "name": "Debug Current Test File",
      "autoAttachChildProcesses": true,
      "skipFiles": ["<node_internals>/**", "**/node_modules/**"],
      "program": "${workspaceRoot}/node_modules/vitest/vitest.mjs",
      "args": ["run", "${relativeFile}"],
      "smartStep": true,
      "console": "integratedTerminal"
    }
  ]
}
```

----------------------------------------

TITLE: Matching Types with Vitest Matcher in TypeScript
DESCRIPTION: Applies `.toMatchTypeOf` to verify if a value's type extends or is compatible with another type. Depends on `vitest` and requires TypeScript type analysis. Accepts values or union types and checks for structural compatibility rather than strict equality, facilitating flexible type match assertions in tests.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect-typeof.md#_snippet_1

LANGUAGE: TypeScript
CODE:
```
import { expectTypeOf } from 'vitest'

expectTypeOf({ a: 1, b: 1 }).toMatchTypeOf({ a: 1 })
expectTypeOf<number>().toMatchTypeOf<string | number>()
expectTypeOf<string | number>().not.toMatchTypeOf<number>()
```

----------------------------------------

TITLE: Configuring Vitest Coverage Thresholds with Glob Patterns (TypeScript)
DESCRIPTION: This configuration snippet demonstrates how to set specific coverage thresholds for files matching glob patterns within the Vitest test configuration. It shows how to apply a 100% threshold to files like 'src/utils/**.ts' and '**/math.ts', alongside general thresholds for functions and branches.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_41

LANGUAGE: ts
CODE:
```
{
  coverage: {
    thresholds: {
      // Thresholds for all files
      functions: 95,
      branches: 70,

      // Thresholds for matching glob pattern
      'src/utils/**.ts': { 100: true },
      '**/math.ts': { 100: true }
    }
  }
}
```

----------------------------------------

TITLE: Providing Values in Global Setup (JavaScript)
DESCRIPTION: Shows how the `provide` function can be used within a global setup file (`globalSetup.js`) to make values available for injection across all tests, providing an alternative way to share dynamic data.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/test-project.md#_snippet_6

LANGUAGE: javascript
CODE:
```
export default function setup({ provide }) {
  provide('wsPort', 3000)
}
```

----------------------------------------

TITLE: Manually Install Vitest Browser Mode with Playwright
DESCRIPTION: Install `vitest`, `@vitest/browser`, and `playwright` to use Playwright as the E2E provider. This setup is recommended for running tests in CI environments and offers benefits like parallel execution and faster performance via Chrome DevTools Protocol.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/index.md#_snippet_2

LANGUAGE: npm
CODE:
```
npm install -D vitest @vitest/browser playwright
```

LANGUAGE: yarn
CODE:
```
yarn add -D vitest @vitest/browser playwright
```

LANGUAGE: pnpm
CODE:
```
pnpm add -D vitest @vitest/browser playwright
```

LANGUAGE: bun
CODE:
```
bun add -D vitest @vitest/browser playwright
```

----------------------------------------

TITLE: Using JSON Reporter - CLI
DESCRIPTION: This snippet shows how to use the 'json' reporter using the command-line.  It utilizes the `--reporter=json` option when running vitest. This will output the results in JSON format.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/reporters.md#_snippet_15

LANGUAGE: bash
CODE:
```
npx vitest --reporter=json
```

----------------------------------------

TITLE: Using assert.lengthOf in Vitest (TypeScript)
DESCRIPTION: Demonstrates `assert.lengthOf`, which asserts that an object (like an array, string, Set, or Map) has a specific `length` or `size`. The example imports from `vitest` and shows checks for arrays, strings, Sets, and Maps within a test, including optional messages.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_68

LANGUAGE: typescript
CODE:
```
import { assert, test } from 'vitest'

test('assert.lengthOf', () => {
  assert.lengthOf([1, 2, 3], 3, 'array has length of 3')
  assert.lengthOf('foobar', 6, 'string has length of 6')
  assert.lengthOf(new Set([1, 2, 3]), 3, 'set has size of 3')
  assert.lengthOf(new Map([['a', 1], ['b', 2], ['c', 3]]), 3, 'map has size of 3')
})
```

----------------------------------------

TITLE: Configuration Structure in Vitest Config File
DESCRIPTION: Demonstrates the proper structure of the configuration object in Vitest config file, showing that browser options should be nested within the test property.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/config.md#_snippet_1

LANGUAGE: typescript
CODE:
```
export default defineConfig({
  test: {
    browser: {},
  },
})
```

----------------------------------------

TITLE: Asserting Element Accessible Description in Vitest Tests (JavaScript)
DESCRIPTION: Verifies that a DOM element has a specific accessible description, derived from attributes like `title`, `aria-label`, `alt`, `aria-describedby`, or `aria-description`. Useful for accessibility testing to ensure elements are properly described for assistive technologies. Supports exact string match or regular expressions.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_12

LANGUAGE: TypeScript
CODE:
```
function toHaveAccessibleDescription(description?: string | RegExp): Promise<void>
```

LANGUAGE: HTML
CODE:
```
<a
  data-testid="link"
  href="/"
  aria-label="Home page"
  title="A link to start over"
  >Start</a
>
<a data-testid="extra-link" href="/about" aria-label="About page">About</a>
<img src="avatar.jpg" data-testid="avatar" alt="User profile pic" />
<img
  src="logo.jpg"
  data-testid="logo"
  alt="Company logo"
  aria-describedby="t1"
/>
<span id="t1" role="presentation">The logo of Our Company</span>
<img
  src="logo.jpg"
  data-testid="logo2"
  alt="Company logo"
  aria-description="The logo of Our Company"
/>
```

LANGUAGE: JavaScript
CODE:
```
await expect.element(getByTestId('link')).toHaveAccessibleDescription()
await expect.element(getByTestId('link')).toHaveAccessibleDescription('A link to start over')
await expect.element(getByTestId('link')).not.toHaveAccessibleDescription('Home page')
await expect.element(getByTestId('extra-link')).not.toHaveAccessibleDescription()
await expect.element(getByTestId('avatar')).not.toHaveAccessibleDescription()
await expect.element(getByTestId('logo')).not.toHaveAccessibleDescription('Company logo')
await expect.element(getByTestId('logo')).toHaveAccessibleDescription(
  'The logo of Our Company',
)
await expect.element(getByTestId('logo2')).toHaveAccessibleDescription(
  'The logo of Our Company',
)
```

----------------------------------------

TITLE: Conditionally Skipping a Vitest describe Suite (TypeScript)
DESCRIPTION: Shows how to use `describe.skipIf` to conditionally skip a test suite based on a boolean condition, useful for environment-specific tests.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/index.md#_snippet_38

LANGUAGE: TypeScript
CODE:
```
import { describe, test } from 'vitest'

const isDev = process.env.NODE_ENV === 'development'

describe.skipIf(isDev)('prod only test suite', () => {
  // this test suite only runs in production
})
```

----------------------------------------

TITLE: Inline Snapshot Usage
DESCRIPTION: Demonstrates the usage of inline snapshots via the `wrapper` function. The example calls `toMatchInlineSnapshot` to assert the received value against an inline snapshot. The code shows how to use both automatically inferred and explicitly provided inline snapshots. `pretty-format` is required and the naming is hard-coded when parsing test files.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/packages/snapshot/README.md#_snippet_6

LANGUAGE: javascript
CODE:
```
// uses "pretty-format", so it requires quotes
// also naming is hard-coded when parsing test files
wrapper('text 1').toMatchInlineSnapshot()
wrapper('text 2').toMatchInlineSnapshot('"text 2"')
```

----------------------------------------

TITLE: toBeRequired Assertion Example
DESCRIPTION: Demonstrates how to use the toBeRequired assertion to check if a form element is currently required.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_7

LANGUAGE: html
CODE:
```
<input data-testid="required-input" required />
<input data-testid="aria-required-input" aria-required="true" />
<input data-testid="conflicted-input" required aria-required="false" />
<input data-testid="aria-not-required-input" aria-required="false" />
<input data-testid="optional-input" />
<input data-testid="unsupported-type" type="image" required />
<select data-testid="select" required></select>
<textarea data-testid="textarea" required></textarea>
<div data-testid="supported-role" role="tree" required></div>
<div data-testid="supported-role-aria" role="tree" aria-required="true"></div>
```

LANGUAGE: typescript
CODE:
```
await expect.element(getByTestId('required-input')).toBeRequired()
await expect.element(getByTestId('aria-required-input')).toBeRequired()
await expect.element(getByTestId('conflicted-input')).toBeRequired()
await expect.element(getByTestId('aria-not-required-input')).not.toBeRequired()
await expect.element(getByTestId('optional-input')).not.toBeRequired()
await expect.element(getByTestId('unsupported-type')).not.toBeRequired()
await expect.element(getByTestId('select')).toBeRequired()
await expect.element(getByTestId('textarea')).toBeRequired()
await expect.element(getByTestId('supported-role')).not.toBeRequired()
await expect.element(getByTestId('supported-role-aria')).toBeRequired()
```

----------------------------------------

TITLE: Attempting to Mock Internal Function Call (TypeScript)
DESCRIPTION: Demonstrates using `vi.spyOn` and `vi.mock` in a Vitest test file to mock the `foo` function exported from `./foobar.js`. It highlights that these external mocks will not intercept calls to `foo` made by `foobar` within the original module.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/mocking.md#_snippet_6

LANGUAGE: ts
CODE:
```
import { vi } from 'vitest'
import * as mod from './foobar.js'

// this will only affect "foo" outside of the original module
vi.spyOn(mod, 'foo')
vi.mock('./foobar.js', async (importOriginal) => {
  return {
    ...await importOriginal<typeof import('./foobar.js')>(),
    // this will only affect "foo" outside of the original module
    foo: () => 'mocked'
  }
})
```

----------------------------------------

TITLE: Resetting Modules in Vitest Setup File
DESCRIPTION: This code demonstrates how to reset modules in a Vitest setup file to avoid conflicts when mocking modules with `vi.mock`.  `vi.resetModules()` clears the module cache, ensuring that subsequent `vi.mock` calls are effective. It prevents the "Cannot mock because it is already loaded" error. It's important to note that setup file and test files will reference different modules in this case.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/common-errors.md#_snippet_2

LANGUAGE: typescript
CODE:
```
import { vi } from 'vitest'
import { sideEffect } from './mocked-file.js'

sideEffect()

vi.resetModules()
```

----------------------------------------

TITLE: Stubbing Global Variables with Vitest vi.stubGlobal (TypeScript)
DESCRIPTION: This snippet illustrates how to use `vi.stubGlobal` in Vitest to change the value of a global variable, such as `innerWidth`. It shows how the stubbed value is accessible directly, via `globalThis`, and potentially via `window` in a browser-like environment.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_22

LANGUAGE: typescript
CODE:
```
import { vi } from 'vitest'

// `innerWidth` is "0" before calling stubGlobal

vi.stubGlobal('innerWidth', 100)

innerWidth === 100
globalThis.innerWidth === 100
// if you are using jsdom or happy-dom
window.innerWidth === 100
```

----------------------------------------

TITLE: Verifying At Least One Assertion with expect.hasAssertions in Vitest
DESCRIPTION: Use `expect.hasAssertions()` to verify that at least one assertion was called during a test. This prevents false positives in tests involving asynchronous callbacks where assertions might be skipped if the callback isn't executed.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_64

LANGUAGE: ts
CODE:
```
import { expect, test } from 'vitest'
import { db } from './db.js'

const cbs = []

function onSelect(cb) {
  cbs.push(cb)
}

// after selecting from db, we call all callbacks
function select(id) {
  return db.select({ id }).then((data) => {
    return Promise.all(
      cbs.map(cb => cb(data)),
    )
  })
}

test('callback was called', async () => {
  expect.hasAssertions()
  onSelect((data) => {
    // should be called on select
    expect(data).toBeTruthy()
  })
  // if not awaited, test will fail
  // if you don't have expect.hasAssertions(), test will pass
  await select(3)
})
```

----------------------------------------

TITLE: Extracting Guard Types from Predicates with Vitest in TypeScript
DESCRIPTION: Applies `.guards` matcher to extract the asserted type from type predicate functions (`v is Type`). Requires Vitest and a predicate function. Supports assertions for user-defined or built-in type guard functions.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect-typeof.md#_snippet_11

LANGUAGE: TypeScript
CODE:
```
import { expectTypeOf } from 'vitest'

function isString(v: any): v is string {
  return typeof v === 'string'
}
expectTypeOf(isString).guards.toBeString()
```

----------------------------------------

TITLE: Assert Value is NaN with Vitest
DESCRIPTION: This demonstrates `assert.isNaN`, which asserts that a given value is NaN. It requires the `vitest` framework. The input is a value, and the assertion passes if the value is NaN.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_19

LANGUAGE: TypeScript
CODE:
```
import { assert, test } from 'vitest'

const calculation = 1 * 'vitest'

test('assert.isNaN', () => {
  assert.isNaN(calculation, '1 * "vitest" is NaN')
})
```

----------------------------------------

TITLE: Using Test Context Expect with Concurrent Vitest Tests (TypeScript)
DESCRIPTION: Highlights the necessity of using the `expect` object provided via the local test context when performing Snapshots or Assertions within concurrent tests. This ensures that the correct test is associated with the assertion or snapshot.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/index.md#_snippet_16

LANGUAGE: TypeScript
CODE:
```
test.concurrent('test 1', async ({ expect }) => {
  expect(foo).toMatchSnapshot()
})
test.concurrent('test 2', async ({ expect }) => {
  expect(foo).toMatchSnapshot()
})
```

----------------------------------------

TITLE: toBeEmptyDOMElement Assertion Example
DESCRIPTION: Shows how to use the toBeEmptyDOMElement assertion to check if an element has no visible content for the user.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_4

LANGUAGE: html
CODE:
```
<span data-testid="not-empty"><span data-testid="empty"></span></span>
<span data-testid="with-whitespace"> </span>
<span data-testid="with-comment"><!-- comment --></span>
```

LANGUAGE: typescript
CODE:
```
await expect.element(getByTestId('empty')).toBeEmptyDOMElement()
await expect.element(getByTestId('not-empty')).not.toBeEmptyDOMElement()
await expect.element(
  getByTestId('with-whitespace')
).not.toBeEmptyDOMElement()
```

----------------------------------------

TITLE: Merging Shared Vitest Configuration (TypeScript)
DESCRIPTION: Defines a project-specific Vitest configuration in TypeScript by merging a shared configuration file ('../vitest.shared.js') with project-specific options, such as setting the test environment to 'jsdom'.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/projects.md#_snippet_8

LANGUAGE: typescript
CODE:
```
import { defineProject, mergeConfig } from 'vitest/config'
import configShared from '../vitest.shared.js'

export default mergeConfig(
  configShared,
  defineProject({
    test: {
      environment: 'jsdom',
    }
  })
)
```

----------------------------------------

TITLE: Configure Per-Action Timeout with Playwright and Vitest
DESCRIPTION: Demonstrates how to set a specific timeout for a single Playwright action using the `timeout` option within the action call, overriding the default actionTimeout setting.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/playwright.md#_snippet_4

LANGUAGE: TypeScript
CODE:
```
import { page, userEvent } from '@vitest/browser/context'

await userEvent.click(page.getByRole('button'), {
  timeout: 1_000,
})
```

----------------------------------------

TITLE: Returning 'this' Context with mockReturnThis
DESCRIPTION: This snippet showcases `mockReturnThis`, which sets the mock implementation to return the `this` context. This is a shorthand for `spy.mockImplementation(function () { return this })` and is useful for testing method chaining.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/mock.md#_snippet_13

LANGUAGE: typescript
CODE:
```
spy.mockImplementation(function () {
  return this
})
```

----------------------------------------

TITLE: Mocking Modules with __mocks__ in Vitest (TypeScript)
DESCRIPTION: Demonstrates how Vitest automatically uses files in __mocks__ folders when vi.mock is called without a factory. It shows importing and using mocked versions of both a dependency (axios) and a local module (increment) based on the __mocks__ directory structure.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_5

LANGUAGE: typescript
CODE:
```
import { vi } from 'vitest'

// axios is a default export from `__mocks__/axios.js`
import axios from 'axios'

// increment is a named export from `src/__mocks__/increment.js`
import { increment } from '../increment.js'

vi.mock('axios')
vi.mock('../increment.js')

axios.get(`/apples/${increment(1)}`)
```

----------------------------------------

TITLE: Inspecting Mock Return Values and Errors with mock.results (TypeScript/JavaScript)
DESCRIPTION: The `mock.results` property is an array containing objects that describe the outcome of each call to the mock function. Each result object has a `type` ('return' or 'throw') and a `value` (the returned value or the thrown error). For functions returning promises, the `type` is always 'return', regardless of promise resolution.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/mock.md#_snippet_18

LANGUAGE: typescript
CODE:
```
interface MockResultReturn<T> {
  type: 'return'
  /**
   * The value that was returned from the function.
   * If function returned a Promise, then this will be a resolved value.
   */
  value: T
}

interface MockResultIncomplete {
  type: 'incomplete'
  value: undefined
}

interface MockResultThrow {
  type: 'throw'
  /**
   * An error that was thrown during function execution.
   */
  value: any
}

type MockResult<T> =
  | MockResultReturn<T>
  | MockResultThrow
  | MockResultIncomplete

const results: MockResult<ReturnType<T>>[]
```

LANGUAGE: javascript
CODE:
```
const fn = vi.fn()
  .mockReturnValueOnce('result')
  .mockImplementationOnce(() => { throw new Error('thrown error') })

const result = fn() // returned 'result'

try {
  fn() // threw Error
}
catch {}

fn.mock.results === [
  // first result
  {
    type: 'return',
    value: 'result',
  },
  // last result
  {
    type: 'throw',
    value: Error,
  },
]
```

----------------------------------------

TITLE: Spying on Class Property (TypeScript)
DESCRIPTION: Demonstrates using `vi.spyOn` to spy on a class property (specifically a getter). This allows asserting on property access and mocking its return value.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/mocking.md#_snippet_25

LANGUAGE: ts
CODE:
```
const dog = new Dog('Cooper')

const nameSpy = vi.spyOn(dog, 'name', 'get').mockReturnValue('Max')

expect(dog.name).toBe('Max')
expect(nameSpy).toHaveBeenCalledTimes(1)
```

----------------------------------------

TITLE: CLI Command for Browser Debugging
DESCRIPTION: This bash command runs Vitest in browser mode with debugging enabled. It uses `--inspect-brk` to pause execution on the first line, `--browser` to enable browser mode, and `--no-file-parallelism` to disable parallel test execution. Requires Vitest to be installed.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/debugging.md#_snippet_2

LANGUAGE: bash
CODE:
```
vitest --inspect-brk --browser --no-file-parallelism
```

----------------------------------------

TITLE: Initialize Vitest Browser Mode (CLI)
DESCRIPTION: Use the `vitest init browser` command-line utility for an easier setup process. This command automatically installs the necessary dependencies and helps configure Vitest for browser mode.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/index.md#_snippet_0

LANGUAGE: npm
CODE:
```
npx vitest init browser
```

LANGUAGE: yarn
CODE:
```
yarn exec vitest init browser
```

LANGUAGE: pnpm
CODE:
```
pnpx vitest init browser
```

LANGUAGE: bun
CODE:
```
bunx vitest init browser
```

----------------------------------------

TITLE: Assigning Vitest Test Pools with poolMatchGlobs (TS)
DESCRIPTION: Shows how to use the `poolMatchGlobs` option to automatically assign different test pools (like 'threads' or 'browser') to test files based on glob patterns. The first matching glob determines the pool used for a test file.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_20

LANGUAGE: ts
CODE:
```
import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    poolMatchGlobs: [
      // all tests in "worker-specific" directory will run inside a worker as if you enabled `--pool=threads` for them,
      ['**/tests/worker-specific/**', 'threads'],
      // run all tests in "browser" directory in an actual browser
      ['**/tests/browser/**', 'browser']
      // all other tests will run based on "browser.enabled" and "threads" options, if you didn't specify other globs
      // ...
    ]
  }
})
```

----------------------------------------

TITLE: Spying on an object returned from a function using vi.mock cache in Vitest
DESCRIPTION: Illustrates how to mock a function that returns an object by using `vi.mock` with a factory function that caches and returns a spy object. This ensures subsequent calls to the mocked function return the same spy instance.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/mocking.md#_snippet_33

LANGUAGE: ts
CODE:
```
export function useObject() {
  return { method: () => true }
}
```

LANGUAGE: ts
CODE:
```
import { useObject } from './example.js'

const obj = useObject()
obj.method()
```

LANGUAGE: ts
CODE:
```
import { useObject } from './example.js'

vi.mock(import('./example.js'), () => {
  let _cache
  const useObject = () => {
    if (!_cache) {
      _cache = {
        method: vi.fn(),
      }
    }
    // now every time that useObject() is called it will
    // return the same object reference
    return _cache
  }
  return { useObject }
})

const obj = useObject()
// obj.method was called inside some-path
expect(obj.method).toHaveBeenCalled()
```

----------------------------------------

TITLE: Running Concurrent Tests with Vitest describe.concurrent (TS)
DESCRIPTION: Use `describe.concurrent` (or its alias `suite.concurrent`) to execute all nested test suites and individual tests within it in parallel. This can significantly speed up test execution for independent tests.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/index.md#_snippet_41

LANGUAGE: typescript
CODE:
```
import { describe, test } from 'vitest'

// All suites and tests within this suite will be run in parallel
describe.concurrent('suite', () => {
  test('concurrent test 1', async () => { /* ... */ })
  describe('concurrent suite 2', async () => {
    test('concurrent test inner 1', async () => { /* ... */ })
    test('concurrent test inner 2', async () => { /* ... */ })
  })
  test.concurrent('concurrent test 3', async () => { /* ... */ })
})
```

----------------------------------------

TITLE: Asserting Element Accessible Error Message in Vitest Tests (JavaScript)
DESCRIPTION: Verifies that a DOM element has a specific accessible error message, typically linked via `aria-errormessage` and used in conjunction with `aria-invalid`. Important for testing the accessibility of form validation feedback. Supports exact string match or regular expressions.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_13

LANGUAGE: TypeScript
CODE:
```
function toHaveAccessibleErrorMessage(message?: string | RegExp): Promise<void>
```

LANGUAGE: HTML
CODE:
```
<input
  aria-label="Has Error"
  aria-invalid="true"
  aria-errormessage="error-message"
/>
<div id="error-message" role="alert">This field is invalid</div>

<input aria-label="No Error Attributes" />
<input
  aria-label="Not Invalid"
  aria-invalid="false"
  aria-errormessage="error-message"
/>
```

LANGUAGE: JavaScript
CODE:
```
// Inputs with Valid Error Messages
await expect.element(getByRole('textbox', { name: 'Has Error' })).toHaveAccessibleErrorMessage()
await expect.element(getByRole('textbox', { name: 'Has Error' })).toHaveAccessibleErrorMessage(
  'This field is invalid',
)
await expect.element(getByRole('textbox', { name: 'Has Error' })).toHaveAccessibleErrorMessage(
  /invalid/i,
)
await expect.element(
  getByRole('textbox', { name: 'Has Error' }),
).not.toHaveAccessibleErrorMessage('This field is absolutely correct!')

// Inputs without Valid Error Messages
await expect.element(
  getByRole('textbox', { name: 'No Error Attributes' }),
).not.toHaveAccessibleErrorMessage()

await expect.element(
  getByRole('textbox', { name: 'Not Invalid' }),
).not.toHaveAccessibleErrorMessage()
```

----------------------------------------

TITLE: dblClick Method - Simulate Double Click on Element
DESCRIPTION: Triggers a double click event on the element, suitable for testing double-click interactions. Options allow setting cursor position and click timing.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_31

LANGUAGE: TypeScript
CODE:
```
function dblClick(options?: UserEventDoubleClickOptions): Promise<void>
```

----------------------------------------

TITLE: Setting a timeout for hooks in Vitest
DESCRIPTION: This snippet shows how hooks like `beforeAll` can also receive a timeout parameter, allowing control over setup durations within the test lifecycle.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/filtering.md#_snippet_4

LANGUAGE: typescript
CODE:
```
import { beforeAll } from 'vitest'

beforeAll(async () => { /* ... */ }, 1000)
```

----------------------------------------

TITLE: Configure Vitest Concurrent Test Execution (sequence.concurrent)
DESCRIPTION: Enables running tests in parallel. By default, tests are not run concurrently.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/cli-generated.md#_snippet_29

LANGUAGE: CLI
CODE:
```
--sequence.concurrent
```

LANGUAGE: Config
CODE:
```
sequence.concurrent
```

----------------------------------------

TITLE: Showing query Behavior with Sample DOM and Locators (TypeScript and HTML)
DESCRIPTION: Demonstrates the behavior of .query() with different locators on a sample DOM structure. Shows both successful and error-throwing calls. Requires page object and the correct HTML structure matching test selectors. Input consists of DOM nodes, output is Element or null; ambiguous selectors throw exceptions.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_47

LANGUAGE: html
CODE:
```
<div>Hello <span>World</span></div>
<div>Hello</div>
```

LANGUAGE: typescript
CODE:
```
page.getByText('Hello World').query() // ✅ HTMLDivElement
page.getByText('Hello Germany').query() // ✅ null
page.getByText('World').query() // ✅ HTMLSpanElement
page.getByText('Hello', { exact: true }).query() // ✅ HTMLSpanElement
```

LANGUAGE: typescript
CODE:
```
// returns multiple elements
page.getByText('Hello').query() // ❌
page.getByText(/^Hello/).query() // ❌
```

----------------------------------------

TITLE: Using expect.soft for Soft Assertions in Vitest
DESCRIPTION: Illustrates the use of `expect.soft` within a Vitest test. Unlike standard `expect`, `expect.soft` marks a test as failed upon assertion failure but allows the test execution to continue, reporting all soft errors at the end of the test run.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_3

LANGUAGE: TypeScript
CODE:
```
import { expect, test } from 'vitest'

test('expect.soft test', () => {
  expect.soft(1 + 1).toBe(3) // mark the test as fail and continue
  expect.soft(1 + 2).toBe(4) // mark the test as fail and continue
})
// reporter will report both errors at the end of the run
```

----------------------------------------

TITLE: Module with Internal Function Call (JavaScript)
DESCRIPTION: Defines two exported functions, `foo` and `foobar`, within the same JavaScript module. The `foobar` function calls `foo` internally, setting up an example to demonstrate limitations when attempting to mock `foo` from outside the module.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/mocking.md#_snippet_5

LANGUAGE: js
CODE:
```
export function foo() {
  return 'foo'
}

export function foobar() {
  return `${foo()}bar`
}
```

----------------------------------------

TITLE: Hovering Element with userEvent in Vitest (TypeScript)
DESCRIPTION: Illustrates how to use `userEvent.hover` to move the mouse cursor over a specified element in a Vitest browser test. The example shows selecting an element using `page.getByRole` and then hovering over it using `userEvent.hover` or the direct locator method. The exact cursor position after hovering depends on the provider (`webdriverio` defaults to center, `playwright` to a visible point).
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/interactivity-api.md#_snippet_18

LANGUAGE: TypeScript
CODE:
```
import { page, userEvent } from '@vitest/browser/context'

test('hovers logo element', async () => {
  const logo = page.getByRole('img', { name: /logo/ })

  await userEvent.hover(logo)
  // or you can access it directly on the locator
  await logo.hover()
})
```

----------------------------------------

TITLE: Asserting an Object is an Instance of a Constructor using Vitest (TypeScript)
DESCRIPTION: Shows how to use `assert.instanceOf` in Vitest tests to verify if an object is an instance of a specific constructor function or class. Uses `assert` and `test`.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_40

LANGUAGE: typescript
CODE:
```
import { assert, test } from 'vitest'

function Person(name) { this.name = name }
const foo = new Person('foo')

class Tea {
  constructor(name) {
    this.name = name
  }
}
const coffee = new Tea('coffee')

test('assert.instanceOf', () => {
  assert.instanceOf(foo, Person, 'foo is an instance of Person')
  assert.instanceOf(coffee, Tea, 'coffee is an instance of Tea')
})
```

----------------------------------------

TITLE: Coverage All Files Option
DESCRIPTION: Determines whether to include all files, including untested ones, in the coverage report. Can be enabled via the CLI using `--coverage.all` or in the configuration file using the `coverage.all` property.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/cli-generated.md#_snippet_15



----------------------------------------

TITLE: Configure tsconfig for JSDOM Types (JSON)
DESCRIPTION: Shows how to update the `tsconfig.json` file to include the `vitest/jsdom` type definition. This allows TypeScript to recognize the `jsdom` global variable available when using the 'jsdom' environment.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_16

LANGUAGE: json
CODE:
```
{
  "compilerOptions": {
    "types": ["vitest/jsdom"]
  }
}
```

----------------------------------------

TITLE: Initializing Vitest Project Configuration for Browser - Bash
DESCRIPTION: Showcases how to use the Vitest CLI to initialize project configuration targeted for browser environments. The <name> argument should be 'browser' as currently supported. Input: browser as a value. Output: Sets up necessary config files in the project. Limitation: At present, only the browser mode is available.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/cli.md#_snippet_5

LANGUAGE: bash
CODE:
```
vitest init browser

```

----------------------------------------

TITLE: Adding TypeScript Type References for Browser Mode
DESCRIPTION: Explains how to add type references in a test or setup file using `/// <reference types="..." />` directives to enable TypeScript support for Vitest browser matchers and provider-specific options. This is necessary for correct type checking when using browser mode.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/index.md#_snippet_7

LANGUAGE: ts
CODE:
```
/// <reference types="@vitest/browser/matchers" />
```

LANGUAGE: ts
CODE:
```
/// <reference types="@vitest/browser/providers/playwright" />
```

LANGUAGE: ts
CODE:
```
/// <reference types="@vitest/browser/providers/webdriverio" />
```

----------------------------------------

TITLE: Handling Multiple Line Selections with Vitest CLI - Bash
DESCRIPTION: Illustrates the attempt to run tests across multiple specified line numbers or ranges within a file using Vitest. Currently supported: running tests at distinct line numbers separated by commas. Not supported: specifying a range using dash notation. Input: line numbers (comma-separated or range) with filename. Output: Only tests at specifically listed lines are executed; ranges are ignored. Limitation: range syntax (e.g., 10-25) is not supported.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/cli.md#_snippet_2

LANGUAGE: bash
CODE:
```
$ vitest basic/foo.test.ts:10, basic/foo.test.ts:25 # ✅
$ vitest basic/foo.test.ts:10-25 # ❌

```

----------------------------------------

TITLE: Using assert.notProperty in Vitest (TypeScript)
DESCRIPTION: Illustrates `assert.notProperty`, used to assert that an object does not have a specific property, either directly or inherited. The snippet imports from `vitest` and checks for the absence of the 'coffee' property within a test function.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_57

LANGUAGE: typescript
CODE:
```
import { assert, test } from 'vitest'

test('assert.notProperty', () => {
  assert.notProperty({ tea: { green: 'matcha' } }, 'coffee')
})
```

----------------------------------------

TITLE: Migrate environmentMatchGlobs to Projects (TS)
DESCRIPTION: Illustrates the deprecated `environmentMatchGlobs` configuration and provides the recommended alternative using the `projects` option in `vitest/config`. This demonstrates how to achieve environment assignment based on globs using the current API.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_17

LANGUAGE: ts
CODE:
```
export default defineConfig({
  test: {
    environmentMatchGlobs: [ 
      ['./*.jsdom.test.ts', 'jsdom'], 
    ], 
    projects: [ 
      { 
        extends: true, 
        test: {
          environment: 'jsdom'
        }
      }
    ]
  }
})
```

----------------------------------------

TITLE: Restoring Environment Variables with Vitest vi.unstubAllEnvs (TypeScript)
DESCRIPTION: This snippet demonstrates how to use `vi.unstubAllEnvs` in Vitest to restore environment variables (`process.env` and `import.meta.env`) to their original values after they have been modified using `vi.stubEnv`. It shows stubbing the `NODE_ENV` multiple times and then restoring it to the initial state.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_21

LANGUAGE: typescript
CODE:
```
import { vi } from 'vitest'

// `process.env.NODE_ENV` and `import.meta.env.NODE_ENV`
// are "development" before calling stubEnv

vi.stubEnv('NODE_ENV', 'production')

process.env.NODE_ENV === 'production'
import.meta.env.NODE_ENV === 'production'

vi.stubEnv('NODE_ENV', 'staging')

process.env.NODE_ENV === 'staging'
import.meta.env.NODE_ENV === 'staging'

vi.unstubAllEnvs()

// restores to the value that were stored before the first "stubEnv" call
process.env.NODE_ENV === 'development'
import.meta.env.NODE_ENV === 'development'
```

----------------------------------------

TITLE: Configuring Serial and Parallel Hooks in Vitest (TypeScript)
DESCRIPTION: Shows how to switch hook execution order (from serial to parallel) in Vitest 2.0+ by setting 'test.sequence.hooks' to 'parallel' within the config object. Appropriate for configuring afterAll/afterEach hook behavior. Dependencies: defineConfig. Input: none. Output: sequential or parallel test hook execution.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/migration.md#_snippet_8

LANGUAGE: TypeScript
CODE:
```
export default defineConfig({
  test: {
    sequence: {
      hooks: 'parallel',
    },
  },
})
```

----------------------------------------

TITLE: Restoring Global Variables with Vitest vi.unstubAllGlobals (TypeScript)
DESCRIPTION: This snippet demonstrates using `vi.unstubAllGlobals` in Vitest to restore global variables to their original state after being modified by `vi.stubGlobal`. It shows stubbing `IntersectionObserver` with a mock function and then restoring it to its initial `undefined` state.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_24

LANGUAGE: typescript
CODE:
```
import { vi } from 'vitest'

const Mock = vi.fn()

// IntersectionObserver is "undefined" before calling "stubGlobal"

vi.stubGlobal('IntersectionObserver', Mock)

IntersectionObserver === Mock
global.IntersectionObserver === Mock
globalThis.IntersectionObserver === Mock
// if you are using jsdom or happy-dom
window.IntersectionObserver === Mock

vi.unstubAllGlobals()

globalThis.IntersectionObserver === undefined
'IntersectionObserver' in globalThis === false
// throws ReferenceError, because it's not defined
IntersectionObserver === undefined
```

----------------------------------------

TITLE: Assert Value is Below with Vitest
DESCRIPTION: This code demonstrates `assert.isBelow` used for asserting that a value is strictly less than another value. It uses the `vitest` testing framework. The input is two numbers, where the assertion passes if the first number is strictly less than the second.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_11

LANGUAGE: TypeScript
CODE:
```
import { assert, test } from 'vitest'

test('assert.isBelow', () => {
  assert.isBelow(3, 6, '3 is strictly less than 6')
})
```

----------------------------------------

TITLE: Using hover via Locator API in Vitest (TypeScript)
DESCRIPTION: Demonstrates applying the hover method to an element found using page.getByRole in Vitest's browser context, simulating mouse entry events. Depends on @vitest/browser/context for page object and locator utilities. Accepts role arguments for finding the element, and supports async execution; completes when hover is done. Useful for testing UI states or trigger hover-specific behaviors.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_35

LANGUAGE: typescript
CODE:
```
import { page } from '@vitest/browser/context'

await page.getByRole('img', { name: 'Rose' }).hover()
```

----------------------------------------

TITLE: filter.has - Find Elements Containing Specific Child Elements
DESCRIPTION: Filters parent elements to include only those that contain child elements matching a provided locator, useful for narrowing down elements based on nested structure or content.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_26

LANGUAGE: TypeScript
CODE:
```
has: Locator
```

----------------------------------------

TITLE: Using toHaveDisplayValue Assertion with Form Elements - TypeScript
DESCRIPTION: Demonstrates usage of `toHaveDisplayValue` in test code. Elements are queried by labels and assertions are made to check their displayed values using strings, regex, or arrays of strings/regex in the case of multiple selections. It confirms that the UI elements display expected user-facing values.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_30

LANGUAGE: ts
CODE:
```
const input = page.getByLabelText('First name')
const textarea = page.getByLabelText('Description')
const selectSingle = page.getByLabelText('Fruit')
const selectMultiple = page.getByLabelText('Fruits')

await expect.element(input).toHaveDisplayValue('Luca')
await expect.element(input).toHaveDisplayValue(/Luc/)
await expect.element(textarea).toHaveDisplayValue('An example description here.')
await expect.element(textarea).toHaveDisplayValue(/example/)
await expect.element(selectSingle).toHaveDisplayValue('Select a fruit...')
await expect.element(selectSingle).toHaveDisplayValue(/Select/)
await expect.element(selectMultiple).toHaveDisplayValue([/Avocado/, 'Banana'])
```

----------------------------------------

TITLE: Using element with expect for Assertions in Vitest (TypeScript)
DESCRIPTION: Shows how to use locator.element() in combination with expect assertions to check element states. element() is automatically called by expect.element when used in retried assertions, simplifying test syntax. Requires @vitest/browser/context and assertion extensions.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_50

LANGUAGE: typescript
CODE:
```
await expect.element(page.getByRole('button')).toBeDisabled()
```

----------------------------------------

TITLE: Providing TypeScript Types for Vitest Fixtures
DESCRIPTION: Explains how to define and apply TypeScript types for custom fixtures by passing a type interface as a generic argument to `test.extend`.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/test-context.md#_snippet_14

LANGUAGE: ts
CODE:
```
interface MyFixtures {
  todos: number[]
  archive: number[]
}

const test = baseTest.extend<MyFixtures>({
  todos: [],
  archive: []
})

test('types are defined correctly', ({ todos, archive }) => {
  expectTypeOf(todos).toEqualTypeOf<number[]>()
  expectTypeOf(archive).toEqualTypeOf<number[]>()
})
```

LANGUAGE: ts
CODE:
```
import { test as baseTest } from 'vitest'

const test = baseTest.extend<{
  todos: number[]
  schema: string
}>({
  todos: ({ schema }, use) => use([]),
  schema: 'test'
})

test('types are correct', ({
  todos, // number[]
  schema, // string
}) => {
  // ...
})
```

----------------------------------------

TITLE: Updating Test PoolOptions for Default Forks in Vitest (TypeScript)
DESCRIPTION: Demonstrates how to migrate test runner 'poolOptions' from threads to forks as the default pool setting changes in Vitest 2.0. Requires defineConfig from Vitest. Key parameters: poolOptions. Outcome: more stable test environment.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/migration.md#_snippet_7

LANGUAGE: TypeScript
CODE:
```
export default defineConfig({
  test: {
    poolOptions: {
      threads: {
        singleThread: true,
      },
      forks: {
        singleFork: true,
      },
    }
  }
})
```

----------------------------------------

TITLE: toSatisfy - Vitest Assertion (TypeScript)
DESCRIPTION: This assertion checks if a value satisfies a certain predicate.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_60

LANGUAGE: ts
CODE:
```
import { describe, expect, it } from 'vitest'

const isOdd = (value: number) => value % 2 !== 0

describe('toSatisfy()', () => {
  it('pass with 0', () => {
    expect(1).toSatisfy(isOdd)
  })

  it('pass with negation', () => {
    expect(2).not.toSatisfy(isOdd)
  })
})
```

----------------------------------------

TITLE: Using assert.match in Vitest (TypeScript)
DESCRIPTION: Shows how to use `assert.match` to assert that a string value matches a given regular expression. The example imports `assert` and `test` from `vitest` and checks if 'foobar' starts with 'foo' using a regex within a test case, providing an optional message.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_54

LANGUAGE: typescript
CODE:
```
import { assert, test } from 'vitest'

test('assert.match', () => {
  assert.match('foobar', /^foo/, 'regexp matches')
})
```

----------------------------------------

TITLE: Combining Reporters
DESCRIPTION: This snippet demonstrates using multiple reporters simultaneously. It shows how to include multiple reporters in the `reporters` array within the `test` configuration.  This will output the test results in different formats.  In the example, it configures both JSON and the default reporter.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/reporters.md#_snippet_5

LANGUAGE: ts
CODE:
```
export default defineConfig({
  test: {
    reporters: ['json', 'default'],
    outputFile: './test-output.json'
  },
})

```

----------------------------------------

TITLE: Performing Asynchronous Operations Inside vi.hoisted (Vitest, TypeScript)
DESCRIPTION: Shows that the factory function provided to `vi.hoisted` can be asynchronous, allowing for operations like fetching data before the test file's imports are fully evaluated, even in environments without top-level await.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_41

LANGUAGE: TypeScript
CODE:
```
const json = await vi.hoisted(async () => {
  const response = await fetch('https://jsonplaceholder.typicode.com/posts')
  return response.json()
})
```

----------------------------------------

TITLE: Configuring Vitest Coverage Reporters (TypeScript)
DESCRIPTION: Sets the output reporters for the coverage report. The default is `['text', 'html', 'clover', 'json']`. This example changes it to `['text', 'json', 'html']`.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/coverage.md#_snippet_3

LANGUAGE: typescript
CODE:
```
import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    coverage: {
      reporter: ['text', 'json', 'html'],
    },
  },
})
```

----------------------------------------

TITLE: Eliminating In-Source Test Code in Production Builds (TypeScript)
DESCRIPTION: Shows how to configure Vitest and the underlying bundler using `define` options so the code in `if (import.meta.vitest)` blocks is removed in production. By setting `'import.meta.vitest': 'undefined'`, it allows dead code elimination to occur. This prevents in-source tests from being included in production bundles. Applies to Vite and other build tools supporting similar defines.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/in-source.md#_snippet_3

LANGUAGE: TypeScript
CODE:
```
import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    includeSource: ['src/**/*.{js,ts}']
  },
  define: { // [!code ++]
    'import.meta.vitest': 'undefined' // [!code ++]
  } // [!code ++]
})
```

----------------------------------------

TITLE: Asserting No Property Change with Vitest - TypeScript
DESCRIPTION: This snippet verifies that a modifier function does not change a specified property of an object when executed. It requires the Vitest library, and the key parameters are the modifier function, object, property name, and an optional message. The input is an object and a modifier, and it asserts that the object's property remains unchanged after applying the modifier. Use when ensuring immutability or expected non-mutation.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_102

LANGUAGE: TypeScript
CODE:
```
import { assert, test } from 'vitest'

test('assert.doesNotChange', () => {
  const obj = { val: 10 }
  function fn() { obj.val += 2 };
  assert.doesNotChange(fn, obj, 'val', 2)
})
```

----------------------------------------

TITLE: Snapshot Configuration for printBasicPrototype (TypeScript)
DESCRIPTION: This code demonstrates how to configure the `printBasicPrototype` option in `vitest.config.ts` to change the default snapshot formatting to match Jest's behavior. Dependencies: vitest. Input: none. Output: Configuration of snapshot format.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/snapshot.md#_snippet_10

LANGUAGE: typescript
CODE:
```
import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    snapshotFormat: {
      printBasicPrototype: true,
    },
  },
})
```

----------------------------------------

TITLE: Stubbing Environment Variables Vitest TypeScript
DESCRIPTION: Demonstrates how to use `vi.stubEnv` to temporarily change the values of environment variables on `process.env` and `import.meta.env`. It also mentions `vi.unstubAllEnvs` for restoring original values.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_20

LANGUAGE: typescript
CODE:
```
import { vi } from 'vitest'

// `process.env.NODE_ENV` and `import.meta.env.NODE_ENV`
// are "development" before calling "vi.stubEnv"

vi.stubEnv('NODE_ENV', 'production')

process.env.NODE_ENV === 'production'
import.meta.env.NODE_ENV === 'production'

vi.stubEnv('NODE_ENV', undefined)

process.env.NODE_ENV === undefined
import.meta.env.NODE_ENV === undefined

// doesn't change other envs
import.meta.env.MODE === 'development'
```

----------------------------------------

TITLE: Using toMatchInlineSnapshot() in Vitest (TypeScript)
DESCRIPTION: This code snippet shows how to use `toMatchInlineSnapshot()` to store the snapshot directly within the test file. Vitest will automatically update the test file with the snapshot. Dependencies: vitest. Input: none. Output: A snapshot string within the test file.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/snapshot.md#_snippet_2

LANGUAGE: typescript
CODE:
```
import { expect, it } from 'vitest'

it('toUpperCase', () => {
  const result = toUpperCase('foobar')
  expect(result).toMatchInlineSnapshot()
})
```

----------------------------------------

TITLE: Using JUnit Reporter - Configuration
DESCRIPTION: This snippet demonstrates configuring the `junit` reporter within the `vitest.config.ts` file.  It sets the `reporters` array to `['junit']`. The JUnit reporter outputs test results in JUnit XML format.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/reporters.md#_snippet_13

LANGUAGE: ts
CODE:
```
export default defineConfig({
  test: {
    reporters: ['junit']
  },
})

```

----------------------------------------

TITLE: Declaring all Function in Vitest (TypeScript)
DESCRIPTION: Defines the all() function, which retrieves all matching locators as an array. Internally calls .elements and wraps each DOM element with page.elementLocator for chainable automated tests. Never throws errors, returns an array of Locator objects.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_53

LANGUAGE: typescript
CODE:
```
function all(): Locator[]
```

----------------------------------------

TITLE: Restoring Spied Methods Vitest TypeScript
DESCRIPTION: Shows the effect of calling `vi.restoreAllMocks` after spying on an object method. It demonstrates that restoring mocks brings back the original implementation and object descriptor, preventing further changes to the mock implementation.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_18

LANGUAGE: typescript
CODE:
```
const cart = {
  getApples: () => 42,
}

const spy = vi.spyOn(cart, 'getApples').mockReturnValue(10)

console.log(cart.getApples()) // 10
vi.restoreAllMocks()
console.log(cart.getApples()) // 42
spy.mockReturnValue(10)
console.log(cart.getApples()) // still 42!
```

----------------------------------------

TITLE: Using assert.hasAnyKeys in Vitest (TypeScript)
DESCRIPTION: Illustrates `assert.hasAnyKeys`, used to assert that an object, Map, or Set contains at least one of the specified keys. Keys can be provided as an array or as the keys of a given object. The example imports from `vitest` and shows checks for objects, Maps, and Sets within a test.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_69

LANGUAGE: typescript
CODE:
```
import { assert, test } from 'vitest'

test('assert.hasAnyKeys', () => {
  assert.hasAnyKeys({ foo: 1, bar: 2, baz: 3 }, ['foo', 'iDontExist', 'baz'])
  assert.hasAnyKeys({ foo: 1, bar: 2, baz: 3 }, { foo: 30, iDontExist: 99, baz: 1337 })
  assert.hasAnyKeys(new Map([[{ foo: 1 }, 'bar'], ['key', 'value']]), [{ foo: 1 }, 'key'])
  assert.hasAnyKeys(new Set([{ foo: 'bar' }, 'anotherKey']), [{ foo: 'bar' }, 'anotherKey'])
})
```

----------------------------------------

TITLE: Configuring TypeScript Types in tsconfig.json
DESCRIPTION: Demonstrates how to add Vitest browser type references to the `compilerOptions.types` array in `tsconfig.json`. This provides global type availability but note that specifying this field disables automatic `@types/*` package loading.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/index.md#_snippet_8

LANGUAGE: json
CODE:
```
{
  "compilerOptions": {
    "types": ["@vitest/browser/matchers"]
  }
}
```

LANGUAGE: json
CODE:
```
{
  "compilerOptions": {
    "types": ["@vitest/browser/providers/playwright"]
  }
}
```

LANGUAGE: json
CODE:
```
{
  "compilerOptions": {
    "types": ["@vitest/browser/providers/webdriverio"]
  }
}
```

----------------------------------------

TITLE: Browser Commands in Vitest Browser Mode (TypeScript)
DESCRIPTION: Defines the `commands` export, which provides access to available browser commands within the Vitest environment. This is a direct shortcut to `server.commands` and allows tests to execute browser-specific actions.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/context.md#_snippet_1

LANGUAGE: typescript
CODE:
```
/**
 * Available commands for the browser.
 * A shortcut to `server.commands`.
 */
export const commands: BrowserCommands
```

----------------------------------------

TITLE: Configuring Multiple Browser Instances in Vitest 3.0 (JS/TS)
DESCRIPTION: This configuration snippet shows how to set up multiple browser test instances using the `instances` array within the `browser` configuration. Each object in the array defines a specific browser setup, allowing different browsers or configurations (like launch options, setup files, or provided variables) to be tested efficiently with a single Vite server.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/blog/vitest-3.md#_snippet_1

LANGUAGE: JavaScript
CODE:
```
import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    browser: {
      provider: 'playwright',
      instances: [
        {
          browser: 'chromium',
          launch: { devtools: true },
        },
        {
          browser: 'firefox',
          setupFiles: ['./setup.firefox.ts'],
          provide: {
            secret: 'my-secret',
          },
        },
      ],
    }
  }
})
```

----------------------------------------

TITLE: Installing jsdom for Browser Mocking using Bash
DESCRIPTION: This bash snippet shows installation of 'jsdom' as a development dependency. 'jsdom' enables Vitest to mock DOM and browser APIs in a Node.js environment. This should be run before configuring the test environment with 'jsdom' as the target. It must be executed in the project directory.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/features.md#_snippet_6

LANGUAGE: bash
CODE:
```
$ npm i -D jsdom

```

----------------------------------------

TITLE: Listing Tests With Name Filters and JSON Output - Shell
DESCRIPTION: Demonstrates usage of the Vitest CLI to list all tests in a file matching a given test name filter, with support for outputting results as raw text or JSON. Takes an optional --json flag, which can redirect output to a file. Input: filename, name filter, --json flag. Output: List of test names and optionally their structure, either on stdout or in the specified file. Limitation: --json outputs to stdout unless a file is specified.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/cli.md#_snippet_6

LANGUAGE: shell
CODE:
```
vitest list filename.spec.ts -t="some-test" --json=./file.json

```

----------------------------------------

TITLE: TSX example demonstrating `disabled` option for `getByRole`
DESCRIPTION: This TSX snippet demonstrates how to use the `disabled` option with `getByRole` to filter elements based on their disabled state. It includes examples using input elements with the `disabled` attribute. Requires a TSX environment that supports JSX syntax. No external dependencies needed other than a rendering context for the TSX.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_4

LANGUAGE: tsx
CODE:
```
<input type="text" disabled />

page.getByRole('textbox', { disabled: true }) // ✅
page.getByRole('textbox', { disabled: false }) // ❌
```

----------------------------------------

TITLE: Filtering individual tests by full name using --testNamePattern
DESCRIPTION: This snippet illustrates filtering tests by their full name using the `-t` or `--testNamePattern` option, useful for targeting specific tests within files.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/filtering.md#_snippet_1

LANGUAGE: bash
CODE:
```
$ vitest -t "test name pattern"
```

----------------------------------------

TITLE: Assert Deep Equality with Vitest
DESCRIPTION: This demonstrates `assert.deepEqual`, which tests for deep equality of objects. It requires the `vitest` testing framework. The input is two objects, and the assertion passes if they have the same properties and values (recursively).
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_7

LANGUAGE: TypeScript
CODE:
```
import { assert, test } from 'vitest'

test('assert.deepEqual', () => {
  assert.deepEqual({ color: 'green' }, { color: 'green' })
})
```

----------------------------------------

TITLE: Conditionally Configuring Vitest cacheDir for Vitest (TypeScript)
DESCRIPTION: Shows how to set the `cacheDir` specifically for Vitest runs by checking the `process.env.VITEST` environment variable within the `defineConfig`. This allows sharing a config file with Vite while having a dedicated cache for Vitest.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_48

LANGUAGE: TypeScript
CODE:
```
import { defineConfig } from 'vitest/config'

export default defineConfig({
  cacheDir: process.env.VITEST ? 'custom-folder/.vitest' : undefined
})
```

----------------------------------------

TITLE: Using expect.any with Vitest
DESCRIPTION: This asymmetric matcher checks if a value is an instance of a specified constructor. It's useful for verifying the type of dynamically generated values within an equality check.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_67

LANGUAGE: TypeScript
CODE:
```
import { expect, test } from 'vitest'
import { generateId } from './generators.js'

test('"id" is a number', () => {
  expect({ id: generateId() }).toEqual({ id: expect.any(Number) })
})
```

----------------------------------------

TITLE: Previewing HTML Report with Vite Preview
DESCRIPTION: This command uses Vite's preview functionality to serve the generated HTML report.  The `--outDir ./html` flag specifies that the report is located in the ./html directory. The command requires Vite to be installed and the HTML report to be present in the specified output directory. The output is a preview server serving the generated HTML report in the browser.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/ui.md#_snippet_3

LANGUAGE: javascript
CODE:
```
npx vite preview --outDir ./html
```

----------------------------------------

TITLE: Configuring Vitest Coverage Provider (TypeScript)
DESCRIPTION: Configures the coverage provider for Vitest tests. You can choose between 'v8' (default) and 'istanbul'. Vitest will prompt for installation if the corresponding package is missing.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/coverage.md#_snippet_0

LANGUAGE: typescript
CODE:
```
import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    coverage: {
      provider: 'istanbul' // or 'v8'
    },
  },
})
```

----------------------------------------

TITLE: Filtering Vitest Browser Projects via CLI
DESCRIPTION: This shell command demonstrates how to use the `--project` CLI flag to filter and run tests only for a specific browser instance (project) defined in the Vitest configuration.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/multiple-setups.md#_snippet_2

LANGUAGE: shell
CODE:
```
$ vitest --project=chromium
```

----------------------------------------

TITLE: Using unplugin-auto-import with Vitest (TypeScript)
DESCRIPTION: Provides an example of integrating `unplugin-auto-import` into the Vitest configuration using a Vite plugin to automatically import Vitest APIs, including generating TypeScript declarations.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_11

LANGUAGE: ts
CODE:
```
import { defineConfig } from 'vitest/config'
import AutoImport from 'unplugin-auto-import/vite'

export default defineConfig({
  plugins: [
    AutoImport({
      imports: ['vitest'],
      dts: true, // generate TypeScript declaration
    }),
  ],
})
```

----------------------------------------

TITLE: Example Vitest Test Output (Text)
DESCRIPTION: Example console output shown after successfully running the Vitest tests.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/index.md#_snippet_4

LANGUAGE: txt
CODE:
```
✓ sum.test.js (1)
  ✓ adds 1 + 2 to equal 3

Test Files  1 passed (1)
     Tests  1 passed (1)
  Start at  02:15:44
  Duration  311ms
```

----------------------------------------

TITLE: Asserting Greater Than or Equal with toBeGreaterThanOrEqual in Vitest (TypeScript)
DESCRIPTION: The `toBeGreaterThanOrEqual` matcher asserts if the actual value is greater than or equal to the received value. This includes the case where the values are equal.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_22

LANGUAGE: TypeScript
CODE:
```
import { expect, test } from 'vitest'
import { getApples } from './stocks.js'

test('have 11 apples or more', () => {
  expect(getApples()).toBeGreaterThanOrEqual(11)
})
```

----------------------------------------

TITLE: Asserting Numeric Property Increases By Specific Value with Vitest - TypeScript
DESCRIPTION: This snippet checks that a modifier function increases a numeric property or its return value by exactly a given amount. It uses the Vitest assert utility with parameters for the modifier, target object, property, change amount, and optional message. Ideal when the precise value of the change is important for program correctness.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_105

LANGUAGE: TypeScript
CODE:
```
import { assert, test } from 'vitest'

test('assert.increasesBy', () => {
  const obj = { val: 10 }
  function fn() { obj.val += 10 };
  assert.increasesBy(fn, obj, 'val', 10)
})
```

----------------------------------------

TITLE: Using assert.hasAllKeys in Vitest (TypeScript)
DESCRIPTION: Demonstrates `assert.hasAllKeys`, which asserts that an object, Map, or Set contains all, and only all, of the specified keys. Keys can be provided as an array or implicitly via another object's keys. The example imports from `vitest` and shows checks for objects, Maps, and Sets within a test.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_70

LANGUAGE: typescript
CODE:
```
import { assert, test } from 'vitest'

test('assert.hasAllKeys', () => {
  assert.hasAllKeys({ foo: 1, bar: 2, baz: 3 }, ['foo', 'bar', 'baz'])
  assert.hasAllKeys({ foo: 1, bar: 2, baz: 3 }, { foo: 30, bar: 99, baz: 1337 })
  assert.hasAllKeys(new Map([[{ foo: 1 }, 'bar'], ['key', 'value']]), [{ foo: 1 }, 'key'])
  assert.hasAllKeys(new Set([{ foo: 'bar' }, 'anotherKey'], [{ foo: 'bar' }, 'anotherKey']))
})
```

----------------------------------------

TITLE: Waiting for Server Readiness with vi.waitFor (TypeScript)
DESCRIPTION: Shows how to use vi.waitFor with a synchronous callback that throws an error until a condition is met. Includes options for timeout and interval. Requires Vitest and a server creation function.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_35

LANGUAGE: TypeScript
CODE:
```
import { expect, test, vi } from 'vitest';
import { createServer } from './server.js';

test('Server started successfully', async () => {
  const server = createServer();

  await vi.waitFor(
    () => {
      if (!server.isReady) {
        throw new Error('Server not started');
      }

      console.log('Server started');
    },
    {
      timeout: 500, // default is 1000
      interval: 20, // default is 50
    }
  );
  expect(server.isReady).toBe(true);
});
```

----------------------------------------

TITLE: Checking Constructible Types with Vitest
DESCRIPTION: This snippet utilizes `toBeConstructibleWith()` to ensure a type can be constructed with given parameters. It imports `expectTypeOf` from 'vitest'. It demonstrates constructing a `Date` object with different arguments.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect-typeof.md#_snippet_27

LANGUAGE: ts
CODE:
```
import { expectTypeOf } from 'vitest'

expectTypeOf(Date).toBeConstructibleWith(new Date())
expectTypeOf(Date).toBeConstructibleWith('01-01-2000')
```

----------------------------------------

TITLE: Enabling Typechecking in Vitest Scripts - JSON
DESCRIPTION: Shows how to modify the `scripts` section in `package.json` to include the `--typecheck` flag in the Vitest test command, enabling type checking during test execution.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/testing-types.md#_snippet_4

LANGUAGE: json
CODE:
```
{
  "scripts": {
    "test": "vitest --typecheck"
  }
}
```

----------------------------------------

TITLE: Deprecated Context Extension with beforeEach Hook in Vitest
DESCRIPTION: Shows the deprecated method of extending the test context using the `beforeEach` hook. This approach is not compatible with contexts extended via `test.extend`.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/test-context.md#_snippet_15

LANGUAGE: ts
CODE:
```
import { beforeEach, it } from 'vitest'

beforeEach(async (context) => {
  // extend context
  context.foo = 'bar'
})

it('should work', ({ foo }) => {
  console.log(foo) // 'bar'
})
```

----------------------------------------

TITLE: Defining Vitest Global Setup with onTestsRerun Callback (TS)
DESCRIPTION: Illustrates how to use the 'onTestsRerun' callback within a Vitest global setup function (available since Vitest 3). This callback is executed when tests are rerun, allowing for custom logic like restarting a database.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_33

LANGUAGE: ts
CODE:
```
import type { TestProject } from 'vitest/node'

export default function setup(project: TestProject) {
  project.onTestsRerun(async () => {
    await restartDb()
  })
}
```

----------------------------------------

TITLE: Using vi.doMock for Non-Hoisted Mocking in Vitest (TypeScript)
DESCRIPTION: Illustrates the behavior of vi.doMock, showing that it does not affect static imports made before the call but applies to subsequent dynamic imports. It also demonstrates creating a mock factory that accesses variables defined in the test file's scope.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_7

LANGUAGE: typescript
CODE:
```
import { beforeEach, test } from 'vitest'
import { increment } from './increment.js'

// the module is not mocked, because vi.doMock is not called yet
increment(1) === 2

let mockedIncrement = 100

beforeEach(() => {
  // you can access variables inside a factory
  vi.doMock('./increment.js', () => ({ increment: () => ++mockedIncrement }))
})

test('importing the next module imports mocked one', async () => {
  // original import WAS NOT MOCKED, because vi.doMock is evaluated AFTER imports
  expect(increment(1)).toBe(2)
  const { increment: mockedIncrement } = await import('./increment.js')
  // new dynamic import returns mocked module
  expect(mockedIncrement(1)).toBe(101)
  expect(mockedIncrement(1)).toBe(102)
  expect(mockedIncrement(1)).toBe(103)
})
```

----------------------------------------

TITLE: Configuring Vitest Provide and Injecting Values (TS)
DESCRIPTION: Demonstrates how to define values using the 'provide' option in the Vitest configuration and subsequently access those values within test files using the 'inject' function. This allows sharing serializable data across different processes.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_28

LANGUAGE: ts
CODE:
```
import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    provide: {
      API_KEY: '123',
    },
  },
})
```

LANGUAGE: ts
CODE:
```
import { expect, inject, test } from 'vitest'

test('api key is defined', () => {
  expect(inject('API_KEY')).toBe('123')
})
```

----------------------------------------

TITLE: Enable Vitest Node.js Inspector and Break (inspectBrk)
DESCRIPTION: Activates the Node.js inspector and pauses execution before tests begin, allowing for debugging from the start.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/cli-generated.md#_snippet_34

LANGUAGE: CLI
CODE:
```
--inspectBrk [[host:]port]
```

LANGUAGE: Config
CODE:
```
inspectBrk
```

----------------------------------------

TITLE: Temporarily Overriding Implementation with withImplementation
DESCRIPTION: This example demonstrates how to use `withImplementation` to temporarily override the implementation of a mock function within a callback. The original implementation is restored after the callback is executed.  Supports both synchronous and asynchronous callbacks.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/mock.md#_snippet_5

LANGUAGE: javascript
CODE:
```
const myMockFn = vi.fn(() => 'original')

myMockFn.withImplementation(() => 'temp', () => {
  myMockFn() // 'temp'
})

myMockFn() // 'original'
```

----------------------------------------

TITLE: Asserting Nested Property Inclusion using Vitest (TypeScript)
DESCRIPTION: Shows how to use `assert.nestedInclude` in Vitest tests to check for the inclusion of nested properties in objects using dot and bracket notation. Special characters '.' and '[]' in keys need double backslash escaping. Imports `assert` and `test`.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_46

LANGUAGE: typescript
CODE:
```
import { assert, test } from 'vitest'

test('assert.nestedInclude', () => {
  assert.nestedInclude({ '.a': { b: 'x' } }, { '\\.a.[b]': 'x' })
  assert.nestedInclude({ a: { '[b]': 'x' } }, { 'a.\\[b\\]': 'x' })
})
```

----------------------------------------

TITLE: Asserting String Types with Vitest in TypeScript
DESCRIPTION: Uses `.toBeString` to verify a value or type is a string. Requires Vitest and works with string literals and string type assertions. Important for APIs expecting string data or interfaces.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect-typeof.md#_snippet_19

LANGUAGE: TypeScript
CODE:
```
import { expectTypeOf } from 'vitest'

expectTypeOf(42).not.toBeString()
expectTypeOf('').toBeString()
expectTypeOf('a').toBeString()
```

----------------------------------------

TITLE: Installing Vitest UI with npm
DESCRIPTION: This command installs the Vitest UI package as a development dependency.  It uses npm to install the @vitest/ui package. This package provides the necessary components for the Vitest UI functionality.  No specific parameters are needed for installation. The output is the installed package and its dependencies.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/ui.md#_snippet_0

LANGUAGE: bash
CODE:
```
npm i -D @vitest/ui
```

----------------------------------------

TITLE: Mocking Module with Promise and Overriding Exports in Vitest (TypeScript)
DESCRIPTION: Illustrates using `vi.mock` with a dynamic `import()` promise instead of a string path. The factory function uses `importOriginal()` to get the actual module's type and exports, allowing selective overriding of exports while keeping others.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_2

LANGUAGE: ts
CODE:
```
@filename: ./path/to/module.js
export declare function total(...numbers: number[]): number
// @filename: test.js
import { vi } from 'vitest'
// ---cut---
vi.mock(import('./path/to/module.js'), async (importOriginal) => {
  const mod = await importOriginal() // type is inferred
  //    ^?
  return {
    ...mod,
    // replace some exports
    total: vi.fn(),
  }
})
```

----------------------------------------

TITLE: Shuffling Test Order in Vitest Suites (TS)
DESCRIPTION: Use `describe.shuffle` (or `suite.shuffle`) to run tests within a specific suite in a random order, overriding global shuffle settings. The shuffle behavior is inherited by nested suites unless explicitly disabled using the `{ shuffle: false }` option.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/index.md#_snippet_45

LANGUAGE: typescript
CODE:
```
import { describe, test } from 'vitest'

// or describe('suite', { shuffle: true }, ...)
describe.shuffle('suite', () => {
  test('random test 1', async () => { /* ... */ })
  test('random test 2', async () => { /* ... */ })
  test('random test 3', async () => { /* ... */ })

  // `shuffle` is inherited
  describe('still random', () => {
    test('random 4.1', async () => { /* ... */ })
    test('random 4.2', async () => { /* ... */ })
  })

  // disable shuffle inside
  describe('not random', { shuffle: false }, () => {
    test('in order 5.1', async () => { /* ... */ })
    test('in order 5.2', async () => { /* ... */ })
  })
})
// order depends on sequence.seed option in config (Date.now() by default)
```

----------------------------------------

TITLE: Asserting Map/Set Has Any Deep Keys with Vitest (TypeScript)
DESCRIPTION: Demonstrates using `assert.hasAnyDeepKeys` in Vitest to verify that a Map or Set contains at least one of the specified keys, performing a deep comparison for object keys. Keys can be provided as an array of objects/strings or as the keys of another object.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_74

LANGUAGE: typescript
CODE:
```
import { assert, test } from 'vitest'

test('assert.hasAnyDeepKeys', () => {
  assert.hasAnyDeepKeys(new Map([[{ one: 'one' }, 'valueOne'], [1, 2]]), { one: 'one' })
  assert.hasAnyDeepKeys(new Map([[{ one: 'one' }, 'valueOne'], [1, 2]]), [{ one: 'one' }, { two: 'two' }])
  assert.hasAnyDeepKeys(new Map([[{ one: 'one' }, 'valueOne'], [{ two: 'two' }, 'valueTwo']]), [{ one: 'one' }, { two: 'two' }])
  assert.hasAnyDeepKeys(new Set([{ one: 'one' }, { two: 'two' }]), { one: 'one' })
  assert.hasAnyDeepKeys(new Set([{ one: 'one' }, { two: 'two' }]), [{ one: 'one' }, { three: 'three' }])
  assert.hasAnyDeepKeys(new Set([{ one: 'one' }, { two: 'two' }]), [{ one: 'one' }, { two: 'two' }])
})
```

----------------------------------------

TITLE: Multiple Browser Configurations with Inherited Options
DESCRIPTION: Shows how multiple browser configurations inherit options from the root config, including setup files and custom paths. Also demonstrates how to properly organize browser instances.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/config.md#_snippet_2

LANGUAGE: typescript
CODE:
```
export default defineConfig({
  test: {
    setupFile: ['./root-setup-file.js'],
    browser: {
      enabled: true,
      testerHtmlPath: './custom-path.html',
      instances: [
        {
          // will have both setup files: "root" and "browser"
          setupFile: ['./browser-setup-file.js'],
          // implicitly has "testerHtmlPath" from the root config
          // testerHtmlPath: './custom-path.html',
        },
      ],
    },
  },
})
```

----------------------------------------

TITLE: Typing Specific Vitest Hooks with Generics in TypeScript
DESCRIPTION: This example shows how to apply specific type interfaces, like `LocalTestContext`, to individual Vitest hooks (`beforeEach`, `it`) using generics. This method allows you to define context properties that are only available and type-checked within those specific hooks, providing more granular control over context typing.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/test-context.md#_snippet_17

LANGUAGE: TypeScript
CODE:
```
interface LocalTestContext {
  foo: string
}

beforeEach<LocalTestContext>(async (context) => {
  // typeof context is 'TestContext & LocalTestContext'
  context.foo = 'bar'
})

it<LocalTestContext>('should work', ({ foo }) => {
  // typeof foo is 'string'
  console.log(foo) // 'bar'
})
```

----------------------------------------

TITLE: Advancing Fake Timers to Next Frame with Vitest vi.advanceTimersToNextFrame (TypeScript)
DESCRIPTION: This snippet shows how to use `vi.advanceTimersToNextFrame` in Vitest's fake timer environment. It advances the fake clock by the duration needed to execute callbacks scheduled with `requestAnimationFrame`, useful for testing browser-like rendering scenarios.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_29

LANGUAGE: typescript
CODE:
```
let frameRendered = false

requestAnimationFrame(() => {
  frameRendered = true
})

vi.advanceTimersToNextFrame()

expect(frameRendered).toBe(true)
```

----------------------------------------

TITLE: Asserting Promise Resolution Types with Vitest in TypeScript
DESCRIPTION: Uses `.resolves` to extract the type of the resolved value from a Promise, enabling further type assertions. Requires Vitest, works with function types that return a Promise or explicit Promise values, and allows chained type checks on asynchronous logic.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect-typeof.md#_snippet_10

LANGUAGE: TypeScript
CODE:
```
import { expectTypeOf } from 'vitest'

async function asyncFunc() {
  return 123
}

expectTypeOf(asyncFunc).returns.resolves.toBeNumber()
expectTypeOf(Promise.resolve('string')).resolves.toBeString()
```

----------------------------------------

TITLE: Output File Configuration
DESCRIPTION: Writes test results to a file when a supporter reporter is specified. Can be set via the CLI using `--outputFile <filename/-s>` or in the configuration file using the `outputFile` property. Use dot notation for individual outputs of multiple reporters (e.g., `--outputFile.tap=./tap.txt`).
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/cli-generated.md#_snippet_14



----------------------------------------

TITLE: Demonstrating vi.hoisted Import Access Error (Vitest, TypeScript)
DESCRIPTION: Illustrates that variables from static imports are not available inside the `vi.hoisted` factory function because the factory runs before the hoisted imports are evaluated. This code will throw a runtime error.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_38

LANGUAGE: TypeScript
CODE:
```
import { value } from './some/module.js'

vi.hoisted(() => { value }) // throws an error // [!code warning]
```

----------------------------------------

TITLE: Reporters Configuration
DESCRIPTION: Specifies the reporters to use for test results. Can be set via the CLI using `--reporter <name>` or in the configuration file using the `reporters` property.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/cli-generated.md#_snippet_13



----------------------------------------

TITLE: userEvent.setup Function Signature
DESCRIPTION: Provides the TypeScript signature for the `userEvent.setup` function, which creates a new user event instance useful for managing keyboard state.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/interactivity-api.md#_snippet_2

LANGUAGE: ts
CODE:
```
function setup(): UserEvent
```

----------------------------------------

TITLE: Asserting Object Lacks Specific Keys with Vitest (TypeScript)
DESCRIPTION: Demonstrates using `assert.doesNotHaveAnyKeys` in Vitest to verify that an object (or Map/Set) does not contain any of the specified keys. Keys can be provided as an array of strings/objects or as the keys of another object.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_72

LANGUAGE: typescript
CODE:
```
import { assert, test } from 'vitest'

test('assert.doesNotHaveAnyKeys', () => {
  assert.doesNotHaveAnyKeys({ foo: 1, bar: 2, baz: 3 }, ['one', 'two', 'example'])
  assert.doesNotHaveAnyKeys({ foo: 1, bar: 2, baz: 3 }, { one: 1, two: 2, example: 'foo' })
  assert.doesNotHaveAnyKeys(new Map([[{ foo: 1 }, 'bar'], ['key', 'value']]), [{ one: 'two' }, 'example'])
  assert.doesNotHaveAnyKeys(new Set([{ foo: 'bar' }, 'anotherKey'], [{ one: 'two' }, 'example']))
})
```

----------------------------------------

TITLE: Test Name Pattern Configuration
DESCRIPTION: Runs tests whose full names match the specified regular expression pattern. Can be set via the CLI using `-t, --testNamePattern <pattern>` or in the configuration file using the `testNamePattern` property.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/cli-generated.md#_snippet_4



----------------------------------------

TITLE: Extracting Function Return Types with Vitest in TypeScript
DESCRIPTION: Applies `.returns` to determine and assert the return value type of functions. Requires Vitest and is used with function types. Ensures the tested function provides the expected return type and supports chaining type assertions for advanced validation.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect-typeof.md#_snippet_4

LANGUAGE: TypeScript
CODE:
```
import { expectTypeOf } from 'vitest'

expectTypeOf(() => {}).returns.toBeVoid()
expectTypeOf((a: number) => [a, a]).returns.toEqualTypeOf([1, 2])
```

----------------------------------------

TITLE: Enable UI Option
DESCRIPTION: Enables the Vitest UI. Can be enabled via the CLI using `--ui` or in the configuration file using the `ui` property.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/cli-generated.md#_snippet_6



----------------------------------------

TITLE: Image Snapshot with jest-image-snapshot (TypeScript)
DESCRIPTION: This snippet demonstrates how to use `jest-image-snapshot` with Vitest to create image snapshots. It reads an image file and compares it to a stored snapshot. Dependencies: jest-image-snapshot. Input: Image file path. Output: Comparison against the content of the specified file.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/snapshot.md#_snippet_5

LANGUAGE: typescript
CODE:
```
test('image snapshot', () => {
  expect(readFileSync('./test/stubs/input-image.png'))
    .toMatchImageSnapshot()
})
```

----------------------------------------

TITLE: Example Vitest Test Affected by forceRerunTriggers (TS)
DESCRIPTION: Provides an example of a Vitest test that executes an external script. Vitest's module graph cannot track changes within the executed script's output ('dist/index.js'), highlighting a scenario where the 'forceRerunTriggers' option might be necessary to ensure reruns.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_34

LANGUAGE: ts
CODE:
```
test('execute a script', async () => {
  // Vitest cannot rerun this test, if content of `dist/index.js` changes
  await execa('node', ['dist/index.js'])
})
```

----------------------------------------

TITLE: Using assert.nestedPropertyVal in Vitest (TypeScript)
DESCRIPTION: Shows how to use `assert.nestedPropertyVal` to assert that an object has a nested property (using dot/bracket notation) with a specific value, using strict equality (===). The example imports from `vitest` and verifies the value of 'tea.green' within a test.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_64

LANGUAGE: typescript
CODE:
```
import { assert, test } from 'vitest'

test('assert.nestedPropertyVal', () => {
  assert.nestedPropertyVal({ tea: { green: 'matcha' } }, 'tea.green', 'matcha')
})
```

----------------------------------------

TITLE: Using Hashbang for Vite Node Scripts (TypeScript)
DESCRIPTION: Example TypeScript file (`file.ts`) showing how to use a hashbang (`#!/usr/bin/env vite-node --script`) to allow the script to be executed directly using `vite-node` without explicitly invoking it via `npx`. The script logs command-line arguments passed to it.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/packages/vite-node/README.md#_snippet_3

LANGUAGE: typescript
CODE:
```
#!/usr/bin/env vite-node --script

console.log('argv:', process.argv.slice(2))
```

----------------------------------------

TITLE: Configuring Forks Pool Options in Vitest
DESCRIPTION: This TypeScript snippet demonstrates how to specify configuration options for the 'forks' test pool within the `poolOptions` section of the Vitest configuration file.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_24

LANGUAGE: ts
CODE:
```
import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    poolOptions: {
      forks: {
        // Forks related options here
      }
    }
  }
})
```

----------------------------------------

TITLE: Configuring Vitest Projects (vitest.config.js)
DESCRIPTION: Shows how to define multiple test projects within the `vitest.config.js` file using an array in `test.projects`. Illustrates configuring projects by path, implicitly resolving the name, or explicitly setting the `name` property.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/test-project.md#_snippet_1

LANGUAGE: typescript
CODE:
```
import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    projects: [
      './packages/server', // has package.json with "@pkg/server"
      './utils', // doesn't have a package.json file
      {
        // doesn't customize the name
        test: {
          pool: 'threads',
        },
      },
      {
        // customized the name
        test: {
          name: 'custom',
        },
      },
    ],
  },
})
```

----------------------------------------

TITLE: Migrating Jest Timeout to Vitest Configuration with TypeScript
DESCRIPTION: Demonstrates replacing jest.setTimeout with the Vitest configuration API vi.setConfig. Ensures test timeouts are properly set for async tests. Requires Vitest and TypeScript; vi must be available in scope. Input: timeout value in milliseconds; Output: updated test timeout configuration.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/migration.md#_snippet_15

LANGUAGE: typescript
CODE:
```
jest.setTimeout(5_000) // [!code --]
vi.setConfig({ testTimeout: 5_000 }) // [!code ++]
```

----------------------------------------

TITLE: Accessing Class Instance Properties with Vitest in TypeScript
DESCRIPTION: Uses `.instance` to perform type assertions on instances of classes, allowing checks for presence and typing of properties and methods. Depends on Vitest and a valid constructable class. Supports comprehensive instance shape validation in tests.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect-typeof.md#_snippet_8

LANGUAGE: TypeScript
CODE:
```
import { expectTypeOf } from 'vitest'

expectTypeOf(Date).instance.toHaveProperty('toISOString')
```

----------------------------------------

TITLE: Migrating Jest Mock Type Imports to Vitest with TypeScript
DESCRIPTION: Illustrates replacing Jest's global namespace mock typing with explicit type imports from Vitest. This aids type safety and avoids namespace conflicts. Requires Vitest installed and TypeScript. Input: function type signatures; Output: properly imported and typed mock variables.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/migration.md#_snippet_14

LANGUAGE: typescript
CODE:
```
let fn: jest.Mock<(name: string) => number> // [!code --]
import type { Mock } from 'vitest' // [!code ++]
let fn: Mock<(name: string) => number> // [!code ++]
```

----------------------------------------

TITLE: Configuring Reporters with Options
DESCRIPTION: This example shows how to configure reporters with specific options within the `vitest.config.ts` file. It configures the 'junit' reporter with a custom suite name. This allows for more detailed control over the output, tailoring the reports to fit specific project needs. The options are passed as an array where the first element is the reporter name and the second element is an object containing the reporter's options.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/reporters.md#_snippet_2

LANGUAGE: ts
CODE:
```
export default defineConfig({
  test: {
    reporters: [
      'default',
      ['junit', { suiteName: 'UI tests' }]
    ],
  },
})

```

----------------------------------------

TITLE: Using assert.notPropertyVal in Vitest (TypeScript)
DESCRIPTION: Demonstrates `assert.notPropertyVal`, asserting that an object either doesn't have a property or has it with a different value than specified, using strict equality (===). The example imports from `vitest` and shows two cases within a test: checking for a different value and checking for a non-existent property.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_59

LANGUAGE: typescript
CODE:
```
import { assert, test } from 'vitest'

test('assert.notPropertyVal', () => {
  assert.notPropertyVal({ tea: 'is good' }, 'tea', 'is bad')
  assert.notPropertyVal({ tea: 'is good' }, 'coffee', 'is good')
})
```

----------------------------------------

TITLE: Asserting Object Types with Vitest in TypeScript
DESCRIPTION: Uses `.toBeObject` to check if the provided type is an object. Requires Vitest and can distinguish between objects and primitives, supporting robust API or data structure guards.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect-typeof.md#_snippet_17

LANGUAGE: TypeScript
CODE:
```
import { expectTypeOf } from 'vitest'

expectTypeOf(42).not.toBeObject()
expectTypeOf({}).toBeObject()
```

----------------------------------------

TITLE: Comparing Vitest and Testing Library Keyboard State
DESCRIPTION: Illustrates the difference in keyboard state handling between Vitest's `userEvent` (which maintains state) and the original `@testing-library/user-event` (which resets state per call), highlighting why Vitest's approach is more suitable for native browser interaction.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/interactivity-api.md#_snippet_3

LANGUAGE: ts
CODE:
```
import { userEvent as vitestUserEvent } from '@vitest/browser/context'
import { userEvent as originalUserEvent } from '@testing-library/user-event'

await vitestUserEvent.keyboard('{Shift}') // press shift without releasing
await vitestUserEvent.keyboard('{/Shift}') // releases shift

await originalUserEvent.keyboard('{Shift}') // press shift without releasing
await originalUserEvent.keyboard('{/Shift}') // DID NOT release shift because the state is different
```

----------------------------------------

TITLE: Writing Reporter Output to File - CLI
DESCRIPTION: This snippet demonstrates how to direct reporter output to a file when using the command-line.  It uses the `--reporter=json` to specify the JSON reporter and `--outputFile` to specify the output file path.  The output file will contain the test results in JSON format.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/reporters.md#_snippet_3

LANGUAGE: bash
CODE:
```
npx vitest --reporter=json --outputFile=./test-output.json
```

----------------------------------------

TITLE: Configuring Vitest Custom Coverage Provider (TypeScript)
DESCRIPTION: Configures Vitest to use a custom coverage provider. The `provider` is set to 'custom', and `customProviderModule` specifies the module path or name.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/coverage.md#_snippet_6

LANGUAGE: typescript
CODE:
```
import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    coverage: {
      provider: 'custom',
      customProviderModule: 'my-custom-coverage-provider'
    },
  },
})
```

----------------------------------------

TITLE: Using toMatchFileSnapshot() in Vitest (TypeScript)
DESCRIPTION: This example demonstrates how to use `toMatchFileSnapshot()` to compare a value against the content of a specific file. This is useful for snapshots of formatted content. Dependencies: vitest. Input: none. Output: Comparison against the content of the specified file.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/snapshot.md#_snippet_4

LANGUAGE: typescript
CODE:
```
import { expect, it } from 'vitest'

it('render basic', async () => {
  const result = renderHTML(h('div', { class: 'foo' }))
  await expect(result).toMatchFileSnapshot('./test/basic.output.html')
})
```

----------------------------------------

TITLE: Coverage Provider Configuration
DESCRIPTION: Selects the tool for coverage collection. Available values are "v8", "istanbul", and "custom". Can be set via the CLI using `--coverage.provider <name>` or in the configuration file using the `coverage.provider` property.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/cli-generated.md#_snippet_16



----------------------------------------

TITLE: Asserting Nth Call Arguments with Vitest
DESCRIPTION: Checks if a spy function was called with specific arguments at a particular invocation index (1-based). Requires a spy function.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_49

LANGUAGE: typescript
CODE:
```
import { expect, test, vi } from 'vitest'

const market = {
  buy(subject: string, amount: number) {
    // ...
  },
}

test('first call of spy function called with right params', () => {
  const buySpy = vi.spyOn(market, 'buy')

  market.buy('apples', 10)
  market.buy('apples', 20)

  expect(buySpy).toHaveBeenNthCalledWith(1, 'apples', 10)
})
```

----------------------------------------

TITLE: Configure vmThreads Pool Options in Vitest (TypeScript)
DESCRIPTION: This snippet demonstrates how to define configuration options specifically for the 'vmThreads' test pool within the Vitest configuration file (vitest.config.ts). It shows the basic structure for adding vmThreads related settings under the 'poolOptions' property.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_25

LANGUAGE: TypeScript
CODE:
```
import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    poolOptions: {
      vmThreads: {
        // VM threads related options here
      }
    }
  }
})
```

----------------------------------------

TITLE: Configuring Threads Pool Options in Vitest
DESCRIPTION: This TypeScript snippet shows how to define configuration options specifically for the 'threads' test pool within the `poolOptions` section of the Vitest configuration file.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_23

LANGUAGE: ts
CODE:
```
import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    poolOptions: {
      threads: {
        // Threads related options here
      }
    }
  }
})
```

----------------------------------------

TITLE: Ordered Members Inequality Assertion (TypeScript)
DESCRIPTION: Defines `assert.notSameOrderedMembers` to verify two arrays do not have the same elements in order. The test case demonstrates mismatch detection.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_88

LANGUAGE: TypeScript
CODE:
```
import { assert, test } from 'vitest'

 test('assert.notSameOrderedMembers', () => {
  assert.notSameOrderedMembers([1, 2, 3], [2, 1, 3], 'not same ordered members')
})
```

----------------------------------------

TITLE: Defining and Using toHaveStyle Matcher in Vitest - TypeScript
DESCRIPTION: Defines the toHaveStyle matcher used to assert the presence of inline or stylesheet-applied CSS styles on DOM elements. The input parameter can be a CSS string or an object matching CSSStyleDeclaration, supporting flexibility. Outputs assertion pass/fail for strict matching of all expected property values. Requires HTML element with applicable style. Limitations: only verifies that all specified styles are applied; ignores extraneous styles.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_22

LANGUAGE: TypeScript
CODE:
```
function toHaveStyle(css: string | Partial<CSSStyleDeclaration>): Promise<void>
```

LANGUAGE: TypeScript
CODE:
```
const button = getByTestId('delete-button')

await expect.element(button).toHaveStyle('display: none')
await expect.element(button).toHaveStyle({ display: 'none' })
await expect.element(button).toHaveStyle(`
  background-color: red;
  display: none;
`)
await expect.element(button).toHaveStyle({
  backgroundColor: 'red',
  display: 'none',
})
await expect.element(button).not.toHaveStyle(`
  background-color: blue;
  display: none;
`)
await expect.element(button).not.toHaveStyle({
  backgroundColor: 'blue',
  display: 'none',
})
```

----------------------------------------

TITLE: Using assert.deepOwnInclude in Vitest (TypeScript)
DESCRIPTION: Demonstrates how to use the `assert.deepOwnInclude` method in a Vitest test. This assertion checks if an object (`haystack`) deeply includes the own properties of another object (`needle`), ignoring inherited properties. The example imports `assert` and `test` from `vitest` and calls `assert.deepOwnInclude` within a test case.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_52

LANGUAGE: typescript
CODE:
```
import { assert, test } from 'vitest'

test('assert.deepOwnInclude', () => {
  assert.deepOwnInclude({ a: { b: 2 } }, { a: { b: 2 } })
})
```

----------------------------------------

TITLE: Targeting Line Numbers in Test Files - Bash
DESCRIPTION: Shows how to invoke Vitest to run only tests located at a specific line in a given file. This feature requires the full file path, either relative to the current working directory or absolute. Multiple valid forms are demonstrated; invalid cases include omitting the extension or using incomplete filenames. Input: a filename (with extension) and line number. Output: Test(s) at the specified line are executed. Limitations: range selection (e.g., 10-25) is not supported.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/cli.md#_snippet_1

LANGUAGE: bash
CODE:
```
$ vitest basic/foo.test.ts:10
$ vitest basic/foo.js:10 # ✅
$ vitest ./basic/foo.js:10 # ✅
$ vitest /users/project/basic/foo.js:10 # ✅
$ vitest foo:10 # ❌
$ vitest ./basic/foo:10 # ❌

```

----------------------------------------

TITLE: Comparing Variable Types with expectTypeOf and typeof - TypeScript
DESCRIPTION: Shows how to compare the types of two variables (`one` and `two`) using `expectTypeOf` combined with the `typeof` operator as a type argument. This is useful when comparing two concrete types derived from function calls.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/testing-types.md#_snippet_2

LANGUAGE: ts
CODE:
```
const one = valueFromFunctionOne({ some: { complex: inputs } })
const two = valueFromFunctionTwo({ some: { other: inputs } })

expectTypeOf(one).toEqualTypeOf<typeof two>()
```

----------------------------------------

TITLE: filter.hasNot - Exclude Elements Containing Certain Child Elements
DESCRIPTION: Filters parent elements to exclude those containing child elements matching a specified locator, helping refine searches to elements lacking certain nested content.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_27

LANGUAGE: TypeScript
CODE:
```
hasNot: Locator
```

----------------------------------------

TITLE: Assertion for Non-Throwing Functions in Vitest (TypeScript)
DESCRIPTION: Defines `assert.doesNotThrow` to verify that a function does not throw an error of a specified type or message. It supports checking against error constructors, specific error instances, and message matchers. The snippet demonstrates its usage within a test case.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_80

LANGUAGE: TypeScript
CODE:
```
import { assert, test } from 'vitest'

 test('assert.doesNotThrow', () => {
  assert.doesNotThrow(fn, 'Any Error thrown must not have this message')
  assert.doesNotThrow(fn, /Any Error thrown must not match this/)
  assert.doesNotThrow(fn, Error)
  assert.doesNotThrow(fn, errorInstance)
  assert.doesNotThrow(fn, Error, 'Error must not have this message')
  assert.doesNotThrow(fn, errorInstance, 'Error must not have this message')
  assert.doesNotThrow(fn, Error, /Error must not match this/)
  assert.doesNotThrow(fn, errorInstance, /Error must not match this/)
})
```

----------------------------------------

TITLE: Running Conditional Tests with Vitest (TypeScript)
DESCRIPTION: Demonstrates how to use `test.runIf` to execute a test only if a specified condition is true. This is the inverse of `test.skipIf`. Note that this syntax is not supported when using Vitest solely as a type checker.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/index.md#_snippet_12

LANGUAGE: TypeScript
CODE:
```
import { assert, test } from 'vitest'

const isDev = process.env.NODE_ENV === 'development'

test.runIf(isDev)('dev only test', () => {
  // this test only runs in development
})
```

----------------------------------------

TITLE: Updating Runtime Configuration with vi.setConfig (Vitest, TypeScript)
DESCRIPTION: Illustrates how to use `vi.setConfig` to modify specific runtime configuration options for the current test file. This method only supports options that affect the file's execution environment.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_42

LANGUAGE: TypeScript
CODE:
```
vi.setConfig({
  allowOnly: true,
  testTimeout: 10_000,
  hookTimeout: 10_000,
  clearMocks: true,
  restoreMocks: true,
  fakeTimers: {
    now: new Date(2021, 11, 19),
    // supports the whole object
  },
  maxConcurrency: 10,
  sequence: {
    hooks: 'stack'
    // supports only "sequence.hooks"
  }
})
```

----------------------------------------

TITLE: Defining Custom Test Environment | Vitest | TypeScript
DESCRIPTION: This code defines a custom Vitest test environment object. It requires a `name`, `transformMode`, and optional `setupVM` (for experimental-vm pool) and `setup` functions. The `setup` and `setupVM` functions should return a `teardown` function.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/environment.md#_snippet_1

LANGUAGE: TypeScript
CODE:
```
import type { Environment } from 'vitest/environments'

export default <Environment>{
  name: 'custom',
  transformMode: 'ssr',
  // optional - only if you support "experimental-vm" pool
  async setupVM() {
    const vm = await import('node:vm')
    const context = vm.createContext()
    return {
      getVmContext() {
        return context
      },
      teardown() {
        // called after all tests with this env have been run
      }
    }
  },
  setup() {
    // custom setup
    return {
      teardown() {
        // called after all tests with this env have been run
      }
    }
  }
}
```

----------------------------------------

TITLE: Defining and Using toHaveFormValues Matcher in Vitest - TypeScript
DESCRIPTION: Defines the toHaveFormValues matcher, used to assert a form or fieldset's form control values against an expected object. Requires a form or fieldset element; other elements are not supported. Key parameter is expectedValues, an object mapping input names to their expected values (string, number, boolean, or array as appropriate). Handles normalization for various input and select types as described. Output is a pass/fail assertion based on value matching. Limitations: only valid for form/fieldset; cannot be applied to non-form containers.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_20

LANGUAGE: TypeScript
CODE:
```
function toHaveFormValues(expectedValues: Record<string, unknown>): Promise<void>
```

LANGUAGE: TypeScript
CODE:
```
await expect.element(getByTestId('login-form')).toHaveFormValues({
  username: 'jane.doe',
  rememberMe: true,
})
```

----------------------------------------

TITLE: Asserting Nth Function Return Value with Vitest
DESCRIPTION: Verifies that a spy function successfully returned a specific value on a particular call index (1-based). Requires a spy function.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_54

LANGUAGE: typescript
CODE:
```
import { expect, test, vi } from 'vitest'

test('spy function returns bananas on second call', () => {
  const sell = vi.fn((product: string) => ({ product }))

  sell('apples')
  sell('bananas')

  expect(sell).toHaveNthReturnedWith(2, { product: 'bananas' })
})
```

----------------------------------------

TITLE: Using Custom Vitest Reporters via CLI and TypeScript Configuration
DESCRIPTION: Demonstrates how to use third-party or user-defined custom reporters in Vitest by specifying the NPM package name or the file path to the reporter implementation. Custom reporters must implement the Reporter interface as defined in Vitest. The snippet shows enabling a published reporter by name and using a local reporter file path through the CLI and config options.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/reporters.md#_snippet_23

LANGUAGE: bash
CODE:
```
npx vitest --reporter=some-published-vitest-reporter
```

LANGUAGE: typescript
CODE:
```
export default defineConfig({
  test: {
    reporters: ["some-published-vitest-reporter"]
  },
})
```

LANGUAGE: bash
CODE:
```
npx vitest --reporter=./path/to/reporter.ts
```

----------------------------------------

TITLE: Asserting Numeric Property Increase with Vitest - TypeScript
DESCRIPTION: This code tests whether a modifier function increases a numeric property of an object when executed. Dependencies include the Vitest library. Key parameters are the modifier function, the object to modify, the property name, and an optional message. The assertion passes only if the property's value increases after running the modifier.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_104

LANGUAGE: TypeScript
CODE:
```
import { assert, test } from 'vitest'

test('assert.increases', () => {
  const obj = { val: 10 }
  function fn() { obj.val = 13 };
  assert.increases(fn, obj, 'val')
})
```

----------------------------------------

TITLE: Testing vi.doUnmock Behavior in Vitest (TypeScript)
DESCRIPTION: Illustrates the difference between hoisted vi.mock and non-hoisted vi.doUnmock. It shows that vi.doUnmock affects subsequent imports of the module but does not re-evaluate or change modules that have already been imported.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/vi.md#_snippet_12

LANGUAGE: ts
CODE:
```
import { increment } from './increment.js'

// increment is already mocked, because vi.mock is hoisted
increment(1) === 100

// this is hoisted, and factory is called before the import on line 1
vi.mock('./increment.js', () => ({ increment: () => 100 }))

// all calls are mocked, and `increment` always returns 100
increment(1) === 100
increment(30) === 100

// this is not hoisted, so other import will return unmocked module
vi.doUnmock('./increment.js')

// this STILL returns 100, because `vi.doUnmock` doesn't reevaluate a module
increment(1) === 100
increment(30) === 100

// the next import is unmocked, now `increment` is the original function that returns count + 1
const { increment: unmockedIncrement } = await import('./increment.js')

unmockedIncrement(1) === 2
unmockedIncrement(30) === 31
```

----------------------------------------

TITLE: Defining and Using toHaveClass Matcher in Vitest - TypeScript
DESCRIPTION: This code defines the TypeScript signatures for the toHaveClass matcher and demonstrates usage in testing if elements have specific classes. It supports both string and RegExp inputs for class name matching, with an optional exact option to assert for an exact set of classes. Dependencies include a Vitest testing environment and DOM querying utilities like getByTestId. Key parameters are classNames (string or RegExp) and an optional options object with the exact property. The input consists of elements with class attributes, and the output is an assertion pass/fail about class presence. Limitation: exact: true cannot be set if only regular expressions are used.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_16

LANGUAGE: TypeScript
CODE:
```
function toHaveClass(...classNames: string[], options?: { exact: boolean }): Promise<void>
function toHaveClass(...classNames: (string | RegExp)[]): Promise<void>
```

LANGUAGE: TypeScript
CODE:
```
const deleteButton = getByTestId('delete-button')
const noClasses = getByTestId('no-classes')

await expect.element(deleteButton).toHaveClass('extra')
await expect.element(deleteButton).toHaveClass('btn-danger btn')
await expect.element(deleteButton).toHaveClass(/danger/, 'btn')
await expect.element(deleteButton).toHaveClass('btn-danger', 'btn')
await expect.element(deleteButton).not.toHaveClass('btn-link')
await expect.element(deleteButton).not.toHaveClass(/link/)

// ⚠️ regexp matches against individual classes, not the whole classList
await expect.element(deleteButton).not.toHaveClass(/btn extra/)

// the element has EXACTLY a set of classes (in any order)
await expect.element(deleteButton).toHaveClass('btn-danger extra btn', {
  exact: true
})
// if it has more than expected it is going to fail
await expect.element(deleteButton).not.toHaveClass('btn-danger extra', {
  exact: true
})

await expect.element(noClasses).not.toHaveClass()
```

----------------------------------------

TITLE: Asserting a Value is Not a Boolean using Vitest (TypeScript)
DESCRIPTION: Shows how to use `assert.isNotBoolean` in a Vitest test to verify that a variable is not a boolean. Requires `assert` and `test` from 'vitest'.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_37

LANGUAGE: typescript
CODE:
```
import { assert, test } from 'vitest'

const isReady = 'sure'

test('assert.isBoolean', () => {
  assert.isBoolean(isReady, 'isReady is not a boolean but string')
})
```

----------------------------------------

TITLE: Configuring Custom Coverage Reporters in Vitest (TypeScript)
DESCRIPTION: Examples showing how to configure custom coverage reporters in Vitest. It demonstrates specifying reporters by NPM package name or local file path, with or without options.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_38

LANGUAGE: typescript
CODE:
```
{
    reporter: [
      // Specify reporter using name of the NPM package
      '@vitest/custom-coverage-reporter',
      ['@vitest/custom-coverage-reporter', { someOption: true }],

      // Specify reporter using local path
      '/absolute/path/to/custom-reporter.cjs',
      ['/absolute/path/to/custom-reporter.cjs', { someOption: true }],
    ]
  }
```

----------------------------------------

TITLE: Configuring WebdriverIO Types in tsconfig.json
DESCRIPTION: Updates the `compilerOptions.types` array in the `tsconfig.json` file to explicitly include the type definitions for Vitest's WebdriverIO provider. Adding specific types here disables the default auto-loading of `@types/*` packages.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/webdriverio.md#_snippet_1

LANGUAGE: json
CODE:
```
{
  "compilerOptions": {
    "types": ["@vitest/browser/providers/webdriverio"]
  }
}
```

----------------------------------------

TITLE: Defining Custom Matcher with expect.extend in Vitest (TypeScript)
DESCRIPTION: This snippet demonstrates how to define a custom matcher, `toBeFoo`, using `expect.extend`. It checks if the received value is exactly 'foo'. The example shows how to use the custom matcher in a standard assertion and as an asymmetric matcher within `toEqual`.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_73

LANGUAGE: TypeScript
CODE:
```
import { expect, test } from 'vitest'

test('custom matchers', () => {
  expect.extend({
    toBeFoo: (received, expected) => {
      if (received !== 'foo') {
        return {
          message: () => `expected ${received} to be foo`,
          pass: false,
        }
      }
    },
  })

  expect('foo').toBeFoo()
  expect({ foo: 'foo' }).toEqual({ foo: expect.toBeFoo() })
})
```

----------------------------------------

TITLE: CLI Command for Debugging Vitest (Version >= 1.1)
DESCRIPTION: This bash command launches Vitest with debugging enabled, disabling file parallelism using `--no-file-parallelism`. Requires Vitest version 1.1 or higher to be installed.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/debugging.md#_snippet_6

LANGUAGE: sh
CODE:
```
# If pool is unknown
vitest --inspect-brk --no-file-parallelism
```

----------------------------------------

TITLE: Using toBePartiallyChecked Assertion for Mixed and Indeterminate Checkboxes - TypeScript
DESCRIPTION: This code snippet demonstrates retrieving checkbox elements in various states and asserting whether they are partially checked using `toBePartiallyChecked`. It includes setting the indeterminate property manually for relevant inputs to satisfy the partial check condition.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_36

LANGUAGE: ts
CODE:
```
const ariaCheckboxMixed = getByTestId('aria-checkbox-mixed')
const inputCheckboxChecked = getByTestId('input-checkbox-checked')
const inputCheckboxUnchecked = getByTestId('input-checkbox-unchecked')
const ariaCheckboxChecked = getByTestId('aria-checkbox-checked')
const ariaCheckboxUnchecked = getByTestId('aria-checkbox-unchecked')
const inputCheckboxIndeterminate = getByTestId('input-checkbox-indeterminate')

await expect.element(ariaCheckboxMixed).toBePartiallyChecked()
await expect.element(inputCheckboxChecked).not.toBePartiallyChecked()
await expect.element(inputCheckboxUnchecked).not.toBePartiallyChecked()
await expect.element(ariaCheckboxChecked).not.toBePartiallyChecked()
await expect.element(ariaCheckboxUnchecked).not.toBePartiallyChecked()

inputCheckboxIndeterminate.element().indeterminate = true
await expect.element(inputCheckboxIndeterminate).toBePartiallyChecked()
```

----------------------------------------

TITLE: Filtering Tests with Vitest CLI - Bash
DESCRIPTION: Demonstrates how to run Vitest in the current directory and filter test files by name inclusion. This command expects Vitest to be installed globally or available via package scripts and accepts an argument that filters test file paths for matches containing the given string. The filter is a simple substring match, not a glob or regex. Input: "foobar" as the file filter. Output: Runs only test files whose path includes "foobar". No external dependencies besides Vitest itself.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/cli.md#_snippet_0

LANGUAGE: bash
CODE:
```
vitest foobar

```

----------------------------------------

TITLE: Asserting Reference Inequality with not.toBe in Vitest (TypeScript)
DESCRIPTION: This example demonstrates using `not.toBe` to assert that two distinct objects, even if they have the same properties and values, are not the same instance in memory (i.e., they do not have the same reference).
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_26

LANGUAGE: TypeScript
CODE:
```
import { expect, test } from 'vitest'

const stockBill = {
  type: 'apples',
  count: 13,
}

const stockMary = {
  type: 'apples',
  count: 13,
}

test('stocks are not the same', () => {
  expect(stockBill).not.toBe(stockMary)
})
```

----------------------------------------

TITLE: Using Expect Context with Concurrent Tests
DESCRIPTION: Illustrates the use of the context-bound 'expect' API within concurrent tests, which is necessary for correctly tracking snapshot tests when run in parallel.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/test-context.md#_snippet_2

LANGUAGE: TypeScript
CODE:
```
import { it } from 'vitest'

it.concurrent('math is easy', ({ expect }) => {
  expect(2 + 2).toMatchInlineSnapshot()
})

it.concurrent('math is hard', ({ expect }) => {
  expect(2 * 2).toMatchInlineSnapshot()
})
```

----------------------------------------

TITLE: Matching Snapshot Shape with Vitest toMatchSnapshot (TypeScript)
DESCRIPTION: Shows how to use `toMatchSnapshot` with an optional shape argument. This allows matching only a subset of properties or their types in the received value, rather than requiring an exact match of the entire object structure.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_38

LANGUAGE: TypeScript
CODE:
```
import { expect, test } from 'vitest'

test('matches snapshot', () => {
  const data = { foo: new Set(['bar', 'snapshot']) }
  expect(data).toMatchSnapshot({ foo: expect.any(Set) })
})
```

----------------------------------------

TITLE: Setting Debugging Port in Vitest
DESCRIPTION: This bash command runs Vitest with a specified debugging port.  It overrides the default port `9229` with `3000`. `--inspect-brk=127.0.0.1:3000` sets the debugging port, `--browser` enables browser mode, and `--no-file-parallelism` disables parallel execution.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/debugging.md#_snippet_3

LANGUAGE: bash
CODE:
```
vitest --inspect-brk=127.0.0.1:3000 --browser --no-file-parallelism
```

----------------------------------------

TITLE: toHaveResolved - Vitest Assertion (TypeScript)
DESCRIPTION: This assertion checks if a function has successfully resolved a value at least once (i.e., did not reject). Requires a spy function to be passed to `expect`. If the function returned a promise, but it was not resolved yet, this will fail.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_55

LANGUAGE: ts
CODE:
```
import { expect, test, vi } from 'vitest'
import db from './db/apples.js'

async function getApplesPrice(amount: number) {
  return amount * await db.get('price')
}

test('spy function resolved a value', async () => {
  const getPriceSpy = vi.fn(getApplesPrice)

  const price = await getPriceSpy(10)

  expect(price).toBe(100)
  expect(getPriceSpy).toHaveResolved()
})
```

----------------------------------------

TITLE: Asserting Function Return with Vitest
DESCRIPTION: Confirms that a spy function has successfully returned a value at least once without throwing an error. Requires a spy function.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_50

LANGUAGE: typescript
CODE:
```
import { expect, test, vi } from 'vitest'

function getApplesPrice(amount: number) {
  const PRICE = 10
  return amount * PRICE
}

test('spy function returned a value', () => {
  const getPriceSpy = vi.fn(getApplesPrice)

  const price = getPriceSpy(10)

  expect(price).toBe(100)
  expect(getPriceSpy).toHaveReturned()
})
```

----------------------------------------

TITLE: Define Custom Test Environment (TS)
DESCRIPTION: Provides an example of defining a custom test environment in TypeScript. It shows the required `Environment` interface structure, including `name`, `transformMode`, and `setup` with an optional `teardown` function.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_15

LANGUAGE: ts
CODE:
```
import type { Environment } from 'vitest'

export default <Environment>{
  name: 'custom',
  transformMode: 'ssr',
  setup() {
    // custom setup
    return {
      teardown() {
        // called after all tests with this env have been run
      }
    }
  }
}
```

----------------------------------------

TITLE: Testing a Web Worker with Vitest (TypeScript)
DESCRIPTION: Demonstrates how to test a Web Worker in a Vitest test file (`worker.test.ts`). It imports `@vitest/web-worker` for setup, instantiates the worker using either the `?worker` import syntax or the standard `new Worker(URL)` constructor, sends data using `worker.postMessage`, and receives the response via the `worker.onmessage` event handler.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/packages/web-worker/README.md#_snippet_4

LANGUAGE: typescript
CODE:
```
// worker.test.ts
import '@vitest/web-worker'
import MyWorker from '../worker?worker'

let worker = new MyWorker()
// new Worker is also supported
worker = new Worker(new URL('../src/worker.ts', import.meta.url))

worker.postMessage('hello')
worker.onmessage = (e) => {
  // e.data equals to 'hello world'
}
```

----------------------------------------

TITLE: Configure Vitest Test Shuffling (sequence.shuffle.tests)
DESCRIPTION: Determines if individual tests within files are run in a random order. The default setting is `false`.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/cli-generated.md#_snippet_28

LANGUAGE: CLI
CODE:
```
--sequence.shuffle.tests
```

LANGUAGE: Config
CODE:
```
sequence.shuffle.tests
```

----------------------------------------

TITLE: Configuring Vitest Threads Pool Test Runner for CPU and Heap Profiling in TypeScript
DESCRIPTION: This TypeScript snippet demonstrates configuring Vitest's test runner with 'threads' pool for CPU and heap profiling. It sets execArgv flags similar to the forks configuration, directing profiling outputs to 'test-runner-profile' and enables a single thread profile generation via 'singleThread: true'. Required dependencies include Node.js and Vitest basics. Tests are executed with these profiling flags producing profiling files for analysis. It is important to note that some profiling options may be limited or incompatible with worker threads in Node.js.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/profiling-test-performance.md#_snippet_1

LANGUAGE: typescript
CODE:
```
import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    pool: 'threads',
    poolOptions: {
      threads: {
        execArgv: [
          '--cpu-prof',
          '--cpu-prof-dir=test-runner-profile',
          '--heap-prof',
          '--heap-prof-dir=test-runner-profile'
        ],

        // To generate a single profile
        singleThread: true,
      },
    },
  },
})
```

----------------------------------------

TITLE: Adding TypeScript Types for Custom Vitest Matchers
DESCRIPTION: This TypeScript snippet shows how to extend the default `Assertion` and `AsymmetricMatchersContaining` interfaces in a declaration file (e.g., `vitest.d.ts`) to provide type safety and autocompletion for custom matchers defined with `expect.extend`.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect.md#_snippet_74

LANGUAGE: TypeScript
CODE:
```
interface CustomMatchers<R = unknown> {
  toBeFoo: () => R
}

declare module 'vitest' {
  interface Assertion<T = any> extends CustomMatchers<T> {}
  interface AsymmetricMatchersContaining extends CustomMatchers {}
}
```

----------------------------------------

TITLE: Configuring Verbose Reporter
DESCRIPTION: This snippet demonstrates configuring the `verbose` reporter. It configures the reporter by setting the `reporters` array to `['verbose']`.  The verbose reporter displays each individual test after the suite has finished and also displays currently running tests that are taking longer than [`slowTestThreshold`](/config/#slowtestthreshold).
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/reporters.md#_snippet_10

LANGUAGE: ts
CODE:
```
export default defineConfig({
  test: {
    reporters: [
      ['verbose', { summary: false }]
    ]
  },
})

```

----------------------------------------

TITLE: Registering onTestFinished Hook for Concurrent Tests in Vitest (TypeScript)
DESCRIPTION: This example shows the recommended way to use `onTestFinished` with concurrent tests. The hook is accessed from the test context object passed to the test callback, ensuring it is correctly associated with the specific concurrent test instance for reliable per-test cleanup.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/index.md#_snippet_57

LANGUAGE: ts
CODE:
```
import { test } from 'vitest'

test.concurrent('performs a query', ({ onTestFinished }) => {
  const db = connectDb()
  onTestFinished(() => db.close())
  db.query('SELECT * FROM users')
})
```

----------------------------------------

TITLE: Registering onTestFailed Hook for Concurrent Tests in Vitest (TypeScript)
DESCRIPTION: This example demonstrates the recommended way to use `onTestFailed` with concurrent tests. By accessing the hook from the test context, the callback is correctly associated with the failing concurrent test instance, allowing for reliable debugging by logging errors specific to that test.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/index.md#_snippet_60

LANGUAGE: ts
CODE:
```
import { test } from 'vitest'

test.concurrent('performs a query', ({ onTestFailed }) => {
  const db = connectDb()
  onTestFailed(({ task }) => {
    console.log(task.result.errors)
  })
  db.query('SELECT * FROM users')
})
```

----------------------------------------

TITLE: Running Vitest Sharded Tests (CLI)
DESCRIPTION: Describes how to split Vitest test execution into smaller subsets (shards) across multiple machines or processes using the `--shard` option. Requires the `--reporter=blob` option to save results for later merging.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/improving-performance.md#_snippet_3

LANGUAGE: sh
CODE:
```
vitest run --reporter=blob --shard=1/3 # 1st machine
vitest run --reporter=blob --shard=2/3 # 2nd machine
vitest run --reporter=blob --shard=3/3 # 3rd machine
```

----------------------------------------

TITLE: Using test.concurrent.for with TestContext (Vitest, TypeScript)
DESCRIPTION: Demonstrates using `test.for` with the `concurrent` modifier, which allows accessing the `TestContext` object as the second parameter in the test function. This context can be used for features like concurrent snapshot testing.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/index.md#_snippet_26

LANGUAGE: TypeScript
CODE:
```
test.concurrent.for([
  [1, 1],
  [1, 2],
  [2, 1]
])('add(%i, %i)', ([a, b], { expect }) => {
  expect(a + b).matchSnapshot()
})
```

----------------------------------------

TITLE: Custom Snapshot Serializer Module (TypeScript)
DESCRIPTION: This code defines a custom snapshot serializer as a module that can be imported into the Vitest config. This allows you to reuse the serializer across multiple tests. Dependencies: vitest. Input: Value to serialize. Output: Serialized string representation of the value.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/snapshot.md#_snippet_7

LANGUAGE: typescript
CODE:
```
import { SnapshotSerializer } from 'vitest'

export default {
  serialize(val, config, indentation, depth, refs, printer) {
    // `printer` is a function that serializes a value using existing plugins.
    return `Pretty foo: ${printer(
      val.foo,
      config,
      indentation,
      depth,
      refs,
    )}`
  },
  test(val) {
    return val && Object.prototype.hasOwnProperty.call(val, 'foo')
  },
} satisfies SnapshotSerializer
```

----------------------------------------

TITLE: Inspecting Mock Settled Promise Results with mock.settledResults (TypeScript/JavaScript)
DESCRIPTION: The `mock.settledResults` property tracks the settled outcomes (fulfilled or rejected) of promises returned by the mock function. It's an array of objects, each with a `type` ('fulfilled' or 'rejected') and the corresponding resolved `value` or rejection reason. This array populates only after the promises have settled.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/mock.md#_snippet_19

LANGUAGE: typescript
CODE:
```
interface MockSettledResultFulfilled<T> {
  type: 'fulfilled'
  value: T
}

interface MockSettledResultRejected {
  type: 'rejected'
  value: any
}

export type MockSettledResult<T> =
  | MockSettledResultFulfilled<T>
  | MockSettledResultRejected

const settledResults: MockSettledResult<Awaited<ReturnType<T>>>[]
```

LANGUAGE: javascript
CODE:
```
const fn = vi.fn().mockResolvedValueOnce('result')

const result = fn()

fn.mock.settledResults === []

await result

fn.mock.settledResults === [
  {
    type: 'fulfilled',
    value: 'result',
  },
]
```

----------------------------------------

TITLE: Fail Assertion with Vitest
DESCRIPTION: This code showcases how to intentionally force an assertion failure. It can be used to verify failure scenarios or to signal that a code path should not be reached. Requires the `vitest` testing framework. It takes an optional message as input and always results in test failure. The second usage takes actual, expected, message, and operator.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_1

LANGUAGE: TypeScript
CODE:
```
import { assert, test } from 'vitest'

test('assert.fail', () => {
  assert.fail('error message on failure')
  assert.fail('foo', 'bar', 'foo is not bar', '===')
})
```

----------------------------------------

TITLE: Testing Asynchronous Code with Vitest Using Promise Pattern in JavaScript
DESCRIPTION: This snippet illustrates how to handle asynchronous tests by returning a Promise from the test function in Vitest. The Promise constructor receives a done callback, which is called inside the Promise to indicate completion. This approach replaces explicit done callback parameters and leverages promise resolution. Vitest and JavaScript promise support are required. The test function returns a Promise that resolves when the async process completes.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/examples/promise-done.md#_snippet_1

LANGUAGE: JavaScript
CODE:
```
it('should work', () => new Promise(done => { // [!code ++]
  // ...
  done()
}) // [!code --]
})) // [!code ++]
```

----------------------------------------

TITLE: HTML Context for toHaveFormValues Usage - HTML
DESCRIPTION: Sample form with username, password, and a checked rememberMe checkbox. Test ID allows the element to be located in the TypeScript test code. Used for demonstrating toHaveFormValues assertions.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_21

LANGUAGE: HTML
CODE:
```
<form data-testid="login-form">
  <input type="text" name="username" value="jane.doe" />
  <input type="password" name="password" value="12345678" />
  <input type="checkbox" name="rememberMe" checked />
  <button type="submit">Sign in</button>
</form>
```

----------------------------------------

TITLE: Vitest Bench Options Interface
DESCRIPTION: Defines the interface for the optional configuration object passed to the `bench` function in Vitest. It includes properties for controlling benchmark duration, iterations, timing source, abort signals, error handling, warmup phases, and setup/teardown hooks.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/index.md#_snippet_28

LANGUAGE: ts
CODE:
```
export interface Options {
  /**
   * time needed for running a benchmark task (milliseconds)
   * @default 500
   */
  time?: number

  /**
   * number of times that a task should run if even the time option is finished
   * @default 10
   */
  iterations?: number

  /**
   * function to get the current timestamp in milliseconds
   */
  now?: () => number

  /**
   * An AbortSignal for aborting the benchmark
   */
  signal?: AbortSignal

  /**
   * Throw if a task fails (events will not work if true)
   */
  throws?: boolean

  /**
   * warmup time (milliseconds)
   * @default 100ms
   */
  warmupTime?: number

  /**
   * warmup iterations
   * @default 5
   */
  warmupIterations?: number

  /**
   * setup function to run before each benchmark task (cycle)
   */
  setup?: Hook

  /**
   * teardown function to run after each benchmark task (cycle)
   */
  teardown?: Hook
}
```

----------------------------------------

TITLE: Coverage Allow External Option
DESCRIPTION: Collects coverage of files located outside the project root. Can be enabled via the CLI using `--coverage.allowExternal` or in the configuration file using the `coverage.allowExternal` property. Defaults to `false`.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/cli-generated.md#_snippet_26



----------------------------------------

TITLE: Example Usage of Custom Serializer (TypeScript)
DESCRIPTION: This shows an example of how a custom serializer is used in a test. It defines a simple object and then uses `toMatchSnapshot` to create a snapshot using the defined custom serializer. Dependencies: custom serializer. Input: Object to serialize. Output: Snapshot of the serialized object.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/snapshot.md#_snippet_9

LANGUAGE: typescript
CODE:
```
test('foo snapshot test', () => {
  const bar = {
    foo: {
      x: 1,
      y: 2,
    },
  }

  expect(bar).toMatchSnapshot()
})
```

----------------------------------------

TITLE: Conditionally Running a Vitest describe Suite (TypeScript)
DESCRIPTION: Demonstrates how to use `describe.runIf` to conditionally run a test suite based on a boolean condition, the opposite of `describe.skipIf`.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/index.md#_snippet_39

LANGUAGE: TypeScript
CODE:
```
import { assert, describe, test } from 'vitest'

const isDev = process.env.NODE_ENV === 'development'

describe.runIf(isDev)('dev only test suite', () => {
  // this test suite only runs in development
})
```

----------------------------------------

TITLE: Modifying Global Vitest Config (TypeScript)
DESCRIPTION: Demonstrates how to access and modify the global Vitest configuration object (`vitest.config`) directly within the `configureVitest` hook. Examples include disabling coverage and adding a new reporter, noting that the configuration is already resolved at this stage.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/plugin.md#_snippet_2

LANGUAGE: ts
CODE:
```
vitest.config.coverage.enabled = false
vitest.config.reporters.push([['my-reporter', {}]])
```

----------------------------------------

TITLE: Vitest Test Sharding for High CPU Machines (Shell)
DESCRIPTION: Illustrates using test sharding on a single high-CPU machine to distribute the load from the Vite server bottleneck. It shows how to run multiple sharded processes in parallel using `&` and `wait`, limiting the threads per process with `VITEST_MAX_THREADS`.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/improving-performance.md#_snippet_6

LANGUAGE: sh
CODE:
```
# Example for splitting tests on 32 CPU to 4 shards.
# As each process needs 1 main thread, there's 7 threads for test runners (1+7)*4 = 32
# Use VITEST_MAX_THREADS or VITEST_MAX_FORKS depending on the pool:
VITEST_MAX_THREADS=7 vitest run --reporter=blob --shard=1/4 & \
VITEST_MAX_THREADS=7 vitest run --reporter=blob --shard=2/4 & \
VITEST_MAX_THREADS=7 vitest run --reporter=blob --shard=3/4 & \
VITEST_MAX_THREADS=7 vitest run --reporter=blob --shard=4/4 & \
wait # https://man7.org/linux/man-pages/man2/waitpid.2.html

vitest run --merge-reports
```

----------------------------------------

TITLE: Ordered Members Equality Assertion (TypeScript)
DESCRIPTION: Defines `assert.sameOrderedMembers` to assert two arrays have identical elements in the same order, using strict equality. Demonstrates its usage in a test.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_87

LANGUAGE: TypeScript
CODE:
```
import { assert, test } from 'vitest'

 test('assert.sameOrderedMembers', () => {
  assert.sameOrderedMembers([1, 2, 3], [1, 2, 3], 'same ordered members')
})
```

----------------------------------------

TITLE: Configuring Vitest to Include Source Files (TypeScript)
DESCRIPTION: This snippet demonstrates how to configure Vitest using `defineConfig` to include source files (JavaScript and TypeScript) for in-source testing. By setting `includeSource` in `test` options, it instructs Vitest to search and execute tests embedded within files in the `src/` directory. The configuration is required to enable in-source testing support.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/in-source.md#_snippet_1

LANGUAGE: TypeScript
CODE:
```
import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    includeSource: ['src/**/*.{js,ts}'] // [!code ++]
  }
})
```

----------------------------------------

TITLE: Configuring Snapshot Serializers in Vitest (TypeScript)
DESCRIPTION: This code shows how to configure the `snapshotSerializers` option in the `vitest.config.ts` file to implicitly add custom serializers to your tests. Dependencies: vitest. Input: none. Output: Configuration of snapshot serializers.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/snapshot.md#_snippet_8

LANGUAGE: typescript
CODE:
```
import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    snapshotSerializers: ['path/to/custom-serializer.ts'],
  },
})
```

----------------------------------------

TITLE: Running Only a Specific Benchmark with Vitest
DESCRIPTION: This snippet demonstrates the use of `bench.only` to isolate and run only a particular benchmark within a suite. This is commonly used for debugging or focusing on a single performance test.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/index.md#_snippet_32

LANGUAGE: ts
CODE:
```
import { bench } from 'vitest'

bench.only('normal sorting', () => {
  const x = [1, 5, 4, 2, 3]
  x.sort((a, b) => {
    return a - b
  })
})
```

----------------------------------------

TITLE: Marking Expected Failing Tests with Vitest (TypeScript)
DESCRIPTION: Demonstrates the use of `test.fails` to indicate that a test is expected to fail. This prevents the overall test run from failing when the assertion within the `test.fails` block fails. This syntax is not available when using Vitest as a type checker.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/index.md#_snippet_19

LANGUAGE: TypeScript
CODE:
```
import { expect, test } from 'vitest'

function myAsyncFunc() {
  return new Promise(resolve => resolve(1))
}
test.fails('fail test', async () => {
  await expect(myAsyncFunc()).rejects.toBe(1)
})
```

----------------------------------------

TITLE: Example HTML Structure for toHaveDisplayValue Usage - HTML
DESCRIPTION: This HTML snippet provides example form elements including text input, textarea, single select, and multiple select with various option values. These serve as test targets for the `toHaveDisplayValue` function to verify visible values shown to users.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_29

LANGUAGE: html
CODE:
```
<label for="input-example">First name</label>
<input type="text" id="input-example" value="Luca" />

<label for="textarea-example">Description</label>
<textarea id="textarea-example">An example description here.</textarea>

<label for="single-select-example">Fruit</label>
<select id="single-select-example">
  <option value="">Select a fruit...</option>
  <option value="banana">Banana</option>
  <option value="ananas">Ananas</option>
  <option value="avocado">Avocado</option>
</select>

<label for="multiple-select-example">Fruits</label>
<select id="multiple-select-example" multiple>
  <option value="">Select a fruit...</option>
  <option value="banana" selected>Banana</option>
  <option value="ananas">Ananas</option>
  <option value="avocado" selected>Avocado</option>
</select>
```

----------------------------------------

TITLE: Object Property Change Assertion (TypeScript)
DESCRIPTION: Defines `assert.changes` to verify that executing a modifier function alters a specified property of an object.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_100

LANGUAGE: TypeScript
CODE:
```
import { assert, test } from 'vitest'

 test('assert.changes', () => {
  const obj = { val: 10 }
  function fn() { obj.val = 22 };
  assert.changes(fn, obj, 'val')
})
```

----------------------------------------

TITLE: In-Source Testing with Vitest TypeScript API (Inspired by Rust)
DESCRIPTION: This snippet shows how to co-locate implementation and test code within the same TypeScript source file, leveraging the 'import.meta.vitest' property. Dependencies include TypeScript, Vitest, and a setup that recognizes 'import.meta.vitest'. The test context is conditionally imported, and tests are defined in the same closure as the implementation, facilitating direct access to private states. Inputs are typical function arguments; outputs are assertions on function behavior. This setup reduces the need for exports solely for testing purposes.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/features.md#_snippet_9

LANGUAGE: typescript
CODE:
```
// the implementation
export function add(...args: number[]): number {
  return args.reduce((a, b) => a + b, 0)
}

// in-source test suites
if (import.meta.vitest) {
  const { it, expect } = import.meta.vitest
  it('add', () => {
    expect(add()).toBe(0)
    expect(add(1)).toBe(1)
    expect(add(1, 2, 3)).toBe(6)
  })
}

```

----------------------------------------

TITLE: Configuring Browser Instances in Vitest with TypeScript
DESCRIPTION: Demonstrates migrating from deprecated 'browser.name' and 'browser.providerOptions' to the new 'browser.instances' configuration array in Vitest 4. Utilizes defineConfig to export the configuration object with multiple browser instance objects. Requires TypeScript and Vitest configuration context.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/migration.md#_snippet_1

LANGUAGE: TypeScript
CODE:
```
export default defineConfig({
  test: {
    browser: {
      // Deprecated
      name: 'chromium',
      providerOptions: {
        launch: { devtools: true },
      },
      // Recommended
      instances: [
        {
          browser: 'chromium',
          launch: { devtools: true },
        },
      ],
    },
  },
})
```

----------------------------------------

TITLE: Strict Error Comparison with expect in Vitest (TypeScript)
DESCRIPTION: Shows how Vitest 3.0 introduces stricter error object comparisons via toEqual and toThrowError. Demonstrates asymmetric and type-based error matching. Requires 'expect' and can be used when testing for thrown errors with additional properties (like cause) or specific error prototypes.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/migration.md#_snippet_5

LANGUAGE: TypeScript
CODE:
```
expect(new Error('hi', { cause: 'x' })).toEqual(new Error('hi')) // ✅
expect(new Error('hi')).toEqual(new Error('hi', { cause: 'x' })) // ❌
```

LANGUAGE: TypeScript
CODE:
```
expect(() => {
  throw new TypeError('type error')
})
  .toThrowError(new Error('type error'))
  .toThrowError(new TypeError('type error'))
```

----------------------------------------

TITLE: Disabling Vitest File Parallelism (CLI & Config)
DESCRIPTION: Shows how to prevent multiple test files from running in parallel to potentially improve startup time. This can be achieved using the `--no-file-parallelism` CLI flag or the `test.fileParallelism` config option.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/improving-performance.md#_snippet_1

LANGUAGE: bash
CODE:
```
vitest --no-file-parallelism
```

LANGUAGE: ts
CODE:
```
import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    fileParallelism: false,
  },
})
```

----------------------------------------

TITLE: Using assert.nestedProperty in Vitest (TypeScript)
DESCRIPTION: Demonstrates `assert.nestedProperty`, which asserts that an object has a nested property specified using dot or bracket notation. The example imports from `vitest` and checks for the existence of 'tea.green' within a test.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_62

LANGUAGE: typescript
CODE:
```
import { assert, test } from 'vitest'

test('assert.deepPropertyVal', () => { // Note: Test name seems incorrect in original text, likely should be assert.nestedProperty
  assert.nestedProperty({ tea: { green: 'matcha' } }, 'tea.green')
})
```

----------------------------------------

TITLE: Using assert.property in Vitest (TypeScript)
DESCRIPTION: Demonstrates the `assert.property` method, which asserts that an object possesses a specified property, either directly or inherited. The example imports from `vitest` and shows checks for both a direct property ('tea') and an inherited property ('toString') within a test.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_56

LANGUAGE: typescript
CODE:
```
import { assert, test } from 'vitest'

test('assert.property', () => {
  assert.property({ tea: { green: 'matcha' } }, 'tea')
  assert.property({ tea: { green: 'matcha' } }, 'toString')
})
```

----------------------------------------

TITLE: Enabling TypeScript Definitions for import.meta.vitest
DESCRIPTION: Configures TypeScript's `tsconfig.json` to include type declarations for `import.meta.vitest` by adding `vitest/importMeta` under `types`. This provides proper typing within source files so that Vitest's testing API is accessible and type-safe. Required for full TypeScript support when writing in-source Vitest tests.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/in-source.md#_snippet_6

LANGUAGE: JSON
CODE:
```
{
  "compilerOptions": {
    "types": [
      "vitest/importMeta" // [!code ++]
    ]
  }
}
```

----------------------------------------

TITLE: Running Sequential Tests within Vitest Concurrent Suites (TS)
DESCRIPTION: The `describe.sequential` (or `suite.sequential`) method can be used inside a `describe.concurrent` suite to force tests within the sequential suite to run one after another. This is useful for tests that have dependencies or cannot run in parallel.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/index.md#_snippet_44

LANGUAGE: typescript
CODE:
```
import { describe, test } from 'vitest'

describe.concurrent('suite', () => {
  test('concurrent test 1', async () => { /* ... */ })
  test('concurrent test 2', async () => { /* ... */ })

  describe.sequential('', () => {
    test('sequential test 1', async () => { /* ... */ })
    test('sequential test 2', async () => { /* ... */ })
  })
})
```

----------------------------------------

TITLE: Reusing Mocked Methods with vi.spyOn in Vitest (TypeScript)
DESCRIPTION: Demonstrates the updated behavior where vi.spyOn reuses an existing mock if the method is already mocked, preventing duplicate spies. Illustrates sequence of spy, mock, restore, and verification steps. Vi.isMockFunction is used to assert the true/false state before and after restoreAllMocks. Dependencies: 'vi.spyOn', 'vi.restoreAllMocks', 'vi.isMockFunction'.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/migration.md#_snippet_3

LANGUAGE: TypeScript
CODE:
```
vi.spyOn(fooService, 'foo').mockImplementation(() => 'bar')
vi.spyOn(fooService, 'foo').mockImplementation(() => 'bar')
vi.restoreAllMocks()
vi.isMockFunction(fooService.foo) // true
vi.isMockFunction(fooService.foo) // false
```

----------------------------------------

TITLE: Configure Vitest diff option with object (TypeScript)
DESCRIPTION: Configures the display of diff results directly within the Vitest configuration object. Allows customization of indicators for added/removed lines and control over annotation lines. Requires importing `picocolors` for colored output.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/config/index.md#_snippet_52

LANGUAGE: ts
CODE:
```
import { defineConfig } from 'vitest/config'
import c from 'picocolors'

export default defineConfig({
  test: {
    diff: {
      aIndicator: c.bold('--'),
      bIndicator: c.bold('++'),
      omitAnnotationLines: true,
    },
  },
})
```

----------------------------------------

TITLE: Defining Default and Injected Fixture Values in Vitest
DESCRIPTION: Shows how to define a fixture with a default value using the tuple syntax and mark it as `{ injected: true }`. This allows the value to be overridden in different Vitest project configurations.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/test-context.md#_snippet_12

LANGUAGE: ts
CODE:
```
import { test as base } from 'vitest'

const test = base.extend({
  url: [
    // default value if "url" is not defined in the config
    '/default',
    // mark the fixture as "injected" to allow the override
    { injected: true },
  ],
})

test('works correctly', ({ url }) => {
  // url is "/default" in "project-new"
  // url is "/full" in "project-full"
  // url is "/empty" in "project-empty"
})
```

LANGUAGE: ts
CODE:
```
import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    projects: [
      {
        test: {
          name: 'project-new',
        },
      },
      {
        test: {
          name: 'project-full',
          provide: {
            url: '/full',
          },
        },
      },
      {
        test: {
          name: 'project-empty',
          provide: {
            url: '/empty',
          },
        },
      },
    ],
  },
})
```

----------------------------------------

TITLE: Vitest List Command Output Example - Plain Text
DESCRIPTION: Shows sample output for the 'vitest list' command, including nested describe/test structure, as well as output when using --filesOnly (plain text). Inputs: combinations of CLI filters. Output: Human-readable listing of test suites or file paths. Dependency: Vitest CLI.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/cli.md#_snippet_8

LANGUAGE: txt
CODE:
```
describe > some-test
describe > some-test > test 1
describe > some-test > test 2

```

LANGUAGE: txt
CODE:
```
tests/test1.test.ts
tests/test2.test.ts

```

----------------------------------------

TITLE: Using assert.propertyVal in Vitest (TypeScript)
DESCRIPTION: Shows how to use `assert.propertyVal` to assert that an object has a specific property (direct or inherited) with a particular value, using strict equality (===). The example imports from `vitest` and checks if the 'tea' property equals 'is good' within a test.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_58

LANGUAGE: typescript
CODE:
```
import { assert, test } from 'vitest'

test('assert.notPropertyVal', () => { // Note: Test name seems incorrect in original text, likely should be assert.propertyVal
  assert.propertyVal({ tea: 'is good' }, 'tea', 'is good')
})
```

----------------------------------------

TITLE: Adding a Custom Snapshot Serializer (TypeScript)
DESCRIPTION: This code demonstrates how to add a custom snapshot serializer using `expect.addSnapshotSerializer`. This allows you to alter how values are serialized before being stored as a snapshot. Dependencies: vitest. Input: Value to serialize. Output: Serialized string representation of the value.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/snapshot.md#_snippet_6

LANGUAGE: typescript
CODE:
```
expect.addSnapshotSerializer({
  serialize(val, config, indentation, depth, refs, printer) {
    // `printer` is a function that serializes a value using existing plugins.
    return `Pretty foo: ${printer(
      val.foo,
      config,
      indentation,
      depth,
      refs,
    )}`
  },
  test(val) {
    return val && Object.prototype.hasOwnProperty.call(val, 'foo')
  },
})
```

----------------------------------------

TITLE: Writing Reporter Output to File - Configuration
DESCRIPTION: This code snippet shows how to configure the reporter in the `vitest.config.ts` file to write the output to a file.  It configures the 'json' reporter and specifies the output file path using the `outputFile` configuration option. The output file will contain the test results in JSON format.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/reporters.md#_snippet_4

LANGUAGE: ts
CODE:
```
export default defineConfig({
  test: {
    reporters: ['json'],
    outputFile: './test-output.json'
  },
})

```

----------------------------------------

TITLE: Add Playwright Types to Vitest Shims
DESCRIPTION: Reference the Playwright provider types in a Vitest shims file to enable TypeScript recognition of provider options and extra expect properties.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/playwright.md#_snippet_0

LANGUAGE: TypeScript
CODE:
```
/// <reference types="@vitest/browser/providers/playwright" />
```

----------------------------------------

TITLE: Declaring selectOptions Function in Vitest (TypeScript)
DESCRIPTION: Defines the selectOptions function for interacting with <select> elements, allowing selection by string, HTMLElement(s), or Locator(s). Takes a flexible values argument and optional UserEventSelectOptions; returns a resolved Promise when selection is completed. Useful for automating dropdown and multi-select UI components; requires that corresponding option elements are present and unique.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_42

LANGUAGE: typescript
CODE:
```
function selectOptions(
  values:
    | HTMLElement
    | HTMLElement[]
    | Locator
    | Locator[]
    | string
    | string[],
  options?: UserEventSelectOptions,
): Promise<void>
```

----------------------------------------

TITLE: Checking for `any` Type using Vitest in TypeScript
DESCRIPTION: Uses `.toBeAny` matcher to assert that a provided value is of type `any`. Requires Vitest and operates at the static type level. Enables detection and prevention of overly broad types in code bases.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/expect-typeof.md#_snippet_13

LANGUAGE: TypeScript
CODE:
```
import { expectTypeOf } from 'vitest'

expectTypeOf<any>().toBeAny()
expectTypeOf({} as any).toBeAny()
expectTypeOf('string').not.toBeAny()
```

----------------------------------------

TITLE: Fixture Initialization Based on Usage
DESCRIPTION: Explains that Vitest only initializes fixtures if they are accessed (destructured) within the test function, optimizing test execution by skipping unused fixture setup.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/test-context.md#_snippet_9

LANGUAGE: TypeScript
CODE:
```
import { test as baseTest } from 'vitest'

const test = baseTest.extend<{
  todos: number[]
  archive: number[]
}>({
  todos: async ({ task }, use) => {
    await use([1, 2, 3])
  },
  archive: []
})

// todos will not run
test('skip', () => {})
test('skip', ({ archive }) => {})

// todos will run
test('run', ({ todos }) => {})

```

----------------------------------------

TITLE: HTML Context for toHaveFocus Usage - HTML
DESCRIPTION: Single input element inside a div, with a test ID for retrieval in TypeScript/JS tests. Serves as the node under test for focus assertions. No dependencies beyond standard HTML.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_19

LANGUAGE: HTML
CODE:
```
<div><input type="text" data-testid="element-to-focus" /></div>
```

----------------------------------------

TITLE: Asserting Object Is Sealed with Vitest - TypeScript
DESCRIPTION: Ensures that an object is sealed (cannot add or remove properties) using Vitest's assert.isSealed method. Accepts the object to be checked (e.g., Object.seal or Object.freeze results) and optionally a message. Use to check for prevention of property addition/removal, leveraging JavaScript object sealing features.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_116

LANGUAGE: TypeScript
CODE:
```
import { assert, test } from 'vitest'

test('assert.isSealed', () => {
  const sealedObject = Object.seal({})
  const frozenObject = Object.seal({})

  assert.isSealed(sealedObject)
  assert.isSealed(frozenObject)
})
```

----------------------------------------

TITLE: Accessing Mock Call Contexts (`this`) with mock.contexts (TypeScript/JavaScript)
DESCRIPTION: The `mock.contexts` property stores an array of the `this` context values used during each invocation of the mock function. This is useful for verifying the context in which the mock was called, especially when using methods like `apply` or `call`.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/mock.md#_snippet_21

LANGUAGE: typescript
CODE:
```
const contexts: ThisParameterType<T>[]
```

LANGUAGE: javascript
CODE:
```
const fn = vi.fn()
const context = {}

fn.apply(context)
fn.call(context)

fn.mock.contexts[0] === context
fn.mock.contexts[1] === context
```

----------------------------------------

TITLE: Writing In-Source Tests with Vitest in TypeScript
DESCRIPTION: This snippet shows how to organize implementation and test code within a single TypeScript module using Vitest. The main function is exported, followed by an `if (import.meta.vitest)` block containing suites using Vitest's `it` and `expect` primitives. Inputs tested include zero arguments and multiple numbers. Dependencies include Vitest's test runner, and the implementation is pure TypeScript. The file is structured so that private/internal logic can be tested directly, bypassing the need for exports.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/in-source.md#_snippet_0

LANGUAGE: TypeScript
CODE:
```
export function add(...args: number[]) {
  return args.reduce((a, b) => a + b, 0)
}

if (import.meta.vitest) {
  const { it, expect } = import.meta.vitest
  it('add', () => {
    expect(add()).toBe(0)
    expect(add(1)).toBe(1)
    expect(add(1, 2, 3)).toBe(6)
  })
}
```

----------------------------------------

TITLE: Tracking Mock Execution Order with mock.invocationCallOrder (TypeScript/JavaScript)
DESCRIPTION: The `mock.invocationCallOrder` property is an array of numbers indicating the global order in which this specific mock function was invoked relative to all other Vitest mocks defined in the test suite. Each number represents a unique invocation across all mocks.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/mock.md#_snippet_20

LANGUAGE: typescript
CODE:
```
const invocationCallOrder: number[]
```

LANGUAGE: javascript
CODE:
```
const fn1 = vi.fn()
const fn2 = vi.fn()

fn1()
fn2()
fn1()

fn1.mock.invocationCallOrder === [1, 3]
fn2.mock.invocationCallOrder === [2]
```

----------------------------------------

TITLE: filter.hasText - Filter Elements Containing Specific Text
DESCRIPTION: Narrows elements to those containing given text or regex inside, case-insensitive for strings. Useful for selecting elements based on visible or inner text content.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_28

LANGUAGE: TypeScript
CODE:
```
hasText: string | RegExp
```

----------------------------------------

TITLE: Set Non-Membership Assertion with Different Members (TypeScript)
DESCRIPTION: Defines `assert.notSameMembers` to assert that two arrays have different members. Uses strict equality for member comparison.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_84

LANGUAGE: TypeScript
CODE:
```
import { assert, test } from 'vitest'

 test('assert.sameMembers', () => {
  assert.notSameMembers([1, 2, 3], [5, 1, 3], 'not same members')
})
```

----------------------------------------

TITLE: Add Playwright Types to tsconfig.json
DESCRIPTION: Alternatively, add the Playwright provider types directly to the compilerOptions.types field in your tsconfig.json file for TypeScript recognition. Be aware this disables auto-loading of @types/* packages.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/playwright.md#_snippet_1

LANGUAGE: JSON
CODE:
```
{
  "compilerOptions": {
    "types": ["@vitest/browser/providers/playwright"]
  }
}
```

----------------------------------------

TITLE: Ensuring Injected Project Inclusion (TypeScript)
DESCRIPTION: Explains how to modify the `vitest.config.project` array within the `configureVitest` hook to explicitly include the name of a newly injected project. This ensures the project runs even if the user has specified project filters.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/plugin.md#_snippet_5

LANGUAGE: ts
CODE:
```
vitest.config.project.push('my-project-name')
```

----------------------------------------

TITLE: Configuring Vitest HTML Reporter
DESCRIPTION: This TypeScript code configures Vitest to generate an HTML report of the test results. It leverages the defineConfig function from 'vitest/config'.  The `reporters` option in the configuration specifies that an 'html' reporter should be used.  The output is a generated HTML report based on the test results. No specific input is necessary as the test runs are configured elsewhere.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/ui.md#_snippet_2

LANGUAGE: typescript
CODE:
```
import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    reporters: ['html'],
  },
})
```

----------------------------------------

TITLE: Printing Test Files Only With Vitest CLI - Bash
DESCRIPTION: Explains how to use the --filesOnly flag with Vitest's list command to print only the matching test file paths rather than individual tests. Input: --filesOnly flag. Output: File paths of all matching test files are printed to standard output.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/cli.md#_snippet_7

LANGUAGE: bash
CODE:
```
vitest list --filesOnly

```

----------------------------------------

TITLE: TSX example demonstrating `includeHidden` option for `getByRole`
DESCRIPTION: This TSX snippet demonstrates how to use the `includeHidden` option with `getByRole` to include or exclude hidden elements in the search. It includes examples using a button with `display: none`. Requires a TSX environment that supports JSX syntax. No external dependencies needed other than a rendering context for the TSX.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_6

LANGUAGE: tsx
CODE:
```
<button style="display: none" />

page.getByRole('button') // ❌
page.getByRole('button', { includeHidden: false }) // ❌
page.getByRole('button', { includeHidden: true }) // ✅
```

----------------------------------------

TITLE: Testing Text Selections in DOM Elements Using TypeScript with Vitest
DESCRIPTION: Demonstrates multiple test scenarios using TypeScript where text selections are set programmatically via setSelectionRange for inputs and textareas, or via the Selection and Range DOM APIs for more complex selections spanning multiple nodes. The examples show how to assert the presence or absence of selected text using the toHaveSelection method on elements identified by data-testid selectors. It covers single node selections and composite selections spanning parent and sibling nodes.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/assertion-api.md#_snippet_42

LANGUAGE: TypeScript
CODE:
```
getByTestId('text').element().setSelectionRange(5, 13)
await expect.element(getByTestId('text')).toHaveSelection('selected')

getByTestId('textarea').element().setSelectionRange(0, 5)
await expect.element('textarea').toHaveSelection('text ')

const selection = document.getSelection()
const range = document.createRange()
selection.removeAllRanges()
selection.empty()
selection.addRange(range)

// selection of child applies to the parent as well
range.selectNodeContents(getByTestId('child').element())
await expect.element(getByTestId('child')).toHaveSelection('selected')
await expect.element(getByTestId('parent')).toHaveSelection('selected')

// selection that applies from prev all, parent text before child, and part child.
range.setStart(getByTestId('prev').element(), 0)
range.setEnd(getByTestId('child').element().childNodes[0], 3)
await expect.element(queryByTestId('prev')).toHaveSelection('prev')
await expect.element(queryByTestId('child')).toHaveSelection('sel')
await expect.element(queryByTestId('parent')).toHaveSelection('text sel')
await expect.element(queryByTestId('next')).not.toHaveSelection()

// selection that applies from part child, parent text after child and part next.
range.setStart(getByTestId('child').element().childNodes[0], 3)
range.setEnd(getByTestId('next').element().childNodes[0], 2)
await expect.element(queryByTestId('child')).toHaveSelection('ected')
await expect.element(queryByTestId('parent')).toHaveSelection('ected text')
await expect.element(queryByTestId('prev')).not.toHaveSelection()
await expect.element(queryByTestId('next')).toHaveSelection('ne')
```

----------------------------------------

TITLE: Registering Server Close Handler with Vitest Programmatic API (TypeScript)
DESCRIPTION: Registers a callback function that will be executed when the Vitest server is closed. Allows performing cleanup or other actions upon server shutdown.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/advanced/api/vitest.md#_snippet_29

LANGUAGE: ts
CODE:
```
function onClose(fn: () => Awaitable<void>): void
```

----------------------------------------

TITLE: Configuring mockerPlugin with Vite Plugin System - TypeScript
DESCRIPTION: Shows how to set up Vitest's mockerPlugin within Vite by importing it and adding to the plugins array in the exported config. Requires Vite, @vitest/mocker/node, and defines an initial plugin integration. The exported configuration ensures that Vitest's mocking capabilities are available during builds and development.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/packages/mocker/EXPORTS.md#_snippet_0

LANGUAGE: TypeScript
CODE:
```
import { mockerPlugin } from '@vitest/mocker/node'

export default defineConfig({
  plugins: [mockerPlugin()],
})
```

----------------------------------------

TITLE: Object Property Change by Specific Amount (TypeScript)
DESCRIPTION: Defines `assert.changesBy` to verify a change in an object property by a specific delta after executing a modifier function.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_101

LANGUAGE: TypeScript
CODE:
```
import { assert, test } from 'vitest'

 test('assert.changesBy', () => {
  const obj = { val: 10 }
  function fn() { obj.val += 2 };
  assert.changesBy(fn, obj, 'val', 2)
})
```

----------------------------------------

TITLE: Deep Inclusion of Members in Any Order (TypeScript)
DESCRIPTION: Defines `assert.includeDeepMembers` to check if all `subset` objects are included in `superset` with deep equality, ignoring duplicates.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_93

LANGUAGE: TypeScript
CODE:
```
import { assert, test } from 'vitest'

 test('assert.includeDeepMembers', () => {
  assert.includeDeepMembers([{ a: 1 }, { b: 2 }, { c: 3 }], [{ b: 2 }, { a: 1 }, { b: 2 }], 'include deep members')
})
```

----------------------------------------

TITLE: Declaring query Function in Vitest (TypeScript)
DESCRIPTION: Declares the query function, returning a single DOM element matching the locator, or null if none found. Throws an error if multiple elements match the selector. Useful for conditional logic based on element presence; intended for precise, unambiguous selections only. Does not throw if zero elements are found.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_46

LANGUAGE: typescript
CODE:
```
function query(): Element | null
```

----------------------------------------

TITLE: Registering onTestFailed Hook Globally in Vitest (TypeScript)
DESCRIPTION: This snippet shows how to use the global `onTestFailed` hook within a test. The callback is executed only if the test fails, receiving the test context which includes task results and errors. This hook is useful for debugging failed tests by logging specific information. Note that this global hook is not recommended for concurrent tests.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/index.md#_snippet_59

LANGUAGE: ts
CODE:
```
import { onTestFailed, test } from 'vitest'

test('performs a query', () => {
  const db = connectDb()
  onTestFailed(({ task }) => {
    console.log(task.result.errors)
  })
  db.query('SELECT * FROM users')
})
```

----------------------------------------

TITLE: Debugging Vite Node Transformation via Env Var (Bash)
DESCRIPTION: Demonstrates enabling transformation debugging by setting the `VITE_NODE_DEBUG_DUMP=true` environment variable. When running `vite-node`, this causes the transformed code for each module to be saved ('dumped') into the `.vite-node/dump` directory.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/packages/vite-node/README.md#_snippet_7

LANGUAGE: bash
CODE:
```
VITE_NODE_DEBUG_DUMP=true vite-node example.ts
```

----------------------------------------

TITLE: TSX example demonstrating `checked` option for `getByRole`
DESCRIPTION: This TSX snippet demonstrates how to use the `checked` option with `getByRole` to filter elements based on their checked state (aria-checked or <input type="checkbox"/>). It includes examples of elements with and without the checked attribute set. Requires a TSX environment that supports JSX syntax.  No external dependencies needed other than a rendering context for the TSX.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_3

LANGUAGE: tsx
CODE:
```
<>
  <button role="checkbox" aria-checked="true" />
  <input type="checkbox" checked />
</>

page.getByRole('checkbox', { checked: true }) // ✅
page.getByRole('checkbox', { checked: false }) // ❌
```

----------------------------------------

TITLE: Array Inclusion of Members Not Present (TypeScript)
DESCRIPTION: Defines `assert.notIncludeMembers` to assert that `subset` elements are not all contained within `superset`. Uses strict equality.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/api/assert.md#_snippet_92

LANGUAGE: TypeScript
CODE:
```
import { assert, test } from 'vitest'

 test('assert.notIncludeMembers', () => {
  assert.notIncludeMembers([1, 2, 3], [5, 1], 'not include members')
})
```

----------------------------------------

TITLE: Declaring element Function in Vitest (TypeScript)
DESCRIPTION: Defines the element() function, retrieving a single DOM element for the locator's selector. Throws an error if zero or multiple matches are found. Used for strict element selection when presence and uniqueness are guaranteed; returns Element if found, otherwise throws.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/locators.md#_snippet_48

LANGUAGE: typescript
CODE:
```
function element(): Element
```

----------------------------------------

TITLE: Testing userEvent.tripleClick in Vitest (TypeScript)
DESCRIPTION: Demonstrates how to use `userEvent.tripleClick` within a Vitest browser test to simulate a triple click and verify the `click` event's `detail` property is 3. Shows both the `userEvent` and direct locator syntax.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/interactivity-api.md#_snippet_9

LANGUAGE: typescript
CODE:
```
import { page, userEvent } from '@vitest/browser/context'

test('triggers a triple click on an element', async () => {
  const logo = page.getByRole('img', { name: /logo/ })
  let tripleClickFired = false
  logo.addEventListener('click', (evt) => {
    if (evt.detail === 3) {
      tripleClickFired = true
    }
  })

  await userEvent.tripleClick(logo)
  // or you can access it directly on the locator
  await logo.tripleClick()

  expect(tripleClickFired).toBe(true)
})
```

----------------------------------------

TITLE: Defining Vitest Browser Project Names in Configuration
DESCRIPTION: These configuration examples illustrate how Vitest assigns project names to browser instances. It shows the default naming based on the browser name and how a custom `name` field or a root config `name` affects the final project name used for filtering.
SOURCE: https://github.com/vitest-dev/vitest/blob/main/docs/guide/browser/multiple-setups.md#_snippet_3

LANGUAGE: ts
CODE:
```
export default defineConfig({
  test: {
    browser: {
      instances: [
        // name: chromium
        { browser: 'chromium' },
        // name: custom
        { browser: 'firefox', name: 'custom' },
      ]
    }
  }
})
```

LANGUAGE: ts
CODE:
```
export default defineConfig({
  test: {
    name: 'custom',
    browser: {
      instances: [
        // name: custom (chromium)
        { browser: 'chromium' },
        // name: manual
        { browser: 'firefox', name: 'manual' },
      ]
    }
  }
})
```